bun test v1.2.21 (7c45ed97)

src\index.test.ts:
Source: struct DescriptiveError {
    source : *Str;
    description : *Str;
    reason : *Str;
    fix : *Str;
}

fn Ok<T, X>(value : T) => {
    fn isSuccess() => true;
    fn isFailure() => false;

    this
}

fn Err<T, X>(error : X) => {
    fn isSuccess() => false;
    fn isFailure() => true;

    this
}

type Result<T, X> = Ok<T, X> | Err<T, X>;
type InterpretError = DescriptiveError;

struct FunctionParam {
    name : *Str;
    type : *Str;
}

struct FunctionDefinition {
    body : *Str;
    returnType : *Str;
    params : *[FunctionParam];
}

// OK, now that I can comment, I can explain myself a bit better.
// If a function is marked as `extern` you should just provide a common-sense implementation in JS.
extern fn createSlice<T>() : *[T];
extern fn getSlice(slice : *[T], index : USize) => T;
extern fn addSlice(slice : *[T], element : T) => *[T];

let slice : *[I32] = createSlice<I32>();
Error: Undefined variable
Reason: Variable 'extern fn getSlice(slice : *[T], index : USize)' is not defined
Fix: Declare the variable first using 'let varName = value;'
(pass) interpret(empty string) => 0
(pass) interpret("100") => 100
(pass) interpret("100U8") => 100
(pass) interpret("-100U8") => Err
(pass) interpret("256U8") => Err
(pass) interpret invalid input returns descriptive error
(pass) interpret("100U8 is U8") => 1
(pass) interpret("100U8 is U16") => 0
(pass) interpret("100U16 is U8") => 0
(pass) interpret("100 is I32") => 1
(pass) interpret("100 is U8") => 0
(pass) interpret("1U8 + 2U8") => 3
(pass) interpret("(1U8 + 2U8)") => 3
(pass) interpret("1U8 + 255U8") => Err
(pass) interpret("1U8 + 255") => Err
(pass) interpret("1U8 + 255U16") => 256
(pass) interpret("(1U8 + 256U16) is U16") => 1
(pass) interpret("struct Ok {}") => 0
(pass) interpret duplicate struct declarations => Err
(pass) interpret duplicate struct fields => Err
(pass) interpret invalid field type => Err
(pass) interpret generic struct => 0
(pass) interpret variable binding => 0
(pass) interpret duplicate variable declarations => Err
(pass) interpret typed variable binding => 100
(pass) interpret type mismatch in variable assignment => Err
(pass) interpret type mismatch assigning variable to typed variable => Err
(pass) interpret("1U8 + 2U8 + 3U8") => 6
(pass) interpret("1U8 + 255 + 1U16") => 257
(pass) interpret("100U16 + 200U16 + 1U8") => Err
(pass) interpret type alias => 100
(pass) interpret function definition and call => 100
(pass) interpret mutable variable and reassignment => 1
(pass) interpret typed mutable variable and reassignment => 100
(pass) interpret string length access => 4
(pass) interpret string variable property access => 4
(pass) interpret generic function definition => 0
(pass) interpret generic function call with concrete argument => 100
(pass) interpret generic function call with explicit type parameter => 100
(pass) interpret generic function call with explicit type parameter and property access => 100
(pass) interpret index.tuff struct and function definitions with optional return type => 0
(pass) interpret function with unknown return type => Err
(pass) interpret this.x property access for variable => 100
(pass) interpret function with nested function definition => 0
(pass) interpret multiple functions with same nested function names => 0
(pass) interpret generic type alias definition => 0
(pass) interpret generic function with parametrized type alias in variable declaration => 0
(pass) interpret type check on variable with is operator (no parameters) => 1
(pass) interpret parametrized type check with is operator => 1
(pass) interpret parametrized function call check with base name => 1
(pass) interpret simple function call check with is operator => 1
(pass) interpret parametrized type check with concrete type annotation => 1
(pass) interpret parametrized type check with generic type annotation => 1
(pass) interpret duplicate function definitions => Err
(pass) interpret actual index.tuff content => 100
(pass) interpret duplicate function parameters => Err
(pass) interpret function with unknown parameter type => Err
(pass) interpret function with parameter and function call => 100
(pass) interpret function with multiple parameters and addition => 100
(pass) interpret function call with missing argument => Err
(pass) interpret function call with type mismatch (I64 to U16) => Err
(pass) interpret function call with this. prefix => 100
(pass) interpret function returning this and accessing parameter property => 100
(pass) interpret function returning this inside block and accessing property => 100
(pass) interpret function returning this with nested function call => 100
(pass) interpret variable storing this context and calling nested function => 100
(pass) interpret function with struct return type and typed variable assignment => 100
(pass) interpret function with inferred type from function name => 100
(pass) interpret Result type with nested isSuccess and isFailure methods => 0
(pass) interpret struct with array field type => 0
(pass) interpret type alias with union syntax => 0
(pass) interpret type declarations with trailing comment => 0
21 |   test(description, () => {
22 |     const result = interpret(input);
23 |     if (result.isSuccess()) {
24 |       expect(result.value).toBe(expected);
25 |     } else {
26 |       expect(result.error).toBeUndefined();
                                ^
error: expect(received).toBeUndefined()

Received: {
  source: "createSlice<I32>()",
  description: "Failed to parse input as a number",
  reason: "The input string cannot be converted to a valid integer",
  fix: "Provide a valid numeric string (e.g., '42', '100', '-5')",
}

      at <anonymous> (C:\Users\mathm\Documents\Projects\Tuff\src\index.test.ts:26:28)
(fail) interpret extern function declarations and generic function call => 0

1 tests failed:
(fail) interpret extern function declarations and generic function call => 0

 72 pass
 1 fail
 109 expect() calls
Ran 73 tests across 1 file. [37.00ms]
