let { get_interned_str, map_new, set_new, vec_new } = selfhost::runtime_lexer;
let { lex_init, lex_all } = selfhost::runtime_lexer;
let { lint_assert_file_length } = selfhost::runtime_lexer;
let { str_includes } = selfhost::runtime_lexer;
let { parse_init, node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5, node_set_data1 } = selfhost::parser_core;
let { p_parse_program, desugar } = selfhost::parser_decls;
let { resolve_names } = selfhost::resolver;
let { typecheck_program, typecheck_program_with_options } = selfhost::typecheck;
let { borrowcheck_program } = selfhost::borrowcheck;
let { generate_js } = selfhost::codegen_stmt;
let { generate_c } = selfhost::codegen_c;
let { lint_reset, lint_take_issues, lint_program, lint_add_circular_import_issue } = selfhost::linter;

fn module_loader_sanitize_max_effective_lines(max_effective_lines: I32) : I32 => {
    if (max_effective_lines <= 0) {
        500
    } else {
        max_effective_lines
    }
}

fn module_emit_target_output(typed: I32, merged_source: *Str, target: *Str) : *Str => {
    if (target.str_eq("js")) {
        return generate_js(typed);
    }
    if (target.str_eq("c")) {
        return generate_c(typed, __host_get_c_substrate());
    }
    panic_with_code(
        "E_UNSUPPORTED_TARGET",
        "Unsupported codegen target: ".str_concat(target),
        "The compiler was asked to emit code for a target that is not implemented.",
        "Use target 'js' or target 'c'."
    );
    ""
}

    fn module_loader_normalize_flag(value: I32) : I32 => {
        if (value == 0) { 0 } else { 1 }
    }

fn module_parts_to_relative_path(parts: Vec) : *Str => {
    let sb = sb_new();
    let i = 0;
    let len = parts.vec_length();
    while (i < len) {
        if (i > 0) {
            sb_append(sb, "/");
        }
        sb_append(sb, get_interned_str(parts.vec_get(i)));
        i = i + 1;
    }
    sb_append(sb, ".tuff");
    sb_build(sb)
}

fn join_sources(sources: Vec<*Str>) : *Str => {
    let sb = sb_new();
    let i = 0;
    let len = sources.vec_length();
    while (i < len) {
        if (i > 0) {
            sb_append(sb, "\n\n");
        }
        sb_append(sb, sources.vec_get(i));
        i = i + 1;
    }
    sb_build(sb)
}

fn module_with_c_runtime_prelude(source: *Str, target: *Str) : *Str => {
    if (!target.str_eq("c")) {
        return source;
    }
    if (source.str_includes("fn tuff_runtime_panic(")) {
        return source;
    }
    let prelude = __host_get_c_runtime_prelude_source();
    if (prelude.str_eq("")) {
        return source;
    }
    source.str_concat("\n\n").str_concat(prelude)
}

fn strip_import_decls(program: I32) : I32 => {
    let stmts = node_get_data1(program);
    let filtered = vec_new();
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        let stmt = stmts.vec_get(i);
        if (node_kind(stmt) != 6) {
            filtered.vec_push(stmt);
        }
        i = i + 1;
    }
    node_set_data1(program, filtered);
    program
}

fn is_module_decl_kind(kind: I32) : Bool => {
    // Uses literal node-kind IDs to avoid cross-module constant resolution.
    kind == 2 ||   // NK_FN_DECL
    kind == 16 ||  // NK_CLASS_FN_DECL
    kind == 3 ||   // NK_STRUCT_DECL
    kind == 60 ||  // NK_ENUM_DECL
    kind == 63 ||  // NK_OBJECT_DECL
    kind == 65 ||  // NK_CONTRACT_DECL
    kind == 4 ||   // NK_TYPE_ALIAS
    kind == 5 ||   // NK_LET_DECL
    kind == 17 ||  // NK_EXTERN_FN_DECL
    kind == 18 ||  // NK_EXTERN_LET_DECL
    kind == 19     // NK_EXTERN_TYPE_DECL
}

fn collect_module_declarations(stmts: Vec) : *mut Set<*Str> => {
    let declared = set_new();
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let kind = node_kind(stmt);
        if (is_module_decl_kind(kind)) {
            declared.set_add(get_interned_str(node_get_data1(stmt)));
        }
        i = i + 1;
    }
    declared
}

fn module_scope_define(scopes: Vec, depth: I32, name: *Str) : I32 => {
    let scope = scopes.vec_get(depth);
    scope.set_add(name);
    0
}

fn module_scope_has(scopes: Vec, depth: I32, name: *Str) : Bool => {
    let i = depth;
    while (i >= 0) {
        if (scopes.vec_get(i).set_has(name)) {
            return true;
        }
        i = i - 1;
    }
    false
}

fn module_check_expr_implicit_imports(n: I32, declared: *mut Set, imported: *mut Set, all_exported_declared: *mut Set, all_extern_declared: *mut Set, scopes: Vec, depth: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);
    if (kind == 24) {
        let name = get_interned_str(node_get_data1(n));
        if (!module_scope_has(scopes, depth, name) && !declared.set_has(name) && !imported.set_has(name)) {
            if (all_exported_declared.set_has(name) && !all_extern_declared.set_has(name)) {
                panic_with_code(
                    "E_MODULE_IMPLICIT_IMPORT",
                    "Strict module imports require explicit import for symbol '".str_concat(name).str_concat("'"),
                    "A module referenced a symbol declared in another module without importing it explicitly.",
                    "Add the symbol to the module import list (for example: let { symbol } = moduleName;)."
                );
            }
        }
        return 0;
    }

    if (kind == 25) {
        module_check_expr_implicit_imports(node_get_data2(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        module_check_expr_implicit_imports(node_get_data3(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        return 0;
    }

    if (kind == 26 || kind == 34) {
        module_check_expr_implicit_imports(node_get_data2(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        if (kind == 34) {
            module_check_expr_implicit_imports(node_get_data1(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        }
        return 0;
    }

    if (kind == 27) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        let args = node_get_data2(n);
        let i = 0;
        let len = args.vec_length();
        while (i < len) {
            module_check_expr_implicit_imports(args.vec_get(i), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
            i = i + 1;
        }
        return 0;
    }

    if (kind == 28) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        return 0;
    }

    if (kind == 29) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        module_check_expr_implicit_imports(node_get_data2(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        return 0;
    }

    if (kind == 30) {
        let fields = node_get_data2(n);
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let f = fields.vec_get(i);
            module_check_expr_implicit_imports(f.vec_get(1), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
            i = i + 1;
        }
        return 0;
    }

    if (kind == 31) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        module_check_stmt_implicit_imports(node_get_data2(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        if (node_get_data3(n) != 0) {
            module_check_stmt_implicit_imports(node_get_data3(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        }
        return 0;
    }

    if (kind == 32) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        let cases = node_get_data2(n);
        let i = 0;
        let len = cases.vec_length();
        while (i < len) {
            let case_node = cases.vec_get(i);
            let pat = case_node.vec_get(0);
            let body = case_node.vec_get(1);
            let next_depth = depth + 1;
            scopes.vec_push(set_new());
            if (node_kind(pat) == 53) {
                let fields = node_get_data2(pat);
                let j = 0;
                let fLen = fields.vec_length();
                while (j < fLen) {
                    module_scope_define(scopes, next_depth, get_interned_str(fields.vec_get(j)));
                    j = j + 1;
                }
            } else if (node_kind(pat) == 52) {
                let pat_name = get_interned_str(node_get_data1(pat));
                if (!declared.set_has(pat_name) && !imported.set_has(pat_name)) {
                    module_scope_define(scopes, next_depth, pat_name);
                }
            }
            module_check_stmt_implicit_imports(body, declared, imported, all_exported_declared, all_extern_declared, scopes, next_depth);
            scopes.vec_pop();
            i = i + 1;
        }
        return 0;
    }

    if (kind == 33) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
    }

    0
}

fn module_check_stmt_implicit_imports(n: I32, declared: *mut Set, imported: *mut Set, all_exported_declared: *mut Set, all_extern_declared: *mut Set, scopes: Vec, depth: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);
    if (kind == 12) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        let stmts = node_get_data1(n);
        let i = 0;
        let len = stmts.vec_length();
        while (i < len) {
            module_check_stmt_implicit_imports(stmts.vec_get(i), declared, imported, all_exported_declared, all_extern_declared, scopes, next_depth);
            i = i + 1;
        }
        scopes.vec_pop();
        return 0;
    }

    if (kind == 2 || kind == 16) {
        let fnScopes = vec_new();
        fnScopes.vec_push(set_new());
        let params = node_get_data3(n);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let p = params.vec_get(i);
            module_scope_define(fnScopes, 0, get_interned_str(p.vec_get(0)));
            i = i + 1;
        }
        module_check_stmt_implicit_imports(node_get_data5(n), declared, imported, all_exported_declared, all_extern_declared, fnScopes, 0);
        return 0;
    }

    if (kind == 5) {
        module_check_expr_implicit_imports(node_get_data3(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        module_scope_define(scopes, depth, get_interned_str(node_get_data1(n)));
        return 0;
    }

    if (kind == 6) {
        let names = node_get_data1(n);
        let i = 0;
        let len = names.vec_length();
        while (i < len) {
            module_scope_define(scopes, depth, get_interned_str(names.vec_get(i)));
            i = i + 1;
        }
        return 0;
    }

    if (kind == 7) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        return 0;
    }

    if (kind == 13) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        module_check_expr_implicit_imports(node_get_data2(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        return 0;
    }

    if (kind == 8) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        return 0;
    }

    if (kind == 9) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        module_check_stmt_implicit_imports(node_get_data2(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        if (node_get_data3(n) != 0) {
            module_check_stmt_implicit_imports(node_get_data3(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        }
        return 0;
    }

    if (kind == 11) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        module_scope_define(scopes, next_depth, get_interned_str(node_get_data1(n)));
        module_check_expr_implicit_imports(node_get_data2(n), declared, imported, all_exported_declared, all_extern_declared, scopes, next_depth);
        module_check_expr_implicit_imports(node_get_data3(n), declared, imported, all_exported_declared, all_extern_declared, scopes, next_depth);
        module_check_stmt_implicit_imports(node_get_data4(n), declared, imported, all_exported_declared, all_extern_declared, scopes, next_depth);
        scopes.vec_pop();
        return 0;
    }

    if (kind == 10) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        module_check_stmt_implicit_imports(node_get_data2(n), declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
        return 0;
    }

    module_check_expr_implicit_imports(n, declared, imported, all_exported_declared, all_extern_declared, scopes, depth);
    0
}

fn module_assert_no_implicit_imports(source: *Str, declared: *mut Set, imported: *mut Set, all_exported_declared: *mut Set, all_extern_declared: *mut Set) : I32 => {
    lex_init(source);
    lex_all();
    parse_init();
    let program = p_parse_program();
    let topScopes = vec_new();
    topScopes.vec_push(set_new());
    let body = node_get_data1(program);
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        module_check_stmt_implicit_imports(body.vec_get(i), declared, imported, all_exported_declared, all_extern_declared, topScopes, 0);
        i = i + 1;
    }
    0
}

fn module_has_out_export(source: *Str, name: *Str) : Bool => {
    source.str_includes("out fn ".str_concat(name)) ||
    source.str_includes("out struct ".str_concat(name)) ||
    source.str_includes("out copy struct ".str_concat(name)) ||
    source.str_includes("copy out struct ".str_concat(name)) ||
    source.str_includes("out enum ".str_concat(name)) ||
    source.str_includes("out object ".str_concat(name)) ||
    source.str_includes("out contract ".str_concat(name)) ||
    source.str_includes("out type ".str_concat(name)) ||
    source.str_includes("out copy type ".str_concat(name)) ||
    source.str_includes("copy out type ".str_concat(name)) ||
    source.str_includes("out class fn ".str_concat(name))
}

fn gather_module_sources(filePath: *Str, moduleBasePath: *Str, seen: *mut Set, visiting: *mut Set, sources: Vec<*Str>, module_declared_map: Map, all_declared_names: *mut Set, all_exported_declared_names: *mut Set, all_extern_declared_names: *mut Set, lint_enabled: I32, max_effective_lines: I32, module_cycles: Vec<*Str>) : I32 => {
    if (seen.set_has(filePath)) {
        return 0;
    }
    if (visiting.set_has(filePath)) {
        if (lint_enabled == 1) {
            module_cycles.vec_push(filePath);
            return 0;
        }
        panic_with_code(
            "E_MODULE_CYCLE",
            "Module import cycle detected at ".str_concat(filePath),
            "A module was revisited while still being loaded, which means the import graph contains a cycle.",
            "Break the cycle by extracting shared declarations into a third module imported by both sides."
        );
    }
    visiting.set_add(filePath);

    let source = read_file(filePath);
    lex_init(source);
    lex_all();
    parse_init();
    let program = p_parse_program();
    let stmts = node_get_data1(program);
    let declared = collect_module_declarations(stmts);
    module_declared_map.map_set(filePath, declared);
    let all_declared_items = node_get_data1(program);
    let di = 0;
    let dlen = all_declared_items.vec_length();
    while (di < dlen) {
        let dstmt = all_declared_items.vec_get(di);
        let dkind = node_kind(dstmt);
        if (is_module_decl_kind(dkind)) {
            let dname = get_interned_str(node_get_data1(dstmt));
            all_declared_names.set_add(dname);
            if (dkind == 17 || dkind == 18 || dkind == 19) {
                all_extern_declared_names.set_add(dname);
            }
            if (module_has_out_export(source, dname)) {
                all_exported_declared_names.set_add(dname);
            }
        }
        di = di + 1;
    }

    // IMPORTANT: snapshot imports before recursive calls, because parse_init()
    // in child modules clears global AST storage arrays.
    let imports = vec_new();
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        let stmt = stmts.vec_get(i);
        if (node_kind(stmt) == 6) {
            let parts = node_get_data2(stmt);
            let rel = module_parts_to_relative_path(parts);
            let depPath = path_join(moduleBasePath, rel);

            let importNamesRaw = node_get_data1(stmt);
            let importNames = vec_new();
            let j = 0;
            let jLen = importNamesRaw.vec_length();
            while (j < jLen) {
                importNames.vec_push(get_interned_str(importNamesRaw.vec_get(j)));
                j = j + 1;
            }

            let importSpec = vec_new();
            importSpec.vec_push(depPath);
            importSpec.vec_push(importNames);
            imports.vec_push(importSpec);
        }
        i = i + 1;
    }

    i = 0;
    len = imports.vec_length();
    while (i < len) {
        let spec = imports.vec_get(i);
        let depPath = spec.vec_get(0);
        let importNames = spec.vec_get(1);

        gather_module_sources(depPath, moduleBasePath, seen, visiting, sources, module_declared_map, all_declared_names, all_exported_declared_names, all_extern_declared_names, lint_enabled, max_effective_lines, module_cycles);

        let depDeclared = module_declared_map.map_get(depPath);
        let depSource = read_file(depPath);
        let j = 0;
        let jLen = importNames.vec_length();
        while (j < jLen) {
            let importedName = importNames.vec_get(j);
            if (!module_has_out_export(depSource, importedName)) {
                if (depDeclared.set_has(importedName)) {
                    panic_with_code(
                        "E_MODULE_PRIVATE_IMPORT",
                        "Cannot import '".str_concat(importedName).str_concat("' from module: symbol is not exported with 'out'"),
                        "A module import referenced a declaration that exists but is not visible outside its module.",
                        "Mark the declaration with 'out' in the target module, or remove it from the import list."
                    );
                }
                panic_with_code(
                    "E_MODULE_UNKNOWN_EXPORT",
                    "Cannot import '".str_concat(importedName).str_concat("' from module: exported symbol not found"),
                    "A module import requested a symbol that is not exported by the target module.",
                    "Check the import list and add a matching 'out' declaration in the target module."
                );
            }
            j = j + 1;
        }
        i = i + 1;
    }

    let imported_names = set_new();
    i = 0;
    len = imports.vec_length();
    while (i < len) {
        let spec = imports.vec_get(i);
        let importNames = spec.vec_get(1);
        let j = 0;
        let jLen = importNames.vec_length();
        while (j < jLen) {
            imported_names.set_add(importNames.vec_get(j));
            j = j + 1;
        }
        i = i + 1;
    }

    module_assert_no_implicit_imports(source, declared, imported_names, all_exported_declared_names, all_extern_declared_names);

    visiting.set_delete(filePath);
    seen.set_add(filePath);
    sources.vec_push(source);
    0
}

out fn compile_file(inputPath: *Str, outputPath: *Str) : I32 => {
    compile_file_with_options(inputPath, outputPath, 1, 0, 500, 1, "js")
}

out fn compile_file_with_options(inputPath: *Str, outputPath: *Str, strict_safety: I32, lint_enabled: I32, max_effective_lines: I32, borrow_enabled: I32, target: *Str) : I32 => {
    let max_lines = module_loader_sanitize_max_effective_lines(max_effective_lines);
    let strict = module_loader_normalize_flag(strict_safety);
    let lint = module_loader_normalize_flag(lint_enabled);
    let borrow = module_loader_normalize_flag(borrow_enabled);
    let moduleBasePath = path_dirname(inputPath);
    let seen = set_new();
    let visiting = set_new();
    let sources = vec_new();
    let module_declared_map = map_new();
    let all_declared_names = set_new();
    let all_exported_declared_names = set_new();
    let all_extern_declared_names = set_new();
    let module_cycles = vec_new();
    lint_reset();
    gather_module_sources(inputPath, moduleBasePath, seen, visiting, sources, module_declared_map, all_declared_names, all_exported_declared_names, all_extern_declared_names, lint, max_lines, module_cycles);
    let merged = module_with_c_runtime_prelude(join_sources(sources), target);
    lex_init(merged);
    lex_all();
    parse_init();
    let program = p_parse_program();
    program = strip_import_decls(program);
    let desugared = desugar(program);
    let resolved = resolve_names(desugared);
    let typed = typecheck_program_with_options(resolved, strict);
    if (borrow == 1) {
        borrowcheck_program(typed);
    }
    if (lint == 1) {
        lint_program(typed, inputPath, max_lines);
        let i = 0;
        let len = module_cycles.vec_length();
        while (i < len) {
            lint_add_circular_import_issue(module_cycles.vec_get(i));
            i = i + 1;
        }
    }
    let emitted = module_emit_target_output(typed, merged, target);
    write_file(outputPath, emitted)
}

