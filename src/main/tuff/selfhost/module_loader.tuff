let {
    get_interned_str, map_new, set_new, vec_new,
    perf_now, print_error, int_to_string, lex_take_trivia
}
 = selfhost::runtime_lexer;
let {
    lex_init, lex_all
}
 = selfhost::runtime_lexer;
let {
    str_includes
}
 = selfhost::runtime_lexer;
let {
    parse_init, node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4,
    node_get_data5, node_set_data1
}
 = selfhost::parser_core;
let {
    p_parse_program, desugar
}
 = selfhost::parser_decls;
let {
    resolve_names
}
 = selfhost::resolver;
let {
    typecheck_program, typecheck_program_with_options
}
 = selfhost::typecheck;
let {
    borrowcheck_program
}
 = selfhost::borrowcheck;
let {
    generate_js
}
 = selfhost::codegen_stmt;
let {
    generate_c
}
 = selfhost::codegen_c;
let {
    emit_tuff_from_typed
}
 = selfhost::tuff_printer;
let {
    lint_reset, lint_take_issues, lint_program, lint_add_circular_import_issue,
    lint_check_current_file_length
}
 = selfhost::linter;
let {
    module_loader_sanitize_max_effective_lines, module_loader_normalize_flag,
    module_parts_to_relative_path, module_normalize_path, join_sources, module_with_c_runtime_prelude
}
 = selfhost::module_loader_utils;
let {
    sourcemap_init, sourcemap_add, sourcemap_count_lines, sourcemap_lookup
}
 = selfhost::module_sourcemap;
fn module_emit_target_output(typed: I32, merged_source: *Str, target: *Str) : *Str => {
    if (target.str_eq("js")) {
        return generate_js(typed);
    }
    if (target.str_eq("c")) {
        return generate_c(typed, __host_get_c_substrate());
    }
    if (target.str_eq("tuff")) {
        return emit_tuff_from_typed(typed, merged_source, lex_take_trivia());
    }
    panic_with_code(
    "E_UNSUPPORTED_TARGET",
    "Unsupported codegen target: ".str_concat(target),
    "The compiler was asked to emit code for a target that is not implemented.",
    "Use target 'js', target 'c', or target 'tuff'."
    );
    ""
}
let gather_prof_modules : I32 = 0;
let gather_prof_import_edges : I32 = 0;
let gather_prof_read_file_ms : I32 = 0;
let gather_prof_lex_parse_ms : I32 = 0;
let gather_prof_decl_collect_ms : I32 = 0;
let gather_prof_import_snapshot_ms : I32 = 0;
let gather_prof_import_walk_ms : I32 = 0;
let gather_prof_import_recurse_ms : I32 = 0;
let gather_prof_implicit_check_ms : I32 = 0;
fn gather_prof_reset() : I32 => {
    gather_prof_modules = 0;
    gather_prof_import_edges = 0;
    gather_prof_read_file_ms = 0;
    gather_prof_lex_parse_ms = 0;
    gather_prof_decl_collect_ms = 0;
    gather_prof_import_snapshot_ms = 0;
    gather_prof_import_walk_ms = 0;
    gather_prof_import_recurse_ms = 0;
    gather_prof_implicit_check_ms = 0;
    0
}
fn strip_import_decls(program: I32) : I32 => {
    let stmts = node_get_data1(program);
    let filtered = vec_new();
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        let stmt = stmts.vec_get(i);
        if (node_kind(stmt) != 6) {
            filtered.vec_push(stmt);
        }
        i = i + 1;
    }
    node_set_data1(program, filtered);
    program
}
fn is_module_decl_kind(kind: I32) : Bool => {
     // Uses literal node-kind IDs to avoid cross-module constant resolution.
    kind == 2 || // NK_FN_DECL
    kind == 16 || // NK_CLASS_FN_DECL
    kind == 3 || // NK_STRUCT_DECL
    kind == 60 || // NK_ENUM_DECL
    kind == 63 || // NK_OBJECT_DECL
    kind == 65 || // NK_CONTRACT_DECL
    kind == 4 || // NK_TYPE_ALIAS
    kind == 5 || // NK_LET_DECL
    kind == 18 || // NK_EXTERN_LET_DECL
    kind == 19 // NK_EXTERN_TYPE_DECL
}
fn module_is_extern_decl(stmt: I32) : Bool => {
    let kind = node_kind(stmt);
    (kind == 2 && node_get_data5(stmt) == 0) || // NK_FN_DECL with no body
    kind == 18 || // NK_EXTERN_LET_DECL
    kind == 19 // NK_EXTERN_TYPE_DECL
}
fn collect_module_declarations(stmts: Vec<I32>) : *mut Set<*Str> => {
    let declared = set_new();
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let kind = node_kind(stmt);
        if (is_module_decl_kind(kind)) {
            declared.set_add(get_interned_str(node_get_data1(stmt)));
        }
        i = i + 1;
    }
    declared
}
fn module_scope_define(scopes: Vec<I32>, depth: I32, name: *Str) : I32 => {
    let scope = scopes.vec_get(depth);
    scope.set_add(name);
    0
}
fn module_scope_has(scopes: Vec<I32>, depth: I32, name: *Str) : Bool => {
    let i = depth;
    while (i >= 0) {
        if (scopes.vec_get(i).set_has(name)) {
            return true;
        }
        i = i - 1;
    }
    false
}
fn module_check_expr_call_like(n: I32, declared: *mut Set<I32>, imported: *mut Set<I32>,
scopes: Vec<I32>, depth: I32, implicit_candidates: Vec<I32>, implicit_candidate_set: *mut Set<I32>) : I32 => {
    if (node_kind(n) == 27) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        let args = node_get_data2(n);
        let i = 0;
        let len = args.vec_length();
        while (i < len) {
            module_check_expr_implicit_imports(args.vec_get(i), declared, imported,
            scopes, depth, implicit_candidates, implicit_candidate_set);
            i = i + 1;
        }
        return 1;
    }
    if (node_kind(n) == 28) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        return 1;
    }
    if (node_kind(n) == 29) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        module_check_expr_implicit_imports(node_get_data2(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        return 1;
    }
    0
}
fn module_check_expr_composites(n: I32, declared: *mut Set<I32>, imported: *mut Set<I32>,
scopes: Vec<I32>, depth: I32, implicit_candidates: Vec<I32>, implicit_candidate_set: *mut Set<I32>) : I32 => {
    if (node_kind(n) == 30) {
        let fields = node_get_data2(n);
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let f = fields.vec_get(i);
            module_check_expr_implicit_imports(f.vec_get(1), declared, imported,
            scopes, depth, implicit_candidates, implicit_candidate_set);
            i = i + 1;
        }
        return 1;
    }
    if (node_kind(n) == 33) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        return 1;
    }
    0
}
fn module_check_expr_match (n: I32, declared: *mut Set<I32>, imported: *mut Set<I32>, scopes: Vec<I32>,
depth: I32, implicit_candidates: Vec<I32>, implicit_candidate_set: *mut Set<I32>) : I32 => {
    if (node_kind(n) != 32) {
        return 0;
    }
    module_check_expr_implicit_imports(node_get_data1(n), declared, imported,
    scopes, depth, implicit_candidates, implicit_candidate_set);
    let cases = node_get_data2(n);
    let i = 0;
    let len = cases.vec_length();
    while (i < len) {
        let case_node = cases.vec_get(i);
        let pat = case_node.vec_get(0);
        let body = case_node.vec_get(1);
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        if (node_kind(pat) == 53) {
            let fields = node_get_data2(pat);
            let j = 0;
            let fLen = fields.vec_length();
            while (j < fLen) {
                module_scope_define(scopes, next_depth, get_interned_str(fields.vec_get(j)));
                j = j + 1;
            }
        }
        else if (node_kind(pat) == 52) {
            let pat_name = get_interned_str(node_get_data1(pat));
            if (!declared.set_has(pat_name) && !imported.set_has(pat_name)) {
                module_scope_define(scopes, next_depth, pat_name);
            }
        }
        module_check_stmt_implicit_imports(body, declared, imported, scopes, next_depth,
        implicit_candidates, implicit_candidate_set);
        scopes.vec_pop();
        i = i + 1;
    }
    1
}
fn module_collect_declared_sets(source: *Str, program: I32, module_declared_map: Map<I32, I32>,
module_exported_map: Map<I32, I32>, filePath: *Str, all_declared_names: *mut Set<I32>,
all_exported_declared_names: *mut Set<I32>, all_extern_declared_names: *mut Set<I32>) : *mut Set<I32> => {
    let stmts = node_get_data1(program);
    let declared = collect_module_declarations(stmts);
    let exported = set_new();
    module_declared_map.map_set(filePath, declared);
    module_exported_map.map_set(filePath, exported);
    let di = 0;
    let dlen = stmts.vec_length();
    while (di < dlen) {
        let dstmt = stmts.vec_get(di);
        let dkind = node_kind(dstmt);
        if (is_module_decl_kind(dkind)) {
            let dname = get_interned_str(node_get_data1(dstmt));
            all_declared_names.set_add(dname);
            if (module_is_extern_decl(dstmt)) {
                all_extern_declared_names.set_add(dname);
            }
            if (module_has_out_export(source, dname)) {
                exported.set_add(dname);
                all_exported_declared_names.set_add(dname);
            }
        }
        di = di + 1;
    }
    declared
}
fn module_snapshot_import_specs(stmts: Vec<I32>, moduleBasePath: *Str, import_path_cache: Map<I32, I32>) : Vec<I32> => {
    let t0 = perf_now();
    let imports = vec_new();
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        let stmt = stmts.vec_get(i);
        if (node_kind(stmt) == 6) {
            let parts = node_get_data2(stmt);
            let rel = module_parts_to_relative_path(parts);
            let depPath = "";
            if (import_path_cache.map_has(rel)) {
                depPath = import_path_cache.map_get(rel);
            }
            else {
                depPath = module_normalize_path(path_join(moduleBasePath, rel));
                import_path_cache.map_set(rel, depPath);
            }
            let importNamesRaw = node_get_data1(stmt);
            let importNames = vec_new();
            let j = 0;
            let jLen = importNamesRaw.vec_length();
            while (j < jLen) {
                importNames.vec_push(get_interned_str(importNamesRaw.vec_get(j)));
                j = j + 1;
            }
            let importSpec = vec_new();
            importSpec.vec_push(depPath);
            importSpec.vec_push(importNames);
            imports.vec_push(importSpec);
            gather_prof_import_edges = gather_prof_import_edges + 1;
        }
        i = i + 1;
    }
    gather_prof_import_snapshot_ms = gather_prof_import_snapshot_ms + (perf_now() - t0);
    imports
}
fn module_walk_imports(imports: Vec<I32>, moduleBasePath: *Str, seen: *mut Set<I32>, visiting: *mut Set<I32>,
sources: Vec<*Str>, module_paths: Vec<*Str>, module_declared_map: Map<I32, I32>, module_exported_map: Map<I32, I32>,
module_source_cache: Map<I32, I32>, import_path_cache: Map<I32, I32>, all_declared_names: *mut Set<I32>,
all_exported_declared_names: *mut Set<I32>, all_extern_declared_names: *mut Set<I32>, lint_enabled: I32,
max_effective_lines: I32, module_cycles: Vec<*Str>, recursion_depth: I32) : I32 => {
    let i = 0;
    let len = imports.vec_length();
    while (i < len) {
        let spec = imports.vec_get(i);
        let depPath = spec.vec_get(0);
        let importNames = spec.vec_get(1);
        if (!seen.set_has(depPath)) {
            let t_recurse_0 = perf_now();
            gather_module_sources(depPath, moduleBasePath, seen, visiting, sources, module_paths,
            module_declared_map, module_exported_map, module_source_cache, import_path_cache,
            all_declared_names, all_exported_declared_names, all_extern_declared_names, lint_enabled,
            max_effective_lines, module_cycles, recursion_depth + 1);
            if (recursion_depth == 0) {
                gather_prof_import_recurse_ms = gather_prof_import_recurse_ms +
                (perf_now() - t_recurse_0);
            }
        }
        let t_walk_local_0 = perf_now();
        let depDeclared = module_declared_map.map_get(depPath);
        let depExported = module_exported_map.map_get(depPath);
        let j = 0;
        let jLen = importNames.vec_length();
        while (j < jLen) {
            let importedName = importNames.vec_get(j);
            if (!depExported.set_has(importedName)) {
                if (depDeclared.set_has(importedName)) {
                    panic_with_code("E_MODULE_PRIVATE_IMPORT", "Cannot import '".str_concat(importedName).str_concat("' from module: symbol is not exported with 'out'"), "A module import referenced a declaration that exists but is not visible outside its module.", "Mark the declaration with 'out' in the target module, or remove it from the import list.");
                }
                panic_with_code("E_MODULE_UNKNOWN_EXPORT", "Cannot import '".str_concat(importedName).str_concat("' from module: exported symbol not found"), "A module import requested a symbol that is not exported by the target module.", "Check the import list and add a matching 'out' declaration in the target module.");
            }
            j = j + 1;
        }
        gather_prof_import_walk_ms = gather_prof_import_walk_ms +
        (perf_now() - t_walk_local_0);
        i = i + 1;
    }
    0
}
fn module_collect_imported_names(imports: Vec<I32>) : *mut Set<I32> => {
    let imported_names = set_new();
    let i = 0;
    let len = imports.vec_length();
    while (i < len) {
        let spec = imports.vec_get(i);
        let importNames = spec.vec_get(1);
        let j = 0;
        let jLen = importNames.vec_length();
        while (j < jLen) {
            imported_names.set_add(importNames.vec_get(j));
            j = j + 1;
        }
        i = i + 1;
    }
    imported_names
}
fn module_check_expr_implicit_imports(n: I32, declared: *mut Set<I32>, imported: *mut Set<I32>,
scopes: Vec<I32>, depth: I32, implicit_candidates: Vec<I32>, implicit_candidate_set: *mut Set<I32>) : I32 => {
    if (n == 0) {
        return 0;
    }
    let kind = node_kind(n);
    if (kind == 24) {
        let name = get_interned_str(node_get_data1(n));
        if (!module_scope_has(scopes, depth, name) && !declared.set_has(name) &&
        !imported.set_has(name)) {
            if (!implicit_candidate_set.set_has(name)) {
                implicit_candidate_set.set_add(name);
                implicit_candidates.vec_push(name);
            }
        }
        return 0;
    }
    if (kind == 25) {
        module_check_expr_implicit_imports(node_get_data2(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        module_check_expr_implicit_imports(node_get_data3(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        return 0;
    }
    if (kind == 26 || kind == 34) {
        module_check_expr_implicit_imports(node_get_data2(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        if (kind == 34) {
            module_check_expr_implicit_imports(node_get_data1(n), declared, imported,
            scopes, depth, implicit_candidates, implicit_candidate_set);
        }
        return 0;
    }
    if (module_check_expr_call_like(n, declared, imported, scopes, depth,
    implicit_candidates, implicit_candidate_set) == 1) {
        return 0;
    }
    if (module_check_expr_composites(n, declared, imported, scopes, depth,
    implicit_candidates, implicit_candidate_set) == 1) {
        return 0;
    }
    if (kind == 31) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        module_check_stmt_implicit_imports(node_get_data2(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        if (node_get_data3(n) != 0) {
            module_check_stmt_implicit_imports(node_get_data3(n), declared, imported,
            scopes, depth, implicit_candidates, implicit_candidate_set);
        }
        return 0;
    }
    if (module_check_expr_match (n, declared, imported, scopes, depth,
    implicit_candidates, implicit_candidate_set) == 1) {
        return 0;
    }
    0
}
fn module_check_stmt_implicit_imports(n: I32, declared: *mut Set<I32>, imported: *mut Set<I32>,
scopes: Vec<I32>, depth: I32, implicit_candidates: Vec<I32>, implicit_candidate_set: *mut Set<I32>) : I32 => {
    if (n == 0) {
        return 0;
    }
    let kind = node_kind(n);
    if (kind == 12) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        let stmts = node_get_data1(n);
        let i = 0;
        let len = stmts.vec_length();
        while (i < len) {
            module_check_stmt_implicit_imports(stmts.vec_get(i), declared, imported,
            scopes, next_depth, implicit_candidates, implicit_candidate_set);
            i = i + 1;
        }
        scopes.vec_pop();
        return 0;
    }
    if (kind == 2 || kind == 16) {
        let fnScopes = vec_new();
        fnScopes.vec_push(set_new());
        let params = node_get_data3(n);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let p = params.vec_get(i);
            module_scope_define(fnScopes, 0, get_interned_str(p.vec_get(0)));
            i = i + 1;
        }
        module_check_stmt_implicit_imports(node_get_data5(n), declared, imported,
        fnScopes, 0, implicit_candidates, implicit_candidate_set);
        return 0;
    }
    if (kind == 5) {
        module_check_expr_implicit_imports(node_get_data3(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        module_scope_define(scopes, depth, get_interned_str(node_get_data1(n)));
        return 0;
    }
    if (kind == 6) {
        let names = node_get_data1(n);
        let i = 0;
        let len = names.vec_length();
        while (i < len) {
            module_scope_define(scopes, depth, get_interned_str(names.vec_get(i)));
            i = i + 1;
        }
        return 0;
    }
    if (kind == 7) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        return 0;
    }
    if (kind == 13) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        module_check_expr_implicit_imports(node_get_data2(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        return 0;
    }
    if (kind == 8) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        return 0;
    }
    if (kind == 9) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        module_check_stmt_implicit_imports(node_get_data2(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        if (node_get_data3(n) != 0) {
            module_check_stmt_implicit_imports(node_get_data3(n), declared, imported,
            scopes, depth, implicit_candidates, implicit_candidate_set);
        }
        return 0;
    }
    if (kind == 11) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        module_scope_define(scopes, next_depth, get_interned_str(node_get_data1(n)));
        module_check_expr_implicit_imports(node_get_data2(n), declared, imported,
        scopes, next_depth, implicit_candidates, implicit_candidate_set);
        module_check_expr_implicit_imports(node_get_data3(n), declared, imported,
        scopes, next_depth, implicit_candidates, implicit_candidate_set);
        module_check_stmt_implicit_imports(node_get_data4(n), declared, imported,
        scopes, next_depth, implicit_candidates, implicit_candidate_set);
        scopes.vec_pop();
        return 0;
    }
    if (kind == 10) {
        module_check_expr_implicit_imports(node_get_data1(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        module_check_stmt_implicit_imports(node_get_data2(n), declared, imported,
        scopes, depth, implicit_candidates, implicit_candidate_set);
        return 0;
    }
    module_check_expr_implicit_imports(n, declared, imported, scopes, depth,
    implicit_candidates, implicit_candidate_set);
    0
}
fn module_collect_implicit_import_candidates(program: I32, declared: *mut Set<I32>,
imported: *mut Set<I32>) : Vec<I32> => {
    let implicit_candidates = vec_new();
    let implicit_candidate_set = set_new();
    let topScopes = vec_new();
    topScopes.vec_push(set_new());
    let body = node_get_data1(program);
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        module_check_stmt_implicit_imports(body.vec_get(i), declared, imported, topScopes, 0,
        implicit_candidates, implicit_candidate_set);
        i = i + 1;
    }
    implicit_candidates
}
fn module_assert_no_implicit_imports(implicit_candidates: Vec<I32>, all_exported_declared: *mut Set<I32>,
all_extern_declared: *mut Set<I32>) : I32 => {
    let i = 0;
    let len = implicit_candidates.vec_length();
    while (i < len) {
        let name = implicit_candidates.vec_get(i);
        if (all_exported_declared.set_has(name) && !all_extern_declared.set_has(name)) {
            panic_with_code(
            "E_MODULE_IMPLICIT_IMPORT",
            "Strict module imports require explicit import for symbol '".str_concat(name).str_concat("'"),
            "A module referenced a symbol declared in another module without importing it explicitly.",
            "Add the symbol to the module import list (for example: let { symbol } = moduleName;)."
            );
        }
        i = i + 1;
    }
    0
}
fn module_has_out_export(source: *Str, name: *Str) : Bool => {
    source.str_includes("out extern fn ".str_concat(name)) ||
    source.str_includes("extern out fn ".str_concat(name)) ||
    source.str_includes("out fn ".str_concat(name)) ||
    source.str_includes("out struct ".str_concat(name)) ||
    source.str_includes("out copy struct ".str_concat(name)) ||
    source.str_includes("copy out struct ".str_concat(name)) ||
    source.str_includes("out enum ".str_concat(name)) ||
    source.str_includes("out object ".str_concat(name)) ||
    source.str_includes("out contract ".str_concat(name)) ||
    source.str_includes("out type ".str_concat(name)) ||
    source.str_includes("out copy type ".str_concat(name)) ||
    source.str_includes("copy out type ".str_concat(name)) ||
    source.str_includes("out class fn ".str_concat(name))
}
fn gather_module_sources(filePath: *Str, moduleBasePath: *Str, seen: *mut Set<I32>, visiting: *mut Set<I32>,
sources: Vec<*Str>, module_paths: Vec<*Str>, module_declared_map: Map<I32, I32>, module_exported_map: Map<I32, I32>,
module_source_cache: Map<I32, I32>, import_path_cache: Map<I32, I32>, all_declared_names: *mut Set<I32>,
all_exported_declared_names: *mut Set<I32>, all_extern_declared_names: *mut Set<I32>, lint_enabled: I32,
max_effective_lines: I32, module_cycles: Vec<*Str>, recursion_depth: I32) : I32 => {
    filePath = module_normalize_path(filePath);
    moduleBasePath = module_normalize_path(moduleBasePath);
    if (seen.set_has(filePath)) {
        return 0;
    }
    if (visiting.set_has(filePath)) {
        if (lint_enabled == 1) {
            module_cycles.vec_push(filePath);
            return 0;
        }
        panic_with_code(
        "E_MODULE_CYCLE",
        "Module import cycle detected at ".str_concat(filePath),
        "A module was revisited while still being loaded, which means the import graph contains a cycle.",
        "Break the cycle by extracting shared declarations into a third module imported by both sides."
        );
    }
    visiting.set_add(filePath);
    let module_t0 = perf_now();
    gather_prof_modules = gather_prof_modules + 1;
    let source = "";
    if (module_source_cache.map_has(filePath)) {
        source = module_source_cache.map_get(filePath);
    }
    else {
        let t_read_0 = perf_now();
        source = read_file(filePath);
        gather_prof_read_file_ms = gather_prof_read_file_ms + (perf_now() - t_read_0);
        module_source_cache.map_set(filePath, source);
    }
    let t_parse_0 = perf_now();
    lex_init(source);
    lex_all();
    if (lint_enabled == 1) {
        lint_check_current_file_length(filePath, max_effective_lines);
    }
    parse_init();
    let program = p_parse_program();
    gather_prof_lex_parse_ms = gather_prof_lex_parse_ms + (perf_now() - t_parse_0);
    let stmts = node_get_data1(program);
    let t_decl_0 = perf_now();
    let declared = module_collect_declared_sets(source, program, module_declared_map,
    module_exported_map, filePath, all_declared_names, all_exported_declared_names,
    all_extern_declared_names);
    gather_prof_decl_collect_ms = gather_prof_decl_collect_ms + (perf_now() - t_decl_0);
     // IMPORTANT: snapshot imports before recursive calls, because parse_init()
     // in child modules clears global AST storage arrays.
    let imports = module_snapshot_import_specs(stmts, moduleBasePath, import_path_cache);
    let imported_names = module_collect_imported_names(imports);
    let implicit_candidates = module_collect_implicit_import_candidates(program, declared,
    imported_names);
    module_walk_imports(imports, moduleBasePath, seen, visiting, sources, module_paths,
    module_declared_map, module_exported_map, module_source_cache, import_path_cache,
    all_declared_names, all_exported_declared_names, all_extern_declared_names, lint_enabled,
    max_effective_lines, module_cycles, recursion_depth);
    let t_implicit_0 = perf_now();
    module_assert_no_implicit_imports(implicit_candidates, all_exported_declared_names,
    all_extern_declared_names);
    gather_prof_implicit_check_ms = gather_prof_implicit_check_ms + (perf_now() - t_implicit_0);
    visiting.set_delete(filePath);
    seen.set_add(filePath);
    sources.vec_push(source);
    module_paths.vec_push(filePath);
    0
}
out fn compile_file(inputPath: *Str, outputPath: *Str) : I32 => {
    compile_file_with_options(inputPath, outputPath, 0, 500, 1, "js")
}
out fn compile_file_with_options(inputPath: *Str, outputPath: *Str, lint_enabled: I32,
max_effective_lines: I32, borrow_enabled: I32, target: *Str) : I32 => {
    let max_lines = module_loader_sanitize_max_effective_lines(max_effective_lines);
    let lint = module_loader_normalize_flag(lint_enabled);
    let borrow = module_loader_normalize_flag(borrow_enabled);
    inputPath = module_normalize_path(inputPath);
    let moduleBasePath = module_normalize_path(path_dirname(inputPath));
    let seen = set_new();
    let visiting = set_new();
    let sources = vec_new();
    let module_paths = vec_new();
    let module_declared_map = map_new();
    let module_exported_map = map_new();
    let module_source_cache = map_new();
    let import_path_cache = map_new();
    let all_declared_names = set_new();
    let all_exported_declared_names = set_new();
    let all_extern_declared_names = set_new();
    let module_cycles = vec_new();
    gather_prof_reset();
    lint_reset();
    sourcemap_init();
    let t0 = perf_now();
    gather_module_sources(inputPath, moduleBasePath, seen, visiting, sources, module_paths,
    module_declared_map, module_exported_map, module_source_cache, import_path_cache,
    all_declared_names, all_exported_declared_names, all_extern_declared_names, lint, max_lines,
    module_cycles, 0);
    let t1 = perf_now();
    let sm_i = 0;
    let sm_line = 1;
    while (sm_i < module_paths.vec_length()) {
        let sm_path = module_paths.vec_get(sm_i);
        let sm_src = sources.vec_get(sm_i);
        sourcemap_add(sm_path, sm_line);
        sm_line = sm_line + sourcemap_count_lines(sm_src) + 2;
        sm_i = sm_i + 1;
    }
    let joined = join_sources(sources);
    let merged = module_with_c_runtime_prelude(joined, target);
    let t2 = perf_now();
    lex_init(merged);
    lex_all();
    parse_init();
    let program = p_parse_program();
    program = strip_import_decls(program);
    let t3 = perf_now();
    let desugared = desugar(program);
    let resolved = resolve_names(desugared);
    let t4 = perf_now();
    let typed = typecheck_program_with_options(resolved);
    let t5 = perf_now();
    if (borrow == 1) {
        borrowcheck_program(typed);
    }
    let t6 = perf_now();
    if (lint == 1) {
         // File-length lint already ran per module file during gather_module_sources.
        lint_program(typed, inputPath, max_lines, 0);
        let i = 0;
        let len = module_cycles.vec_length();
        while (i < len) {
            lint_add_circular_import_issue(module_cycles.vec_get(i));
            i = i + 1;
        }
    }
    let t7 = perf_now();
    let emitted = module_emit_target_output(typed, merged, target);
    let t8 = perf_now();
    write_file(outputPath, emitted)
}
