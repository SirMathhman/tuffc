 // ============================================================================
 // AST Node Kinds
 // ============================================================================
let {
    tokKind, tokValue, tokLine, tokCol, getIntern, intToString, vecNew, setNew, internStr
}
 = selfhost::runtimeLexer;
let {
    selfhostParserKindsMarker
}
 = selfhost::parserKinds;
let {
    Ok, Err, Result
}
 = selfhost::Result;
let {
    ParseError
}
 = selfhost::errors::ParseError;
 // ============================================================================
 // AST Storage (array-based)
 // ============================================================================
let nodeKinds : Vec<I32> = vecNew();
let nodeData1 : Vec<I32> = vecNew();
 // Generic data slot 1
let nodeData2 : Vec<I32> = vecNew();
 // Generic data slot 2
let nodeData3 : Vec<I32> = vecNew();
 // Generic data slot 3
let nodeData4 : Vec<I32> = vecNew();
 // Generic data slot 4
let nodeData5 : Vec<I32> = vecNew();
 // Generic data slot 5
let nodeToks : Vec<I32> = vecNew();
 // Token index at parse time (for line/col)
let nodeCount : I32 = 1;
out fn nodeNew(kind: I32) : I32 => {
    let idx = nodeCount;
    nodeKinds.vecPush(kind);
    nodeData1.vecPush(0);
    nodeData2.vecPush(0);
    nodeData3.vecPush(0);
    nodeData4.vecPush(0);
    nodeData5.vecPush(0);
    nodeToks.vecPush(parsePos);
    nodeCount = nodeCount + 1;
    idx
}
out fn nodeKind(idx: I32) : I32 => nodeKinds.vecGet(idx);
out fn nodeSetData1<T>(idx: I32, v: T) : I32 => {
    nodeData1.vecSet(idx, v);
    0
}
out fn nodeSetData2<T>(idx: I32, v: T) : I32 => {
    nodeData2.vecSet(idx, v);
    0
}
out fn nodeSetData3<T>(idx: I32, v: T) : I32 => {
    nodeData3.vecSet(idx, v);
    0
}
out fn nodeSetData4<T>(idx: I32, v: T) : I32 => {
    nodeData4.vecSet(idx, v);
    0
}
out fn nodeSetData5<T>(idx: I32, v: T) : I32 => {
    nodeData5.vecSet(idx, v);
    0
}
out fn nodeGetData1(idx: I32) : I32 => nodeData1.vecGet(idx);
out fn nodeGetData2(idx: I32) : I32 => nodeData2.vecGet(idx);
out fn nodeGetData3(idx: I32) : I32 => nodeData3.vecGet(idx);
out fn nodeGetData4(idx: I32) : I32 => nodeData4.vecGet(idx);
out fn nodeGetData5(idx: I32) : I32 => nodeData5.vecGet(idx);
out fn nodeGetLine(idx: I32) : I32 => tokLine(nodeToks.vecGet(idx));
out fn nodeGetCol(idx: I32) : I32 => tokCol(nodeToks.vecGet(idx));
 // ============================================================================
 // Parser
 // ============================================================================
let parsePos : I32 = 0;
let parseExports : *mut Set<*Str> = setNew();
// Cached symbol IDs for fast comparison
let PC_SYM_STAR : I32 = 0;
let PC_SYM_LBRACKET : I32 = 0;
let PC_SYM_LPAREN : I32 = 0;
fn pcInitSymbolCache() : I32 => {
    if (PC_SYM_STAR == 0) {
        PC_SYM_STAR = internStr("*");
        PC_SYM_LBRACKET = internStr("[");
        PC_SYM_LPAREN = internStr("(");
    }
    0
}
out fn getParseExports() : *mut Set<*Str> => parseExports;
out fn parseInit() : I32 => {
    parsePos = 0;
    parseExports = setNew();
     // Clear node arrays for fresh compilation
    nodeKinds.vecClear();
    nodeData1.vecClear();
    nodeData2.vecClear();
    nodeData3.vecClear();
    nodeData4.vecClear();
    nodeData5.vecClear();
    nodeToks.vecClear();
     // Reserve index 0 as null/sentinel node.
    nodeKinds.vecPush(0);
    nodeData1.vecPush(0);
    nodeData2.vecPush(0);
    nodeData3.vecPush(0);
    nodeData4.vecPush(0);
    nodeData5.vecPush(0);
    nodeToks.vecPush(0);
    nodeCount = 1;
    0
}
out fn pPeek(offset: I32) : I32 => {
    let idx = parsePos + offset;
    if (idx >= tokCount) {
        tokCount - 1
    }
    else {
        idx
    }
}
out fn pMark() : I32 => parsePos;
out fn pRestore(mark: I32) : I32 => {
    parsePos = mark;
    0
}
out fn pAtKind(kind: I32) : Bool => tokKind(pPeek(0)) == kind;
out fn pAtValue(val: *Str) : Bool => {
    let v = tokValue(pPeek(0));
    internMap.mapHas(val) && internMap.mapGet(val) == v
}
out fn pAt(kind: I32, val: *Str) : Bool => pAtKind(kind) && pAtValue(val);
out fn pEat() : I32 => {
    let t = pPeek(0);
    parsePos = parsePos + 1;
    t
}
fn pTokenKindName(knd: I32) : *Str => {
    if (knd == TK_EOF) {
        return "eof";
    }
    if (knd == TK_KEYWORD) {
        return "keyword";
    }
    if (knd == TK_IDENTIFIER) {
        return "identifier";
    }
    if (knd == TK_NUMBER) {
        return "number";
    }
    if (knd == TK_STRING) {
        return "string";
    }
    if (knd == TK_BOOL) {
        return "bool";
    }
    if (knd == TK_SYMBOL) {
        return "symbol";
    }
    if (knd == TK_CHAR) {
        return "char";
    }
    "token"
}
fn pTokenValueForError(t: I32) : *Str => {
    let knd = tokKind(t);
    if (knd == TK_BOOL) {
        if (tokValue(t) == 0) {
            return "false";
        }
        return "true";
    }
    if (
    knd == TK_KEYWORD ||
    knd == TK_IDENTIFIER ||
    knd == TK_NUMBER ||
    knd == TK_STRING ||
    knd == TK_SYMBOL ||
    knd == TK_CHAR ||
    knd == TK_EOF
    ) {
        let raw = getIntern(tokValue(t));
        if (knd == TK_SYMBOL && raw.strLength() == 0) {
            return "<empty-symbol>";
        }
        return raw;
    }
    "<unknown>"
}
fn pTokenDebugAt(i: I32) : *Str => {
    if (i < 0 || i >= tokCount) {
        return "<none>";
    }
    let kname = pTokenKindName(tokKind(i));
    let val = pTokenValueForError(i);
    let line = intToString(tokLine(i));
    let col = intToString(tokCol(i));
    kname
    .strConcat(":")
    .strConcat(val)
    .strConcat(" @")
    .strConcat(line)
    .strConcat(":")
    .strConcat(col)
}
out fn pErrorWithTokenContext(msg: *Str) : I32 => {
    let t = pPeek(0);
    let curIdx = t;
    let prevIdx = parsePos - 1;
    let nextIdx = parsePos + 1;
    let foundKind = pTokenKindName(tokKind(curIdx));
    let value = pTokenValueForError(curIdx);
    let line = intToString(tokLine(curIdx));
    let col = intToString(tokCol(curIdx));
    let prevTok = pTokenDebugAt(prevIdx);
    let curTok = pTokenDebugAt(curIdx);
    let nextTok = pTokenDebugAt(nextIdx);
    panic(msg
    .strConcat(" (found ")
    .strConcat(foundKind)
    .strConcat(":")
    .strConcat(value)
    .strConcat(" at ")
    .strConcat(line)
    .strConcat(":")
    .strConcat(col)
    .strConcat("; context: [prev=")
    .strConcat(prevTok)
    .strConcat(", current=")
    .strConcat(curTok)
    .strConcat(", next=")
    .strConcat(nextTok)
    .strConcat("]")
    .strConcat(")"));
    0
}

// Parse error helpers - dual pattern for Result migration
// p_panic_loc: For non-Result helper functions - returns I32, panics
out fn pPanicLoc(code: *Str, message: *Str, reason: *Str, fix: *Str) : I32 => {
    let t = pPeek(0);
    panicWithCodeLoc(code, message, reason, fix, tokLine(t), tokCol(t));
    0
}

// p_result_error: For Result-returning functions - returns Result<I32, ParseError>
out fn pResultError(code: *Str, message: *Str, reason: *Str, fix: *Str) : Result<I32, ParseError> => {
    let t = pPeek(0);
    let err = ParseError {
        code: code,
        message: message,
        reason: reason,
        fix: fix,
        line: tokLine(t),
        col: tokCol(t)
    };
    Err<ParseError> { error: err }
}

out fn pExpectKind(kind: I32, msg: *Str) : I32 => {
    if (!pAtKind(kind)) {
        pErrorWithTokenContext(msg);
    }
    pEat()
}
out fn pExpect(kind: I32, val: *Str, msg: *Str) : I32 => {
    if (!pAt(kind, val)) {
        pErrorWithTokenContext(msg);
    }
    pEat()
}
out fn pParseIdentifier() : I32 => {
    let t = pExpectKind(TK_IDENTIFIER, "Expected identifier");
    tokValue(t)
}
 // Note: No forward declarations needed - JS hoists functions
out fn pCanStartTypeTok() : Bool => {
    if (pAtKind(TK_IDENTIFIER)) {
        return true;
    }
    if (pAt(TK_SYMBOL, "*")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "[")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "(")) {
        return true;
    }
    false
}
out fn pCanStartTypeTokAt(offset: I32) : Bool => {
    pcInitSymbolCache();
    let idx = pPeek(offset);
    let k = tokKind(idx);
    if (k == TK_IDENTIFIER) {
        return true;
    }
    if (k == TK_SYMBOL) {
        let v = tokValue(idx);
        if (v == PC_SYM_STAR || v == PC_SYM_LBRACKET || v == PC_SYM_LPAREN) {
            return true;
        }
    }
    false
}
out fn pCanStartTypeAfterLifetimeTokAt(offset: I32) : Bool => {
    pcInitSymbolCache();
    let idx = pPeek(offset);
    let k = tokKind(idx);
    if (k == TK_IDENTIFIER) {
        return true;
    }
    if (k == TK_SYMBOL) {
        let v = tokValue(idx);
        if (v == PC_SYM_STAR || v == PC_SYM_LBRACKET || v == PC_SYM_LPAREN) {
            return true;
        }
    }
    if (k == TK_KEYWORD) {
        let kw = getIntern(tokValue(idx));
        if (kw.strEq("mut") || kw.strEq("move") || kw.strEq("out") || kw.strEq("uninit")) {
            return true;
        }
    }
    false
}
out fn pCanStartRefinementExpr() : Bool => {
    if (pAtKind(TK_NUMBER)) {
        return true;
    }
    if (pAtKind(TK_IDENTIFIER)) {
        return true;
    }
    if (pAtKind(TK_BOOL)) {
        return true;
    }
    if (pAtKind(TK_STRING)) {
        return true;
    }
    if (pAt(TK_SYMBOL, "(")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "-")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "!")) {
        return true;
    }
    false
}
out fn pCanStartRefinementExprAt(offset: I32) : Bool => {
    let idx = pPeek(offset);
    let k = tokKind(idx);
    if (k == TK_NUMBER || k == TK_IDENTIFIER || k == TK_BOOL || k == TK_STRING || k == TK_CHAR) {
        return true;
    }
    if (k == TK_SYMBOL) {
        let s = getIntern(tokValue(idx));
        if (s.strEq("(") || s.strEq("-") || s.strEq("!")) {
            return true;
        }
    }
    false
}
fn pParseTypePrimaryPointer() : I32 => {
    pEat();
    let mutable = 0;
    let movePtr = 0;
    let lifeName = 0;
    let progressed = true;
    while (progressed) {
        progressed = false;
        if (mutable == 0 && pAt(TK_KEYWORD, "mut")) {
            pEat();
            mutable = 1;
            progressed = true;
        }
        else if (movePtr == 0 && pAt(TK_KEYWORD, "move")) {
            pEat();
            movePtr = 1;
            progressed = true;
        }
        else if (lifeName == 0 && pAtKind(TK_IDENTIFIER) &&
        pCanStartTypeAfterLifetimeTokAt(1)) {
            lifeName = tokValue(pEat());
            progressed = true;
        }
    }
    let inner = pParseTypePrimary();
    let node = nodeNew(NK_POINTER_TYPE);
    nodeSetData1(node, mutable);
    nodeSetData2(node, inner);
    nodeSetData3(node, movePtr);
    nodeSetData4(node, lifeName);
    node
}
fn pParseTypePrimaryInlineStructVariant() : I32 => {
    pExpect(TK_KEYWORD, "struct", "Expected 'struct' in inline union variant");
    let name = pParseIdentifier();
    pExpect(TK_SYMBOL, "{", "Expected '{' after inline struct variant name");
    while (!pAt(TK_SYMBOL, "}")) {
        pParseIdentifier();
        pExpect(TK_SYMBOL, ":", "Expected ':' after inline struct field name");
        pParseType();
        pExpect(TK_SYMBOL, ";", "Expected ';' after inline struct field type");
    }
    pExpect(TK_SYMBOL, "}", "Expected '}' after inline struct variant");
    let typeNode = nodeNew(NK_NAMED_TYPE);
    nodeSetData1(typeNode, name);
    nodeSetData2(typeNode, vecNew());
    typeNode
}
fn pParseTypePrimaryArray() : I32 => {
    pEat();
    let elem = pParseType();
    let init = 0;
    let total = 0;
    if (pAt(TK_SYMBOL, ";")) {
        pEat();
        init = pParseExpression(0);
        pExpect(TK_SYMBOL, ";", "Expected ';' in array type");
        total = pParseExpression(0);
    }
    pExpect(TK_SYMBOL, "]", "Expected ']'");
    let node = nodeNew(NK_ARRAY_TYPE);
    nodeSetData1(node, elem);
    nodeSetData2(node, init);
    nodeSetData3(node, total);
    node
}
fn pTrySkipNamedTupleMemberLabel() : I32 => {
    if (tokKind(pPeek(0)) == TK_IDENTIFIER && tokKind(pPeek(1)) == TK_SYMBOL) {
        let sym = getIntern(tokValue(pPeek(1)));
        if (sym.strEq(":")) {
            pEat();
            pEat();
        }
    }
    0
}
fn pParseTypePrimaryTupleOrFn() : I32 => {
    pEat();
    let members = vecNew();
    if (!pAt(TK_SYMBOL, ")")) {
        pTrySkipNamedTupleMemberLabel();
        members.vecPush(pParseType());
        while (pAt(TK_SYMBOL, ",")) {
            pEat();
            pTrySkipNamedTupleMemberLabel();
            members.vecPush(pParseType());
        }
    }
    pExpect(TK_SYMBOL, ")", "Expected ')' in tuple type");
    if (pAt(TK_SYMBOL, "=>")) {
        pEat();
        let ret = pParseType();
        let fnty = nodeNew(NK_FUNCTION_TYPE);
        nodeSetData1(fnty, members);
        nodeSetData2(fnty, ret);
        return fnty;
    }
    let node = nodeNew(NK_TUPLE_TYPE);
    nodeSetData1(node, members);
    node
}
fn pParseTypePrimaryNumericSentinel() : I32 => {
    let t = pEat();
    let raw = getIntern(tokValue(t));
    if (!(raw.strEq("0USize") || raw.strEq("0"))) {
        pPanicLoc(
        "E_PARSE_INVALID_LITERAL",
        "Only 0 or 0USize is supported as a type-level numeric sentinel",
        "Type-level numeric literals are restricted to zero sentinels",
        "Use 0 or 0USize for type-level numeric sentinels"
    );
    }
    let base = nodeNew(NK_NAMED_TYPE);
    nodeSetData1(base, intern("USize"));
    nodeSetData2(base, vecNew());
    let lit = nodeNew(NK_NUMBER_LIT);
    nodeSetData1(lit, tokValue(t));
    let refine = nodeNew(NK_REFINEMENT_TYPE);
    nodeSetData1(refine, base);
    nodeSetData2(refine, intern("=="));
    nodeSetData3(refine, lit);
    refine
}
fn pParseTypePrimaryNamedOrApplied() : I32 => {
    let name = pParseIdentifier();
    let generics = vecNew();
    while (pAt(TK_SYMBOL, "::")) {
        pEat();
        pParseIdentifier();
    }
    let wouldBeMemberRefine = false;
    if (pAt(TK_SYMBOL, "<")) {
        let k1 = tokKind(pPeek(1));
        let k2 = tokKind(pPeek(2));
        if (k1 == TK_IDENTIFIER && k2 == TK_SYMBOL) {
            let s2 = getIntern(tokValue(pPeek(2)));
            if (s2.strEq(".") || s2.strEq("(")) {
                wouldBeMemberRefine = true;
            }
        }
    }
    if (pAt(TK_SYMBOL, "<") && pCanStartTypeTokAt(1) && !wouldBeMemberRefine) {
        pEat();
        if (!pAt(TK_SYMBOL, ">")) {
            generics.vecPush(pParseType());
            while (pAt(TK_SYMBOL, ",")) {
                pEat();
                generics.vecPush(pParseType());
            }
        }
        pExpect(TK_SYMBOL, ">", "Expected '>' in generic args");
    }
    let typeNode = nodeNew(NK_NAMED_TYPE);
    nodeSetData1(typeNode, name);
    nodeSetData2(typeNode, generics);
    if (pAt(TK_SYMBOL, "(") && generics.vecLength() == 0) {
        pEat();
        let args = vecNew();
        if (!pAt(TK_SYMBOL, ")")) {
            args.vecPush(pParseExpression(0));
            while (pAt(TK_SYMBOL, ",")) {
                pEat();
                args.vecPush(pParseExpression(0));
            }
        }
        pExpect(TK_SYMBOL, ")", "Expected ')' after type-application arguments");
        let applied = nodeNew(NK_APPLIED_TYPE);
        nodeSetData1(applied, name);
        nodeSetData2(applied, args);
        return applied;
    }
    typeNode
}
out fn pParseTypePrimary() : I32 => {
    if (pAt(TK_KEYWORD, "struct")) {
        return pParseTypePrimaryInlineStructVariant();
    }
    if (pAt(TK_SYMBOL, "*")) {
        return pParseTypePrimaryPointer();
    }
    if (pAt(TK_SYMBOL, "[")) {
        return pParseTypePrimaryArray();
    }
    if (pAt(TK_SYMBOL, "(")) {
        return pParseTypePrimaryTupleOrFn();
    }
    if (pAtKind(TK_NUMBER)) {
        return pParseTypePrimaryNumericSentinel();
    }
    pParseTypePrimaryNamedOrApplied()
}
out fn pParseType() : I32 => {
    let typeNode = pParseTypePrimary();
     // Refinement predicate
    let hasRefine = pAt(TK_SYMBOL, "!=") || pAt(TK_SYMBOL, "<") || pAt(TK_SYMBOL, ">") || pAt(TK_SYMBOL, "<=") || pAt(TK_SYMBOL, ">=");
    let startsGenericCallSuffix = false;
    if (pAt(TK_SYMBOL, ">") && tokKind(pPeek(1)) == TK_SYMBOL) {
        let nextSym = getIntern(tokValue(pPeek(1)));
        if (nextSym.strEq("(")) {
            startsGenericCallSuffix = true;
        }
    }
    if (hasRefine && pCanStartRefinementExprAt(1) && !startsGenericCallSuffix) {
        let op = tokValue(pEat());
        let valExpr = pParseExpression(0);
        let refine = nodeNew(NK_REFINEMENT_TYPE);
        nodeSetData1(refine, typeNode);
        nodeSetData2(refine, op);
        nodeSetData3(refine, valExpr);
        typeNode = refine;
    }
     // Arithmetic type/value expressions used in annotations (e.g. SizeOf<T> * L)
    while (
    pAt(TK_SYMBOL, "+") ||
    pAt(TK_SYMBOL, "-") ||
    pAt(TK_SYMBOL, "*") ||
    pAt(TK_SYMBOL, "/") ||
    pAt(TK_SYMBOL, "%")
    ) {
        let op = tokValue(pEat());
        let right = pParseTypePrimary();
        let bin = nodeNew(NK_BINARY_EXPR);
        nodeSetData1(bin, op);
        nodeSetData2(bin, typeNode);
        nodeSetData3(bin, right);
        typeNode = bin;
    }
     // Union types
    while (pAt(TK_SYMBOL, "|") || pAt(TK_SYMBOL, "|>")) {
        let isExtract = 0;
        if (pAt(TK_SYMBOL, "|>")) {
            isExtract = 1;
        }
        pEat();
        let right = pParseTypePrimary();
        let unionNode = nodeNew(NK_UNION_TYPE);
        nodeSetData1(unionNode, typeNode);
        nodeSetData2(unionNode, right);
        nodeSetData3(unionNode, isExtract);
        typeNode = unionNode;
    }
    typeNode
}
out fn pParsePattern() : I32 => {
     // Wildcard
    if (pAt(TK_SYMBOL, "_") || pAt(TK_IDENTIFIER, "_")) {
        pEat();
        return nodeNew(NK_WILDCARD_PAT);
    }
     // Number literal
    if (pAtKind(TK_NUMBER)) {
        let t = pEat();
        let node = nodeNew(NK_LITERAL_PAT);
        nodeSetData1(node, tokValue(t));
        return node;
    }
     // Bool literal
    if (pAtKind(TK_BOOL)) {
        let t = pEat();
        let node = nodeNew(NK_LITERAL_PAT);
        nodeSetData1(node, tokValue(t));
        return node;
    }
    // Name or struct pattern (supports optional leading 'struct')
    let hasStructKeyword = false;
    if (pAt(TK_KEYWORD, "struct")) {
        pEat();
        hasStructKeyword = true;
    }
    let name = pParseIdentifier();
     // Optional generic qualifiers in pattern position: Some<T>, Foo<A, B>
    if (pAt(TK_SYMBOL, "<") && pCanStartTypeTokAt(1)) {
        pEat();
        if (!pAt(TK_SYMBOL, ">")) {
            pParseType();
            while (pAt(TK_SYMBOL, ",")) {
                pEat();
                pParseType();
            }
        }
        pExpect(TK_SYMBOL, ">", "Expected '>' in pattern generic args");
    }
    if (pAt(TK_SYMBOL, "{")) {
        pEat();
        let fields = vecNew();
        if (!pAt(TK_SYMBOL, "}")) {
            fields.vecPush(pParseIdentifier());
            while (pAt(TK_SYMBOL, ",")) {
                pEat();
                fields.vecPush(pParseIdentifier());
            }
        }
        pExpect(TK_SYMBOL, "}", "Expected '}' in pattern");
        let node = nodeNew(NK_STRUCT_PAT);
        nodeSetData1(node, name);
        nodeSetData2(node, fields);
        return node;
    }
    if (hasStructKeyword) {
        let node = nodeNew(NK_STRUCT_PAT);
        nodeSetData1(node, name);
        nodeSetData2(node, vecNew());
        return node;
    }
    let node = nodeNew(NK_NAME_PAT);
    nodeSetData1(node, name);
    node
}
out fn selfhostParserCoreMarker() : I32 => 0;
