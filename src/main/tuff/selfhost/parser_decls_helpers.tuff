let { get_intern, tok_kind, tok_value, vec_new } = selfhost::runtime_lexer;
let { p_expect, p_expect_kind, p_parse_identifier, p_at, p_eat, p_parse_type, p_parse_type_primary, p_at_kind, p_can_start_refinement_expr_at, p_peek, node_kind, node_new, node_set_data1, node_set_data2, node_set_data3, node_set_data4, node_set_data5, node_get_data1, node_get_data2 } = selfhost::parser_core;

let parse_temp_counter : I32 = 0;

fn p_new_temp_name(prefix: *Str) : I32 => {
    parse_temp_counter = parse_temp_counter + 1;
    intern(prefix.str_concat(int_to_string(parse_temp_counter)))
}

fn p_decls_helpers_new_stmt_list(stmts: Vec) : I32 => {
    let n = node_new(NK_STMT_LIST);
    node_set_data1(n, stmts);
    n
}

fn p_parse_constraint_value_atom() : I32 => {
    if (p_at_kind(TK_IDENTIFIER)) {
        let n = node_new(NK_IDENTIFIER);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at_kind(TK_NUMBER)) {
        let n = node_new(NK_NUMBER_LIT);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at_kind(TK_BOOL)) {
        let n = node_new(NK_BOOL_LIT);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at_kind(TK_STRING)) {
        let n = node_new(NK_STRING_LIT);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at_kind(TK_CHAR)) {
        let n = node_new(NK_CHAR_LIT);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at(TK_SYMBOL, "(")) {
        p_eat();
        let inner = p_parse_expression(0);
        p_expect(TK_SYMBOL, ")", "Expected ')' in generic constraint expression");
        return inner;
    }
    p_parse_type_primary()
}

fn p_parse_constraint_value_expr() : I32 => {
    let left = p_parse_constraint_value_atom();
    while (
        p_at(TK_SYMBOL, "+") ||
        p_at(TK_SYMBOL, "-") ||
        p_at(TK_SYMBOL, "*") ||
        p_at(TK_SYMBOL, "/") ||
        p_at(TK_SYMBOL, "%")
    ) {
        let op = tok_value(p_eat());
        let right = p_parse_constraint_value_atom();
        let bin = node_new(NK_BINARY_EXPR);
        node_set_data1(bin, op);
        node_set_data2(bin, left);
        node_set_data3(bin, right);
        left = bin;
    }
    left
}

fn p_parse_generic_constraint_type() : I32 => {
    let type_node = p_parse_type_primary();

    let starts_generic_call_suffix = false;
    if (p_at(TK_SYMBOL, ">") && tok_kind(p_peek(1)) == TK_SYMBOL) {
        let next_sym = get_intern(tok_value(p_peek(1)));
        if (next_sym.str_eq("(")) {
            starts_generic_call_suffix = true;
        }
    }

    let has_refine =
        (p_at(TK_SYMBOL, "!=") ||
        p_at(TK_SYMBOL, "<") ||
        p_at(TK_SYMBOL, ">") ||
        p_at(TK_SYMBOL, "<=") ||
        p_at(TK_SYMBOL, ">=")) &&
        p_can_start_refinement_expr_at(1) &&
        !starts_generic_call_suffix;

    if (has_refine) {
        let op = tok_value(p_eat());
        let value = p_parse_constraint_value_expr();
        let refine = node_new(NK_REFINEMENT_TYPE);
        node_set_data1(refine, type_node);
        node_set_data2(refine, op);
        node_set_data3(refine, value);
        type_node = refine;
    }

    while (p_at(TK_SYMBOL, "|") || p_at(TK_SYMBOL, "|>")) {
        let is_extract = 0;
        if (p_at(TK_SYMBOL, "|>")) {
            is_extract = 1;
        }
        p_eat();
        let right = p_parse_type_primary();
        let union_node = node_new(NK_UNION_TYPE);
        node_set_data1(union_node, type_node);
        node_set_data2(union_node, right);
        node_set_data3(union_node, is_extract);
        type_node = union_node;
    }

    type_node
}

fn p_parse_decl_generics(close_message: *Str) : Vec => {
    let generics = vec_new();
    if (p_at(TK_SYMBOL, "<")) {
        p_eat();
        if (!p_at(TK_SYMBOL, ">")) {
            while (true) {
                generics.vec_push(p_parse_identifier());
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    p_parse_generic_constraint_type();
                }
                if (!p_at(TK_SYMBOL, ",")) {
                    break;
                }
                p_eat();
            }
        }
        p_expect(TK_SYMBOL, ">", close_message);
    }
    generics
}

out fn p_parse_function(is_class: I32, mode: I32) : I32 => {
    p_expect(TK_KEYWORD, "fn", "Expected 'fn'");
    let name = p_parse_identifier();

    let generics = p_parse_decl_generics("Expected '>'");

    p_expect(TK_SYMBOL, "(", "Expected '('");
    let params = vec_new();
    if (!p_at(TK_SYMBOL, ")")) {
        while (true) {
            let pname = 0;
            let ptype = 0;

            if (p_at(TK_SYMBOL, "*")) {
                ptype = p_parse_type();
                if (p_at_kind(TK_IDENTIFIER)) {
                    pname = p_parse_identifier();
                } else {
                    if (node_kind(ptype) == NK_POINTER_TYPE) {
                        let inner = node_get_data2(ptype);
                        if (inner != 0 && node_kind(inner) == NK_NAMED_TYPE) {
                            let inner_name = node_get_data1(inner);
                            if (get_intern(inner_name).str_eq("this")) {
                                pname = inner_name;
                            } else {
                                p_expect_kind(TK_IDENTIFIER, "Expected identifier");
                            }
                        } else {
                            p_expect_kind(TK_IDENTIFIER, "Expected identifier");
                        }
                    } else {
                        p_expect_kind(TK_IDENTIFIER, "Expected identifier");
                    }
                }
            } else {
                pname = p_parse_identifier();
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    ptype = p_parse_type();
                }
            }

            let param = vec_new();
            param.vec_push(pname);
            param.vec_push(ptype);
            params.vec_push(param);

            if (!p_at(TK_SYMBOL, ",")) {
                break;
            }
            p_eat();
        }
    }
    p_expect(TK_SYMBOL, ")", "Expected ')'");

    let ret_type = 0;
    if (p_at(TK_SYMBOL, ":")) {
        p_eat();
        ret_type = p_parse_type();
    }

    let body = 0;
    if (mode == 1) {
        p_expect(TK_SYMBOL, ";", "Expected ';' after expect function declaration");
    } else {
        p_expect(TK_SYMBOL, "=>", "Expected '=>'");
        if (p_at(TK_SYMBOL, "{")) {
            body = p_parse_block();
        } else {
            body = p_parse_expression(0);
        }

        if (node_kind(body) != NK_BLOCK) {
            if (!p_at(TK_SYMBOL, "}") && !p_at_kind(TK_EOF)) {
                p_expect(TK_SYMBOL, ";", "Expected ';'");
            }
        }
    }

    let kind = NK_FN_DECL;
    if (is_class == 1) {
        kind = NK_CLASS_FN_DECL;
    } else if (mode == 1) {
        kind = NK_EXPECT_FN_DECL;
    } else if (mode == 2) {
        kind = NK_ACTUAL_FN_DECL;
    }
    let node = node_new(kind);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, params);
    node_set_data4(node, ret_type);
    node_set_data5(node, body);
    node
}

out fn p_parse_struct(is_copy: I32) : I32 => {
    p_expect(TK_KEYWORD, "struct", "Expected 'struct'");
    let name = p_parse_identifier();

    let generics = p_parse_decl_generics("Expected '>'");

    p_expect(TK_SYMBOL, "{", "Expected '{'");
    let fields = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        let fname = p_parse_identifier();
        p_expect(TK_SYMBOL, ":", "Expected ':'");
        let ftype = p_parse_type();
        let field = vec_new();
        field.vec_push(fname);
        field.vec_push(ftype);
        fields.vec_push(field);
        if (p_at(TK_SYMBOL, ",") || p_at(TK_SYMBOL, ";")) {
            p_eat();
        }
    }
    p_expect(TK_SYMBOL, "}", "Expected '}'");

    let node = node_new(NK_STRUCT_DECL);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, fields);
    node_set_data4(node, is_copy);
    node
}

out fn p_parse_enum() : I32 => {
    p_expect(TK_KEYWORD, "enum", "Expected 'enum'");
    let name = p_parse_identifier();
    p_expect(TK_SYMBOL, "{", "Expected '{' after enum name");
    let variants = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        variants.vec_push(p_parse_identifier());
        if (p_at(TK_SYMBOL, ",") || p_at(TK_SYMBOL, ";")) {
            p_eat();
        }
    }
    p_expect(TK_SYMBOL, "}", "Expected '}' after enum body");
    let node = node_new(NK_ENUM_DECL);
    node_set_data1(node, name);
    node_set_data2(node, variants);
    node
}

out fn p_parse_object() : I32 => {
    p_expect(TK_KEYWORD, "object", "Expected 'object'");
    let name = p_parse_identifier();

    let generics = p_parse_decl_generics("Expected '>'");

    p_expect(TK_SYMBOL, "{", "Expected '{' after object name");
    let inputs = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        p_expect(TK_KEYWORD, "in", "Expected 'in' in object input declaration");
        p_expect(TK_KEYWORD, "let", "Expected 'let' in object input declaration");
        let input_name = p_parse_identifier();
        p_expect(TK_SYMBOL, ":", "Expected ':' in object input declaration");
        let input_type = p_parse_type();
        p_expect(TK_SYMBOL, ";", "Expected ';' after object input declaration");

        let input_field = vec_new();
        input_field.vec_push(input_name);
        input_field.vec_push(input_type);
        inputs.vec_push(input_field);
    }
    p_expect(TK_SYMBOL, "}", "Expected '}' after object body");

    let node = node_new(NK_OBJECT_DECL);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, inputs);
    node
}

out fn p_parse_contract() : I32 => {
    p_expect(TK_KEYWORD, "contract", "Expected 'contract'");
    let name = p_parse_identifier();
    p_expect(TK_SYMBOL, "{", "Expected '{' after contract name");

    let methods = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        p_expect(TK_KEYWORD, "fn", "Expected 'fn' in contract declaration");
        let mname = p_parse_identifier();
        let mgenerics = p_parse_decl_generics("Expected '>' after contract method generics");

        p_expect(TK_SYMBOL, "(", "Expected '(' in contract method signature");
        let params = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            while (true) {
                let pname = 0;
                let ptype = 0;
                let implicit_this = 0;

                if (p_at(TK_SYMBOL, "*")) {
                    p_eat();
                    if (p_at(TK_KEYWORD, "mut")) {
                        p_eat();
                    }
                    pname = p_parse_identifier();
                    ptype = 0;
                    implicit_this = 1;
                } else {
                    pname = p_parse_identifier();
                    if (p_at(TK_SYMBOL, ":")) {
                        p_eat();
                        ptype = p_parse_type();
                    }
                }

                let param = vec_new();
                param.vec_push(pname);
                param.vec_push(ptype);
                param.vec_push(implicit_this);
                params.vec_push(param);

                if (!p_at(TK_SYMBOL, ",")) {
                    break;
                }
                p_eat();
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')' after contract method params");

        let ret = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            ret = p_parse_type();
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after contract method signature");

        let method = vec_new();
        method.vec_push(mname);
        method.vec_push(mgenerics);
        method.vec_push(params);
        method.vec_push(ret);
        methods.vec_push(method);
    }

    p_expect(TK_SYMBOL, "}", "Expected '}' after contract body");
    let node = node_new(NK_CONTRACT_DECL);
    node_set_data1(node, name);
    node_set_data2(node, methods);
    node
}

out fn p_parse_type_alias(is_copy: I32) : I32 => {
    p_expect(TK_KEYWORD, "type", "Expected 'type'");
    let name = p_parse_identifier();

    if (p_at(TK_SYMBOL, "(")) {
        p_eat();
        let value_params = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            while (true) {
                let pname = p_parse_identifier();
                let ptype = 0;
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    ptype = p_parse_type();
                }
                let param = vec_new();
                param.vec_push(pname);
                param.vec_push(ptype);
                value_params.vec_push(param);
                if (!p_at(TK_SYMBOL, ",")) {
                    break;
                }
                p_eat();
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')' after dep-type-alias value params");
        p_expect(TK_SYMBOL, "=", "Expected '=' in dep-type-alias");
        let aliased = p_parse_type();
        let destructor_name = 0;
        if (p_at(TK_KEYWORD, "then")) {
            p_eat();
            destructor_name = p_parse_identifier();
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after dep-type-alias");
        let node = node_new(NK_DEP_TYPE_ALIAS);
        node_set_data1(node, name);
        node_set_data2(node, value_params);
        node_set_data3(node, aliased);
        node_set_data4(node, is_copy);
        node_set_data5(node, destructor_name);
        return node;
    }

    let generics = p_parse_decl_generics("Expected '>'");

    p_expect(TK_SYMBOL, "=", "Expected '='");
    let aliased = p_parse_type();
    let destructor_name = 0;
    if (p_at(TK_KEYWORD, "then")) {
        p_eat();
        destructor_name = p_parse_identifier();
    }
    p_expect(TK_SYMBOL, ";", "Expected ';'");

    let node = node_new(NK_TYPE_ALIAS);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, aliased);
    node_set_data4(node, is_copy);
    node_set_data5(node, destructor_name);
    node
}

out fn p_parse_let() : I32 => {
    p_expect(TK_KEYWORD, "let", "Expected 'let'");

    if (p_at(TK_KEYWORD, "mut")) {
        p_eat();
    }

    if (p_at(TK_SYMBOL, "{")) {
        p_eat();
        let names = vec_new();
        if (!p_at(TK_SYMBOL, "}")) {
            names.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                names.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, "}", "Expected '}'");
        p_expect(TK_SYMBOL, "=", "Expected '='");
        let parts = vec_new();
        parts.vec_push(p_parse_identifier());
        while (p_at(TK_SYMBOL, "::")) {
            p_eat();
            parts.vec_push(p_parse_identifier());
        }
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        let node = node_new(NK_IMPORT_DECL);
        node_set_data1(node, names);
        node_set_data2(node, parts);
        return node;
    }

    if (p_at(TK_SYMBOL, "(")) {
        p_eat();
        let names = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            names.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                names.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')' in tuple let destructuring");
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            p_parse_type();
        }
        p_expect(TK_SYMBOL, "=", "Expected '=' in tuple let destructuring");
        let rhs = p_parse_expression(0);
        p_expect(TK_SYMBOL, ";", "Expected ';' after tuple let destructuring");

        let lowered = vec_new();
        let tmp_name = p_new_temp_name("__tuple_tmp_");

        let tmp_decl = node_new(NK_LET_DECL);
        node_set_data1(tmp_decl, tmp_name);
        node_set_data2(tmp_decl, 0);
        node_set_data3(tmp_decl, rhs);
        lowered.vec_push(tmp_decl);

        let i = 0;
        while (i < names.vec_length()) {
            let tmp_ident = node_new(NK_IDENTIFIER);
            node_set_data1(tmp_ident, tmp_name);

            let idx_lit = node_new(NK_NUMBER_LIT);
            node_set_data1(idx_lit, intern(int_to_string(i)));

            let idx_expr = node_new(NK_INDEX_EXPR);
            node_set_data1(idx_expr, tmp_ident);
            node_set_data2(idx_expr, idx_lit);

            let elem_decl = node_new(NK_LET_DECL);
            node_set_data1(elem_decl, names.vec_get(i));
            node_set_data2(elem_decl, 0);
            node_set_data3(elem_decl, idx_expr);
            lowered.vec_push(elem_decl);

            i = i + 1;
        }

        return p_decls_helpers_new_stmt_list(lowered);
    }

    let name = p_parse_identifier();
    let vtype = 0;
    if (p_at(TK_SYMBOL, ":")) {
        p_eat();
        vtype = p_parse_type();
    }
    p_expect(TK_SYMBOL, "=", "Expected '='");
    let value = p_parse_expression(0);
    p_expect(TK_SYMBOL, ";", "Expected ';'");

    let node = node_new(NK_LET_DECL);
    node_set_data1(node, name);
    node_set_data2(node, vtype);
    node_set_data3(node, value);
    node
}

out fn p_parse_for() : I32 => {
    p_expect(TK_KEYWORD, "for", "Expected 'for'");
    p_expect(TK_SYMBOL, "(", "Expected '('");
    let iter = p_parse_identifier();
    p_expect(TK_KEYWORD, "in", "Expected 'in'");
    let start = p_parse_expression(0);
    p_expect(TK_SYMBOL, "..", "Expected '..'");
    let end = p_parse_expression(0);
    p_expect(TK_SYMBOL, ")", "Expected ')'");
    let body = p_parse_block();

    let node = node_new(NK_FOR_STMT);
    node_set_data1(node, iter);
    node_set_data2(node, start);
    node_set_data3(node, end);
    node_set_data4(node, body);
    node
}

out fn p_parse_lifetime() : I32 => {
    p_expect(TK_KEYWORD, "lifetime", "Expected 'lifetime'");
    let names = vec_new();
    names.vec_push(p_parse_identifier());
    while (p_at(TK_SYMBOL, ",")) {
        p_eat();
        names.vec_push(p_parse_identifier());
    }
    let body = p_parse_block();
    let node = node_new(NK_LIFETIME_STMT);
    node_set_data1(node, names);
    node_set_data2(node, body);
    node
}

out fn p_parse_extern_decl() : I32 => {
    if (p_at(TK_KEYWORD, "fn")) {
        p_eat();
        let name = p_parse_identifier();

        let generics = p_parse_decl_generics("Expected '>'");

        p_expect(TK_SYMBOL, "(", "Expected '('");
        let params = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            while (true) {
                let pname = 0;
                let ptype = 0;

                if (p_at(TK_SYMBOL, "*")) {
                    ptype = p_parse_type();
                    pname = p_parse_identifier();
                } else {
                    pname = p_parse_identifier();
                    if (p_at(TK_SYMBOL, ":")) {
                        p_eat();
                        ptype = p_parse_type();
                    }
                }

                let param = vec_new();
                param.vec_push(pname);
                param.vec_push(ptype);
                params.vec_push(param);

                if (!p_at(TK_SYMBOL, ",")) {
                    break;
                }
                p_eat();
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')'");

        let ret_type = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            ret_type = p_parse_type();
        }

        p_expect(TK_SYMBOL, ";", "Expected ';' after extern fn");

        let node = node_new(NK_EXTERN_FN_DECL);
        node_set_data1(node, name);
        node_set_data2(node, generics);
        node_set_data3(node, params);
        node_set_data4(node, ret_type);
        return node;
    }
    if (p_at(TK_KEYWORD, "let")) {
        p_eat();

        if (p_at(TK_SYMBOL, "{")) {
            p_eat();
            let names = vec_new();
            if (!p_at(TK_SYMBOL, "}")) {
                names.vec_push(p_parse_identifier());
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    names.vec_push(p_parse_identifier());
                }
            }
            p_expect(TK_SYMBOL, "}", "Expected '}' after extern let bindings");
            p_expect(TK_SYMBOL, "=", "Expected '=' in extern let bindings");
            let source_parts = vec_new();
            source_parts.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, "::")) {
                p_eat();
                source_parts.vec_push(p_parse_identifier());
            }
            p_expect(TK_SYMBOL, ";", "Expected ';' after extern let bindings");
            let node = node_new(NK_EXTERN_IMPORT_DECL);
            node_set_data1(node, names);
            node_set_data2(node, source_parts);
            return node;
        }

        let name = p_parse_identifier();
        let typ = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            typ = p_parse_type();
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern let");
        let node = node_new(NK_EXTERN_LET_DECL);
        node_set_data1(node, name);
        node_set_data2(node, typ);
        return node;
    }
    if (p_at(TK_KEYWORD, "type")) {
        p_eat();
        let name = p_parse_identifier();
        let generics = p_parse_decl_generics("Expected '>' after extern type generics");
        let destructor_name = 0;
        if (p_at(TK_KEYWORD, "then")) {
            p_eat();
            destructor_name = p_parse_identifier();
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern type");
        let node = node_new(NK_EXTERN_TYPE_DECL);
        node_set_data1(node, name);
        node_set_data2(node, generics);
        node_set_data5(node, destructor_name);
        return node;
    }
    panic("Expected fn, let, or type after extern")
}

out fn selfhost_parser_decls_helpers_marker() : I32 => 0;
