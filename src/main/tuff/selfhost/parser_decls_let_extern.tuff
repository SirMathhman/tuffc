let {
    get_intern, tok_kind, tok_value, vec_new
}
 = selfhost::runtime_lexer;
let {
    p_expect, p_parse_identifier, p_at, p_eat, p_parse_type, p_parse_type_primary, p_at_kind,
    p_can_start_refinement_expr_at, p_peek, node_new, node_set_data1, node_set_data2, node_set_data3, node_set_data4, node_set_data5
}
 = selfhost::parser_core;
let parse_temp_counter : I32 = 0;
fn p_new_temp_name(prefix: *Str) : I32 => {
    parse_temp_counter = parse_temp_counter + 1;
    intern(prefix.str_concat(int_to_string(parse_temp_counter)))
}
fn p_decls_let_extern_new_stmt_list(stmts: Vec) : I32 => {
    let n = node_new(NK_STMT_LIST);
    node_set_data1(n, stmts);
    n
}
out fn p_parse_let() : I32 => {
    p_expect(TK_KEYWORD, "let", "Expected 'let'");
    if (p_at(TK_KEYWORD, "mut")) {
        p_eat();
    }
    if (p_at(TK_SYMBOL, "{")) {
        p_eat();
        let names = vec_new();
        if (!p_at(TK_SYMBOL, "}")) {
            names.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                names.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, "}", "Expected '}'");
        p_expect(TK_SYMBOL, "=", "Expected '='");
        let parts = vec_new();
        parts.vec_push(p_parse_identifier());
        while (p_at(TK_SYMBOL, "::")) {
            p_eat();
            parts.vec_push(p_parse_identifier());
        }
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        let node = node_new(NK_IMPORT_DECL);
        node_set_data1(node, names);
        node_set_data2(node, parts);
        return node;
    }
    if (p_at(TK_SYMBOL, "(")) {
        p_eat();
        let names = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            names.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                names.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')' in tuple let destructuring");
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            p_parse_type();
        }
        p_expect(TK_SYMBOL, "=", "Expected '=' in tuple let destructuring");
        let rhs = p_parse_expression(0);
        p_expect(TK_SYMBOL, ";", "Expected ';' after tuple let destructuring");
        let lowered = vec_new();
        let tmp_name = p_new_temp_name("__tuple_tmp_");
        let tmp_decl = node_new(NK_LET_DECL);
        node_set_data1(tmp_decl, tmp_name);
        node_set_data2(tmp_decl, 0);
        node_set_data3(tmp_decl, rhs);
        lowered.vec_push(tmp_decl);
        let i = 0;
        while (i < names.vec_length()) {
            let tmp_ident = node_new(NK_IDENTIFIER);
            node_set_data1(tmp_ident, tmp_name);
            let idx_lit = node_new(NK_NUMBER_LIT);
            node_set_data1(idx_lit, intern(int_to_string(i)));
            let idx_expr = node_new(NK_INDEX_EXPR);
            node_set_data1(idx_expr, tmp_ident);
            node_set_data2(idx_expr, idx_lit);
            let elem_decl = node_new(NK_LET_DECL);
            node_set_data1(elem_decl, names.vec_get(i));
            node_set_data2(elem_decl, 0);
            node_set_data3(elem_decl, idx_expr);
            lowered.vec_push(elem_decl);
            i = i + 1;
        }
        return p_decls_let_extern_new_stmt_list(lowered);
    }
    let name = p_parse_identifier();
    let vtype = 0;
    if (p_at(TK_SYMBOL, ":")) {
        p_eat();
        vtype = p_parse_type();
    }
    p_expect(TK_SYMBOL, "=", "Expected '='");
    let value = p_parse_expression(0);
    p_expect(TK_SYMBOL, ";", "Expected ';'");
    let node = node_new(NK_LET_DECL);
    node_set_data1(node, name);
    node_set_data2(node, vtype);
    node_set_data3(node, value);
    node
}
fn p_le_parse_constraint_value_atom() : I32 => {
    if (p_at_kind(TK_IDENTIFIER)) {
        let n = node_new(NK_IDENTIFIER);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at_kind(TK_NUMBER)) {
        let n = node_new(NK_NUMBER_LIT);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at_kind(TK_BOOL)) {
        let n = node_new(NK_BOOL_LIT);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at_kind(TK_STRING)) {
        let n = node_new(NK_STRING_LIT);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at_kind(TK_CHAR)) {
        let n = node_new(NK_CHAR_LIT);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at(TK_SYMBOL, "(")) {
        p_eat();
        let inner = p_parse_expression(0);
        p_expect(TK_SYMBOL, ")", "Expected ')' in generic constraint expression");
        return inner;
    }
    p_parse_type_primary()
}
fn p_le_parse_constraint_value_expr() : I32 => {
    let left = p_le_parse_constraint_value_atom();
    while (
    p_at(TK_SYMBOL, "+") ||
    p_at(TK_SYMBOL, "-") ||
    p_at(TK_SYMBOL, "*") ||
    p_at(TK_SYMBOL, "/") ||
    p_at(TK_SYMBOL, "%")
    ) {
        let op = tok_value(p_eat());
        let right = p_le_parse_constraint_value_atom();
        let bin = node_new(NK_BINARY_EXPR);
        node_set_data1(bin, op);
        node_set_data2(bin, left);
        node_set_data3(bin, right);
        left = bin;
    }
    left
}
fn p_le_parse_generic_constraint_type() : I32 => {
    let type_node = p_parse_type_primary();
    let starts_generic_call_suffix = false;
    if (p_at(TK_SYMBOL, ">") && tok_kind(p_peek(1)) == TK_SYMBOL) {
        let next_sym = get_intern(tok_value(p_peek(1)));
        if (next_sym.str_eq("(")) {
            starts_generic_call_suffix = true;
        }
    }
    let has_refine =
    (p_at(TK_SYMBOL, "!=") ||
    p_at(TK_SYMBOL, "<") ||
    p_at(TK_SYMBOL, ">") ||
    p_at(TK_SYMBOL, "<=") ||
    p_at(TK_SYMBOL, ">=")) &&
    p_can_start_refinement_expr_at(1) &&
    !starts_generic_call_suffix;
    if (has_refine) {
        let op = tok_value(p_eat());
        let value = p_le_parse_constraint_value_expr();
        let refine = node_new(NK_REFINEMENT_TYPE);
        node_set_data1(refine, type_node);
        node_set_data2(refine, op);
        node_set_data3(refine, value);
        type_node = refine;
    }
    while (p_at(TK_SYMBOL, "|") || p_at(TK_SYMBOL, "|>")) {
        let is_extract = 0;
        if (p_at(TK_SYMBOL, "|>")) {
            is_extract = 1;
        }
        p_eat();
        let right = p_parse_type_primary();
        let union_node = node_new(NK_UNION_TYPE);
        node_set_data1(union_node, type_node);
        node_set_data2(union_node, right);
        node_set_data3(union_node, is_extract);
        type_node = union_node;
    }
    type_node
}
fn p_le_parse_decl_generics(close_message: *Str) : Vec => {
    let generics = vec_new();
    if (p_at(TK_SYMBOL, "<")) {
        p_eat();
        if (!p_at(TK_SYMBOL, ">")) {
            while (true) {
                generics.vec_push(p_parse_identifier());
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    p_le_parse_generic_constraint_type();
                }
                if (!p_at(TK_SYMBOL, ",")) {
                    break;
                }
                p_eat();
            }
        }
        p_expect(TK_SYMBOL, ">", close_message);
    }
    generics
}
out fn p_parse_extern_fn_decl() : I32 => {
    p_expect(TK_KEYWORD, "fn", "Expected 'fn'");
    let name = p_parse_identifier();
    let generics = p_le_parse_decl_generics("Expected '>'");
    p_expect(TK_SYMBOL, "(", "Expected '('");
    let params = vec_new();
    if (!p_at(TK_SYMBOL, ")")) {
        while (true) {
            let pname = 0;
            let ptype = 0;
            if (p_at(TK_SYMBOL, "*")) {
                ptype = p_parse_type();
                pname = p_parse_identifier();
            }
            else {
                pname = p_parse_identifier();
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    ptype = p_parse_type();
                }
            }
            let param = vec_new();
            param.vec_push(pname);
            param.vec_push(ptype);
            params.vec_push(param);
            if (!p_at(TK_SYMBOL, ",")) {
                break;
            }
            p_eat();
        }
    }
    p_expect(TK_SYMBOL, ")", "Expected ')'");
    let ret_type = 0;
    if (p_at(TK_SYMBOL, ":")) {
        p_eat();
        ret_type = p_parse_type();
    }
    p_expect(TK_SYMBOL, ";", "Expected ';' after extern fn");
    let node = node_new(NK_FN_DECL);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, params);
    node_set_data4(node, ret_type);
    node_set_data5(node, 0);
    node
}
out fn p_parse_extern_decl() : I32 => {
    if (p_at(TK_KEYWORD, "fn")) {
        return p_parse_extern_fn_decl();
    }
    if (p_at(TK_KEYWORD, "let")) {
        p_eat();
        if (p_at(TK_SYMBOL, "{")) {
            p_eat();
            let names = vec_new();
            if (!p_at(TK_SYMBOL, "}")) {
                names.vec_push(p_parse_identifier());
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    names.vec_push(p_parse_identifier());
                }
            }
            p_expect(TK_SYMBOL, "}", "Expected '}' after extern let bindings");
            p_expect(TK_SYMBOL, "=", "Expected '=' in extern let bindings");
            let source_parts = vec_new();
            source_parts.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, "::")) {
                p_eat();
                source_parts.vec_push(p_parse_identifier());
            }
            p_expect(TK_SYMBOL, ";", "Expected ';' after extern let bindings");
            let node = node_new(NK_EXTERN_IMPORT_DECL);
            node_set_data1(node, names);
            node_set_data2(node, source_parts);
            return node;
        }
        let name = p_parse_identifier();
        let typ = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            typ = p_parse_type();
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern let");
        let node = node_new(NK_EXTERN_LET_DECL);
        node_set_data1(node, name);
        node_set_data2(node, typ);
        return node;
    }
    if (p_at(TK_KEYWORD, "type")) {
        p_eat();
        let name = p_parse_identifier();
        let generics = p_le_parse_decl_generics("Expected '>' after extern type generics");
        let destructor_name = 0;
        if (p_at(TK_KEYWORD, "then")) {
            p_eat();
            destructor_name = p_parse_identifier();
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern type");
        let node = node_new(NK_EXTERN_TYPE_DECL);
        node_set_data1(node, name);
        node_set_data2(node, generics);
        node_set_data5(node, destructor_name);
        return node;
    }
    panic("Expected fn, let, or type after extern")
}
out fn selfhost_parser_decls_let_extern_marker() : I32 => 0;
