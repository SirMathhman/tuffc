// ============================================================================
// JavaScript Code Generation
// ============================================================================

let { get_interned_str, vec_new } = selfhost::runtime_lexer;
let { node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5 } = selfhost::parser_core;

fn emit_expr(n: I32) : *Str => {
    let kind = node_kind(n);
    
    if (kind == NK_NUMBER_LIT) {
        let val = node_get_data1(n);
        // Get the number string from intern
        return get_interned_str(val);
    }
    
    if (kind == NK_BOOL_LIT) {
        let val = node_get_data1(n);
        if (val == 1) { return "true"; }
        return "false";
    }
    
    if (kind == NK_STRING_LIT) {
        let val = node_get_data1(n);
        let s = get_interned_str(val);
        return "\"".str_concat(s).str_concat("\"");
    }
    
    if (kind == NK_CHAR_LIT) {
        let val = node_get_data1(n);
        let s = get_interned_str(val);
        return "\"".str_concat(s).str_concat("\"");
    }
    
    if (kind == NK_IDENTIFIER) {
        let name_idx = node_get_data1(n);
        return get_interned_str(name_idx);
    }
    
    if (kind == NK_UNARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("&") || op.str_eq("&mut")) {
            return emit_expr(node_get_data2(n));
        }
        let inner = emit_expr(node_get_data2(n));
        return "(".str_concat(op).str_concat(inner.str_concat(")"));
    }
    
    if (kind == NK_BINARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("==")) { op = "==="; }
        if (op.str_eq("!=")) { op = "!=="; }
        let left = emit_expr(node_get_data2(n));
        let right = emit_expr(node_get_data3(n));
        return str_concat("(".str_concat(left).str_concat(" ".str_concat(op)).str_concat(" ".str_concat(right)), ")");
    }
    
    if (kind == NK_CALL_EXPR) {
        let callee = emit_expr(node_get_data1(n));
        let args = node_get_data2(n);
        let arg_strs = vec_new();
        let i = 0;
        let len = args.vec_length();
        while (i < len) {
            arg_strs.vec_push(emit_expr(args.vec_get(i)));
            i = i + 1;
        }
        let args_str = arg_strs.vec_join(", ");
        return callee.str_concat("(").str_concat(args_str.str_concat(")"));
    }
    
    if (kind == NK_MEMBER_EXPR) {
        let obj = emit_expr(node_get_data1(n));
        let prop = get_interned_str(node_get_data2(n));
        return obj.str_concat(".").str_concat(prop);
    }
    
    if (kind == NK_INDEX_EXPR) {
        let target = emit_expr(node_get_data1(n));
        let idx_expr = emit_expr(node_get_data2(n));
        return target.str_concat("[").str_concat(idx_expr).str_concat("]");
    }
    
    if (kind == NK_STRUCT_INIT) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        let fields = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "({ __tag: ");
        sb_append(sb, "\"".str_concat(name).str_concat("\""));
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            let key_idx = field.vec_get(0);
            let val_node = field.vec_get(1);
            sb_append(sb, ", ");
            sb_append(sb, get_interned_str(key_idx));
            sb_append(sb, ": ");
            sb_append(sb, emit_expr(val_node));
            i = i + 1;
        }
        sb_append(sb, " })");
        return sb_build(sb);
    }
    
    if (kind == NK_IF_EXPR) {
        let cond = emit_expr(node_get_data1(n));
        let then_b = node_get_data2(n);
        let else_b = node_get_data3(n);
        let then_str = if (node_kind(then_b) == NK_BLOCK) { emit_block_as_iife(then_b) } else { emit_expr(then_b) };
        let else_str = if (else_b == 0) { "undefined" } else {
            if (node_kind(else_b) == NK_BLOCK) { emit_block_as_iife(else_b) } else { emit_expr(else_b) }
        };
        return str_concat("((".str_concat(cond).str_concat(") ? ").str_concat(then_str.str_concat(" : ")), else_str.str_concat(")"));
    }
    
    if (kind == NK_MATCH_EXPR) {
        let target = emit_expr(node_get_data1(n));
        let cases = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "(() => { const __m = ");
        sb_append(sb, target);
        sb_append(sb, "; ");
        let i = 0;
        let len = cases.vec_length();
        while (i < len) {
            let case_node = cases.vec_get(i);
            let pat = case_node.vec_get(0);
            let body = case_node.vec_get(1);
            let guard = emit_pattern_guard("__m", pat);
            if (i == 0) {
                sb_append(sb, "if (");
            } else {
                sb_append(sb, "else if (");
            }
            sb_append(sb, guard);
            sb_append(sb, ") { ");
            sb_append(sb, emit_pattern_bindings("__m", pat));
            sb_append(sb, "return ");
            sb_append(sb, if (node_kind(body) == NK_BLOCK) { emit_block(body) } else { emit_expr(body) });
            sb_append(sb, "; } ");
            i = i + 1;
        }
        sb_append(sb, "else { throw new Error(\"Non-exhaustive match\"); } })()");
        return sb_build(sb);
    }
    
    if (kind == NK_IS_EXPR) {
        let inner = emit_expr(node_get_data1(n));
        let pat = node_get_data2(n);
        return "(".str_concat(emit_pattern_guard(inner, pat)).str_concat(")");
    }
    
    if (kind == NK_UNWRAP_EXPR) {
        return emit_expr(node_get_data1(n));
    }
    
    "undefined"
}

fn emit_pattern_guard(value_expr: *Str, pat: I32) : *Str => {
    let kind = node_kind(pat);
    if (kind == NK_WILDCARD_PAT) { return "true"; }
    if (kind == NK_LITERAL_PAT) {
        let val = get_interned_str(node_get_data1(pat));
        return value_expr.str_concat(" === ").str_concat(val).str_concat("");
    }
    if (kind == NK_NAME_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        return str_concat(value_expr.str_concat(" && ").str_concat(value_expr).str_concat(".__tag === \""), name.str_concat("\""));
    }
    if (kind == NK_STRUCT_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        return str_concat(value_expr.str_concat(" && ").str_concat(value_expr).str_concat(".__tag === \""), name.str_concat("\""));
    }
    "false"
}

fn emit_pattern_bindings(value_expr: *Str, pat: I32) : *Str => {
    let kind = node_kind(pat);
    if (kind == NK_STRUCT_PAT) {
        let fields = node_get_data2(pat);
        let sb = sb_new();
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let fname_idx = fields.vec_get(i);
            let fname = get_interned_str(fname_idx);
            sb_append(sb, "const ");
            sb_append(sb, fname);
            sb_append(sb, " = ");
            sb_append(sb, value_expr);
            sb_append(sb, ".");
            sb_append(sb, fname);
            sb_append(sb, "; ");
            i = i + 1;
        }
        return sb_build(sb);
    }
    if (kind == NK_NAME_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        return "const ".str_concat(name).str_concat(" = ").str_concat(value_expr.str_concat("; "));
    }
    ""
}

out fn selfhost_codegen_expr_marker() : I32 => 0;
