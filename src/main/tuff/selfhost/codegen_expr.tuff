// ============================================================================
// JavaScript Code Generation
// ============================================================================

let { get_interned_str, vec_new } = selfhost::runtime_lexer;
let { node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5 } = selfhost::parser_core;

fn emit_expr(n: I32) : *Str => {
    let kind = node_kind(n);
    
    if (kind == NK_NUMBER_LIT) {
        let val = node_get_data1(n);
        // Get the number string from intern
        return get_interned_str(val);
    }
    
    if (kind == NK_BOOL_LIT) {
        let val = node_get_data1(n);
        if (val == 1) { return "true"; }
        return "false";
    }
    
    if (kind == NK_STRING_LIT) {
        let val = node_get_data1(n);
        let s = get_interned_str(val);
        return "\"".str_concat(s).str_concat("\"");
    }
    
    if (kind == NK_CHAR_LIT) {
        let val = node_get_data1(n);
        let s = get_interned_str(val);
        return "\"".str_concat(s).str_concat("\"");
    }
    
    if (kind == NK_IDENTIFIER) {
        let name_idx = node_get_data1(n);
        return get_interned_str(name_idx);
    }
    
    if (kind == NK_UNARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("&") || op.str_eq("&mut")) {
            return emit_expr(node_get_data2(n));
        }
        let inner = emit_expr(node_get_data2(n));
        return "(".str_concat(op).str_concat(inner.str_concat(")"));
    }
    
    if (kind == NK_BINARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("==")) { op = "==="; }
        if (op.str_eq("!=")) { op = "!=="; }
        let left = emit_expr(node_get_data2(n));
        let right = emit_expr(node_get_data3(n));
        return str_concat("(".str_concat(left).str_concat(" ".str_concat(op)).str_concat(" ".str_concat(right)), ")");
    }
    
    if (kind == NK_CALL_EXPR) {
        let callee_node = node_get_data1(n);
        if (node_kind(callee_node) == NK_IDENTIFIER) {
            let callee_name = get_interned_str(node_get_data1(callee_node));
            if (callee_name.str_eq("drop")) {
                return "undefined";
            }
            if (callee_name.str_eq("into") && node_get_data3(n) == 1) {
                let args = node_get_data2(n);
                if (args.vec_length() < 1) {
                    return "undefined";
                }

                let type_args = node_get_data4(n);
                let contract_name = "";
                if (type_args.vec_length() == 1 && node_kind(type_args.vec_get(0)) == NK_NAMED_TYPE) {
                    contract_name = get_interned_str(node_get_data1(type_args.vec_get(0)));
                }

                let src_node = args.vec_get(0);
                let src = emit_expr(src_node);
                let consume_source = "";
                if (node_kind(src_node) == NK_IDENTIFIER) {
                    consume_source = get_interned_str(node_get_data1(src_node)).str_concat(" = undefined;");
                }

                if (node_get_data5(n) == 1) {
                    return "(() => { const __src = ".str_concat(src)
                        .str_concat("; const __conv = __src?.__into?.[")
                        .str_concat("\"").str_concat(contract_name).str_concat("\"")
                        .str_concat("]; if (!__conv) { throw new Error(\"Missing into converter for ")
                        .str_concat(if (contract_name.str_eq("")) { "<unknown>" } else { contract_name })
                        .str_concat("\"); } ")
                        .str_concat(consume_source)
                        .str_concat(" let __used = false; return (...__intoArgs) => { if (__used) { throw new Error(\"Into converter already consumed for ")
                        .str_concat(if (contract_name.str_eq("")) { "<unknown>" } else { contract_name })
                        .str_concat("\"); } __used = true; return __conv(...__intoArgs); }; })()");
                }

                let arg_strs = vec_new();
                let i = 1;
                let len = args.vec_length();
                while (i < len) {
                    arg_strs.vec_push(emit_expr(args.vec_get(i)));
                    i = i + 1;
                }
                let rest_args = arg_strs.vec_join(", ");
                return "(() => { const __src = ".str_concat(src)
                    .str_concat("; const __conv = __src?.__into?.[")
                    .str_concat("\"").str_concat(contract_name).str_concat("\"")
                    .str_concat("]; if (!__conv) { throw new Error(\"Missing into converter for ")
                    .str_concat(if (contract_name.str_eq("")) { "<unknown>" } else { contract_name })
                    .str_concat("\"); } const __out = __conv(")
                    .str_concat(rest_args)
                    .str_concat("); ")
                    .str_concat(consume_source)
                    .str_concat(" return __out; })()");
            }
        }
        let callee = emit_expr(node_get_data1(n));
        let args = node_get_data2(n);
        let arg_strs = vec_new();
        let i = 0;
        let len = args.vec_length();
        while (i < len) {
            arg_strs.vec_push(emit_expr(args.vec_get(i)));
            i = i + 1;
        }
        let args_str = arg_strs.vec_join(", ");
        return callee.str_concat("(").str_concat(args_str.str_concat(")"));
    }
    
    if (kind == NK_MEMBER_EXPR) {
        let obj = emit_expr(node_get_data1(n));
        let prop = get_interned_str(node_get_data2(n));
        return obj.str_concat(".").str_concat(prop);
    }
    
    if (kind == NK_INDEX_EXPR) {
        let target = emit_expr(node_get_data1(n));
        let idx_expr = emit_expr(node_get_data2(n));
        return target.str_concat("[").str_concat(idx_expr).str_concat("]");
    }
    
    if (kind == NK_STRUCT_INIT) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        let fields = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "((typeof ");
        sb_append(sb, name);
        sb_append(sb, " === \"function\") ? ");
        sb_append(sb, name);
        sb_append(sb, "({");
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            let key_idx = field.vec_get(0);
            let val_node = field.vec_get(1);
            if (i > 0) {
                sb_append(sb, ", ");
            }
            sb_append(sb, get_interned_str(key_idx));
            sb_append(sb, ": ");
            sb_append(sb, emit_expr(val_node));
            i = i + 1;
        }
        sb_append(sb, "}) : ({ __tag: ");
        sb_append(sb, "\"".str_concat(name).str_concat("\""));
        i = 0;
        while (i < len) {
            let field = fields.vec_get(i);
            let key_idx = field.vec_get(0);
            let val_node = field.vec_get(1);
            sb_append(sb, ", ");
            sb_append(sb, get_interned_str(key_idx));
            sb_append(sb, ": ");
            sb_append(sb, emit_expr(val_node));
            i = i + 1;
        }
        sb_append(sb, " }))");
        return sb_build(sb);
    }
    
    if (kind == NK_IF_EXPR) {
        let cond = emit_expr(node_get_data1(n));
        let then_b = node_get_data2(n);
        let else_b = node_get_data3(n);
        let then_str = if (node_kind(then_b) == NK_BLOCK) { emit_block_as_iife(then_b) } else { emit_expr(then_b) };
        let else_str = if (else_b == 0) { "undefined" } else {
            if (node_kind(else_b) == NK_BLOCK) { emit_block_as_iife(else_b) } else { emit_expr(else_b) }
        };
        return str_concat("((".str_concat(cond).str_concat(") ? ").str_concat(then_str.str_concat(" : ")), else_str.str_concat(")"));
    }
    
    if (kind == NK_MATCH_EXPR) {
        let target = emit_expr(node_get_data1(n));
        let cases = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "(() => { const __m = ");
        sb_append(sb, target);
        sb_append(sb, "; ");
        let i = 0;
        let len = cases.vec_length();
        while (i < len) {
            let case_node = cases.vec_get(i);
            let pat = case_node.vec_get(0);
            let body = case_node.vec_get(1);
            let guard = emit_pattern_guard("__m", pat);
            if (i == 0) {
                sb_append(sb, "if (");
            } else {
                sb_append(sb, "else if (");
            }
            sb_append(sb, guard);
            sb_append(sb, ") { ");
            sb_append(sb, emit_pattern_bindings("__m", pat));
            sb_append(sb, "return ");
            sb_append(sb, if (node_kind(body) == NK_BLOCK) { emit_block(body) } else { emit_expr(body) });
            sb_append(sb, "; } ");
            i = i + 1;
        }
        sb_append(sb, "else { throw new Error(\"Non-exhaustive match\"); } })()");
        return sb_build(sb);
    }
    
    if (kind == NK_IS_EXPR) {
        let inner = emit_expr(node_get_data1(n));
        let pat = node_get_data2(n);
        return "(".str_concat(emit_pattern_guard(inner, pat)).str_concat(")");
    }
    
    if (kind == NK_UNWRAP_EXPR) {
        return emit_expr(node_get_data1(n));
    }

    if (kind == NK_LAMBDA_EXPR) {
        let params = node_get_data1(n);
        let body = node_get_data2(n);
        let pnames = vec_new();
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let param = params.vec_get(i);
            pnames.vec_push(get_interned_str(param.vec_get(0)));
            i = i + 1;
        }
        let args = pnames.vec_join(", ");
        if (node_kind(body) == NK_BLOCK) {
            return "((".str_concat(args).str_concat(") => ").str_concat(emit_fn_block(body)).str_concat(")");
        }
        return "((".str_concat(args).str_concat(") => ").str_concat(emit_expr(body)).str_concat(")");
    }

    if (kind == NK_FN_EXPR) {
        let fname_idx = node_get_data1(n);
        let params = node_get_data3(n);
        let body = node_get_data5(n);
        let pnames = vec_new();
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let param = params.vec_get(i);
            pnames.vec_push(get_interned_str(param.vec_get(0)));
            i = i + 1;
        }
        let args = pnames.vec_join(", ");
        let namePart = "";
        if (fname_idx != 0) {
            namePart = " ".str_concat(get_interned_str(fname_idx));
        }
        if (node_kind(body) == NK_BLOCK) {
            return "(function".str_concat(namePart).str_concat("(").str_concat(args).str_concat(") ").str_concat(emit_fn_block(body)).str_concat(")");
        }
        return "(function".str_concat(namePart).str_concat("(").str_concat(args).str_concat(") { return ").str_concat(emit_expr(body)).str_concat("; })");
    }
    
    "undefined"
}

fn emit_pattern_guard(value_expr: *Str, pat: I32) : *Str => {
    let kind = node_kind(pat);
    if (kind == NK_WILDCARD_PAT) { return "true"; }
    if (kind == NK_LITERAL_PAT) {
        let val = get_interned_str(node_get_data1(pat));
        return value_expr.str_concat(" === ").str_concat(val).str_concat("");
    }
    if (kind == NK_NAME_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        return str_concat(value_expr.str_concat(" && ").str_concat(value_expr).str_concat(".__tag === \""), name.str_concat("\""));
    }
    if (kind == NK_STRUCT_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        return str_concat(value_expr.str_concat(" && ").str_concat(value_expr).str_concat(".__tag === \""), name.str_concat("\""));
    }
    "false"
}

fn emit_pattern_bindings(value_expr: *Str, pat: I32) : *Str => {
    let kind = node_kind(pat);
    if (kind == NK_STRUCT_PAT) {
        let fields = node_get_data2(pat);
        let sb = sb_new();
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let fname_idx = fields.vec_get(i);
            let fname = get_interned_str(fname_idx);
            sb_append(sb, "const ");
            sb_append(sb, fname);
            sb_append(sb, " = ");
            sb_append(sb, value_expr);
            sb_append(sb, ".");
            sb_append(sb, fname);
            sb_append(sb, "; ");
            i = i + 1;
        }
        return sb_build(sb);
    }
    if (kind == NK_NAME_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        return "const ".str_concat(name).str_concat(" = ").str_concat(value_expr.str_concat("; "));
    }
    ""
}

out fn selfhost_codegen_expr_marker() : I32 => 0;
