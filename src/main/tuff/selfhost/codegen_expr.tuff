 // ============================================================================
 // JavaScript Code Generation
 // ============================================================================
let {
    get_interned_str, vec_new
}
 = selfhost::runtime_lexer;
let {
    node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5
}
 = selfhost::parser_core;
fn js_ident_expr(name: *Str) : *Str => {
     // 'this' is a reserved word in JavaScript; rename to avoid SyntaxError.
    if (name.str_eq("this")) {
        return "(typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this))";
    }
    name
}
fn cg_strip_num_suffix(s: *Str) : *Str => {
    let n = s.str_length();
    if (n > 5 && s.str_slice(n - 5, n).str_eq("USize")) {
        return s.str_slice(0, n - 5);
    }
    if (n > 5 && s.str_slice(n - 5, n).str_eq("ISize")) {
        return s.str_slice(0, n - 5);
    }
    if (n > 4 && s.str_slice(n - 4, n).str_eq("U128")) {
        return s.str_slice(0, n - 4);
    }
    if (n > 4 && s.str_slice(n - 4, n).str_eq("I128")) {
        return s.str_slice(0, n - 4);
    }
    if (n > 3 && s.str_slice(n - 3, n).str_eq("U64")) {
        return s.str_slice(0, n - 3);
    }
    if (n > 3 && s.str_slice(n - 3, n).str_eq("I64")) {
        return s.str_slice(0, n - 3);
    }
    if (n > 3 && s.str_slice(n - 3, n).str_eq("U32")) {
        return s.str_slice(0, n - 3);
    }
    if (n > 3 && s.str_slice(n - 3, n).str_eq("I32")) {
        return s.str_slice(0, n - 3);
    }
    if (n > 3 && s.str_slice(n - 3, n).str_eq("U16")) {
        return s.str_slice(0, n - 3);
    }
    if (n > 3 && s.str_slice(n - 3, n).str_eq("I16")) {
        return s.str_slice(0, n - 3);
    }
    if (n > 2 && s.str_slice(n - 2, n).str_eq("U8")) {
        return s.str_slice(0, n - 2);
    }
    if (n > 2 && s.str_slice(n - 2, n).str_eq("I8")) {
        return s.str_slice(0, n - 2);
    }
    s
}
fn emit_expr_call_into(n: I32, callee_node: I32) : *Str => {
    let callee_name = get_interned_str(node_get_data1(callee_node));
    if (!(callee_name.str_eq("into") && node_get_data3(n) == 1)) {
        return "";
    }
    let args = node_get_data2(n);
    if (args.vec_length() < 1) {
        return "undefined";
    }
    let type_args = node_get_data4(n);
    let contract_name = "";
    if (type_args.vec_length() == 1 && node_kind(type_args.vec_get(0)) == NK_NAMED_TYPE) {
        contract_name = get_interned_str(node_get_data1(type_args.vec_get(0)));
    }
    let src_node = args.vec_get(0);
    let src = emit_expr(src_node);
    let consume_source = "";
    let contract_label = contract_name;
    if (contract_label.str_eq("")) {
        contract_label = "<unknown>";
    }
    if (node_kind(src_node) == NK_IDENTIFIER) {
        consume_source = get_interned_str(node_get_data1(src_node)).str_concat(" = undefined;");
    }
    if (node_get_data5(n) == 1) {
        return "(() => { const __src = ".str_concat(src).str_concat("; const __conv = __src?.__into?.[").str_concat("\"").str_concat(contract_name).str_concat("\"").str_concat("]; if (!__conv) { throw new Error(\"Missing into converter for ").str_concat(contract_label).str_concat("\"); } ").str_concat(consume_source).str_concat(" let __used = false; return (...__intoArgs) => { if (__used) { throw new Error(\"Into converter already consumed for ").str_concat(contract_label).str_concat("\"); } __used = true; return __conv(...__intoArgs); }; })()");
    }
    let arg_strs = vec_new();
    let i = 1;
    let len = args.vec_length();
    while (i < len) {
        arg_strs.vec_push(emit_expr(args.vec_get(i)));
        i = i + 1;
    }
    let rest_args = arg_strs.vec_join(", ");
    "(() => { const __src = ".str_concat(src).str_concat("; const __conv = __src?.__into?.[").str_concat("\"").str_concat(contract_name).str_concat("\"").str_concat("]; if (!__conv) { throw new Error(\"Missing into converter for ").str_concat(contract_label).str_concat("\"); } const __out = __conv(").str_concat(rest_args).str_concat("); ").str_concat(consume_source).str_concat(" return __out; })()")
}
fn emit_expr_call_method(n: I32, callee_node: I32) : *Str => {
    if (!(node_get_data3(n) == 1 && node_kind(callee_node) == NK_IDENTIFIER)) {
        return "";
    }
    let args = node_get_data2(n);
    if (args.vec_length() < 1) {
        return "";
    }
    let callee_name = get_interned_str(node_get_data1(callee_node));
    let receiver = emit_expr(args.vec_get(0));
    let rest_args = vec_new();
    let i = 1;
    let len = args.vec_length();
    while (i < len) {
        rest_args.vec_push(emit_expr(args.vec_get(i)));
        i = i + 1;
    }
    let rest_str = rest_args.vec_join(", ");
    let dyn_args = "";
    if (rest_str.str_eq("")) {
        dyn_args = "__recv.ref";
    }
    else {
        dyn_args = "__recv.ref, ".str_concat(rest_str);
    }
    let static_args = "";
    if (rest_str.str_eq("")) {
        static_args = "__recv";
    }
    else {
        static_args = "__recv, ".str_concat(rest_str);
    }
    let method_key = "\"".str_concat(callee_name).str_concat("\"");
    "(() => { const __recv = ".str_concat(receiver).str_concat("; const __prop = __recv?.[").str_concat(method_key).str_concat("]; if (typeof __prop === \"function\") return __prop(").str_concat(rest_str).str_concat("); const __dyn = __recv?.table?.").str_concat(callee_name).str_concat("; return __dyn ? __dyn(").str_concat(dyn_args).str_concat(") : ").str_concat(emit_expr(callee_node)).str_concat("(").str_concat(static_args).str_concat("); })()")
}
fn emit_expr_call_expr(n: I32) : *Str => {
    let callee_node = node_get_data1(n);
    if (node_kind(callee_node) == NK_IDENTIFIER && get_interned_str(node_get_data1(callee_node)).str_eq("drop")) {
        return "undefined";
    }
    let into_call = emit_expr_call_into(n, callee_node);
    if (!into_call.str_eq("")) {
        return into_call;
    }
    let method = emit_expr_call_method(n, callee_node);
    if (!method.str_eq("")) {
        return method;
    }
    let callee = emit_expr(node_get_data1(n));
    let args = node_get_data2(n);
    let arg_strs = vec_new();
    let i = 0;
    let len = args.vec_length();
    while (i < len) {
        arg_strs.vec_push(emit_expr(args.vec_get(i)));
        i = i + 1;
    }
    let args_str = arg_strs.vec_join(", ");
    callee.str_concat("(").str_concat(args_str.str_concat(")"))
}
fn emit_expr_struct_init(n: I32) : *Str => {
    let name = get_interned_str(node_get_data1(n));
    let fields = node_get_data2(n);
    let sb = sb_new();
    sb_append(sb, "((typeof ");
    sb_append(sb, name);
    sb_append(sb, " === \"function\") ? ");
    sb_append(sb, name);
    sb_append(sb, "({");
    let i = 0;
    let len = fields.vec_length();
    while (i < len) {
        let field = fields.vec_get(i);
        if (i > 0) {
            sb_append(sb, ", ");
        }
        sb_append(sb, get_interned_str(field.vec_get(0)));
        sb_append(sb, ": ");
        sb_append(sb, emit_expr(field.vec_get(1)));
        i = i + 1;
    }
    sb_append(sb, "}) : ({ __tag: ");
    sb_append(sb, "\"".str_concat(name).str_concat("\""));
    i = 0;
    while (i < len) {
        let field = fields.vec_get(i);
        sb_append(sb, ", ");
        sb_append(sb, get_interned_str(field.vec_get(0)));
        sb_append(sb, ": ");
        sb_append(sb, emit_expr(field.vec_get(1)));
        i = i + 1;
    }
    sb_append(sb, " }))");
    sb_build(sb)
}
fn emit_expr_complex(n: I32) : *Str => {
    let kind = node_kind(n);
    if (kind == NK_IF_EXPR) {
        let cond = emit_expr(node_get_data1(n));
        let then_b = node_get_data2(n);
        let else_b = node_get_data3(n);
        let then_str = "";
        if (node_kind(then_b) == NK_BLOCK) {
            then_str = emit_block_as_iife(then_b);
        }
        else {
            then_str = emit_expr(then_b);
        }
        let else_str = "undefined";
        if (else_b != 0) {
            if (node_kind(else_b) == NK_BLOCK) {
                else_str = emit_block_as_iife(else_b);
            }
            else {
                else_str = emit_expr(else_b);
            }
        }
        return str_concat("((".str_concat(cond).str_concat(") ? ").str_concat(then_str.str_concat(" : ")), else_str.str_concat(")"));
    }
    if (kind == NK_MATCH_EXPR) {
        let target = emit_expr(node_get_data1(n));
        let cases = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "(() => { const __m = ");
        sb_append(sb, target);
        sb_append(sb, "; ");
        let i = 0;
        let len = cases.vec_length();
        while (i < len) {
            let case_node = cases.vec_get(i);
            let pat = case_node.vec_get(0);
            let body = case_node.vec_get(1);
            let guard = emit_pattern_guard("__m", pat);
            if (i == 0) {
                sb_append(sb, "if (");
            }
            else {
                sb_append(sb, "else if (");
            }
            sb_append(sb, guard);
            sb_append(sb, ") { ");
            sb_append(sb, emit_pattern_bindings("__m", pat));
            sb_append(sb, "return ");
            let body_js = "";
            if (node_kind(body) == NK_BLOCK) {
                body_js = emit_block(body);
            }
            else {
                body_js = emit_expr(body);
            }
            sb_append(sb, body_js);
            sb_append(sb, "; } ");
            i = i + 1;
        }
        sb_append(sb, "else { throw new Error(\"Non-exhaustive match\"); } })()");
        return sb_build(sb);
    }
    if (kind == NK_IS_EXPR) {
        return "(".str_concat(emit_pattern_guard(emit_expr(node_get_data1(n)), node_get_data2(n))).str_concat(")");
    }
    if (kind == NK_UNWRAP_EXPR) {
        return emit_expr(node_get_data1(n));
    }
    if (kind == NK_LAMBDA_EXPR) {
        let params = node_get_data1(n);
        let body = node_get_data2(n);
        let pnames = vec_new();
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            pnames.vec_push(js_ident_expr(get_interned_str(params.vec_get(i).vec_get(0))));
            i = i + 1;
        }
        let args = pnames.vec_join(", ");
        if (node_kind(body) == NK_BLOCK) {
            return "((".str_concat(args).str_concat(") => ").str_concat(emit_fn_block(body)).str_concat(")");
        }
        return "((".str_concat(args).str_concat(") => ").str_concat(emit_expr(body)).str_concat(")");
    }
    if (kind == NK_FN_EXPR) {
        let fname_idx = node_get_data1(n);
        let params = node_get_data3(n);
        let body = node_get_data5(n);
        let pnames = vec_new();
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            pnames.vec_push(js_ident_expr(get_interned_str(params.vec_get(i).vec_get(0))));
            i = i + 1;
        }
        let args = pnames.vec_join(", ");
        let namePart = "";
        if (fname_idx != 0) {
            namePart = " ".str_concat(get_interned_str(fname_idx));
        }
        if (node_kind(body) == NK_BLOCK) {
            return "(function".str_concat(namePart).str_concat("(").str_concat(args).str_concat(") ").str_concat(emit_fn_block(body)).str_concat(")");
        }
        return "(function".str_concat(namePart).str_concat("(").str_concat(args).str_concat(") { return ").str_concat(emit_expr(body)).str_concat("; })");
    }
    ""
}
fn emit_expr(n: I32) : *Str => {
    let kind = node_kind(n);
    if (kind == NK_NUMBER_LIT) {
        let val = node_get_data1(n);
         // Get the number string, stripping any type suffix for valid JS output
        return cg_strip_num_suffix(get_interned_str(val));
    }
    if (kind == NK_BOOL_LIT) {
        let val = node_get_data1(n);
        if (val == 1) {
            return "true";
        }
        return "false";
    }
    if (kind == NK_STRING_LIT) {
        let val = node_get_data1(n);
        let s = get_interned_str(val);
        return "\"".str_concat(s).str_concat("\"");
    }
    if (kind == NK_CHAR_LIT) {
        let val = node_get_data1(n);
        let s = get_interned_str(val);
        return "\"".str_concat(s).str_concat("\"");
    }
    if (kind == NK_IDENTIFIER) {
        let name_idx = node_get_data1(n);
        return js_ident_expr(get_interned_str(name_idx));
    }
    if (kind == NK_UNARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("&") || op.str_eq("&mut")) {
            return emit_expr(node_get_data2(n));
        }
        let inner = emit_expr(node_get_data2(n));
        return "(".str_concat(op).str_concat(inner.str_concat(")"));
    }
    if (kind == NK_BINARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("==")) {
            op = "===";
        }
        if (op.str_eq("!=")) {
            op = "!==";
        }
        let left = emit_expr(node_get_data2(n));
        let right = emit_expr(node_get_data3(n));
        if (op.str_eq("..")) {
            return "(function() { let __cur = ".str_concat(left)
            .str_concat(", __hi = ").str_concat(right)
            .str_concat("; return function() { if (__cur > __hi) return [true, __hi]; let __val = __cur++; return [false, __val]; }; })()");
        }
        return str_concat("(".str_concat(left).str_concat(" ".str_concat(op)).str_concat(" ".str_concat(right)), ")");
    }
    if (kind == NK_CALL_EXPR) {
        return emit_expr_call_expr(n);
    }
    if (kind == NK_MEMBER_EXPR) {
        let obj = emit_expr(node_get_data1(n));
        let prop = get_interned_str(node_get_data2(n));
         // .init on a slice/array emits as .length (JS arrays track initialized count = length)
        if (prop.str_eq("init")) {
            return obj.str_concat(".length");
        }
        return obj.str_concat(".").str_concat(prop);
    }
    if (kind == NK_INDEX_EXPR) {
        let target = emit_expr(node_get_data1(n));
        let idx_expr = emit_expr(node_get_data2(n));
        return target.str_concat("[").str_concat(idx_expr).str_concat("]");
    }
    if (kind == NK_STRUCT_INIT) {
        return emit_expr_struct_init(n);
    }
    if (kind == NK_TUPLE_EXPR) {
        let items = node_get_data1(n);
        let parts = vec_new();
        let i = 0;
        let len = items.vec_length();
        while (i < len) {
            parts.vec_push(emit_expr(items.vec_get(i)));
            i = i + 1;
        }
        return "[".str_concat(parts.vec_join(", ")).str_concat("]");
    }
    let complex = emit_expr_complex(n);
    if (!complex.str_eq("")) {
        return complex;
    }
    "undefined"
}
fn emit_pattern_guard(value_expr: *Str, pat: I32) : *Str => {
    let kind = node_kind(pat);
    if (kind == NK_WILDCARD_PAT) {
        return "true";
    }
    if (kind == NK_LITERAL_PAT) {
        let val = get_interned_str(node_get_data1(pat));
        return value_expr.str_concat(" === ").str_concat(val).str_concat("");
    }
    if (kind == NK_NAME_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        return str_concat(value_expr.str_concat(" && ").str_concat(value_expr).str_concat(".__tag === \""), name.str_concat("\""));
    }
    if (kind == NK_STRUCT_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        return str_concat(value_expr.str_concat(" && ").str_concat(value_expr).str_concat(".__tag === \""), name.str_concat("\""));
    }
    "false"
}
fn emit_pattern_bindings(value_expr: *Str, pat: I32) : *Str => {
    let kind = node_kind(pat);
    if (kind == NK_STRUCT_PAT) {
        let fields = node_get_data2(pat);
        let sb = sb_new();
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let fname_idx = fields.vec_get(i);
            let fname = get_interned_str(fname_idx);
            sb_append(sb, "const ");
            sb_append(sb, fname);
            sb_append(sb, " = ");
            sb_append(sb, value_expr);
            sb_append(sb, ".");
            sb_append(sb, fname);
            sb_append(sb, "; ");
            i = i + 1;
        }
        return sb_build(sb);
    }
    if (kind == NK_NAME_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        return "const ".str_concat(name).str_concat(" = ").str_concat(value_expr.str_concat("; "));
    }
    ""
}
out fn selfhost_codegen_expr_marker() : I32 => 0;
