let {
    p_at, p_eat, p_expect, p_parse_identifier, p_at_kind, p_peek, p_mark, p_restore,
    p_parse_pattern, p_parse_type, p_error_with_token_context, node_new, node_set_data1, node_set_data2, node_set_data3, node_set_data4, node_set_data5
}
 = selfhost::parser_core;
let {
    tok_kind, tok_value, get_interned_str, vec_new
}
 = selfhost::runtime_lexer;
let {
    p_parse_postfix
}
 = selfhost::parser_expr_postfix;
fn p_parse_primary_array() : I32 => {
    p_eat();
    let items = vec_new();
    if (!p_at(TK_SYMBOL, "]")) {
        items.vec_push(p_parse_expression(0));
        while (p_at(TK_SYMBOL, ",")) {
            p_eat();
            if (p_at(TK_SYMBOL, "]")) {
                break;
            }
            items.vec_push(p_parse_expression(0));
        }
    }
    p_expect(TK_SYMBOL, "]", "Expected ']' in array literal");
    let node = node_new(NK_TUPLE_EXPR);
    node_set_data1(node, items);
    p_parse_postfix(node)
}
fn p_parse_primary_basic_literal(kind: I32) : I32 => {
    let t = p_eat();
    let node = node_new(kind);
    node_set_data1(node, tok_value(t));
    p_parse_postfix(node)
}
fn p_try_parse_paren_lambda() : I32 => {
    if (!p_at(TK_SYMBOL, "(")) {
        return 0;
    }
    let mark = p_mark();
    p_eat();
    let params = vec_new();
    let valid = true;
    if (!p_at(TK_SYMBOL, ")")) {
        while (true) {
            if (!p_at_kind(TK_IDENTIFIER)) {
                valid = false;
                break;
            }
            let pname = p_parse_identifier();
            let ptype = 0;
            if (p_at(TK_SYMBOL, ":")) {
                p_eat();
                ptype = p_parse_type();
            }
            let param = vec_new();
            param.vec_push(pname);
            param.vec_push(ptype);
            params.vec_push(param);
            if (p_at(TK_SYMBOL, ",")) {
                p_eat();
                continue;
            }
            break;
        }
    }
    if (valid && p_at(TK_SYMBOL, ")")) {
        p_eat();
        if (p_at(TK_SYMBOL, "=>")) {
            p_eat();
            let body = 0;
            if (p_at(TK_SYMBOL, "{")) {
                body = p_parse_block();
            }
            else {
                body = p_parse_expression(0);
            }
            let lam = node_new(NK_LAMBDA_EXPR);
            node_set_data1(lam, params);
            node_set_data2(lam, body);
            return p_parse_postfix(lam);
        }
    }
    p_restore(mark);
    0
}
fn p_parse_primary_fn_expr() : I32 => {
    p_eat();
    let fname = 0;
    if (p_at_kind(TK_IDENTIFIER)) {
        fname = p_parse_identifier();
    }
    let generics = vec_new();
    if (p_at(TK_SYMBOL, "<")) {
        p_eat();
        if (!p_at(TK_SYMBOL, ">")) {
            while (true) {
                generics.vec_push(p_parse_identifier());
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    p_parse_type();
                }
                if (!p_at(TK_SYMBOL, ",")) {
                    break;
                }
                p_eat();
            }
        }
        p_expect(TK_SYMBOL, ">", "Expected '>'");
    }
    p_expect(TK_SYMBOL, "(", "Expected '(' in function expression");
    let params = vec_new();
    if (!p_at(TK_SYMBOL, ")")) {
        while (true) {
            let pname = p_parse_identifier();
            let ptype = 0;
            if (p_at(TK_SYMBOL, ":")) {
                p_eat();
                ptype = p_parse_type();
            }
            let param = vec_new();
            param.vec_push(pname);
            param.vec_push(ptype);
            params.vec_push(param);
            if (!p_at(TK_SYMBOL, ",")) {
                break;
            }
            p_eat();
        }
    }
    p_expect(TK_SYMBOL, ")", "Expected ')' after params");
    let ret = 0;
    if (p_at(TK_SYMBOL, ":")) {
        p_eat();
        ret = p_parse_type();
    }
    p_expect(TK_SYMBOL, "=>", "Expected '=>' in function expression");
    let body = 0;
    if (p_at(TK_SYMBOL, "{")) {
        body = p_parse_block();
    }
    else {
        body = p_parse_expression(0);
    }
    let fnexpr = node_new(NK_FN_EXPR);
    node_set_data1(fnexpr, fname);
    node_set_data2(fnexpr, generics);
    node_set_data3(fnexpr, params);
    node_set_data4(fnexpr, ret);
    node_set_data5(fnexpr, body);
    p_parse_postfix(fnexpr)
}
fn p_try_parse_identifier_lambda() : I32 => {
    if (!(p_at_kind(TK_IDENTIFIER) && tok_kind(p_peek(1)) == TK_SYMBOL && get_interned_str(tok_value(p_peek(1))).str_eq("=>"))) {
        return 0;
    }
    let pname = p_parse_identifier();
    p_expect(TK_SYMBOL, "=>", "Expected '=>' in lambda expression");
    let param = vec_new();
    param.vec_push(pname);
    param.vec_push(0);
    let params = vec_new();
    params.vec_push(param);
    let body = 0;
    if (p_at(TK_SYMBOL, "{")) {
        body = p_parse_block();
    }
    else {
        body = p_parse_expression(0);
    }
    let lam = node_new(NK_LAMBDA_EXPR);
    node_set_data1(lam, params);
    node_set_data2(lam, body);
    p_parse_postfix(lam)
}
fn p_parse_primary_paren_or_tuple() : I32 => {
    p_eat();
    let first = p_parse_expression(0);
    if (p_at(TK_SYMBOL, ",")) {
        let items = vec_new();
        items.vec_push(first);
        while (p_at(TK_SYMBOL, ",")) {
            p_eat();
            items.vec_push(p_parse_expression(0));
        }
        p_expect(TK_SYMBOL, ")", "Expected ')' after tuple expression");
        let tuple = node_new(NK_TUPLE_EXPR);
        node_set_data1(tuple, items);
        return p_parse_postfix(tuple);
    }
    p_expect(TK_SYMBOL, ")", "Expected ')'");
    p_parse_postfix(first)
}
fn p_parse_primary_if_expr() : I32 => {
    p_eat();
    p_expect(TK_SYMBOL, "(", "Expected '(' after if");
    let cond = p_parse_expression(0);
    p_expect(TK_SYMBOL, ")", "Expected ')' after condition");
    let then_branch = 0;
    if (p_at(TK_SYMBOL, "{")) {
        then_branch = p_parse_block();
    }
    else {
        then_branch = p_parse_expression(0);
    }
    let else_branch = 0;
    if (p_at(TK_KEYWORD, "else")) {
        p_eat();
        if (p_at(TK_SYMBOL, "{")) {
            else_branch = p_parse_block();
        }
        else {
            else_branch = p_parse_expression(0);
        }
    }
    let node = node_new(NK_IF_EXPR);
    node_set_data1(node, cond);
    node_set_data2(node, then_branch);
    node_set_data3(node, else_branch);
    p_parse_postfix(node)
}
fn p_parse_primary_match_expr() : I32 => {
    p_eat();
    p_expect(TK_SYMBOL, "(", "Expected '(' after match");
    let target = p_parse_expression(0);
    p_expect(TK_SYMBOL, ")", "Expected ')' after match target");
    p_expect(TK_SYMBOL, "{", "Expected '{'");
    let cases = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        p_expect(TK_KEYWORD, "case", "Expected 'case'");
        let pat = p_parse_pattern();
        p_expect(TK_SYMBOL, "=", "Expected '='");
        let body = 0;
        if (p_at(TK_SYMBOL, "{")) {
            body = p_parse_block();
        }
        else {
            body = p_parse_expression(0);
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after case");
        let case_node = vec_new();
        case_node.vec_push(pat);
        case_node.vec_push(body);
        cases.vec_push(case_node);
    }
    p_expect(TK_SYMBOL, "}", "Expected '}'");
    let node = node_new(NK_MATCH_EXPR);
    node_set_data1(node, target);
    node_set_data2(node, cases);
    node
}
fn p_parse_primary_identifier_expr() : I32 => {
    let name = p_parse_identifier();
    let expr = node_new(NK_IDENTIFIER);
    node_set_data1(expr, name);
    let generic_args = vec_new();
    let is_type_like = false;
    let name_text = get_interned_str(name);
    if (name_text.str_length() > 0) {
        let c0 = name_text.str_char_at(0);
        if (c0 >= 65 && c0 <= 90) {
            is_type_like = true;
        }
    }
    if (is_type_like && p_at(TK_SYMBOL, "<") && (p_has_generic_struct_init_suffix() || p_has_generic_value_suffix())) {
        p_eat();
        if (!p_at(TK_SYMBOL, ">")) {
            generic_args.vec_push(p_parse_generic_arg_value_or_type());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                generic_args.vec_push(p_parse_generic_arg_value_or_type());
            }
        }
        p_expect(TK_SYMBOL, ">", "Expected '>' in generic struct initializer");
        node_set_data2(expr, generic_args);
    }
    if (p_at(TK_SYMBOL, "{")) {
        p_eat();
        let fields = vec_new();
        if (!p_at(TK_SYMBOL, "}")) {
            let key = p_parse_identifier();
            p_expect(TK_SYMBOL, ":", "Expected ':' in struct init");
            let val = p_parse_expression(0);
            let field = vec_new();
            field.vec_push(key);
            field.vec_push(val);
            fields.vec_push(field);
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                let key2 = p_parse_identifier();
                p_expect(TK_SYMBOL, ":", "Expected ':'");
                let val2 = p_parse_expression(0);
                let field2 = vec_new();
                field2.vec_push(key2);
                field2.vec_push(val2);
                fields.vec_push(field2);
            }
        }
        p_expect(TK_SYMBOL, "}", "Expected '}'");
        let init_node = node_new(NK_STRUCT_INIT);
        node_set_data1(init_node, name);
        node_set_data2(init_node, fields);
        node_set_data3(init_node, generic_args);
        expr = init_node;
    }
    p_parse_postfix(expr)
}
out fn p_parse_primary() : I32 => {
    if (p_at(TK_SYMBOL, "[")) {
        return p_parse_primary_array();
    }
    if (p_at_kind(TK_NUMBER)) {
        return p_parse_primary_basic_literal(NK_NUMBER_LIT);
    }
    if (p_at_kind(TK_BOOL)) {
        return p_parse_primary_basic_literal(NK_BOOL_LIT);
    }
    if (p_at_kind(TK_STRING)) {
        return p_parse_primary_basic_literal(NK_STRING_LIT);
    }
    if (p_at_kind(TK_CHAR)) {
        return p_parse_primary_basic_literal(NK_CHAR_LIT);
    }
    let paren_lambda = p_try_parse_paren_lambda();
    if (paren_lambda != 0) {
        return paren_lambda;
    }
    if (p_at(TK_KEYWORD, "fn")) {
        return p_parse_primary_fn_expr();
    }
    let id_lambda = p_try_parse_identifier_lambda();
    if (id_lambda != 0) {
        return id_lambda;
    }
    if (p_at(TK_SYMBOL, "(")) {
        return p_parse_primary_paren_or_tuple();
    }
    if (p_at(TK_KEYWORD, "if")) {
        return p_parse_primary_if_expr();
    }
    if (p_at(TK_KEYWORD, "match")) {
        return p_parse_primary_match_expr();
    }
    if (p_at_kind(TK_IDENTIFIER)) {
        return p_parse_primary_identifier_expr();
    }
    p_error_with_token_context("Expected expression start (identifier, literal, '(', '[', 'if', 'match', or 'fn')");
    0
}
out fn selfhost_parser_expr_primary_marker() : I32 => 0;
