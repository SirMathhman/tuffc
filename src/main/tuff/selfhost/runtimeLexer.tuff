 // ============================================================================
 // Extern declarations - these come from runtime.js
 // ============================================================================
 // Source attributions satisfy the E_EXTERN_NO_SOURCE gate for C codegen.
 // The actual implementations come from the always-embedded C substrate.
extern let {
    strLength, strCharAt, strSlice, strSliceWindow, strCopy, strMutSlice, strConcat, strEq, strFromCharCode,
    __str_index_of, strTrim, strReplaceAll, charCode, __int_to_string, parseInt
}
 = globalThis;
extern let {
    sbNew, sbAppend, sbAppendChar, sbBuild
}
 = globalThis;
extern let {
    __vec_new, __vec_push, __vec_pop, __vec_get, __vec_set, __vec_length, __vec_init,
    __vec_capacity, __vec_clear, __vec_join, __vec_includes, __vec_clone
}
 = globalThis;
extern let {
    __map_new, mapSet, mapGet, mapHas, mapDelete, mapGetOrDefault, mapClear
}
 = globalThis;
extern let {
    __set_new, setAdd, setHas, setDelete, setClear
}
 = globalThis;
extern let {
    readFile, writeFile, pathJoin, pathDirname, print, __print_error
}
 = globalThis;
extern let {
    panic, panicWithCode, panicWithCodeLoc
}
 = globalThis;
extern let {
    getArgc, getArgv
}
 = globalThis;
extern let {
    __perf_now, profileMark, __profile_take_json
}
 = globalThis;
extern fn strLength(this: *Str) : USize;
type StrIndex(this: *Str) = USize < strLength(this);
extern fn strCharAt(this: *Str, index: StrIndex(this)) : Char;
extern fn strSlice(this: *Str, start: StrIndex(this) <= end, end: StrIndex(this)) : *Str;
lifetime t {
    extern fn strSliceWindow(this: *t Str, start: StrIndex(this) <= end, end: StrIndex(this)) : *t Str;
}
extern fn strCopy(this: *Str) : *Str;
/*
We'll need this eventually.
extern fn str_mut_slice(this: **mut Str, start: I32, end: I32) : *mut Str;
*/
 // Immutable, makes a new string
extern fn strConcat(this: *Str, b: *Str) : *Str;
extern fn strEq(this: *Str, b: *Str) : Bool;
extern fn strFromCharCode(code: I32) : *Str;
extern fn __str_index_of(this: *Str, needle: *Str) : StrIndex(this);
out fn strIndexOf(this: *Str, needle: *Str) : StrIndex(this) => __str_index_of(this, needle);
out fn strIncludes(this: *Str, needle: *Str) : Bool => this.strIndexOf(needle) >= 0;
out fn strStartsWith(this: *Str, prefix: *Str) : Bool => {
    let plen = prefix.strLength();
    if (this.strLength() < plen) {
        false
    }
    else {
        this.strSlice(0, plen).strEq(prefix)
    }
}
extern fn strTrim(this: *Str) : *Str;
extern fn strReplaceAll(this: *Str, from: *Str, to: *Str) : *Str;
extern fn charCode(ch: *Str) : I32;
extern fn __int_to_string(n: I32) : *Str;
out fn intToString(n: I32) : *Str => __int_to_string(n);
extern fn parseInt(s: *Str) : I32;
extern type StringBuilder;
extern fn sbNew() : StringBuilder;
extern fn sbAppend(this: StringBuilder, s: *Str) : StringBuilder;
extern fn sbAppendChar(this: StringBuilder, code: I32) : StringBuilder;
 // Take ownership of the builder
extern fn sbBuild(sb: StringBuilder) : *Str;
extern type Vec<T>;
extern fn __vec_new() : Vec<T>;
extern fn __vec_push(this: Vec<T>, item: T) : Vec<T>;
extern fn __vec_pop(this: Vec<T>) : T;
out fn vecNew() : Vec<T> => __vec_new();
fn vecPush(this: Vec<T>, item: T) : Vec<T> => __vec_push(this, item);
fn vecPop(this: Vec<T>) : T => __vec_pop(this);
extern fn __vec_get(this: Vec<T>, i: I32) : T;
fn vecGet(this: Vec<T>, i: I32) : T => __vec_get(this, i);
extern fn __vec_set(this: Vec<T>, i: I32, v: T) : Vec<T>;
extern fn __vec_length(this: Vec<T>) : USize;
extern fn __vec_init(this: Vec<T>) : USize;
extern fn __vec_capacity(this: Vec<T>) : USize;
extern fn __vec_clear(this: Vec<T>) : Vec<T>;
extern fn __vec_clone(this: Vec<T>) : Vec<T>;
extern fn __vec_join(this: Vec<T>, sep: *Str) : *Str;
extern fn __vec_includes(this: Vec<T>, item: T) : Bool;
fn vecSet(this: Vec<T>, i: I32, v: T) : Vec<T> => __vec_set(this, i, v);
fn vecLength(this: Vec<T>) : I32 => 0 + __vec_length(this);
 // Cast USize to I32
fn vecInit(this: Vec<T>) : USize => __vec_init(this);
fn vecCapacity(this: Vec<T>) : USize => __vec_capacity(this);
fn vecClear(this: Vec<T>) : Vec<T> => __vec_clear(this);
fn vecClone(this: Vec<T>) : Vec<T> => __vec_clone(this);
fn vecJoin(this: Vec<T>, sep: *Str) : *Str => __vec_join(this, sep);
fn vecIncludes(this: Vec<T>, item: T) : Bool => __vec_includes(this, item);
extern type Map<K, V>;
extern fn __map_new() : Map<K, V>;
extern fn mapSet(this: Map<K, V>, k: K, v: V) : Map<K, V>;
extern fn mapGet(this: Map<K, V>, k: K) : V;
extern fn mapGetOrDefault(this: Map<K, V>, k: K, default: V) : V;
extern fn mapHas(this: Map<K, V>, k: K) : Bool;
extern fn mapDelete(this: Map<K, V>, k: K) : Bool;
extern fn mapClear(this: Map<K, V>) : Map<K, V>;
out fn mapNew() : Map<K, V> => __map_new();
extern type Set<T>;
extern fn __set_new() : *mut Set<T>;
extern fn setAdd(this: *mut Set<T>, item: T) : *mut Set<T>;
extern fn setHas(this: *mut Set<T>, item: T) : Bool;
extern fn setDelete(this: *mut Set<T>, item: T) : Bool;
extern fn setClear(this: *mut Set<T>) : *mut Set<T>;
out fn setNew() : *mut Set<T> => __set_new();
extern fn readFile(filePath: *Str) : *Str;
extern fn writeFile(filePath: *Str, contents: *Str) : I32;
extern fn pathJoin(a: *Str, b: *Str) : *Str;
extern fn pathDirname(p: *Str) : *Str;
extern fn print(s: *Str) : I32;
extern fn __print_error(s: *Str) : I32;
out fn printError(s: *Str) : I32 => __print_error(s);
extern fn panic(msg: *Str) : I32;
extern fn panicWithCode(code: *Str, msg: *Str, reason: *Str, fix: *Str) : I32;
extern fn panicWithCodeLoc(code: *Str, msg: *Str, reason: *Str, fix: *Str, line: I32, col: I32) :
I32;
extern fn getArgc() : I32;
extern fn getArgv(i: I32) : *Str;
 // Performance profiling
extern fn __perf_now() : I32;
out fn perfNow() : I32 => __perf_now();
extern fn profileMark(label: *Str, durationMs: I32) : I32;
extern fn __profile_take_json() : *Str;
out fn profileTakeJson() : *Str => __profile_take_json();
 // ============================================================================
 // Token Kinds
 // ============================================================================
let TK_EOF : I32 = 0;
let TK_KEYWORD : I32 = 1;
let TK_IDENTIFIER : I32 = 2;
let TK_NUMBER : I32 = 3;
let TK_STRING : I32 = 4;
let TK_BOOL : I32 = 5;
let TK_SYMBOL : I32 = 6;
let TK_CHAR : I32 = 7;
 // ============================================================================
 // Token structure - array-based representation
 // Tokens are stored in a stride-4 vector: [kind0, value0, line0, col0, kind1, ...]
 // ============================================================================
let tokens : Vec<I32> = vecNew();
let tokCount : I32 = 0;
fn triviaSepField() : *Str => "\u001f";
fn triviaSepRecord() : *Str => "\u001e";
 // Trivia stored as stride-4: [kind, text, line, col, ...]
let triviaData : Vec<I32> = vecNew();
fn triviaAdd(kind: *Str, text: *Str, line: I32, col: I32) : I32 => {
    triviaData.vecPush(kind);
    triviaData.vecPush(text);
    triviaData.vecPush(line);
    triviaData.vecPush(col);
    0
}
out fn lexTakeTrivia() : *Str => {
    let len = triviaData.vecLength();
    if (len = = 0) {
        return "";
    }
    let sep = triviaSepField();
    let rsep = triviaSepRecord();
    let i = 0;
    let result = "";
    while (i < len) {
        if (i > 0) {
            result = result.strConcat(rsep);
        }
        result = result
        .strConcat(triviaData.vecGet(i))
        .strConcat(sep)
        .strConcat(triviaData.vecGet(i + 1))
        .strConcat(sep)
        .strConcat(intToString(triviaData.vecGet(i + 2)))
        .strConcat(sep)
        .strConcat(intToString(triviaData.vecGet(i + 3)));
        i = i + 4;
    }
    triviaData.vecClear();
    result
}
fn tokAdd(kind: I32, value: I32, line: I32, col: I32) : I32 => {
    let idx = tokCount;
    tokens.vecPush(kind);
    tokens.vecPush(value);
    tokens.vecPush(line);
    tokens.vecPush(col);
    tokCount = tokCount + 1;
    idx
}
out fn tokKind(idx: I32) : I32 => tokens.vecGet(idx * 4);
out fn tokValue(idx: I32) : I32 => tokens.vecGet(idx * 4 + 1);
out fn tokLine(idx: I32) : I32 => tokens.vecGet(idx * 4 + 2);
out fn tokCol(idx: I32) : I32 => tokens.vecGet(idx * 4 + 3);
 // String intern table - stores strings by index for reverse lookup
let internTable : Vec<*Str> = vecNew();
let internMap : Map<I32, I32> = mapNew();
fn intern(s: *Str) : I32 => {
    let existing = internMap.mapGetOrDefault(s, -1);
    if (existing != -1) {
        existing
    }
    else {
        let idx = internTable.vecLength();
        internTable.vecPush(s);
        internMap.mapSet(s, idx);
        idx
    }
}
out fn internStr(s: *Str) : I32 => intern(s);
out fn getIntern(idx: I32) : *Str => {
    internTable.vecGet(idx)
}
out fn getInternedStr(idx: I32) : *Str => getIntern(idx);
 // Keywords set
let keywords : *mut Set<I32> = setNew();
fn initKeywords() : I32 => {
    keywords.setAdd("fn");
    keywords.setAdd("let");
    keywords.setAdd("struct");
    keywords.setAdd("enum");
    keywords.setAdd("type");
    keywords.setAdd("match");
    keywords.setAdd("case");
    keywords.setAdd("if");
    keywords.setAdd("else");
    keywords.setAdd("for");
    keywords.setAdd("while");
    keywords.setAdd("loop");
    keywords.setAdd("in");
    keywords.setAdd("return");
    keywords.setAdd("break");
    keywords.setAdd("continue");
    keywords.setAdd("is");
    keywords.setAdd("class");
    keywords.setAdd("object");
    keywords.setAdd("contract");
    keywords.setAdd("impl");
    keywords.setAdd("into");
    keywords.setAdd("with");
    keywords.setAdd("out");
    keywords.setAdd("module");
    keywords.setAdd("extern");
    keywords.setAdd("copy");
    keywords.setAdd("async");
    keywords.setAdd("mut");
    keywords.setAdd("move");
    keywords.setAdd("then");
    keywords.setAdd("lifetime");
    0
}
fn isKeyword(s: *Str) : Bool => keywords.setHas(s);
 // ============================================================================
 // Lexer
 // ============================================================================
let lexSource : *Str = "";
let lexPos : I32 = 0;
let lexLine : I32 = 1;
let lexCol : I32 = 1;
let lexLen : USize = 0;
out fn lexInit(source: *Str) : I32 => {
    let sourceLen = source.strLength();
    lexSource = source;
    lexPos = 0;
    lexLine = 1;
    lexCol = 1;
    lexLen = sourceLen;
     // Clear token arrays for fresh compilation
    tokens.vecClear();
    triviaData.vecClear();
    tokCount = 0;
    0
}
fn lexPeek(offset: I32) : I32 => {
    let p = lexPos + offset;
    if (p >= 0 && p < lexLen) {
        lexSource.strCharAt(p)
    }
    else {
        0
    }
}
fn lexAdvance() : I32 => {
    let ch = lexPeek(0);
    lexPos = lexPos + 1;
    if (ch = = 10) {
        lexLine = lexLine + 1;
        lexCol = 1;
        ch
    }
    else {
        lexCol = lexCol + 1;
        ch
    }
}
fn isAlpha(ch: I32) : Bool => {
    if (ch >= 65 && ch <= 90) {
        true
    }
    else if (ch >= 97 && ch <= 122) {
        true
    }
    else if (ch = = 95) {
        true
    }
    else {
        false
    }
}
fn isDigit(ch: I32) : Bool => ch >= 48 && ch <= 57;
fn isAlnum(ch: I32) : Bool => isAlpha(ch) || isDigit(ch);
fn isWhitespace(ch: I32) : Bool => {
    ch = = 32 || ch = = 9 || ch = = 13 || ch = = 10
}
fn lexReadIdent() : *Str => {
    let sb = sbNew();
    while (isAlnum(lexPeek(0))) {
        sbAppendChar(sb, lexAdvance());
    }
    sbBuild(sb)
}
fn lexReadNumber() : *Str => {
    let sb = sbNew();
     // Handle 0x, 0b, 0o
    if (lexPeek(0) = = 48) {
        let next = lexPeek(1);
        if (next = = 120 || next = = 98 || next = = 111) {
            sbAppendChar(sb, lexAdvance());
            sbAppendChar(sb, lexAdvance());
            while (isAlnum(lexPeek(0)) || lexPeek(0) = = 95) {
                let ch = lexAdvance();
                if (ch != 95) {
                    sbAppendChar(sb, ch);
                }
            }
            return sbBuild(sb);
        }
    }
    while (isDigit(lexPeek(0)) || lexPeek(0) = = 95) {
        let ch = lexAdvance();
        if (ch != 95) {
            sbAppendChar(sb, ch);
        }
    }
    if (lexPeek(0) = = 46 && isDigit(lexPeek(1))) {
        sbAppendChar(sb, lexAdvance());
        while (isDigit(lexPeek(0)) || lexPeek(0) = = 95) {
            let ch = lexAdvance();
            if (ch != 95) {
                sbAppendChar(sb, ch);
            }
        }
    }
    while (isAlnum(lexPeek(0)) || lexPeek(0) = = 95) {
        let ch = lexAdvance();
        if (ch != 95) {
            sbAppendChar(sb, ch);
        }
    }
    sbBuild(sb)
}
fn lexReadString() : *Str => {
    lexAdvance();
     // skip opening "
    let sb = sbNew();
    while (lexPos < lexLen && lexPeek(0) != 34) {
        if (lexPeek(0) = = 92) {
            sbAppendChar(sb, lexAdvance());
            sbAppendChar(sb, lexAdvance());
        }
        else {
            sbAppendChar(sb, lexAdvance());
        }
    }
    if (lexPeek(0) != 34) {
        panicWithCode(
        "E_LEX_UNTERMINATED_STRING",
        "Unterminated string literal at ".strConcat(intToString(lexLine)).strConcat(":").strConcat(intToString(lexCol)),
        "The lexer reached end-of-line or end-of-file before finding the closing quote delimiter for this string.",
        "Close the string with a matching quote delimiter, or escape embedded quotes."
        );
    }
    lexAdvance();
     // skip closing "
    sbBuild(sb)
}
fn lexReadChar() : *Str => {
    lexAdvance();
     // skip opening '
    let sb = sbNew();
    while (lexPos < lexLen && lexPeek(0) != 39) {
        sbAppendChar(sb, lexAdvance());
    }
    if (lexPeek(0) != 39) {
        panicWithCode(
        "E_LEX_UNTERMINATED_CHAR",
        "Unterminated char literal at ".strConcat(intToString(lexLine)).strConcat(":").strConcat(intToString(lexCol)),
        "The lexer reached end-of-line or end-of-file before finding the closing apostrophe delimiter for this char literal.",
        "Close the char literal with a matching apostrophe and ensure only one character (or valid escape) is inside."
        );
    }
    lexAdvance();
     // skip closing '
    sbBuild(sb)
}
fn lexCheckTwo(a: I32, b: I32) : Bool => {
    lexPeek(0) = = a && lexPeek(1) = = b
}
fn lexTryConsumeBom(ch: I32) : Bool => {
    if (lexPos = = 0 && ch = = 239 && lexPeek(1) = = 187 && lexPeek(2) = = 191) {
        lexAdvance();
        lexAdvance();
        lexAdvance();
        return true;
    }
    if (lexPos = = 0 && (ch = = 65279 || ch = = 65534)) {
        lexAdvance();
        return true;
    }
    false
}
fn lexTrySkipWhitespaceOrComment(ch: I32) : Bool => {
    if (isWhitespace(ch)) {
        lexAdvance();
        return true;
    }
    if (ch = = 47 && lexPeek(1) = = 47) {
        let startLine = lexLine;
        let startCol = lexCol;
        let sb = sbNew();
        while (lexPos < lexLen && lexPeek(0) != 10) {
            sbAppendChar(sb, lexAdvance());
        }
        triviaAdd("line_comment", sbBuild(sb), startLine, startCol);
        return true;
    }
    if (ch = = 47 && lexPeek(1) = = 42) {
        let startLine = lexLine;
        let startCol = lexCol;
        let sb = sbNew();
        sbAppendChar(sb, lexAdvance());
        sbAppendChar(sb, lexAdvance());
        while (lexPos < lexLen && !(lexPeek(0) = = 42 && lexPeek(1) = = 47)) {
            sbAppendChar(sb, lexAdvance());
        }
        if (lexPos >= lexLen) {
            panicWithCode(
            "E_LEX_UNTERMINATED_BLOCK_COMMENT",
            "Unterminated block comment near ".strConcat(intToString(lexLine)).strConcat(":").strConcat(intToString(lexCol)),
            "A block comment started with '/*' but the lexer did not find a matching '*/' before end-of-file.",
            "Add a closing '*/' for this comment, or remove the unmatched opening '/*'."
            );
        }
        sbAppendChar(sb, lexAdvance());
        sbAppendChar(sb, lexAdvance());
        triviaAdd("block_comment", sbBuild(sb), startLine, startCol);
        return true;
    }
    false
}
fn lexTryEmitThreeCharSymbol(startLine: I32, startCol: I32) : Bool => {
    if (lexPeek(0) = = 46 && lexPeek(1) = = 46 && lexPeek(2) = = 46) {
        lexAdvance();
        lexAdvance();
        lexAdvance();
        tokAdd(TK_SYMBOL, intern("..."), startLine, startCol);
        return true;
    }
    false
}
fn lexTryEmitTwoCharSymbol(startLine: I32, startCol: I32) : Bool => {
    if (lexCheckTwo(61, 62)) {
        lexAdvance();
        lexAdvance();
        tokAdd(TK_SYMBOL, intern("=>"), startLine, startCol);
        return true;
    }
    if (lexCheckTwo(61, 61)) {
        lexAdvance();
        lexAdvance();
        tokAdd(TK_SYMBOL, intern("=="), startLine, startCol);
        return true;
    }
    if (lexCheckTwo(33, 61)) {
        lexAdvance();
        lexAdvance();
        tokAdd(TK_SYMBOL, intern("!="), startLine, startCol);
        return true;
    }
    if (lexCheckTwo(60, 61)) {
        lexAdvance();
        lexAdvance();
        tokAdd(TK_SYMBOL, intern("<="), startLine, startCol);
        return true;
    }
    if (lexCheckTwo(62, 61)) {
        lexAdvance();
        lexAdvance();
        tokAdd(TK_SYMBOL, intern(">="), startLine, startCol);
        return true;
    }
    if (lexCheckTwo(38, 38)) {
        lexAdvance();
        lexAdvance();
        tokAdd(TK_SYMBOL, intern("&&"), startLine, startCol);
        return true;
    }
    if (lexCheckTwo(124, 124)) {
        lexAdvance();
        lexAdvance();
        tokAdd(TK_SYMBOL, intern("||"), startLine, startCol);
        return true;
    }
    if (lexCheckTwo(58, 58)) {
        lexAdvance();
        lexAdvance();
        tokAdd(TK_SYMBOL, intern("::"), startLine, startCol);
        return true;
    }
    if (lexCheckTwo(46, 46)) {
        lexAdvance();
        lexAdvance();
        tokAdd(TK_SYMBOL, intern(".."), startLine, startCol);
        return true;
    }
    if (lexCheckTwo(124, 62)) {
        lexAdvance();
        lexAdvance();
        tokAdd(TK_SYMBOL, intern("|>"), startLine, startCol);
        return true;
    }
    false
}
out fn lexAll() : I32 => {
    initKeywords();
    while (lexPos < lexLen) {
        let ch = lexPeek(0);
        if (lexTryConsumeBom(ch) || lexTrySkipWhitespaceOrComment(ch)) {
            continue;
        }
        let startLine = lexLine;
        let startCol = lexCol;
        if (lexTryEmitThreeCharSymbol(startLine, startCol) ||
        lexTryEmitTwoCharSymbol(startLine, startCol)) {
            continue;
        }
         // Identifier or keyword
        if (isAlpha(ch)) {
            let text = lexReadIdent();
            if (text.strEq("true")) {
                tokAdd(TK_BOOL, 1, startLine, startCol);
            }
            else if (text.strEq("false")) {
                tokAdd(TK_BOOL, 0, startLine, startCol);
            }
            else if (isKeyword(text)) {
                tokAdd(TK_KEYWORD, intern(text), startLine, startCol);
            }
            else {
                tokAdd(TK_IDENTIFIER, intern(text), startLine, startCol);
            }
            continue;
        }
         // Number
        if (isDigit(ch)) {
            let text = lexReadNumber();
            tokAdd(TK_NUMBER, intern(text), startLine, startCol);
            continue;
        }
         // String
        if (ch = = 34) {
            let text = lexReadString();
            tokAdd(TK_STRING, intern(text), startLine, startCol);
            continue;
        }
         // Char
        if (ch = = 39) {
            let text = lexReadChar();
            tokAdd(TK_CHAR, intern(text), startLine, startCol);
            continue;
        }
         // Single-char symbols
        let symText = strFromCharCode(ch);
        if (symText.strLength() = = 1 && "(){}[],:;+-*/%<>=.!?|&".strIncludes(symText)) {
            lexAdvance();
            tokAdd(TK_SYMBOL, intern(symText), startLine, startCol);
            continue;
        }
        let displayChar = symText;
        if (displayChar.strLength() = = 0) {
            displayChar = "<non-printable>";
        }
        panicWithCode(
        "E_LEX_UNEXPECTED_CHARACTER",
        "Unexpected character '".strConcat(displayChar).strConcat("' (code ").strConcat(intToString(ch)).strConcat(") at ").strConcat(intToString(startLine)).strConcat(":").strConcat(intToString(startCol)),
        "This character is not valid in the current lexical context and cannot be tokenized as part of Tuff syntax.",
        "Remove/replace the character, save source as UTF-8 without BOM, and use only supported symbols/identifiers in source text."
        );
    }
    tokAdd(TK_EOF, intern("<eof>"), lexLine, lexCol);
    tokCount
}
fn countEffectiveTokenLines() : I32 => {
    let seen = mapNew();
    let count = 0;
    let i = 0;
    while (i < tokCount) {
        if (tokKind(i) != TK_EOF) {
            let line = tokLine(i);
            if (!seen.mapHas(line)) {
                seen.mapSet(line, 1);
                count = count + 1;
            }
        }
        i = i + 1;
    }
    count
}
out fn lintEffectiveLineCount() : I32 => countEffectiveTokenLines();
out fn lintAssertFileLength(filePath: *Str, maxEffectiveLines: I32) : I32 => {
    let count = countEffectiveTokenLines();
    if (count > maxEffectiveLines) {
        panicWithCode(
        "E_LINT_FILE_TOO_LONG",
        "File exceeds ".strConcat(intToString(maxEffectiveLines)).strConcat(" effective lines (".strConcat(intToString(count)).strConcat(")")),
        "Large files are harder to review and maintain; this file exceeds the maximum effective line budget after excluding comments and blank lines.",
        "Split this file into smaller modules so each file has at most ".strConcat(intToString(maxEffectiveLines)).strConcat(" non-comment, non-whitespace lines.")
        );
    }
    0
}
out fn selfhostRuntimeLexerMarker() : I32 => 0;
