let {
    getInternedStr, vecNew, mapNew
}
 = selfhost::runtimeLexer;
let {
    nodeKind, nodeGetData1, nodeGetData2, nodeGetData3, nodeGetData4, nodeGetData5
}
 = selfhost::parserCore;
let {
    jsEmitStructDecl, jsEmitEnumDecl, jsEmitObjectDecl, jsEmitContractDecl
}
 = selfhost::codegenStmtDeclEmitters;
 // Top-level type/external-type destructor map: alias/type name -> destructor function name.
let jsGlobalDtorTypeMap : Map<I32, I32> = mapNew();
 // === JS emit context stack for tracking 'this' ===
 // Each frame: [has_explicit_this: I32, fn_name: *Str]
let jsFnStack = vecNew();
fn jsFnStackPush(hasExplicitThis: I32, fnName: *Str) : Void => {
    let frame = vecNew();
    let _a = frame.vecPush(hasExplicitThis);
    let _b = frame.vecPush(fnName);
    let _c = jsFnStack.vecPush(frame);
}
fn jsFnStackPop() : Void => {
     // Use let binding to discard the popped value, avoiding Void/I32 return mismatch.
    let _pop = jsFnStack.vecPop();
}
fn jsStackInSyntheticThis() : Bool => {
    let h = jsFnStack.vecLength();
    if (h == 0) {
        return false;
    }
    let frame = jsFnStack.vecGet(h - 1);
    frame.vecGet(0) == 0
}
fn jsThisExpr() : *Str => {
    let h = jsFnStack.vecLength();
    if (h == 0) {
        return "__tuff_this";
    }
    let frame = jsFnStack.vecGet(h - 1);
    if (frame.vecGet(0) == 1) {
        return "__this_param";
    }
    "__tuff_this"
}
fn jsIdentStmt(name: *Str) : *Str => {
     // 'this' is a reserved word in JavaScript; use context-aware resolution.
    if (name.strEq("this")) {
        return jsThisExpr();
    }
    name
}
fn emitStmtLetOrAssign(n: I32) : *Str => {
    let kind = nodeKind(n);
    if (kind == NK_LET_DECL) {
        let nameIdx = nodeGetData1(n);
        let name = jsIdentStmt(getInternedStr(nameIdx));
        let value = emitExpr(nodeGetData3(n));
        let decl = "let ".strConcat(name).strConcat(" = ").strConcat(value.strConcat(";"));
        if (name.strEq("__this_param")) {
            return decl;
        }
        return decl.strConcat(" if (typeof __tuff_this !== 'undefined') __tuff_this.").strConcat(name).strConcat(" = ").strConcat(name).strConcat(";");
    }
    if (kind == NK_ASSIGN_STMT) {
        let targetNode = nodeGetData1(n);
        let target = emitExpr(targetNode);
        let value = emitExpr(nodeGetData2(n));
        let assign = target.strConcat(" = ").strConcat(value).strConcat(";");
        if (nodeKind(targetNode) == NK_IDENTIFIER) {
            let name = getInternedStr(nodeGetData1(targetNode));
            let jsName = jsIdentStmt(name);
            if (!jsName.strEq("__this_param")) {
                return assign.strConcat(" if (typeof __tuff_this !== 'undefined') __tuff_this.").strConcat(jsName).strConcat(" = ").strConcat(jsName).strConcat(";");
            }
        }
        if (nodeKind(targetNode) == NK_MEMBER_EXPR) {
            let objNode = nodeGetData1(targetNode);
            if (nodeKind(objNode) == NK_IDENTIFIER) {
                let objName = getInternedStr(nodeGetData1(objNode));
                if (objName.strEq("this")) {
                    let prop = getInternedStr(nodeGetData2(targetNode));
                    return "if (typeof __this_param !== 'undefined') { __this_param.".strConcat(prop).strConcat(" = ").strConcat(value).strConcat("; } else { ").strConcat(prop).strConcat(" = ").strConcat(value).strConcat("; if (typeof __tuff_this !== 'undefined') __tuff_this.").strConcat(prop).strConcat(" = ").strConcat(prop).strConcat("; }");
                }
            }
        }
        return assign;
    }
    ""
}
fn emitStmtFlow(n: I32) : *Str => {
    let kind = nodeKind(n);
    if (kind == NK_IMPORT_DECL) {
        return "// import placeholder";
    }
    if (kind == NK_EXPR_STMT) {
        return emitExpr(nodeGetData1(n)).strConcat(";");
    }
    if (kind == NK_RETURN_STMT) {
        let value = nodeGetData1(n);
        if (value == 0) {
            return "return;";
        }
        return "return ".strConcat(emitExpr(value).strConcat(";"));
    }
    if (kind == NK_IF_STMT) {
        let cond = emitExpr(nodeGetData1(n));
        let thenB = emitBlock(nodeGetData2(n));
        let elseB = nodeGetData3(n);
        if (elseB == 0) {
            return "if (".strConcat(cond).strConcat(") ".strConcat(thenB));
        }
        return strConcat("if (".strConcat(cond).strConcat(") ").strConcat(thenB), " else ".strConcat(emitStmtOrBlock(elseB)));
    }
    if (kind == NK_IF_EXPR) {
        let cond = emitExpr(nodeGetData1(n));
        let thenB = nodeGetData2(n);
        let elseB = nodeGetData3(n);
        let thenStr = emitStmtOrBlock(thenB);
        if (elseB == 0) {
            return "if (".strConcat(cond).strConcat(") ".strConcat(thenStr));
        }
        return strConcat("if (".strConcat(cond).strConcat(") ").strConcat(thenStr), " else ".strConcat(emitStmtOrBlock(elseB)));
    }
    if (kind == NK_WHILE_STMT) {
        return "while (".strConcat(emitExpr(nodeGetData1(n))).strConcat(") ".strConcat(emitBlock(nodeGetData2(n))));
    }
    if (kind == NK_FOR_STMT) {
        let iter = jsIdentStmt(getInternedStr(nodeGetData1(n)));
        let start = emitExpr(nodeGetData2(n));
        let end = emitExpr(nodeGetData3(n));
        let body = emitBlock(nodeGetData4(n));
        return strConcat(strConcat(strConcat(strConcat("for (let ".strConcat(iter).strConcat(" = ").strConcat(start), "; ".strConcat(iter)), " < ".strConcat(end)), "; ".strConcat(iter.strConcat("++) "))), body);
    }
    if (kind == NK_LOOP_STMT) {
        return "while (true) ".strConcat(emitBlock(nodeGetData1(n)));
    }
    if (kind == NK_BREAK_STMT) {
        return "break;";
    }
    if (kind == NK_CONTINUE_STMT) {
        return "continue;";
    }
    if (kind == NK_INTO_STMT) {
        return "// into ".strConcat(getInternedStr(nodeGetData1(n)));
    }
    if (kind == NK_LIFETIME_STMT) {
        return emitBlock(nodeGetData2(n));
    }
    if (kind == NK_BLOCK) {
        return emitBlock(n);
    }
    ""
}
fn emitStmtFnDecl(n: I32) : *Str => {
    let name = getInternedStr(nodeGetData1(n));
    let params = nodeGetData3(n);
    let body = nodeGetData5(n);
    let paramNames = vecNew();
    let hasExplicitThis = 0;
    let i = 0;
    let len = params.vecLength();
    while (i < len) {
        let pname = getInternedStr(params.vecGet(i).vecGet(0));
        if (pname.strEq("this")) {
            hasExplicitThis = 1;
            paramNames.vecPush("__this_param");
        }
        else {
            paramNames.vecPush(pname);
        }
        i = i + 1;
    }
    let paramsStr = paramNames.vecJoin(", ");
    let captureVar = "__tuff_outer_for_".strConcat(name);
    let preamble = "";
    let initThis = "";
    let suffix = "";
    if (hasExplicitThis == 1) {
        initThis = "let __tuff_this = undefined;\n";
    }
    else {
        preamble = "const ".strConcat(captureVar).strConcat(" = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;\n");
        let fields = vecNew();
        let j = 0;
        while (j < len) {
            let pname = getInternedStr(params.vecGet(j).vecGet(0));
            if (!pname.strEq("this")) {
                fields.vecPush(pname.strConcat(": ").strConcat(pname));
            }
            j = j + 1;
        }
        fields.vecPush("this: ".strConcat(captureVar));
        initThis = "let __tuff_this = { ".strConcat(fields.vecJoin(", ")).strConcat(" };\n");
        suffix = "\nif (typeof __tuff_this !== 'undefined') __tuff_this.".strConcat(name).strConcat(" = ").strConcat(name).strConcat(";");
    }
    if (nodeKind(body) == NK_BLOCK) {
        return preamble.strConcat("function ".strConcat(name).strConcat("(".strConcat(paramsStr)).strConcat(") ".strConcat(emitFnBlockWithInit(body, initThis)))).strConcat(suffix);
    }
    preamble.strConcat("function ".strConcat(name).strConcat("(".strConcat(paramsStr)).strConcat(") {\n  ").strConcat(initThis).strConcat("  return ").strConcat(emitExpr(body)).strConcat(";\n}")).strConcat(suffix)
}
fn jsIsExternFnDecl(n: I32) : Bool => {
    let kind = nodeKind(n);
    kind == NK_FN_DECL && nodeGetData5(n) == 0
}
fn emitStmtDecls(n: I32) : *Str => {
    let kind = nodeKind(n);
    if (kind == NK_EXPECT_FN_DECL) {
        return "// expect fn ".strConcat(getInternedStr(nodeGetData1(n)));
    }
    if (jsIsExternFnDecl(n)) {
        return "// extern fn ".strConcat(getInternedStr(nodeGetData1(n)));
    }
    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
        return emitStmtFnDecl(n);
    }
    if (kind == NK_STRUCT_DECL) {
        return jsEmitStructDecl(n);
    }
    if (kind == NK_TYPE_ALIAS) {
        return "// type ".strConcat(getInternedStr(nodeGetData1(n))).strConcat(" = ...");
    }
    if (kind == NK_DEP_TYPE_ALIAS) {
        return "// type ".strConcat(getInternedStr(nodeGetData1(n))).strConcat("(...) = ...");
    }
    if (kind == NK_ENUM_DECL) {
        return jsEmitEnumDecl(n);
    }
    if (kind == NK_OBJECT_DECL) {
        return jsEmitObjectDecl(n);
    }
    if (kind == NK_CONTRACT_DECL) {
        return jsEmitContractDecl(n);
    }
    if (kind == NK_EXTERN_LET_DECL) {
        return "// extern let ".strConcat(getInternedStr(nodeGetData1(n)));
    }
    if (kind == NK_EXTERN_TYPE_DECL) {
        return "// extern type ".strConcat(getInternedStr(nodeGetData1(n)));
    }
    if (kind == NK_EXTERN_IMPORT_DECL) {
        let parts = nodeGetData2(n);
        let i = 0;
        let source = "";
        let __len = parts.vecLength();
        while (i < __len) {
            if (i > 0) {
                source = source.strConcat("::");
            }
            source = source.strConcat(getInternedStr(parts.vecGet(i)));
            i = i + 1;
        }
        return "// extern from ".strConcat(source);
    }
    ""
}
fn emitStmt(n: I32) : *Str => {
    let code = emitStmtLetOrAssign(n);
    if (!code.strEq("")) {
        return code;
    }
    code = emitStmtFlow(n);
    if (!code.strEq("")) {
        return code;
    }
    emitStmtDecls(n)
}
fn emitStmtOrBlock(n: I32) : *Str => {
    if (nodeKind(n) == NK_BLOCK) {
        return emitBlock(n);
    }
    "{ ".strConcat(emitStmt(n).strConcat(" }"))
}
fn emitBlock(n: I32) : *Str => {
    let stmts = nodeGetData1(n);
    let sb = sbNew();
    sbAppend(sb, "{\n");
    let i = 0;
    let len = stmts.vecLength();
    while (i < len) {
        sbAppend(sb, "  ");
        sbAppend(sb, emitStmt(stmts.vecGet(i)));
        sbAppend(sb, "\n");
        i = i + 1;
    }
    sbAppend(sb, "}");
    sbBuild(sb)
}
 // Emit a block wrapped in an IIFE for use in expressions
fn emitBlockAsIife(n: I32) : *Str => {
    let stmts = nodeGetData1(n);
    let len = stmts.vecLength();
    if (len == 0) {
        return "(() => undefined)()";
    }
    let sb = sbNew();
    sbAppend(sb, "(() => {\n");
    let i = 0;
    while (i < len) {
        let stmt = stmts.vecGet(i);
        let isLast = i == len - 1;
        let kind = nodeKind(stmt);
        if (isLast && kind == NK_EXPR_STMT) {
            sbAppend(sb, "  return ");
            sbAppend(sb, emitExpr(nodeGetData1(stmt)));
            sbAppend(sb, ";\n");
        }
        else if (isLast && (kind == NK_IF_STMT || kind == NK_IF_EXPR)) {
            sbAppend(sb, "  return ");
            sbAppend(sb, emitIfAsExpr(stmt));
            sbAppend(sb, ";\n");
        }
        else {
            sbAppend(sb, "  ");
            sbAppend(sb, emitStmt(stmt));
            sbAppend(sb, "\n");
        }
        i = i + 1;
    }
    sbAppend(sb, "})()");
    sbBuild(sb)
}
fn emitFnBlockWithInit(n: I32, initThis: *Str) : *Str => {
    let stmts = nodeGetData1(n);
    let len = stmts.vecLength();
    let sb = sbNew();
    sbAppend(sb, "{\n");
    if (!initThis.strEq("")) {
        sbAppend(sb, "  ");
        sbAppend(sb, initThis);
    }
    if (len == 0) {
        sbAppend(sb, "}");
        return sbBuild(sb);
    }
     // Pass 1: collect type aliases with destructors
    let dtorTypeMap = mapNew();
    let si = 0;
    while (si < len) {
        let stmt = stmts.vecGet(si);
        if (nodeKind(stmt) == NK_TYPE_ALIAS && nodeGetData5(stmt) != 0) {
            let aliasName = getInternedStr(nodeGetData1(stmt));
            let dtorName = getInternedStr(nodeGetData5(stmt));
            dtorTypeMap.mapSet(aliasName, dtorName);
        }
        si = si + 1;
    }
     // Merge top-level map entries for any let annotation lookup that isn't locally shadowed.
     // map iteration is unavailable; direct lookups are done against global map below when needed.
     // Pass 2: collect let-declared variables that have a destructor type
    let dtorVarNames = vecNew();
    let dtorVarDtors = vecNew();
    si = 0;
    while (si < len) {
        let stmt = stmts.vecGet(si);
        if (nodeKind(stmt) == NK_LET_DECL) {
            let typeNode = nodeGetData2(stmt);
            if (typeNode != 0 && nodeKind(typeNode) == 40) {
                let typeName = getInternedStr(nodeGetData1(typeNode));
                let localDtor = dtorTypeMap.mapGetOrDefault(typeName, "");
                let globalDtor = jsGlobalDtorTypeMap.mapGetOrDefault(typeName, "");
                if (localDtor != "" || globalDtor != "") {
                    dtorVarNames.vecPush(getInternedStr(nodeGetData1(stmt)));
                    if (localDtor != "") {
                        dtorVarDtors.vecPush(localDtor);
                    }
                    else {
                        dtorVarDtors.vecPush(globalDtor);
                    }
                }
            }
        }
        si = si + 1;
    }
     // Build destructor call string (reverse order = LIFO destruction)
    let dtorCalls = "";
    let dtorCount = dtorVarNames.vecLength();
    if (dtorCount > 0) {
        let di = dtorCount - 1;
        while (di >= 0) {
            let vn = dtorVarNames.vecGet(di);
            let dn = dtorVarDtors.vecGet(di);
            dtorCalls = dtorCalls.strConcat(dn).strConcat("(").strConcat(vn).strConcat(");\n  ");
            di = di - 1;
        }
    }
    let i = 0;
    while (i < len) {
        let stmt = stmts.vecGet(i);
        let isLast = i == len - 1;
        let kind = nodeKind(stmt);
        if (isLast && kind == NK_EXPR_STMT) {
            if (!dtorCalls.strEq("")) {
                sbAppend(sb, "  ");
                sbAppend(sb, dtorCalls);
            }
            sbAppend(sb, "  return ");
            sbAppend(sb, emitExpr(nodeGetData1(stmt)));
            sbAppend(sb, ";\n");
        }
        else if (isLast && (kind == NK_IF_STMT || kind == NK_IF_EXPR)) {
             // Return the result of the if expression
            if (!dtorCalls.strEq("")) {
                sbAppend(sb, "  ");
                sbAppend(sb, dtorCalls);
            }
            sbAppend(sb, "  return ");
            sbAppend(sb, emitIfAsExpr(stmt));
            sbAppend(sb, ";\n");
        }
        else {
            sbAppend(sb, "  ");
            sbAppend(sb, emitStmt(stmt));
            sbAppend(sb, "\n");
        }
        i = i + 1;
    }
    sbAppend(sb, "}");
    return sbBuild(sb);
}
fn emitFnBlockWithPreamble(n: I32, preamble: *Str) : *Str => {
    let stmts = nodeGetData1(n);
    let len = stmts.vecLength();
    if (len == 0) {
        if (preamble.strEq("")) {
            return "{\n}";
        }
        return "{\n  ".strConcat(preamble).strConcat("\n}");
    }
    let sb = sbNew();
    sbAppend(sb, "{\n");
    if (!preamble.strEq("")) {
        sbAppend(sb, "  ");
        sbAppend(sb, preamble);
        sbAppend(sb, "\n");
    }
    let i = 0;
    while (i < len) {
        let stmt = stmts.vecGet(i);
        let isLast = i == len - 1;
        let kind = nodeKind(stmt);
        if (isLast && kind == NK_EXPR_STMT) {
            sbAppend(sb, "  return ");
            sbAppend(sb, emitExpr(nodeGetData1(stmt)));
            sbAppend(sb, ";\n");
        }
        else if (isLast && (kind == NK_IF_STMT || kind == NK_IF_EXPR)) {
            sbAppend(sb, "  return ");
            sbAppend(sb, emitIfAsExpr(stmt));
            sbAppend(sb, ";\n");
        }
        else {
            sbAppend(sb, "  ");
            sbAppend(sb, emitStmt(stmt));
            sbAppend(sb, "\n");
        }
        i = i + 1;
    }
    sbAppend(sb, "}");
    sbBuild(sb)
}
fn emitFnBlock(n: I32) : *Str => emitFnBlockWithPreamble(n, "");
 // Emit an if statement as a ternary expression
fn emitIfAsExpr(n: I32) : *Str => {
    let cond = emitExpr(nodeGetData1(n));
    let thenBranch = nodeGetData2(n);
    let elseBranch = nodeGetData3(n);
    let thenCode = emitBranchAsExpr(thenBranch);
    let elseCode = "undefined";
    if (elseBranch != 0) {
        elseCode = emitBranchAsExpr(elseBranch);
    }
    strConcat("((".strConcat(cond).strConcat(") ? ").strConcat(thenCode.strConcat(" : ")), elseCode.strConcat(")"))
}
fn emitBranchAsExpr(n: I32) : *Str => {
    let kind = nodeKind(n);
    if (kind == NK_BLOCK) {
         // Wrap block in IIFE
        let stmts = nodeGetData1(n);
        let len = stmts.vecLength();
        if (len == 0) {
            return "undefined";
        }
        let sb = sbNew();
        sbAppend(sb, "(() => {\n");
        let i = 0;
        while (i < len) {
            let stmt = stmts.vecGet(i);
            let isLast = i == len - 1;
            let stmtKind = nodeKind(stmt);
            if (isLast && stmtKind == NK_EXPR_STMT) {
                sbAppend(sb, "    return ");
                sbAppend(sb, emitExpr(nodeGetData1(stmt)));
                sbAppend(sb, ";\n");
            }
            else if (isLast && (stmtKind == NK_IF_STMT || stmtKind == NK_IF_EXPR)) {
                sbAppend(sb, "    return ");
                sbAppend(sb, emitIfAsExpr(stmt));
                sbAppend(sb, ";\n");
            }
            else {
                sbAppend(sb, "    ");
                sbAppend(sb, emitStmt(stmt));
                sbAppend(sb, "\n");
            }
            i = i + 1;
        }
        sbAppend(sb, "  })()");
        return sbBuild(sb);
    }
    if (kind == NK_IF_STMT || kind == NK_IF_EXPR) {
        return emitIfAsExpr(n);
    }
    emitExpr(n)
}
out fn generateJs(program: I32) : *Str => {
    let stmts = nodeGetData1(program);
    jsGlobalDtorTypeMap = mapNew();
    let gi = 0;
    let glen = stmts.vecLength();
    while (gi < glen) {
        let s = stmts.vecGet(gi);
        let k = nodeKind(s);
        if ((k == NK_TYPE_ALIAS || k == NK_EXTERN_TYPE_DECL) && nodeGetData5(s) != 0) {
            jsGlobalDtorTypeMap.mapSet(getInternedStr(nodeGetData1(s)), getInternedStr(nodeGetData5(s)));
        }
        gi = gi + 1;
    }
    let sb = sbNew();
    sbAppend(sb, "\"use strict\";\n\n");
    let i = 0;
    let len = stmts.vecLength();
    while (i < len) {
        sbAppend(sb, emitStmt(stmts.vecGet(i)));
        sbAppend(sb, "\n\n");
        i = i + 1;
    }
    sbBuild(sb)
}
out fn selfhostCodegenStmtMarker() : I32 => 0;
