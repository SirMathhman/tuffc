let { get_intern, get_interned_str, tok_kind, tok_value, tok_line, tok_col, vec_new } = selfhost::runtime_lexer;
let { p_expect, p_expect_kind, p_parse_identifier, p_at, p_eat, p_parse_type, p_parse_type_primary, p_at_kind, p_can_start_refinement_expr_at, p_peek, p_mark, p_error_with_token_context, node_kind, node_new, node_set_data1, node_set_data2, node_set_data3, node_set_data4, node_set_data5, node_get_data1, node_get_data2, node_get_data3 } = selfhost::parser_core;

let parse_temp_counter : I32 = 0;

fn p_new_temp_name(prefix: *Str) : I32 => {
    parse_temp_counter = parse_temp_counter + 1;
    intern(prefix.str_concat(int_to_string(parse_temp_counter)))
}

fn p_new_stmt_list(stmts: Vec) : I32 => {
    let n = node_new(NK_STMT_LIST);
    node_set_data1(n, stmts);
    n
}

fn p_parse_constraint_value_atom() : I32 => {
    if (p_at_kind(TK_IDENTIFIER)) {
        let n = node_new(NK_IDENTIFIER);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at_kind(TK_NUMBER)) {
        let n = node_new(NK_NUMBER_LIT);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at_kind(TK_BOOL)) {
        let n = node_new(NK_BOOL_LIT);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at_kind(TK_STRING)) {
        let n = node_new(NK_STRING_LIT);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at_kind(TK_CHAR)) {
        let n = node_new(NK_CHAR_LIT);
        node_set_data1(n, tok_value(p_eat()));
        return n;
    }
    if (p_at(TK_SYMBOL, "(")) {
        p_eat();
        let inner = p_parse_expression(0);
        p_expect(TK_SYMBOL, ")", "Expected ')' in generic constraint expression");
        return inner;
    }
    p_parse_type_primary()
}

fn p_parse_constraint_value_expr() : I32 => {
    let left = p_parse_constraint_value_atom();
    while (
        p_at(TK_SYMBOL, "+") ||
        p_at(TK_SYMBOL, "-") ||
        p_at(TK_SYMBOL, "*") ||
        p_at(TK_SYMBOL, "/") ||
        p_at(TK_SYMBOL, "%")
    ) {
        let op = tok_value(p_eat());
        let right = p_parse_constraint_value_atom();
        let bin = node_new(NK_BINARY_EXPR);
        node_set_data1(bin, op);
        node_set_data2(bin, left);
        node_set_data3(bin, right);
        left = bin;
    }
    left
}

fn p_parse_generic_constraint_type() : I32 => {
    let type_node = p_parse_type_primary();

    let starts_generic_call_suffix = false;
    if (p_at(TK_SYMBOL, ">") && tok_kind(p_peek(1)) == TK_SYMBOL) {
        let next_sym = get_intern(tok_value(p_peek(1)));
        if (next_sym.str_eq("(")) {
            starts_generic_call_suffix = true;
        }
    }

    let has_refine =
        (p_at(TK_SYMBOL, "!=") ||
        p_at(TK_SYMBOL, "<") ||
        p_at(TK_SYMBOL, ">") ||
        p_at(TK_SYMBOL, "<=") ||
        p_at(TK_SYMBOL, ">=")) &&
        p_can_start_refinement_expr_at(1) &&
        !starts_generic_call_suffix;

    if (has_refine) {
        let op = tok_value(p_eat());
        let value = p_parse_constraint_value_expr();
        let refine = node_new(NK_REFINEMENT_TYPE);
        node_set_data1(refine, type_node);
        node_set_data2(refine, op);
        node_set_data3(refine, value);
        type_node = refine;
    }

    while (p_at(TK_SYMBOL, "|") || p_at(TK_SYMBOL, "|>")) {
        let is_extract = 0;
        if (p_at(TK_SYMBOL, "|>")) {
            is_extract = 1;
        }
        p_eat();
        let right = p_parse_type_primary();
        let union_node = node_new(NK_UNION_TYPE);
        node_set_data1(union_node, type_node);
        node_set_data2(union_node, right);
        node_set_data3(union_node, is_extract);
        type_node = union_node;
    }

    type_node
}

fn p_parse_decl_generics(close_message: *Str) : Vec => {
    let generics = vec_new();
    if (p_at(TK_SYMBOL, "<")) {
        p_eat();
        if (!p_at(TK_SYMBOL, ">")) {
            while (true) {
                generics.vec_push(p_parse_identifier());
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    p_parse_generic_constraint_type();
                }
                if (!p_at(TK_SYMBOL, ",")) {
                    break;
                }
                p_eat();
            }
        }
        p_expect(TK_SYMBOL, ">", close_message);
    }
    generics
}

fn p_parse_function(is_class: I32, mode: I32) : I32 => {
    p_expect(TK_KEYWORD, "fn", "Expected 'fn'");
    let name = p_parse_identifier();
    
    // Generics
    let generics = p_parse_decl_generics("Expected '>'");
    
    // Parameters
    p_expect(TK_SYMBOL, "(", "Expected '('");
    let params = vec_new();
    if (!p_at(TK_SYMBOL, ")")) {
        while (true) {
            let pname = 0;
            let ptype = 0;

            // Receiver/typed-first shorthand: *mut this, *a mut this, etc.
            if (p_at(TK_SYMBOL, "*")) {
                ptype = p_parse_type();
                if (p_at_kind(TK_IDENTIFIER)) {
                    pname = p_parse_identifier();
                } else {
                    // Compatibility shorthand: `*mut a this` (no explicit param name token after type)
                    if (node_kind(ptype) == NK_POINTER_TYPE) {
                        let inner = node_get_data2(ptype);
                        if (inner != 0 && node_kind(inner) == NK_NAMED_TYPE) {
                            let inner_name = node_get_data1(inner);
                            if (get_intern(inner_name).str_eq("this")) {
                                pname = inner_name;
                            } else {
                                p_expect_kind(TK_IDENTIFIER, "Expected identifier");
                            }
                        } else {
                            p_expect_kind(TK_IDENTIFIER, "Expected identifier");
                        }
                    } else {
                        p_expect_kind(TK_IDENTIFIER, "Expected identifier");
                    }
                }
            } else {
                pname = p_parse_identifier();
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    ptype = p_parse_type();
                }
            }

            let param = vec_new();
            param.vec_push(pname);
            param.vec_push(ptype);
            params.vec_push(param);

            if (!p_at(TK_SYMBOL, ",")) {
                break;
            }
            p_eat();
        }
    }
    p_expect(TK_SYMBOL, ")", "Expected ')'");
    
    // Return type
    let ret_type = 0;
    if (p_at(TK_SYMBOL, ":")) {
        p_eat();
        ret_type = p_parse_type();
    }
    
    let body = 0;
    if (mode == 1) {
        p_expect(TK_SYMBOL, ";", "Expected ';' after expect function declaration");
    } else {
        // Body
        p_expect(TK_SYMBOL, "=>", "Expected '=>'");
        if (p_at(TK_SYMBOL, "{")) {
            body = p_parse_block();
        } else {
            body = p_parse_expression(0);
        }
        
        // Semicolon for expression body
        if (node_kind(body) != NK_BLOCK) {
            if (!p_at(TK_SYMBOL, "}") && !p_at_kind(TK_EOF)) {
                p_expect(TK_SYMBOL, ";", "Expected ';'");
            }
        }
    }

    let kind = NK_FN_DECL;
    if (is_class == 1) {
        kind = NK_CLASS_FN_DECL;
    } else if (mode == 1) {
        kind = NK_EXPECT_FN_DECL;
    } else if (mode == 2) {
        kind = NK_ACTUAL_FN_DECL;
    }
    let node = node_new(kind);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, params);
    node_set_data4(node, ret_type);
    node_set_data5(node, body);
    node
}

fn p_parse_struct(is_copy: I32) : I32 => {
    p_expect(TK_KEYWORD, "struct", "Expected 'struct'");
    let name = p_parse_identifier();
    
    let generics = p_parse_decl_generics("Expected '>'");
    
    p_expect(TK_SYMBOL, "{", "Expected '{'");
    let fields = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        let fname = p_parse_identifier();
        p_expect(TK_SYMBOL, ":", "Expected ':'");
        let ftype = p_parse_type();
        let field = vec_new();
        field.vec_push(fname);
        field.vec_push(ftype);
        fields.vec_push(field);
        if (p_at(TK_SYMBOL, ",") || p_at(TK_SYMBOL, ";")) {
            p_eat();
        }
    }
    p_expect(TK_SYMBOL, "}", "Expected '}'");
    
    let node = node_new(NK_STRUCT_DECL);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, fields);
    node_set_data4(node, is_copy);
    node
}

fn p_parse_enum() : I32 => {
    p_expect(TK_KEYWORD, "enum", "Expected 'enum'");
    let name = p_parse_identifier();
    p_expect(TK_SYMBOL, "{", "Expected '{' after enum name");
    let variants = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        variants.vec_push(p_parse_identifier());
        if (p_at(TK_SYMBOL, ",") || p_at(TK_SYMBOL, ";")) {
            p_eat();
        }
    }
    p_expect(TK_SYMBOL, "}", "Expected '}' after enum body");
    let node = node_new(NK_ENUM_DECL);
    node_set_data1(node, name);
    node_set_data2(node, variants);
    node
}

fn p_parse_object() : I32 => {
    p_expect(TK_KEYWORD, "object", "Expected 'object'");
    let name = p_parse_identifier();

    let generics = p_parse_decl_generics("Expected '>'");

    p_expect(TK_SYMBOL, "{", "Expected '{' after object name");
    let inputs = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        p_expect(TK_KEYWORD, "in", "Expected 'in' in object input declaration");
        p_expect(TK_KEYWORD, "let", "Expected 'let' in object input declaration");
        let input_name = p_parse_identifier();
        p_expect(TK_SYMBOL, ":", "Expected ':' in object input declaration");
        let input_type = p_parse_type();
        p_expect(TK_SYMBOL, ";", "Expected ';' after object input declaration");

        let input_field = vec_new();
        input_field.vec_push(input_name);
        input_field.vec_push(input_type);
        inputs.vec_push(input_field);
    }
    p_expect(TK_SYMBOL, "}", "Expected '}' after object body");

    let node = node_new(NK_OBJECT_DECL);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, inputs);
    node
}

fn p_parse_contract() : I32 => {
    p_expect(TK_KEYWORD, "contract", "Expected 'contract'");
    let name = p_parse_identifier();
    p_expect(TK_SYMBOL, "{", "Expected '{' after contract name");

    let methods = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        p_expect(TK_KEYWORD, "fn", "Expected 'fn' in contract declaration");
        let mname = p_parse_identifier();
        let mgenerics = p_parse_decl_generics("Expected '>' after contract method generics");

        p_expect(TK_SYMBOL, "(", "Expected '(' in contract method signature");
        let params = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            while (true) {
                let pname = 0;
                let ptype = 0;
                let implicit_this = 0;

                if (p_at(TK_SYMBOL, "*")) {
                    p_eat();
                    if (p_at(TK_KEYWORD, "mut")) {
                        p_eat();
                    }
                    pname = p_parse_identifier();
                    ptype = 0;
                    implicit_this = 1;
                } else {
                    pname = p_parse_identifier();
                    if (p_at(TK_SYMBOL, ":")) {
                        p_eat();
                        ptype = p_parse_type();
                    }
                }

                let param = vec_new();
                param.vec_push(pname);
                param.vec_push(ptype);
                param.vec_push(implicit_this);
                params.vec_push(param);

                if (!p_at(TK_SYMBOL, ",")) {
                    break;
                }
                p_eat();
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')' after contract method params");

        let ret = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            ret = p_parse_type();
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after contract method signature");

        let method = vec_new();
        method.vec_push(mname);
        method.vec_push(mgenerics);
        method.vec_push(params);
        method.vec_push(ret);
        methods.vec_push(method);
    }

    p_expect(TK_SYMBOL, "}", "Expected '}' after contract body");
    let node = node_new(NK_CONTRACT_DECL);
    node_set_data1(node, name);
    node_set_data2(node, methods);
    node
}

fn p_parse_type_alias(is_copy: I32) : I32 => {
    p_expect(TK_KEYWORD, "type", "Expected 'type'");
    let name = p_parse_identifier();
    
    let generics = p_parse_decl_generics("Expected '>'");
    
    p_expect(TK_SYMBOL, "=", "Expected '='");
    let aliased = p_parse_type();
    let destructor_name = 0;
    if (p_at(TK_KEYWORD, "then")) {
        p_eat();
        destructor_name = p_parse_identifier();
    }
    p_expect(TK_SYMBOL, ";", "Expected ';'");
    
    let node = node_new(NK_TYPE_ALIAS);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, aliased);
    node_set_data4(node, is_copy);
    node_set_data5(node, destructor_name);
    node
}

fn p_parse_let() : I32 => {
    p_expect(TK_KEYWORD, "let", "Expected 'let'");

    // Accept mutability marker for Stage0 parity; mut semantics are enforced later.
    if (p_at(TK_KEYWORD, "mut")) {
        p_eat();
    }
    
    // Destructuring import
    if (p_at(TK_SYMBOL, "{")) {
        p_eat();
        let names = vec_new();
        if (!p_at(TK_SYMBOL, "}")) {
            names.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                names.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, "}", "Expected '}'");
        p_expect(TK_SYMBOL, "=", "Expected '='");
        let parts = vec_new();
        parts.vec_push(p_parse_identifier());
        while (p_at(TK_SYMBOL, "::")) {
            p_eat();
            parts.vec_push(p_parse_identifier());
        }
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        let node = node_new(NK_IMPORT_DECL);
        node_set_data1(node, names);
        node_set_data2(node, parts);
        return node;
    }

    // Tuple destructuring let: let (a, b, c) = expr;
    if (p_at(TK_SYMBOL, "(")) {
        p_eat();
        let names = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            names.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                names.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')' in tuple let destructuring");
        p_expect(TK_SYMBOL, "=", "Expected '=' in tuple let destructuring");
        let rhs = p_parse_expression(0);
        p_expect(TK_SYMBOL, ";", "Expected ';' after tuple let destructuring");

        let lowered = vec_new();
        let tmp_name = p_new_temp_name("__tuple_tmp_");

        let tmp_decl = node_new(NK_LET_DECL);
        node_set_data1(tmp_decl, tmp_name);
        node_set_data2(tmp_decl, 0);
        node_set_data3(tmp_decl, rhs);
        lowered.vec_push(tmp_decl);

        let i = 0;
        while (i < names.vec_length()) {
            let tmp_ident = node_new(NK_IDENTIFIER);
            node_set_data1(tmp_ident, tmp_name);

            let idx_lit = node_new(NK_NUMBER_LIT);
            node_set_data1(idx_lit, intern(int_to_string(i)));

            let idx_expr = node_new(NK_INDEX_EXPR);
            node_set_data1(idx_expr, tmp_ident);
            node_set_data2(idx_expr, idx_lit);

            let elem_decl = node_new(NK_LET_DECL);
            node_set_data1(elem_decl, names.vec_get(i));
            node_set_data2(elem_decl, 0);
            node_set_data3(elem_decl, idx_expr);
            lowered.vec_push(elem_decl);

            i = i + 1;
        }

        return p_new_stmt_list(lowered);
    }
    
    let name = p_parse_identifier();
    let vtype = 0;
    if (p_at(TK_SYMBOL, ":")) {
        p_eat();
        vtype = p_parse_type();
    }
    p_expect(TK_SYMBOL, "=", "Expected '='");
    let value = p_parse_expression(0);
    p_expect(TK_SYMBOL, ";", "Expected ';'");
    
    let node = node_new(NK_LET_DECL);
    node_set_data1(node, name);
    node_set_data2(node, vtype);
    node_set_data3(node, value);
    node
}

fn p_parse_for() : I32 => {
    p_expect(TK_KEYWORD, "for", "Expected 'for'");
    p_expect(TK_SYMBOL, "(", "Expected '('");
    let iter = p_parse_identifier();
    p_expect(TK_KEYWORD, "in", "Expected 'in'");
    let start = p_parse_expression(0);
    p_expect(TK_SYMBOL, "..", "Expected '..'");
    let end = p_parse_expression(0);
    p_expect(TK_SYMBOL, ")", "Expected ')'");
    let body = p_parse_block();
    
    let node = node_new(NK_FOR_STMT);
    node_set_data1(node, iter);
    node_set_data2(node, start);
    node_set_data3(node, end);
    node_set_data4(node, body);
    node
}

fn p_parse_lifetime() : I32 => {
    p_expect(TK_KEYWORD, "lifetime", "Expected 'lifetime'");
    let names = vec_new();
    names.vec_push(p_parse_identifier());
    while (p_at(TK_SYMBOL, ",")) {
        p_eat();
        names.vec_push(p_parse_identifier());
    }
    let body = p_parse_block();
    let node = node_new(NK_LIFETIME_STMT);
    node_set_data1(node, names);
    node_set_data2(node, body);
    node
}

fn p_parse_template_wrapper() : I32 => {
    p_eat(); // template
    p_parse_identifier();
    if (p_at(TK_SYMBOL, ":")) {
        p_eat();
        p_parse_type();
    }
    while (p_at(TK_SYMBOL, ",")) {
        p_eat();
        p_parse_identifier();
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            p_parse_type();
        }
    }

    p_expect(TK_SYMBOL, "{", "Expected '{' after template declaration");
    let stmts = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        let stmt = p_parse_statement();
        if (node_kind(stmt) == NK_BLOCK) {
            let inner = node_get_data1(stmt);
            let j = 0;
            while (j < inner.vec_length()) {
                stmts.vec_push(inner.vec_get(j));
                j = j + 1;
            }
        } else {
            stmts.vec_push(stmt);
        }
    }
    p_expect(TK_SYMBOL, "}", "Expected '}' after template block");

    p_new_stmt_list(stmts)
}

fn p_parse_module_wrapper() : I32 => {
    p_expect(TK_KEYWORD, "module", "Expected 'module'");
    p_parse_identifier();
    p_expect(TK_SYMBOL, "{", "Expected '{' after module name");

    let stmts = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        let stmt = p_parse_statement();
        if (node_kind(stmt) == NK_BLOCK) {
            let inner = node_get_data1(stmt);
            let j = 0;
            while (j < inner.vec_length()) {
                stmts.vec_push(inner.vec_get(j));
                j = j + 1;
            }
        } else {
            stmts.vec_push(stmt);
        }
    }
    p_expect(TK_SYMBOL, "}", "Expected '}' after module body");

    p_new_stmt_list(stmts)
}

// Parse extern fn/let/type declarations
fn p_parse_extern_decl() : I32 => {
    if (p_at(TK_KEYWORD, "fn")) {
        p_eat();
        let name = p_parse_identifier();
        
        // Generics
        let generics = p_parse_decl_generics("Expected '>'");
        
        // Parameters
        p_expect(TK_SYMBOL, "(", "Expected '('");
        let params = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            while (true) {
                let pname = 0;
                let ptype = 0;

                // Receiver/typed-first shorthand: *mut this, *a mut this, etc.
                if (p_at(TK_SYMBOL, "*")) {
                    ptype = p_parse_type();
                    pname = p_parse_identifier();
                } else {
                    pname = p_parse_identifier();
                    if (p_at(TK_SYMBOL, ":")) {
                        p_eat();
                        ptype = p_parse_type();
                    }
                }

                let param = vec_new();
                param.vec_push(pname);
                param.vec_push(ptype);
                params.vec_push(param);

                if (!p_at(TK_SYMBOL, ",")) {
                    break;
                }
                p_eat();
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')'");
        
        // Return type
        let ret_type = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            ret_type = p_parse_type();
        }
        
        // No body - just semicolon
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern fn");
        
        // Create a special node for extern fn
        let node = node_new(NK_EXTERN_FN_DECL);
        node_set_data1(node, name);
        node_set_data2(node, generics);
        node_set_data3(node, params);
        node_set_data4(node, ret_type);
        return node;
    }
    if (p_at(TK_KEYWORD, "let")) {
        p_eat();

        // Extern source attribution metadata:
        // extern let { malloc, free } = stdlib;
        // Keep this metadata in the AST so C codegen can enforce coverage and map headers.
        if (p_at(TK_SYMBOL, "{")) {
            p_eat();
            let names = vec_new();
            if (!p_at(TK_SYMBOL, "}")) {
                names.vec_push(p_parse_identifier());
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    names.vec_push(p_parse_identifier());
                }
            }
            p_expect(TK_SYMBOL, "}", "Expected '}' after extern let bindings");
            p_expect(TK_SYMBOL, "=", "Expected '=' in extern let bindings");
            let source_parts = vec_new();
            source_parts.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, "::")) {
                p_eat();
                source_parts.vec_push(p_parse_identifier());
            }
            p_expect(TK_SYMBOL, ";", "Expected ';' after extern let bindings");
            let node = node_new(NK_EXTERN_IMPORT_DECL);
            node_set_data1(node, names);
            node_set_data2(node, source_parts);
            return node;
        }

        let name = p_parse_identifier();
        let typ = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            typ = p_parse_type();
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern let");
        let node = node_new(NK_EXTERN_LET_DECL);
        node_set_data1(node, name);
        node_set_data2(node, typ);
        return node;
    }
    if (p_at(TK_KEYWORD, "type")) {
        p_eat();
        let name = p_parse_identifier();
        let generics = p_parse_decl_generics("Expected '>' after extern type generics");
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern type");
        let node = node_new(NK_EXTERN_TYPE_DECL);
        node_set_data1(node, name);
        node_set_data2(node, generics);
        return node;
    }
    panic("Expected fn, let, or type after extern")
}

fn p_parse_statement() : I32 => {
    let exported = 0;
    let copy_decl = 0;
    let expect_decl = 0;
    let actual_decl = 0;
    let consumed_modifier = 0;
    let modifier_watchdog = 0;
    while (
        p_at(TK_KEYWORD, "out") ||
        p_at(TK_KEYWORD, "copy") ||
        p_at(TK_KEYWORD, "expect") ||
        p_at(TK_IDENTIFIER, "expect") ||
        p_at(TK_KEYWORD, "actual") ||
        p_at(TK_IDENTIFIER, "actual")
    ) {
        modifier_watchdog = modifier_watchdog + 1;
        if (modifier_watchdog > 1000) {
            p_error_with_token_context("Parser watchdog: declaration-modifier loop exceeded 1000 iterations");
        }
        consumed_modifier = 1;
        if (p_at(TK_KEYWORD, "out")) {
            p_eat();
            if (exported == 1) {
                panic("Duplicate 'out' modifier");
            }
            exported = 1;
        } else if (p_at(TK_KEYWORD, "copy")) {
            p_eat();
            if (copy_decl == 1) {
                panic("Duplicate 'copy' modifier");
            }
            copy_decl = 1;
        } else if (p_at(TK_KEYWORD, "expect") || p_at(TK_IDENTIFIER, "expect")) {
            p_eat();
            if (expect_decl == 1) {
                panic("Duplicate 'expect' modifier");
            }
            expect_decl = 1;
        } else if (p_at(TK_KEYWORD, "actual") || p_at(TK_IDENTIFIER, "actual")) {
            p_eat();
            if (actual_decl == 1) {
                panic("Duplicate 'actual' modifier");
            }
            actual_decl = 1;
        } else {
            panic("Unexpected declaration modifier");
        }
    }

    if (expect_decl == 1 && actual_decl == 1) {
        panic("Cannot combine 'expect' and 'actual' modifiers");
    }

    if (consumed_modifier == 1) {
        let out_node = 0;
        if (p_at(TK_KEYWORD, "struct")) {
            out_node = p_parse_struct(copy_decl);
        } else if (p_at(TK_KEYWORD, "enum")) {
            out_node = p_parse_enum();
        } else if (p_at(TK_KEYWORD, "object")) {
            if (copy_decl == 1) {
                panic("'copy' is only supported on struct/type declarations");
            }
            if (expect_decl == 1 || actual_decl == 1) {
                panic("'expect'/'actual' are currently supported only on fn declarations");
            }
            out_node = p_parse_object();
        } else if (p_at(TK_KEYWORD, "contract")) {
            if (copy_decl == 1) {
                panic("'copy' is only supported on struct/type declarations");
            }
            if (expect_decl == 1 || actual_decl == 1) {
                panic("'expect'/'actual' are currently supported only on fn declarations");
            }
            out_node = p_parse_contract();
        } else if (p_at(TK_KEYWORD, "type")) {
            out_node = p_parse_type_alias(copy_decl);
        } else if (p_at(TK_KEYWORD, "fn")) {
            if (copy_decl == 1) {
                panic("'copy' is only supported on struct/type declarations");
            }
            let mode = 0;
            if (expect_decl == 1) {
                mode = 1;
            } else if (actual_decl == 1) {
                mode = 2;
            }
            out_node = p_parse_function(0, mode);
        } else if (p_at(TK_KEYWORD, "class")) {
            if (copy_decl == 1) {
                panic("'copy' is only supported on struct/type declarations");
            }
            if (expect_decl == 1 || actual_decl == 1) {
                panic("'expect'/'actual' are currently supported only on fn declarations");
            }
            p_eat();
            out_node = p_parse_function(1, 0);
        } else if (p_at(TK_KEYWORD, "module")) {
            if (copy_decl == 1) {
                panic("'copy' is only supported on struct/type declarations");
            }
            if (expect_decl == 1 || actual_decl == 1) {
                panic("'expect'/'actual' are currently supported only on fn declarations");
            }
            out_node = p_parse_module_wrapper();
        } else {
            panic("Expected declaration after modifiers");
        }

        if (exported == 1 && node_kind(out_node) != NK_STMT_LIST) {
            parse_exports.set_add(get_interned_str(node_get_data1(out_node)));
        }
        if (p_at(TK_SYMBOL, ";")) {
            p_eat();
        }
        return out_node;
    }

    if (p_at(TK_KEYWORD, "let")) { return p_parse_let(); }
    if (p_at(TK_KEYWORD, "struct")) {
        let node = p_parse_struct(0);
        if (p_at(TK_SYMBOL, ";")) { p_eat(); }
        return node;
    }
    if (p_at(TK_KEYWORD, "enum")) {
        let node = p_parse_enum();
        if (p_at(TK_SYMBOL, ";")) { p_eat(); }
        return node;
    }
    if (p_at(TK_KEYWORD, "object")) {
        let node = p_parse_object();
        if (p_at(TK_SYMBOL, ";")) { p_eat(); }
        return node;
    }
    if (p_at(TK_KEYWORD, "module")) {
        let node = p_parse_module_wrapper();
        if (p_at(TK_SYMBOL, ";")) { p_eat(); }
        return node;
    }
    if (p_at(TK_KEYWORD, "template") || p_at(TK_IDENTIFIER, "template")) {
        let node = p_parse_template_wrapper();
        if (p_at(TK_SYMBOL, ";")) { p_eat(); }
        return node;
    }
    if (p_at(TK_KEYWORD, "contract")) {
        let node = p_parse_contract();
        if (p_at(TK_SYMBOL, ";")) { p_eat(); }
        return node;
    }
    if (p_at(TK_KEYWORD, "type")) {
        let node = p_parse_type_alias(0);
        if (p_at(TK_SYMBOL, ";")) { p_eat(); }
        return node;
    }
    if (p_at(TK_KEYWORD, "fn")) {
        let node = p_parse_function(0, 0);
        if (p_at(TK_SYMBOL, ";")) { p_eat(); }
        return node;
    }
    if (p_at(TK_KEYWORD, "extern")) {
        p_eat();
        // extern fn/let/type declaration
        return p_parse_extern_decl();
    }
    if (p_at(TK_KEYWORD, "class")) {
        p_eat();
        let node = p_parse_function(1, 0);
        if (p_at(TK_SYMBOL, ";")) { p_eat(); }
        return node;
    }
    if (p_at(TK_KEYWORD, "return")) {
        p_eat();
        let value = 0;
        if (!p_at(TK_SYMBOL, ";")) {
            value = p_parse_expression(0);
        }
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        let node = node_new(NK_RETURN_STMT);
        node_set_data1(node, value);
        return node;
    }
    if (p_at(TK_KEYWORD, "if")) {
        p_eat();
        p_expect(TK_SYMBOL, "(", "Expected '(' after if");
        let cond = p_parse_expression(0);
        p_expect(TK_SYMBOL, ")", "Expected ')' after condition");

        // Statement-form if: block/control-flow branches (e.g. if (...) break;)
        if (
            p_at(TK_SYMBOL, "{") ||
            p_at(TK_KEYWORD, "break") ||
            p_at(TK_KEYWORD, "continue") ||
            p_at(TK_KEYWORD, "return") ||
            p_at(TK_KEYWORD, "if") ||
            p_at(TK_KEYWORD, "while") ||
            p_at(TK_KEYWORD, "for") ||
            p_at(TK_KEYWORD, "loop") ||
            p_at(TK_KEYWORD, "let")
        ) {
            let then_branch = 0;
            if (p_at(TK_SYMBOL, "{")) {
                then_branch = p_parse_block();
            } else {
                then_branch = p_parse_statement();
            }
            let else_branch = 0;
            if (p_at(TK_KEYWORD, "else")) {
                p_eat();
                if (p_at(TK_SYMBOL, "{")) {
                    else_branch = p_parse_block();
                } else {
                    else_branch = p_parse_statement();
                }
            }

            let stmt = node_new(NK_IF_STMT);
            node_set_data1(stmt, cond);
            node_set_data2(stmt, then_branch);
            node_set_data3(stmt, else_branch);
            return stmt;
        }

        // Expression-form if in statement position: if (c) expr else expr
        let then_expr = p_parse_expression(0);
        let else_expr = 0;
        if (p_at(TK_KEYWORD, "else")) {
            p_eat();
            if (p_at(TK_SYMBOL, "{")) {
                else_expr = p_parse_block();
            } else {
                else_expr = p_parse_expression(0);
            }
        }
        let if_expr = node_new(NK_IF_EXPR);
        node_set_data1(if_expr, cond);
        node_set_data2(if_expr, then_expr);
        node_set_data3(if_expr, else_expr);

        if (p_at(TK_SYMBOL, ";")) {
            p_eat();
        } else if (!p_at(TK_SYMBOL, "}")) {
            p_expect(TK_SYMBOL, ";", "Expected ';'");
        }

        let estmt = node_new(NK_EXPR_STMT);
        node_set_data1(estmt, if_expr);
        return estmt;
    }
    if (p_at(TK_KEYWORD, "while")) {
        p_eat();
        p_expect(TK_SYMBOL, "(", "Expected '('");
        let cond = p_parse_expression(0);
        p_expect(TK_SYMBOL, ")", "Expected ')'");
        let body = p_parse_block();
        let node = node_new(NK_WHILE_STMT);
        node_set_data1(node, cond);
        node_set_data2(node, body);
        return node;
    }
    if (p_at(TK_KEYWORD, "for")) { return p_parse_for(); }
    if (p_at(TK_KEYWORD, "loop")) {
        p_eat();
        let body = p_parse_block();
        let node = node_new(NK_LOOP_STMT);
        node_set_data1(node, body);
        return node;
    }
    if (p_at(TK_KEYWORD, "then")) {
        p_eat();
        p_expect(TK_SYMBOL, "(", "Expected '(' after then in then-statement");
        p_expect(TK_SYMBOL, ")", "Expected ')' in then-statement parameter list");
        p_expect(TK_SYMBOL, "=>", "Expected '=>' in then-statement");

        if (p_at(TK_SYMBOL, "{")) {
            return p_parse_block();
        }

        let expr = p_parse_expression(0);
        p_expect(TK_SYMBOL, ";", "Expected ';' after then-statement expression");
        let estmt = node_new(NK_EXPR_STMT);
        node_set_data1(estmt, expr);
        return estmt;
    }
    if (p_at(TK_KEYWORD, "lifetime")) {
        return p_parse_lifetime();
    }
    if (p_at(TK_KEYWORD, "into")) {
        p_eat();
        let cname = p_parse_identifier();
        p_expect(TK_SYMBOL, ";", "Expected ';' after into statement");
        let node = node_new(NK_INTO_STMT);
        node_set_data1(node, cname);
        return node;
    }
    if (p_at(TK_KEYWORD, "break")) {
        p_eat();
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        return node_new(NK_BREAK_STMT);
    }
    if (p_at(TK_KEYWORD, "continue")) {
        p_eat();
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        return node_new(NK_CONTINUE_STMT);
    }
    if (p_at(TK_SYMBOL, "{")) { return p_parse_block(); }
    
    // Expression statement
    let expr = p_parse_expression(0);
    
    // Assignment
    if (p_at(TK_SYMBOL, "=")) {
        p_eat();
        let value = p_parse_expression(0);
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        let node = node_new(NK_ASSIGN_STMT);
        node_set_data1(node, expr);
        node_set_data2(node, value);
        return node;
    }

    // Compound assignment: x += v, x -= v, etc. (lexed as op token followed by '=')
    if (
        (p_at(TK_SYMBOL, "+") || p_at(TK_SYMBOL, "-") || p_at(TK_SYMBOL, "*") || p_at(TK_SYMBOL, "/") || p_at(TK_SYMBOL, "%") || p_at(TK_SYMBOL, "&") || p_at(TK_SYMBOL, "|") || p_at(TK_SYMBOL, "^")) &&
        tok_kind(p_peek(1)) == TK_SYMBOL &&
        get_interned_str(tok_value(p_peek(1))).str_eq("=")
    ) {
        let op_tok = p_eat();
        p_eat();
        let rhs = p_parse_expression(0);
        p_expect(TK_SYMBOL, ";", "Expected ';'");

        let bin = node_new(NK_BINARY_EXPR);
        node_set_data1(bin, tok_value(op_tok));
        node_set_data2(bin, expr);
        node_set_data3(bin, rhs);

        let node = node_new(NK_ASSIGN_STMT);
        node_set_data1(node, expr);
        node_set_data2(node, bin);
        return node;
    }
    
    if (p_at(TK_SYMBOL, ";")) {
        p_eat();
    } else if (!p_at(TK_SYMBOL, "}")) {
        p_expect(TK_SYMBOL, ";", "Expected ';'");
    }
    
    let node = node_new(NK_EXPR_STMT);
    node_set_data1(node, expr);
    node
}

out fn p_parse_program() : I32 => {
    let stmts = vec_new();
    let at_eof = p_at_kind(TK_EOF);
    while (!at_eof) {
        let before = p_mark();
        let stmt = p_parse_statement();
        let after = p_mark();
        if (after == before) {
            p_error_with_token_context("Parser made no progress while parsing top-level statement");
        }
        if (node_kind(stmt) == NK_STMT_LIST) {
            let inner = node_get_data1(stmt);
            let i = 0;
            while (i < inner.vec_length()) {
                stmts.vec_push(inner.vec_get(i));
                i = i + 1;
            }
        } else {
            stmts.vec_push(stmt);
        }
        at_eof = p_at_kind(TK_EOF);
    }
    let node = node_new(NK_PROGRAM);
    node_set_data1(node, stmts);
    node
}

// ============================================================================
// Desugar - skip for now, minimal implementation
// ============================================================================

out fn desugar(program: I32) : I32 => program;

out fn selfhost_parser_decls_marker() : I32 => 0;
