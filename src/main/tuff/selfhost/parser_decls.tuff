let { get_interned_str, vec_new } = selfhost::runtime_lexer;
let { p_expect, p_parse_identifier, p_at, p_eat, p_parse_type, p_at_kind, node_kind, node_new, node_set_data1, node_set_data2, node_set_data3, node_set_data4, node_set_data5, node_get_data1, node_get_data2, node_get_data3 } = selfhost::parser_core;

fn p_parse_decl_generics(close_message: *Str) : Vec => {
    let generics = vec_new();
    if (p_at(TK_SYMBOL, "<")) {
        p_eat();
        if (!p_at(TK_SYMBOL, ">")) {
            while (true) {
                generics.vec_push(p_parse_identifier());
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    p_parse_type();
                }
                if (!p_at(TK_SYMBOL, ",")) {
                    break;
                }
                p_eat();
            }
        }
        p_expect(TK_SYMBOL, ">", close_message);
    }
    generics
}

fn p_parse_function(is_class: I32, mode: I32) : I32 => {
    p_expect(TK_KEYWORD, "fn", "Expected 'fn'");
    let name = p_parse_identifier();
    
    // Generics
    let generics = p_parse_decl_generics("Expected '>'");
    
    // Parameters
    p_expect(TK_SYMBOL, "(", "Expected '('");
    let params = vec_new();
    if (!p_at(TK_SYMBOL, ")")) {
        let pname = p_parse_identifier();
        let ptype = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            ptype = p_parse_type();
        }
        let param = vec_new();
        param.vec_push(pname);
        param.vec_push(ptype);
        params.vec_push(param);
        while (p_at(TK_SYMBOL, ",")) {
            p_eat();
            let pname2 = p_parse_identifier();
            let ptype2 = 0;
            if (p_at(TK_SYMBOL, ":")) {
                p_eat();
                ptype2 = p_parse_type();
            }
            let param2 = vec_new();
            param2.vec_push(pname2);
            param2.vec_push(ptype2);
            params.vec_push(param2);
        }
    }
    p_expect(TK_SYMBOL, ")", "Expected ')'");
    
    // Return type
    let ret_type = 0;
    if (p_at(TK_SYMBOL, ":")) {
        p_eat();
        ret_type = p_parse_type();
    }
    
    let body = 0;
    if (mode == 1) {
        p_expect(TK_SYMBOL, ";", "Expected ';' after expect function declaration");
    } else {
        // Body
        p_expect(TK_SYMBOL, "=>", "Expected '=>'");
        body = if (p_at(TK_SYMBOL, "{")) { p_parse_block() } else { p_parse_expression(0) };
        
        // Semicolon for expression body
        if (node_kind(body) != NK_BLOCK) {
            if (!p_at(TK_SYMBOL, "}") && !p_at_kind(TK_EOF)) {
                p_expect(TK_SYMBOL, ";", "Expected ';'");
            }
        }
    }

    let kind = NK_FN_DECL;
    if (is_class == 1) {
        kind = NK_CLASS_FN_DECL;
    } else if (mode == 1) {
        kind = NK_EXPECT_FN_DECL;
    } else if (mode == 2) {
        kind = NK_ACTUAL_FN_DECL;
    }
    let node = node_new(kind);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, params);
    node_set_data4(node, ret_type);
    node_set_data5(node, body);
    node
}

fn p_parse_struct(is_copy: I32) : I32 => {
    p_expect(TK_KEYWORD, "struct", "Expected 'struct'");
    let name = p_parse_identifier();
    
    let generics = p_parse_decl_generics("Expected '>'");
    
    p_expect(TK_SYMBOL, "{", "Expected '{'");
    let fields = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        let fname = p_parse_identifier();
        p_expect(TK_SYMBOL, ":", "Expected ':'");
        let ftype = p_parse_type();
        let field = vec_new();
        field.vec_push(fname);
        field.vec_push(ftype);
        fields.vec_push(field);
        if (p_at(TK_SYMBOL, ",") || p_at(TK_SYMBOL, ";")) {
            p_eat();
        }
    }
    p_expect(TK_SYMBOL, "}", "Expected '}'");
    
    let node = node_new(NK_STRUCT_DECL);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, fields);
    node_set_data4(node, is_copy);
    node
}

fn p_parse_enum() : I32 => {
    p_expect(TK_KEYWORD, "enum", "Expected 'enum'");
    let name = p_parse_identifier();
    p_expect(TK_SYMBOL, "{", "Expected '{' after enum name");
    let variants = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        variants.vec_push(p_parse_identifier());
        if (p_at(TK_SYMBOL, ",") || p_at(TK_SYMBOL, ";")) {
            p_eat();
        }
    }
    p_expect(TK_SYMBOL, "}", "Expected '}' after enum body");
    let node = node_new(NK_ENUM_DECL);
    node_set_data1(node, name);
    node_set_data2(node, variants);
    node
}

fn p_parse_object() : I32 => {
    p_expect(TK_KEYWORD, "object", "Expected 'object'");
    let name = p_parse_identifier();

    let generics = p_parse_decl_generics("Expected '>'");

    p_expect(TK_SYMBOL, "{", "Expected '{' after object name");
    let inputs = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        p_expect(TK_KEYWORD, "in", "Expected 'in' in object input declaration");
        p_expect(TK_KEYWORD, "let", "Expected 'let' in object input declaration");
        let input_name = p_parse_identifier();
        p_expect(TK_SYMBOL, ":", "Expected ':' in object input declaration");
        let input_type = p_parse_type();
        p_expect(TK_SYMBOL, ";", "Expected ';' after object input declaration");

        let input_field = vec_new();
        input_field.vec_push(input_name);
        input_field.vec_push(input_type);
        inputs.vec_push(input_field);
    }
    p_expect(TK_SYMBOL, "}", "Expected '}' after object body");

    let node = node_new(NK_OBJECT_DECL);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, inputs);
    node
}

fn p_parse_contract() : I32 => {
    p_expect(TK_KEYWORD, "contract", "Expected 'contract'");
    let name = p_parse_identifier();
    p_expect(TK_SYMBOL, "{", "Expected '{' after contract name");

    let methods = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        p_expect(TK_KEYWORD, "fn", "Expected 'fn' in contract declaration");
        let mname = p_parse_identifier();
        let mgenerics = p_parse_decl_generics("Expected '>' after contract method generics");

        p_expect(TK_SYMBOL, "(", "Expected '(' in contract method signature");
        let params = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            while (true) {
                let pname = 0;
                let ptype = 0;
                let implicit_this = 0;

                if (p_at(TK_SYMBOL, "*")) {
                    p_eat();
                    if (p_at(TK_KEYWORD, "mut")) {
                        p_eat();
                    }
                    pname = p_parse_identifier();
                    ptype = 0;
                    implicit_this = 1;
                } else {
                    pname = p_parse_identifier();
                    if (p_at(TK_SYMBOL, ":")) {
                        p_eat();
                        ptype = p_parse_type();
                    }
                }

                let param = vec_new();
                param.vec_push(pname);
                param.vec_push(ptype);
                param.vec_push(implicit_this);
                params.vec_push(param);

                if (!p_at(TK_SYMBOL, ",")) {
                    break;
                }
                p_eat();
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')' after contract method params");

        let ret = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            ret = p_parse_type();
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after contract method signature");

        let method = vec_new();
        method.vec_push(mname);
        method.vec_push(mgenerics);
        method.vec_push(params);
        method.vec_push(ret);
        methods.vec_push(method);
    }

    p_expect(TK_SYMBOL, "}", "Expected '}' after contract body");
    let node = node_new(NK_CONTRACT_DECL);
    node_set_data1(node, name);
    node_set_data2(node, methods);
    node
}

fn p_parse_type_alias(is_copy: I32) : I32 => {
    p_expect(TK_KEYWORD, "type", "Expected 'type'");
    let name = p_parse_identifier();
    
    let generics = p_parse_decl_generics("Expected '>'");
    
    p_expect(TK_SYMBOL, "=", "Expected '='");
    let aliased = p_parse_type();
    let destructor_name = 0;
    if (p_at(TK_KEYWORD, "then")) {
        p_eat();
        destructor_name = p_parse_identifier();
    }
    p_expect(TK_SYMBOL, ";", "Expected ';'");
    
    let node = node_new(NK_TYPE_ALIAS);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, aliased);
    node_set_data4(node, is_copy);
    node_set_data5(node, destructor_name);
    node
}

fn p_parse_let() : I32 => {
    p_expect(TK_KEYWORD, "let", "Expected 'let'");
    
    // Destructuring import
    if (p_at(TK_SYMBOL, "{")) {
        p_eat();
        let names = vec_new();
        if (!p_at(TK_SYMBOL, "}")) {
            names.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                names.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, "}", "Expected '}'");
        p_expect(TK_SYMBOL, "=", "Expected '='");
        let parts = vec_new();
        parts.vec_push(p_parse_identifier());
        while (p_at(TK_SYMBOL, "::")) {
            p_eat();
            parts.vec_push(p_parse_identifier());
        }
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        let node = node_new(NK_IMPORT_DECL);
        node_set_data1(node, names);
        node_set_data2(node, parts);
        return node;
    }
    
    let name = p_parse_identifier();
    let vtype = 0;
    if (p_at(TK_SYMBOL, ":")) {
        p_eat();
        vtype = p_parse_type();
    }
    p_expect(TK_SYMBOL, "=", "Expected '='");
    let value = p_parse_expression(0);
    p_expect(TK_SYMBOL, ";", "Expected ';'");
    
    let node = node_new(NK_LET_DECL);
    node_set_data1(node, name);
    node_set_data2(node, vtype);
    node_set_data3(node, value);
    node
}

fn p_parse_for() : I32 => {
    p_expect(TK_KEYWORD, "for", "Expected 'for'");
    p_expect(TK_SYMBOL, "(", "Expected '('");
    let iter = p_parse_identifier();
    p_expect(TK_KEYWORD, "in", "Expected 'in'");
    let start = p_parse_expression(0);
    p_expect(TK_SYMBOL, "..", "Expected '..'");
    let end = p_parse_expression(0);
    p_expect(TK_SYMBOL, ")", "Expected ')'");
    let body = p_parse_block();
    
    let node = node_new(NK_FOR_STMT);
    node_set_data1(node, iter);
    node_set_data2(node, start);
    node_set_data3(node, end);
    node_set_data4(node, body);
    node
}

fn p_parse_lifetime() : I32 => {
    p_expect(TK_KEYWORD, "lifetime", "Expected 'lifetime'");
    let names = vec_new();
    names.vec_push(p_parse_identifier());
    while (p_at(TK_SYMBOL, ",")) {
        p_eat();
        names.vec_push(p_parse_identifier());
    }
    let body = p_parse_block();
    let node = node_new(NK_LIFETIME_STMT);
    node_set_data1(node, names);
    node_set_data2(node, body);
    node
}

// Parse extern fn/let/type declarations
fn p_parse_extern_decl() : I32 => {
    if (p_at(TK_KEYWORD, "fn")) {
        p_eat();
        let name = p_parse_identifier();
        
        // Generics
        let generics = p_parse_decl_generics("Expected '>'");
        
        // Parameters
        p_expect(TK_SYMBOL, "(", "Expected '('");
        let params = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            let pname = p_parse_identifier();
            let ptype = 0;
            if (p_at(TK_SYMBOL, ":")) {
                p_eat();
                ptype = p_parse_type();
            }
            let param = vec_new();
            param.vec_push(pname);
            param.vec_push(ptype);
            params.vec_push(param);
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                let pname2 = p_parse_identifier();
                let ptype2 = 0;
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    ptype2 = p_parse_type();
                }
                let param2 = vec_new();
                param2.vec_push(pname2);
                param2.vec_push(ptype2);
                params.vec_push(param2);
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')'");
        
        // Return type
        let ret_type = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            ret_type = p_parse_type();
        }
        
        // No body - just semicolon
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern fn");
        
        // Create a special node for extern fn
        let node = node_new(NK_EXTERN_FN_DECL);
        node_set_data1(node, name);
        node_set_data2(node, generics);
        node_set_data3(node, params);
        node_set_data4(node, ret_type);
        return node;
    }
    if (p_at(TK_KEYWORD, "let")) {
        p_eat();
        let name = p_parse_identifier();
        let typ = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            typ = p_parse_type();
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern let");
        let node = node_new(NK_EXTERN_LET_DECL);
        node_set_data1(node, name);
        node_set_data2(node, typ);
        return node;
    }
    if (p_at(TK_KEYWORD, "type")) {
        p_eat();
        let name = p_parse_identifier();
        let generics = p_parse_decl_generics("Expected '>' after extern type generics");
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern type");
        let node = node_new(NK_EXTERN_TYPE_DECL);
        node_set_data1(node, name);
        node_set_data2(node, generics);
        return node;
    }
    panic("Expected fn, let, or type after extern")
}

fn p_parse_statement() : I32 => {
    let exported = 0;
    let copy_decl = 0;
    let expect_decl = 0;
    let actual_decl = 0;
    let consumed_modifier = 0;
    while (
        p_at(TK_KEYWORD, "out") ||
        p_at(TK_KEYWORD, "copy") ||
        p_at(TK_KEYWORD, "expect") ||
        p_at(TK_IDENTIFIER, "expect") ||
        p_at(TK_KEYWORD, "actual") ||
        p_at(TK_IDENTIFIER, "actual")
    ) {
        consumed_modifier = 1;
        if (p_at(TK_KEYWORD, "out")) {
            p_eat();
            if (exported == 1) {
                panic("Duplicate 'out' modifier");
            }
            exported = 1;
        } else if (p_at(TK_KEYWORD, "copy")) {
            p_eat();
            if (copy_decl == 1) {
                panic("Duplicate 'copy' modifier");
            }
            copy_decl = 1;
        } else if (p_at(TK_KEYWORD, "expect") || p_at(TK_IDENTIFIER, "expect")) {
            p_eat();
            if (expect_decl == 1) {
                panic("Duplicate 'expect' modifier");
            }
            expect_decl = 1;
        } else if (p_at(TK_KEYWORD, "actual") || p_at(TK_IDENTIFIER, "actual")) {
            p_eat();
            if (actual_decl == 1) {
                panic("Duplicate 'actual' modifier");
            }
            actual_decl = 1;
        } else {
            panic("Unexpected declaration modifier");
        }
    }

    if (expect_decl == 1 && actual_decl == 1) {
        panic("Cannot combine 'expect' and 'actual' modifiers");
    }

    if (consumed_modifier == 1) {
        let out_node = 0;
        if (p_at(TK_KEYWORD, "struct")) {
            out_node = p_parse_struct(copy_decl);
        } else if (p_at(TK_KEYWORD, "enum")) {
            out_node = p_parse_enum();
        } else if (p_at(TK_KEYWORD, "object")) {
            if (copy_decl == 1) {
                panic("'copy' is only supported on struct/type declarations");
            }
            if (expect_decl == 1 || actual_decl == 1) {
                panic("'expect'/'actual' are currently supported only on fn declarations");
            }
            out_node = p_parse_object();
        } else if (p_at(TK_KEYWORD, "contract")) {
            if (copy_decl == 1) {
                panic("'copy' is only supported on struct/type declarations");
            }
            if (expect_decl == 1 || actual_decl == 1) {
                panic("'expect'/'actual' are currently supported only on fn declarations");
            }
            out_node = p_parse_contract();
        } else if (p_at(TK_KEYWORD, "type")) {
            out_node = p_parse_type_alias(copy_decl);
        } else if (p_at(TK_KEYWORD, "fn")) {
            if (copy_decl == 1) {
                panic("'copy' is only supported on struct/type declarations");
            }
            let mode = 0;
            if (expect_decl == 1) {
                mode = 1;
            } else if (actual_decl == 1) {
                mode = 2;
            }
            out_node = p_parse_function(0, mode);
        } else if (p_at(TK_KEYWORD, "class")) {
            if (copy_decl == 1) {
                panic("'copy' is only supported on struct/type declarations");
            }
            if (expect_decl == 1 || actual_decl == 1) {
                panic("'expect'/'actual' are currently supported only on fn declarations");
            }
            p_eat();
            out_node = p_parse_function(1, 0);
        } else {
            panic("Expected declaration after modifiers");
        }

        if (exported == 1) {
            parse_exports.set_add(get_interned_str(node_get_data1(out_node)));
        }
        return out_node;
    }

    if (p_at(TK_KEYWORD, "let")) { return p_parse_let(); }
    if (p_at(TK_KEYWORD, "struct")) { return p_parse_struct(0); }
    if (p_at(TK_KEYWORD, "enum")) { return p_parse_enum(); }
    if (p_at(TK_KEYWORD, "object")) { return p_parse_object(); }
    if (p_at(TK_KEYWORD, "contract")) { return p_parse_contract(); }
    if (p_at(TK_KEYWORD, "type")) { return p_parse_type_alias(0); }
    if (p_at(TK_KEYWORD, "fn")) { return p_parse_function(0, 0); }
    if (p_at(TK_KEYWORD, "extern")) {
        p_eat();
        // extern fn/let/type declaration
        return p_parse_extern_decl();
    }
    if (p_at(TK_KEYWORD, "class")) {
        p_eat();
        return p_parse_function(1, 0);
    }
    if (p_at(TK_KEYWORD, "return")) {
        p_eat();
        let value = 0;
        if (!p_at(TK_SYMBOL, ";")) {
            value = p_parse_expression(0);
        }
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        let node = node_new(NK_RETURN_STMT);
        node_set_data1(node, value);
        return node;
    }
    if (p_at(TK_KEYWORD, "if")) {
        let expr = p_parse_primary();
        if (node_get_data2(expr) != 0 && node_kind(node_get_data2(expr)) == NK_BLOCK) {
            let stmt = node_new(NK_IF_STMT);
            node_set_data1(stmt, node_get_data1(expr));
            node_set_data2(stmt, node_get_data2(expr));
            node_set_data3(stmt, node_get_data3(expr));
            return stmt;
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after if expression");
        let estmt = node_new(NK_EXPR_STMT);
        node_set_data1(estmt, expr);
        return estmt;
    }
    if (p_at(TK_KEYWORD, "while")) {
        p_eat();
        p_expect(TK_SYMBOL, "(", "Expected '('");
        let cond = p_parse_expression(0);
        p_expect(TK_SYMBOL, ")", "Expected ')'");
        let body = p_parse_block();
        let node = node_new(NK_WHILE_STMT);
        node_set_data1(node, cond);
        node_set_data2(node, body);
        return node;
    }
    if (p_at(TK_KEYWORD, "for")) { return p_parse_for(); }
    if (p_at(TK_KEYWORD, "loop")) {
        p_eat();
        let body = p_parse_block();
        let node = node_new(NK_LOOP_STMT);
        node_set_data1(node, body);
        return node;
    }
    if (p_at(TK_KEYWORD, "lifetime")) {
        return p_parse_lifetime();
    }
    if (p_at(TK_KEYWORD, "into")) {
        p_eat();
        let cname = p_parse_identifier();
        p_expect(TK_SYMBOL, ";", "Expected ';' after into statement");
        let node = node_new(NK_INTO_STMT);
        node_set_data1(node, cname);
        return node;
    }
    if (p_at(TK_KEYWORD, "break")) {
        p_eat();
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        return node_new(NK_BREAK_STMT);
    }
    if (p_at(TK_KEYWORD, "continue")) {
        p_eat();
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        return node_new(NK_CONTINUE_STMT);
    }
    if (p_at(TK_SYMBOL, "{")) { return p_parse_block(); }
    
    // Expression statement
    let expr = p_parse_expression(0);
    
    // Assignment
    if (p_at(TK_SYMBOL, "=")) {
        p_eat();
        let value = p_parse_expression(0);
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        let node = node_new(NK_ASSIGN_STMT);
        node_set_data1(node, expr);
        node_set_data2(node, value);
        return node;
    }
    
    if (p_at(TK_SYMBOL, ";")) {
        p_eat();
    } else if (!p_at(TK_SYMBOL, "}")) {
        p_expect(TK_SYMBOL, ";", "Expected ';'");
    }
    
    let node = node_new(NK_EXPR_STMT);
    node_set_data1(node, expr);
    node
}

out fn p_parse_program() : I32 => {
    let stmts = vec_new();
    while (!p_at_kind(TK_EOF)) {
        stmts.vec_push(p_parse_statement());
    }
    let node = node_new(NK_PROGRAM);
    node_set_data1(node, stmts);
    node
}

// ============================================================================
// Desugar - skip for now, minimal implementation
// ============================================================================

out fn desugar(program: I32) : I32 => program;

out fn selfhost_parser_decls_marker() : I32 => 0;
