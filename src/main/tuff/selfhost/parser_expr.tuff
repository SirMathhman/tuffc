let { p_at, p_eat, p_expect, p_parse_identifier, p_at_kind, p_peek, p_mark, p_restore, p_parse_pattern, p_parse_type, p_can_start_type_tok_at, p_error_with_token_context, node_kind, node_new, node_set_data1, node_set_data2, node_set_data3, node_set_data4, node_set_data5, node_get_data1, node_get_data2, node_get_data3 } = selfhost::parser_core;
let { tok_kind, tok_value, tok_line, tok_col, get_interned_str, vec_new } = selfhost::runtime_lexer;

fn p_has_generic_call_suffix() : Bool => {
    if (!p_at(TK_SYMBOL, "<")) {
        return false;
    }
    if (!p_can_start_type_tok_at(1)) {
        return false;
    }
    let cursor = 0;
    let depth = 0;
    while (true) {
        if (cursor > 200000) {
            p_error_with_token_context("Parser watchdog: generic-call suffix scan exceeded 200000 tokens");
        }
        let ti = p_peek(cursor);
        let tk = tok_kind(ti);
        if (tk == TK_EOF) {
            return false;
        }
        if (tk == TK_SYMBOL) {
            let sym = get_interned_str(tok_value(ti));
            if (sym.str_eq("<")) {
                depth = depth + 1;
            } else if (sym.str_eq(">")) {
                depth = depth - 1;
                if (depth == 0) {
                    let next = p_peek(cursor + 1);
                    if (tok_kind(next) == TK_SYMBOL) {
                        let next_sym = get_interned_str(tok_value(next));
                        return next_sym.str_eq("(");
                    }
                    return false;
                }
            }
        }
        cursor = cursor + 1;
    }
}

fn p_has_generic_struct_init_suffix() : Bool => {
    if (!p_at(TK_SYMBOL, "<")) {
        return false;
    }
    if (!p_can_start_type_tok_at(1)) {
        return false;
    }
    let cursor = 0;
    let depth = 0;
    while (true) {
        if (cursor > 200000) {
            p_error_with_token_context("Parser watchdog: generic-struct-init suffix scan exceeded 200000 tokens");
        }
        let ti = p_peek(cursor);
        let tk = tok_kind(ti);
        if (tk == TK_EOF) {
            return false;
        }
        if (tk == TK_SYMBOL) {
            let sym = get_interned_str(tok_value(ti));
            if (sym.str_eq("<")) {
                depth = depth + 1;
            } else if (sym.str_eq(">")) {
                depth = depth - 1;
                if (depth == 0) {
                    let next = p_peek(cursor + 1);
                    if (tok_kind(next) == TK_SYMBOL) {
                        let next_sym = get_interned_str(tok_value(next));
                        return next_sym.str_eq("{");
                    }
                    return false;
                }
            }
        }
        cursor = cursor + 1;
    }
}

fn p_has_generic_value_suffix() : Bool => {
    if (!p_at(TK_SYMBOL, "<")) {
        return false;
    }
    if (!p_can_start_type_tok_at(1)) {
        return false;
    }
    let cursor = 0;
    let depth = 0;
    while (true) {
        if (cursor > 200000) {
            p_error_with_token_context("Parser watchdog: generic-value suffix scan exceeded 200000 tokens");
        }
        let ti = p_peek(cursor);
        let tk = tok_kind(ti);
        if (tk == TK_EOF) {
            return false;
        }
        if (tk == TK_SYMBOL) {
            let sym = get_interned_str(tok_value(ti));
            if (sym.str_eq("<")) {
                depth = depth + 1;
            } else if (sym.str_eq(">")) {
                depth = depth - 1;
                if (depth == 0) {
                    let next = p_peek(cursor + 1);
                    if (tok_kind(next) == TK_SYMBOL) {
                        let next_sym = get_interned_str(tok_value(next));
                        if (next_sym.str_eq("(")) {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }
        cursor = cursor + 1;
    }
}

fn p_parse_generic_arg_value_or_type() : I32 => {
    let t0 = p_peek(0);
    if (tok_kind(t0) == TK_IDENTIFIER && tok_kind(p_peek(1)) == TK_SYMBOL) {
        let s1 = get_interned_str(tok_value(p_peek(1)));
        if (s1.str_eq(".")) {
            return p_parse_expression(5);
        }
    }

    let cursor = 0;
    let paren_depth = 0;
    let bracket_depth = 0;
    while (true) {
        if (cursor > 200000) {
            p_error_with_token_context("Parser watchdog: generic-arg scan exceeded 200000 tokens");
        }
        let ti = p_peek(cursor);
        let tk = tok_kind(ti);
        if (tk == TK_EOF) {
            break;
        }
        if (tk == TK_SYMBOL) {
            let sym = get_interned_str(tok_value(ti));
            if (sym.str_eq("(")) {
                paren_depth = paren_depth + 1;
            } else if (sym.str_eq(")")) {
                if (paren_depth > 0) { paren_depth = paren_depth - 1; }
            } else if (sym.str_eq("[")) {
                bracket_depth = bracket_depth + 1;
            } else if (sym.str_eq("]")) {
                if (bracket_depth > 0) { bracket_depth = bracket_depth - 1; }
            } else if (paren_depth == 0 && bracket_depth == 0 && (sym.str_eq(",") || sym.str_eq(">"))) {
                break;
            } else if (
                paren_depth == 0 &&
                bracket_depth == 0 &&
                (
                    (cursor > 0 && sym.str_eq(".")) ||
                    (cursor > 0 && sym.str_eq("+")) ||
                    (cursor > 0 && sym.str_eq("-")) ||
                    (cursor > 0 && sym.str_eq("*")) ||
                    (cursor > 0 && sym.str_eq("/")) ||
                    (cursor > 0 && sym.str_eq("%"))
                )
            ) {
                return p_parse_expression(5);
            }
        }
        cursor = cursor + 1;
    }
    p_parse_type()
}

fn p_parse_postfix(exprIn: I32) : I32 => {
    let expr = exprIn;
    let postfix_watchdog = 0;
    while (true) {
        postfix_watchdog = postfix_watchdog + 1;
        if (postfix_watchdog > 10000) {
            p_error_with_token_context("Parser watchdog: postfix loop exceeded 10000 iterations");
        }
        if (node_kind(expr) == NK_MEMBER_EXPR && get_interned_str(node_get_data2(expr)).str_eq("into") && p_at(TK_SYMBOL, "<") && p_has_generic_value_suffix()) {
            p_eat();
            let type_args = vec_new();
            if (!p_at(TK_SYMBOL, ">")) {
                type_args.vec_push(p_parse_generic_arg_value_or_type());
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    type_args.vec_push(p_parse_generic_arg_value_or_type());
                }
            }
            p_expect(TK_SYMBOL, ">", "Expected '>' after into type args");

            let recv = node_get_data1(expr);
            let prop = node_get_data2(expr);
            let args = vec_new();
            args.vec_push(recv);
            let callee = node_new(NK_IDENTIFIER);
            node_set_data1(callee, prop);

            let into_value = node_new(NK_CALL_EXPR);
            node_set_data1(into_value, callee);
            node_set_data2(into_value, args);
            node_set_data3(into_value, 1);
            node_set_data4(into_value, type_args);
            node_set_data5(into_value, 1);
            expr = into_value;
            continue;
        }

        if (p_at(TK_SYMBOL, "<") && p_has_generic_call_suffix()) {
            p_eat();
            let type_args = vec_new();
            if (!p_at(TK_SYMBOL, ">")) {
                type_args.vec_push(p_parse_generic_arg_value_or_type());
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    type_args.vec_push(p_parse_generic_arg_value_or_type());
                }
            }
            p_expect(TK_SYMBOL, ">", "Expected '>' after generic call type args");
            p_expect(TK_SYMBOL, "(", "Expected '(' after generic call type args");

            let args = vec_new();
            if (!p_at(TK_SYMBOL, ")")) {
                args.vec_push(p_parse_expression(0));
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    args.vec_push(p_parse_expression(0));
                }
            }
            p_expect(TK_SYMBOL, ")", "Expected ')' after call args");

            if (node_kind(expr) == NK_MEMBER_EXPR) {
                // Receiver-call sugar: value.method<T>(a, b) => method<T>(value, a, b)
                let recv = node_get_data1(expr);
                let prop = node_get_data2(expr);
                let lowered_args = vec_new();
                lowered_args.vec_push(recv);
                let ai = 0;
                let alen = args.vec_length();
                while (ai < alen) {
                    lowered_args.vec_push(args.vec_get(ai));
                    ai = ai + 1;
                }
                let callee = node_new(NK_IDENTIFIER);
                node_set_data1(callee, prop);
                let call = node_new(NK_CALL_EXPR);
                node_set_data1(call, callee);
                node_set_data2(call, lowered_args);
                node_set_data3(call, 1);
                node_set_data4(call, type_args);
                expr = call;
            } else {
                let call = node_new(NK_CALL_EXPR);
                node_set_data1(call, expr);
                node_set_data2(call, args);
                node_set_data3(call, 0);
                node_set_data4(call, type_args);
                expr = call;
            }
            continue;
        }

        if (p_at(TK_SYMBOL, "(")) {
            p_eat();
            let args = vec_new();
            if (!p_at(TK_SYMBOL, ")")) {
                args.vec_push(p_parse_expression(0));
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    args.vec_push(p_parse_expression(0));
                }
            }
            p_expect(TK_SYMBOL, ")", "Expected ')'");

            if (node_kind(expr) == NK_MEMBER_EXPR) {
                // Receiver-call sugar: value.method(a, b) => method(value, a, b)
                let recv = node_get_data1(expr);
                let prop = node_get_data2(expr);
                let lowered_args = vec_new();
                lowered_args.vec_push(recv);
                let ai = 0;
                let alen = args.vec_length();
                while (ai < alen) {
                    lowered_args.vec_push(args.vec_get(ai));
                    ai = ai + 1;
                }
                let callee = node_new(NK_IDENTIFIER);
                node_set_data1(callee, prop);
                let call = node_new(NK_CALL_EXPR);
                node_set_data1(call, callee);
                node_set_data2(call, lowered_args);
                node_set_data3(call, 1);
                expr = call;
            } else {
                let call = node_new(NK_CALL_EXPR);
                node_set_data1(call, expr);
                node_set_data2(call, args);
                node_set_data3(call, 0);
                expr = call;
            }
            continue;
        }
        if (p_at(TK_SYMBOL, ".")) {
            p_eat();
            let prop = 0;
            if (p_at_kind(TK_IDENTIFIER)) {
                prop = p_parse_identifier();
            } else if (p_at_kind(TK_KEYWORD)) {
                prop = tok_value(p_eat());
            } else {
                p_error_with_token_context("Expected member name after '.'");
            }
            let member = node_new(NK_MEMBER_EXPR);
            node_set_data1(member, expr);
            node_set_data2(member, prop);
            expr = member;
            continue;
        }
        if (p_at(TK_SYMBOL, "[")) {
            p_eat();
            let idx_expr = p_parse_expression(0);
            p_expect(TK_SYMBOL, "]", "Expected ']'");
            let idx_node = node_new(NK_INDEX_EXPR);
            node_set_data1(idx_node, expr);
            node_set_data2(idx_node, idx_expr);
            expr = idx_node;
            continue;
        }
        if (p_at(TK_SYMBOL, "?")) {
            p_eat();
            let unwrap = node_new(NK_UNWRAP_EXPR);
            node_set_data1(unwrap, expr);
            expr = unwrap;
            continue;
        }
        break;
    }
    expr
}

fn p_parse_primary() : I32 => {
    // Array literal: [expr, expr, ...]
    if (p_at(TK_SYMBOL, "[")) {
        p_eat();
        let items = vec_new();
        if (!p_at(TK_SYMBOL, "]")) {
            items.vec_push(p_parse_expression(0));
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                if (p_at(TK_SYMBOL, "]")) { break; }
                items.vec_push(p_parse_expression(0));
            }
        }
        p_expect(TK_SYMBOL, "]", "Expected ']' in array literal");
        let node = node_new(NK_TUPLE_EXPR);
        node_set_data1(node, items);
        return p_parse_postfix(node);
    }

    // Number
    if (p_at_kind(TK_NUMBER)) {
        let t = p_eat();
        let node = node_new(NK_NUMBER_LIT);
        node_set_data1(node, tok_value(t));
        return p_parse_postfix(node);
    }
    
    // Bool
    if (p_at_kind(TK_BOOL)) {
        let t = p_eat();
        let node = node_new(NK_BOOL_LIT);
        node_set_data1(node, tok_value(t));
        return p_parse_postfix(node);
    }
    
    // String
    if (p_at_kind(TK_STRING)) {
        let t = p_eat();
        let node = node_new(NK_STRING_LIT);
        node_set_data1(node, tok_value(t));
        return p_parse_postfix(node);
    }
    
    // Char
    if (p_at_kind(TK_CHAR)) {
        let t = p_eat();
        let node = node_new(NK_CHAR_LIT);
        node_set_data1(node, tok_value(t));
        return p_parse_postfix(node);
    }
    
    // Lambda expression: (x : T) => body  /  () => body
    if (p_at(TK_SYMBOL, "(")) {
        let mark = p_mark();
        p_eat();
        let params = vec_new();
        let valid = true;
        if (!p_at(TK_SYMBOL, ")")) {
            while (true) {
                if (!p_at_kind(TK_IDENTIFIER)) {
                    valid = false;
                    break;
                }
                let pname = p_parse_identifier();
                let ptype = 0;
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    ptype = p_parse_type();
                }
                let param = vec_new();
                param.vec_push(pname);
                param.vec_push(ptype);
                params.vec_push(param);
                if (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    continue;
                }
                break;
            }
        }
        if (valid && p_at(TK_SYMBOL, ")")) {
            p_eat();
            if (p_at(TK_SYMBOL, "=>")) {
                p_eat();
                let body = 0;
                if (p_at(TK_SYMBOL, "{")) {
                    body = p_parse_block();
                } else {
                    body = p_parse_expression(0);
                }
                let lam = node_new(NK_LAMBDA_EXPR);
                node_set_data1(lam, params);
                node_set_data2(lam, body);
                return p_parse_postfix(lam);
            }
        }
        p_restore(mark);
    }

    // Function expression: fn [name] (...) [: T] => body
    if (p_at(TK_KEYWORD, "fn")) {
        p_eat();
        let fname = 0;
        if (p_at_kind(TK_IDENTIFIER)) {
            fname = p_parse_identifier();
        }

        let generics = vec_new();
        if (p_at(TK_SYMBOL, "<")) {
            p_eat();
            if (!p_at(TK_SYMBOL, ">")) {
                while (true) {
                    generics.vec_push(p_parse_identifier());
                    if (p_at(TK_SYMBOL, ":")) {
                        p_eat();
                        p_parse_type();
                    }
                    if (!p_at(TK_SYMBOL, ",")) {
                        break;
                    }
                    p_eat();
                }
            }
            p_expect(TK_SYMBOL, ">", "Expected '>'");
        }

        p_expect(TK_SYMBOL, "(", "Expected '(' in function expression");
        let params = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            while (true) {
                let pname = p_parse_identifier();
                let ptype = 0;
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    ptype = p_parse_type();
                }
                let param = vec_new();
                param.vec_push(pname);
                param.vec_push(ptype);
                params.vec_push(param);
                if (!p_at(TK_SYMBOL, ",")) {
                    break;
                }
                p_eat();
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')' after params");

        let ret = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            ret = p_parse_type();
        }

        p_expect(TK_SYMBOL, "=>", "Expected '=>' in function expression");
        let body = 0;
        if (p_at(TK_SYMBOL, "{")) {
            body = p_parse_block();
        } else {
            body = p_parse_expression(0);
        }

        let fnexpr = node_new(NK_FN_EXPR);
        node_set_data1(fnexpr, fname);
        node_set_data2(fnexpr, generics);
        node_set_data3(fnexpr, params);
        node_set_data4(fnexpr, ret);
        node_set_data5(fnexpr, body);
        return p_parse_postfix(fnexpr);
    }

    // Lambda shorthand: x => body
    if (p_at_kind(TK_IDENTIFIER) && tok_kind(p_peek(1)) == TK_SYMBOL && get_interned_str(tok_value(p_peek(1))).str_eq("=>")) {
        let pname = p_parse_identifier();
        p_expect(TK_SYMBOL, "=>", "Expected '=>' in lambda expression");
        let param = vec_new();
        param.vec_push(pname);
        param.vec_push(0);
        let params = vec_new();
        params.vec_push(param);
        let body = 0;
        if (p_at(TK_SYMBOL, "{")) {
            body = p_parse_block();
        } else {
            body = p_parse_expression(0);
        }
        let lam = node_new(NK_LAMBDA_EXPR);
        node_set_data1(lam, params);
        node_set_data2(lam, body);
        return p_parse_postfix(lam);
    }

    // Parenthesized expression
    if (p_at(TK_SYMBOL, "(")) {
        p_eat();
        let first = p_parse_expression(0);
        if (p_at(TK_SYMBOL, ",")) {
            let items = vec_new();
            items.vec_push(first);
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                items.vec_push(p_parse_expression(0));
            }
            p_expect(TK_SYMBOL, ")", "Expected ')' after tuple expression");
            let tuple = node_new(NK_TUPLE_EXPR);
            node_set_data1(tuple, items);
            return p_parse_postfix(tuple);
        }
        p_expect(TK_SYMBOL, ")", "Expected ')'");
        return p_parse_postfix(first);
    }
    
    // If expression
    if (p_at(TK_KEYWORD, "if")) {
        p_eat();
        p_expect(TK_SYMBOL, "(", "Expected '(' after if");
        let cond = p_parse_expression(0);
        p_expect(TK_SYMBOL, ")", "Expected ')' after condition");
        let then_branch = 0;
        if (p_at(TK_SYMBOL, "{")) {
            then_branch = p_parse_block();
        } else {
            then_branch = p_parse_expression(0);
        }
        let else_branch = 0;
        if (p_at(TK_KEYWORD, "else")) {
            p_eat();
            if (p_at(TK_SYMBOL, "{")) {
                else_branch = p_parse_block();
            } else {
                else_branch = p_parse_expression(0);
            }
        }
        let node = node_new(NK_IF_EXPR);
        node_set_data1(node, cond);
        node_set_data2(node, then_branch);
        node_set_data3(node, else_branch);
        return p_parse_postfix(node);
    }
    
    // Match expression
    if (p_at(TK_KEYWORD, "match")) {
        p_eat();
        p_expect(TK_SYMBOL, "(", "Expected '(' after match");
        let target = p_parse_expression(0);
        p_expect(TK_SYMBOL, ")", "Expected ')' after match target");
        p_expect(TK_SYMBOL, "{", "Expected '{'");
        let cases = vec_new();
        while (!p_at(TK_SYMBOL, "}")) {
            p_expect(TK_KEYWORD, "case", "Expected 'case'");
            let pat = p_parse_pattern();
            p_expect(TK_SYMBOL, "=", "Expected '='");
            let body = 0;
            if (p_at(TK_SYMBOL, "{")) {
                body = p_parse_block();
            } else {
                body = p_parse_expression(0);
            }
            p_expect(TK_SYMBOL, ";", "Expected ';' after case");
            let case_node = vec_new();
            case_node.vec_push(pat);
            case_node.vec_push(body);
            cases.vec_push(case_node);
        }
        p_expect(TK_SYMBOL, "}", "Expected '}'");
        let node = node_new(NK_MATCH_EXPR);
        node_set_data1(node, target);
        node_set_data2(node, cases);
        return node;
    }
    
    // Identifier (possibly struct init or call)
    if (p_at_kind(TK_IDENTIFIER)) {
        let name = p_parse_identifier();
        let expr = node_new(NK_IDENTIFIER);
        node_set_data1(expr, name);

        let generic_args = vec_new();
        let is_type_like = false;
        let name_text = get_interned_str(name);
        if (name_text.str_length() > 0) {
            let c0 = name_text.str_char_at(0);
            if (c0 >= 65 && c0 <= 90) {
                is_type_like = true;
            }
        }
        if (is_type_like && p_at(TK_SYMBOL, "<") && (p_has_generic_struct_init_suffix() || p_has_generic_value_suffix())) {
            p_eat();
            if (!p_at(TK_SYMBOL, ">")) {
                generic_args.vec_push(p_parse_generic_arg_value_or_type());
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    generic_args.vec_push(p_parse_generic_arg_value_or_type());
                }
            }
            p_expect(TK_SYMBOL, ">", "Expected '>' in generic struct initializer");
            node_set_data2(expr, generic_args);
        }
        
        // Struct init
        if (p_at(TK_SYMBOL, "{")) {
            p_eat();
            let fields = vec_new();
            if (!p_at(TK_SYMBOL, "}")) {
                let key = p_parse_identifier();
                p_expect(TK_SYMBOL, ":", "Expected ':' in struct init");
                let val = p_parse_expression(0);
                let field = vec_new();
                field.vec_push(key);
                field.vec_push(val);
                fields.vec_push(field);
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    let key2 = p_parse_identifier();
                    p_expect(TK_SYMBOL, ":", "Expected ':'");
                    let val2 = p_parse_expression(0);
                    let field2 = vec_new();
                    field2.vec_push(key2);
                    field2.vec_push(val2);
                    fields.vec_push(field2);
                }
            }
            p_expect(TK_SYMBOL, "}", "Expected '}'");
            let init_node = node_new(NK_STRUCT_INIT);
            node_set_data1(init_node, name);
            node_set_data2(init_node, fields);
            node_set_data3(init_node, generic_args);
            expr = init_node;
        }
        
        return p_parse_postfix(expr);
    }
    
    p_error_with_token_context("Unexpected token in expression");
    0
}

fn p_parse_unary() : I32 => {
    if (p_at(TK_SYMBOL, "!") || p_at(TK_SYMBOL, "-") || p_at(TK_SYMBOL, "&")) {
        let t = p_eat();
        let op = tok_value(t);
        if (get_interned_str(op).str_eq("&") && p_at(TK_KEYWORD, "mut")) {
            p_eat();
            op = intern("&mut");
        }
        let inner = p_parse_unary();
        let node = node_new(NK_UNARY_EXPR);
        node_set_data1(node, op);
        node_set_data2(node, inner);
        return node;
    }
    p_parse_primary()
}

fn p_get_precedence(op: I32) : I32 => {
    // Map operator to precedence
    // We use intern indices, so we need to check against known values
    if (intern_map.map_has("||") && op == intern_map.map_get("||")) { return 1; }
    if (intern_map.map_has("&&") && op == intern_map.map_get("&&")) { return 2; }
    if (intern_map.map_has("==") && op == intern_map.map_get("==")) { return 3; }
    if (intern_map.map_has("!=") && op == intern_map.map_get("!=")) { return 3; }
    if (intern_map.map_has("<") && op == intern_map.map_get("<")) { return 4; }
    if (intern_map.map_has("<=") && op == intern_map.map_get("<=")) { return 4; }
    if (intern_map.map_has(">") && op == intern_map.map_get(">")) { return 4; }
    if (intern_map.map_has(">=") && op == intern_map.map_get(">=")) { return 4; }
    if (intern_map.map_has("..") && op == intern_map.map_get("..")) { return 4; }
    if (intern_map.map_has("+") && op == intern_map.map_get("+")) { return 5; }
    if (intern_map.map_has("-") && op == intern_map.map_get("-")) { return 5; }
    if (intern_map.map_has("*") && op == intern_map.map_get("*")) { return 6; }
    if (intern_map.map_has("/") && op == intern_map.map_get("/")) { return 6; }
    if (intern_map.map_has("%") && op == intern_map.map_get("%")) { return 6; }
    0
}

fn p_is_binary_op() : Bool => {
    if (p_at(TK_SYMBOL, "+")) { return true; }
    if (p_at(TK_SYMBOL, "-")) { return true; }
    if (p_at(TK_SYMBOL, "*")) { return true; }
    if (p_at(TK_SYMBOL, "/")) { return true; }
    if (p_at(TK_SYMBOL, "%")) { return true; }
    if (p_at(TK_SYMBOL, "==")) { return true; }
    if (p_at(TK_SYMBOL, "!=")) { return true; }
    if (p_at(TK_SYMBOL, "<")) { return true; }
    if (p_at(TK_SYMBOL, "<=")) { return true; }
    if (p_at(TK_SYMBOL, ">")) { return true; }
    if (p_at(TK_SYMBOL, ">=")) { return true; }
    if (p_at(TK_SYMBOL, "..")) { return true; }
    if (p_at(TK_SYMBOL, "&&")) { return true; }
    if (p_at(TK_SYMBOL, "||")) { return true; }
    if (p_at(TK_KEYWORD, "is")) { return true; }
    if (p_at(TK_KEYWORD, "into")) { return true; }
    false
}

fn p_parse_expression(minPrec: I32) : I32 => {
    let left = p_parse_unary();
    let watchdog = 0;
    
    while (p_is_binary_op()) {
        watchdog = watchdog + 1;
        if (watchdog > 200000) {
            p_error_with_token_context("Parser watchdog: binary-expression loop exceeded 200000 iterations");
        }
        if (minPrec <= 0 && p_at(TK_KEYWORD, "into")) {
            p_eat();
            let contract_name = p_parse_identifier();

            let type_args = vec_new();
            let contract_type = node_new(NK_NAMED_TYPE);
            node_set_data1(contract_type, contract_name);
            node_set_data2(contract_type, vec_new());
            type_args.vec_push(contract_type);

            let args = vec_new();
            args.vec_push(left);
            if (p_at(TK_SYMBOL, "(")) {
                p_eat();
                if (!p_at(TK_SYMBOL, ")")) {
                    args.vec_push(p_parse_expression(0));
                    while (p_at(TK_SYMBOL, ",")) {
                        p_eat();
                        args.vec_push(p_parse_expression(0));
                    }
                }
                p_expect(TK_SYMBOL, ")", "Expected ')' after into arguments");
            }

            let call = node_new(NK_CALL_EXPR);
            let callee = node_new(NK_IDENTIFIER);
            node_set_data1(callee, intern("into"));
            node_set_data1(call, callee);
            node_set_data2(call, args);
            node_set_data3(call, 1);
            node_set_data4(call, type_args);
            left = call;
            continue;
        }

        let op = tok_value(p_peek(0));
        let prec = p_get_precedence(op);
        
        // Handle 'is' keyword specially
        if (p_at(TK_KEYWORD, "is")) {
            p_eat();
            let pat = p_parse_pattern();
            let is_node = node_new(NK_IS_EXPR);
            node_set_data1(is_node, left);
            node_set_data2(is_node, pat);
            left = is_node;
            continue;
        }
        
        if (prec < minPrec) {
            break;
        }

        // Don't consume op= sequences (+=, -=, etc.) as binary operators;
        // statement parser handles them as compound assignments.
        if (
            (intern_map.map_has("+") && op == intern_map.map_get("+")) ||
            (intern_map.map_has("-") && op == intern_map.map_get("-")) ||
            (intern_map.map_has("*") && op == intern_map.map_get("*")) ||
            (intern_map.map_has("/") && op == intern_map.map_get("/")) ||
            (intern_map.map_has("%") && op == intern_map.map_get("%")) ||
            (intern_map.map_has("&") && op == intern_map.map_get("&")) ||
            (intern_map.map_has("|") && op == intern_map.map_get("|")) ||
            (intern_map.map_has("^") && op == intern_map.map_get("^"))
        ) {
            let next = p_peek(1);
            if (tok_kind(next) == TK_SYMBOL && get_interned_str(tok_value(next)).str_eq("=")) {
                break;
            }
        }
        
        p_eat();
        let right = p_parse_expression(prec + 1);
        let bin = node_new(NK_BINARY_EXPR);
        node_set_data1(bin, op);
        node_set_data2(bin, left);
        node_set_data3(bin, right);
        left = bin;
    }
    
    left
}

fn p_parse_block() : I32 => {
    p_expect(TK_SYMBOL, "{", "Expected '{'");
    let stmts = vec_new();
    while (!p_at(TK_SYMBOL, "}") && !p_at_kind(TK_EOF)) {
        let before = p_mark();
        let stmt = p_parse_statement();
        let after = p_mark();
        if (after == before) {
            p_error_with_token_context("Parser made no progress while parsing block statement");
        }
        if (node_kind(stmt) == NK_STMT_LIST) {
            let inner = node_get_data1(stmt);
            let i = 0;
            while (i < inner.vec_length()) {
                stmts.vec_push(inner.vec_get(i));
                i = i + 1;
            }
        } else {
            stmts.vec_push(stmt);
        }
    }
    p_expect(TK_SYMBOL, "}", "Expected '}'");
    let node = node_new(NK_BLOCK);
    node_set_data1(node, stmts);
    node
}

out fn selfhost_parser_expr_marker() : I32 => 0;
