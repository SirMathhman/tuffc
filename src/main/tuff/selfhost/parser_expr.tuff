let { p_at, p_eat, p_expect, p_parse_identifier, p_at_kind, p_peek, p_mark, p_parse_pattern, p_error_with_token_context, node_kind, node_new, node_set_data1, node_set_data2, node_set_data3, node_set_data4, node_get_data1 } = selfhost::parser_core;
let { tok_kind, tok_value, tok_line, tok_col, get_interned_str, vec_new } = selfhost::runtime_lexer;
let { p_parse_primary } = selfhost::parser_expr_primary;

fn p_parse_unary() : I32 => {
    if (p_at(TK_SYMBOL, "!") || p_at(TK_SYMBOL, "-") || p_at(TK_SYMBOL, "&")) {
        let t = p_eat();
        let op = tok_value(t);
        if (get_interned_str(op).str_eq("&") && p_at(TK_KEYWORD, "mut")) {
            p_eat();
            op = intern("&mut");
        }
        let inner = p_parse_unary();
        let node = node_new(NK_UNARY_EXPR);
        node_set_data1(node, op);
        node_set_data2(node, inner);
        return node;
    }
    p_parse_primary()
}

fn p_get_precedence(op: I32) : I32 => {
    // Map operator to precedence
    // We use intern indices, so we need to check against known values
    if (intern_map.map_has("||") && op == intern_map.map_get("||")) { return 1; }
    if (intern_map.map_has("&&") && op == intern_map.map_get("&&")) { return 2; }
    if (intern_map.map_has("==") && op == intern_map.map_get("==")) { return 3; }
    if (intern_map.map_has("!=") && op == intern_map.map_get("!=")) { return 3; }
    if (intern_map.map_has("<") && op == intern_map.map_get("<")) { return 4; }
    if (intern_map.map_has("<=") && op == intern_map.map_get("<=")) { return 4; }
    if (intern_map.map_has(">") && op == intern_map.map_get(">")) { return 4; }
    if (intern_map.map_has(">=") && op == intern_map.map_get(">=")) { return 4; }
    if (intern_map.map_has("..") && op == intern_map.map_get("..")) { return 4; }
    if (intern_map.map_has("+") && op == intern_map.map_get("+")) { return 5; }
    if (intern_map.map_has("-") && op == intern_map.map_get("-")) { return 5; }
    if (intern_map.map_has("*") && op == intern_map.map_get("*")) { return 6; }
    if (intern_map.map_has("/") && op == intern_map.map_get("/")) { return 6; }
    if (intern_map.map_has("%") && op == intern_map.map_get("%")) { return 6; }
    0
}

fn p_is_binary_op() : Bool => {
    if (p_at(TK_SYMBOL, "+")) { return true; }
    if (p_at(TK_SYMBOL, "-")) { return true; }
    if (p_at(TK_SYMBOL, "*")) { return true; }
    if (p_at(TK_SYMBOL, "/")) { return true; }
    if (p_at(TK_SYMBOL, "%")) { return true; }
    if (p_at(TK_SYMBOL, "==")) { return true; }
    if (p_at(TK_SYMBOL, "!=")) { return true; }
    if (p_at(TK_SYMBOL, "<")) { return true; }
    if (p_at(TK_SYMBOL, "<=")) { return true; }
    if (p_at(TK_SYMBOL, ">")) { return true; }
    if (p_at(TK_SYMBOL, ">=")) { return true; }
    if (p_at(TK_SYMBOL, "..")) { return true; }
    if (p_at(TK_SYMBOL, "&&")) { return true; }
    if (p_at(TK_SYMBOL, "||")) { return true; }
    if (p_at(TK_KEYWORD, "is")) { return true; }
    if (p_at(TK_KEYWORD, "into")) { return true; }
    false
}

fn p_parse_expression(minPrec: I32) : I32 => {
    let left = p_parse_unary();
    let watchdog = 0;
    
    while (p_is_binary_op()) {
        watchdog = watchdog + 1;
        if (watchdog > 200000) {
            p_error_with_token_context("Parser watchdog: binary-expression loop exceeded 200000 iterations");
        }
        if (minPrec <= 0 && p_at(TK_KEYWORD, "into")) {
            p_eat();
            let contract_name = p_parse_identifier();

            let type_args = vec_new();
            let contract_type = node_new(NK_NAMED_TYPE);
            node_set_data1(contract_type, contract_name);
            node_set_data2(contract_type, vec_new());
            type_args.vec_push(contract_type);

            let args = vec_new();
            args.vec_push(left);
            if (p_at(TK_SYMBOL, "(")) {
                p_eat();
                if (!p_at(TK_SYMBOL, ")")) {
                    args.vec_push(p_parse_expression(0));
                    while (p_at(TK_SYMBOL, ",")) {
                        p_eat();
                        args.vec_push(p_parse_expression(0));
                    }
                }
                p_expect(TK_SYMBOL, ")", "Expected ')' after into arguments");
            }

            let call = node_new(NK_CALL_EXPR);
            let callee = node_new(NK_IDENTIFIER);
            node_set_data1(callee, intern("into"));
            node_set_data1(call, callee);
            node_set_data2(call, args);
            node_set_data3(call, 1);
            node_set_data4(call, type_args);
            left = call;
            continue;
        }

        let op = tok_value(p_peek(0));
        let prec = p_get_precedence(op);
        
        // Handle 'is' keyword specially
        if (p_at(TK_KEYWORD, "is")) {
            p_eat();
            let pat = p_parse_pattern();
            let is_node = node_new(NK_IS_EXPR);
            node_set_data1(is_node, left);
            node_set_data2(is_node, pat);
            left = is_node;
            continue;
        }
        
        if (prec < minPrec) {
            break;
        }

        // Don't consume op= sequences (+=, -=, etc.) as binary operators;
        // statement parser handles them as compound assignments.
        if (
            (intern_map.map_has("+") && op == intern_map.map_get("+")) ||
            (intern_map.map_has("-") && op == intern_map.map_get("-")) ||
            (intern_map.map_has("*") && op == intern_map.map_get("*")) ||
            (intern_map.map_has("/") && op == intern_map.map_get("/")) ||
            (intern_map.map_has("%") && op == intern_map.map_get("%")) ||
            (intern_map.map_has("&") && op == intern_map.map_get("&")) ||
            (intern_map.map_has("|") && op == intern_map.map_get("|")) ||
            (intern_map.map_has("^") && op == intern_map.map_get("^"))
        ) {
            let next = p_peek(1);
            if (tok_kind(next) == TK_SYMBOL && get_interned_str(tok_value(next)).str_eq("=")) {
                break;
            }
        }
        
        p_eat();
        let right = p_parse_expression(prec + 1);
        let bin = node_new(NK_BINARY_EXPR);
        node_set_data1(bin, op);
        node_set_data2(bin, left);
        node_set_data3(bin, right);
        left = bin;
    }
    
    left
}

fn p_parse_block() : I32 => {
    p_expect(TK_SYMBOL, "{", "Expected '{'");
    let stmts = vec_new();
    while (!p_at(TK_SYMBOL, "}") && !p_at_kind(TK_EOF)) {
        let before = p_mark();
        let stmt = p_parse_statement();
        let after = p_mark();
        if (after == before) {
            p_error_with_token_context("Parser made no progress while parsing block statement");
        }
        if (node_kind(stmt) == NK_STMT_LIST) {
            let inner = node_get_data1(stmt);
            let i = 0;
            while (i < inner.vec_length()) {
                stmts.vec_push(inner.vec_get(i));
                i = i + 1;
            }
        } else {
            stmts.vec_push(stmt);
        }
    }
    p_expect(TK_SYMBOL, "}", "Expected '}'");
    let node = node_new(NK_BLOCK);
    node_set_data1(node, stmts);
    node
}

out fn selfhost_parser_expr_marker() : I32 => 0;
