let {
    getInternedStr, strIncludes
}
 = selfhost::runtimeLexer;
out fn moduleLoaderSanitizeMaxEffectiveLines(maxEffectiveLines: I32) : I32 => {
    if (maxEffectiveLines <= 0) {
        500
    }
    else {
        maxEffectiveLines
    }
}
out fn moduleLoaderNormalizeFlag(value: I32) : I32 => {
    if (value = = 0) {
        0
    }
    else {
        1
    }
}
out fn modulePartsToRelativePath(parts: Vec<I32>) : *Str => {
    let sb = sbNew();
    let i = 0;
    let len = parts.vecLength();
    while (i < len) {
        if (i > 0) {
            sbAppend(sb, "/");
        }
        sbAppend(sb, getInternedStr(parts.vecGet(i)));
        i = i + 1;
    }
    sbAppend(sb, ".tuff");
    sbBuild(sb)
}
out fn moduleNormalizePath(p: *Str) : *Str => {
    p.strReplaceAll("\\", "/")
}
out fn joinSources(sources: Vec<*Str>) : *Str => {
    let sb = sbNew();
    let i = 0;
    let len = sources.vecLength();
    while (i < len) {
        if (i > 0) {
            sbAppend(sb, "\n\n");
        }
        sbAppend(sb, sources.vecGet(i));
        i = i + 1;
    }
    sbBuild(sb)
}
out fn moduleWithCRuntimePrelude(source: *Str, target: *Str) : *Str => {
    if (!target.strEq("c") && !target.strEq("c-split")) {
        return source;
    }
    if (source.strIncludes("fn tuff_runtime_panic(")) {
        return source;
    }
    let prelude = __host_get_c_runtime_prelude_source();
    if (prelude.strEq("")) {
        return source;
    }
    source.strConcat("\n\n").strConcat(prelude)
}
out fn selfhostModuleLoaderUtilsMarker() : I32 => 0;
