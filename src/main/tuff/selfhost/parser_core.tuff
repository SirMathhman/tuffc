// ============================================================================
// AST Node Kinds
// ============================================================================

let NK_PROGRAM : I32 = 1;
let NK_FN_DECL : I32 = 2;
let NK_STRUCT_DECL : I32 = 3;
let NK_TYPE_ALIAS : I32 = 4;
let NK_LET_DECL : I32 = 5;
let NK_IMPORT_DECL : I32 = 6;
let NK_EXPR_STMT : I32 = 7;
let NK_RETURN_STMT : I32 = 8;
let NK_IF_STMT : I32 = 9;
let NK_WHILE_STMT : I32 = 10;
let NK_FOR_STMT : I32 = 11;
let NK_BLOCK : I32 = 12;
let NK_ASSIGN_STMT : I32 = 13;
let NK_BREAK_STMT : I32 = 14;
let NK_CONTINUE_STMT : I32 = 15;
let NK_CLASS_FN_DECL : I32 = 16;
let NK_EXTERN_FN_DECL : I32 = 17;
let NK_EXTERN_LET_DECL : I32 = 18;
let NK_EXTERN_TYPE_DECL : I32 = 19;
let NK_ENUM_DECL : I32 = 60;

let NK_NUMBER_LIT : I32 = 20;
let NK_BOOL_LIT : I32 = 21;
let NK_STRING_LIT : I32 = 22;
let NK_CHAR_LIT : I32 = 23;
let NK_IDENTIFIER : I32 = 24;
let NK_BINARY_EXPR : I32 = 25;
let NK_UNARY_EXPR : I32 = 26;
let NK_CALL_EXPR : I32 = 27;
let NK_MEMBER_EXPR : I32 = 28;
let NK_INDEX_EXPR : I32 = 29;
let NK_STRUCT_INIT : I32 = 30;
let NK_IF_EXPR : I32 = 31;
let NK_MATCH_EXPR : I32 = 32;
let NK_IS_EXPR : I32 = 33;
let NK_UNWRAP_EXPR : I32 = 34;

let NK_NAMED_TYPE : I32 = 40;
let NK_POINTER_TYPE : I32 = 41;
let NK_ARRAY_TYPE : I32 = 42;
let NK_TUPLE_TYPE : I32 = 43;
let NK_REFINEMENT_TYPE : I32 = 44;
let NK_UNION_TYPE : I32 = 45;

let NK_WILDCARD_PAT : I32 = 50;
let NK_LITERAL_PAT : I32 = 51;
let NK_NAME_PAT : I32 = 52;
let NK_STRUCT_PAT : I32 = 53;

// ============================================================================
// AST Storage (array-based)
// ============================================================================

let node_kinds : Vec<I32> = vec_new();
let node_data1 : Vec<I32> = vec_new();  // Generic data slot 1
let node_data2 : Vec<I32> = vec_new();  // Generic data slot 2
let node_data3 : Vec<I32> = vec_new();  // Generic data slot 3
let node_data4 : Vec<I32> = vec_new();  // Generic data slot 4
let node_data5 : Vec<I32> = vec_new();  // Generic data slot 5
let node_count : I32 = 0;

fn node_new(kind: I32) : I32 => {
    let idx = node_count;
    node_kinds.vec_push(kind);
    node_data1.vec_push(0);
    node_data2.vec_push(0);
    node_data3.vec_push(0);
    node_data4.vec_push(0);
    node_data5.vec_push(0);
    node_count = node_count + 1;
    idx
}

fn node_kind(idx: I32) : I32 => node_kinds.vec_get(idx);

extern type AnyValue;
fn node_set_data1(idx: I32, v: AnyValue) : I32 => { node_data1.vec_set(idx, v); 0 }
fn node_set_data2(idx: I32, v: AnyValue) : I32 => { node_data2.vec_set(idx, v); 0 }
fn node_set_data3(idx: I32, v: AnyValue) : I32 => { node_data3.vec_set(idx, v); 0 }
fn node_set_data4(idx: I32, v: AnyValue) : I32 => { node_data4.vec_set(idx, v); 0 }
fn node_set_data5(idx: I32, v: AnyValue) : I32 => { node_data5.vec_set(idx, v); 0 }
fn node_get_data1(idx: I32) : I32 => node_data1.vec_get(idx);
fn node_get_data2(idx: I32) : I32 => node_data2.vec_get(idx);
fn node_get_data3(idx: I32) : I32 => node_data3.vec_get(idx);
fn node_get_data4(idx: I32) : I32 => node_data4.vec_get(idx);
fn node_get_data5(idx: I32) : I32 => node_data5.vec_get(idx);

// ============================================================================
// Parser
// ============================================================================

let parse_pos : I32 = 0;
let parse_exports : Set<*Str> = set_new();

fn parse_init() : I32 => {
    parse_pos = 0;
    parse_exports = set_new();
    // Clear node arrays for fresh compilation
    node_kinds.vec_clear();
    node_data1.vec_clear();
    node_data2.vec_clear();
    node_data3.vec_clear();
    node_data4.vec_clear();
    node_data5.vec_clear();
    node_count = 0;
    0
}

fn p_peek(offset: I32) : I32 => {
    let idx = parse_pos + offset;
    if (idx >= tok_count) {
        tok_count - 1
    } else {
        idx
    }
}

fn p_at_kind(kind: I32) : Bool => tok_kind(p_peek(0)) == kind;

fn p_at_value(val: *Str) : Bool => {
    let v = tok_value(p_peek(0));
    intern_map.map_has(val) && intern_map.map_get(val) == v
}

fn p_at(kind: I32, val: *Str) : Bool => p_at_kind(kind) && p_at_value(val);

fn p_eat() : I32 => {
    let t = p_peek(0);
    parse_pos = parse_pos + 1;
    t
}

fn p_expect_kind(kind: I32, msg: *Str) : I32 => {
    if (!p_at_kind(kind)) {
        panic(msg);
    }
    p_eat()
}

fn p_expect(kind: I32, val: *Str, msg: *Str) : I32 => {
    if (!p_at(kind, val)) {
        panic(msg);
    }
    p_eat()
}

fn p_parse_identifier() : I32 => {
    let t = p_expect_kind(TK_IDENTIFIER, "Expected identifier");
    tok_value(t)
}

// Note: No forward declarations needed - JS hoists functions

fn p_can_start_type_tok() : Bool => {
    if (p_at_kind(TK_IDENTIFIER)) { return true; }
    if (p_at(TK_SYMBOL, "*")) { return true; }
    if (p_at(TK_SYMBOL, "[")) { return true; }
    if (p_at(TK_SYMBOL, "(")) { return true; }
    false
}

fn p_can_start_type_tok_at(offset: I32) : Bool => {
    let idx = p_peek(offset);
    let k = tok_kind(idx);
    if (k == TK_IDENTIFIER) {
        return true;
    }
    if (k == TK_SYMBOL) {
        let s = get_intern(tok_value(idx));
        if (s.str_eq("*") || s.str_eq("[") || s.str_eq("(")) {
            return true;
        }
    }
    false
}

fn p_can_start_refinement_expr() : Bool => {
    if (p_at_kind(TK_NUMBER)) { return true; }
    if (p_at_kind(TK_IDENTIFIER)) { return true; }
    if (p_at_kind(TK_BOOL)) { return true; }
    if (p_at_kind(TK_STRING)) { return true; }
    if (p_at(TK_SYMBOL, "(")) { return true; }
    if (p_at(TK_SYMBOL, "-")) { return true; }
    if (p_at(TK_SYMBOL, "!")) { return true; }
    false
}

fn p_parse_type() : I32 => {
    // Pointer type
    if (p_at(TK_SYMBOL, "*")) {
        p_eat();
        let mutable = 0;
        if (p_at(TK_KEYWORD, "mut")) {
            p_eat();
            mutable = 1;
        }
        let inner = p_parse_type();
        let node = node_new(NK_POINTER_TYPE);
        node_set_data1(node, mutable);
        node_set_data2(node, inner);
        return node;
    }
    
    // Array type
    if (p_at(TK_SYMBOL, "[")) {
        p_eat();
        let elem = p_parse_type();
        let init = 0;
        let total = 0;
        if (p_at(TK_SYMBOL, ";")) {
            p_eat();
            init = p_parse_expression(0);
            p_expect(TK_SYMBOL, ";", "Expected ';' in array type");
            total = p_parse_expression(0);
        }
        p_expect(TK_SYMBOL, "]", "Expected ']'");
        let node = node_new(NK_ARRAY_TYPE);
        node_set_data1(node, elem);
        node_set_data2(node, init);
        node_set_data3(node, total);
        return node;
    }
    
    // Tuple type
    if (p_at(TK_SYMBOL, "(")) {
        p_eat();
        let members = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            members.vec_push(p_parse_type());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                members.vec_push(p_parse_type());
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')' in tuple type");
        let node = node_new(NK_TUPLE_TYPE);
        node_set_data1(node, members);
        return node;
    }
    
    // Named type with optional generics
    let name = p_parse_identifier();
    let generics = vec_new();
    
    // Handle :: path
    while (p_at(TK_SYMBOL, "::")) {
        p_eat();
        let part = p_parse_identifier();
        // Combine names - for now just track them
    }
    
    // Generic args
    if (p_at(TK_SYMBOL, "<") && p_can_start_type_tok_at(1)) {
        p_eat();
        if (!p_at(TK_SYMBOL, ">")) {
            generics.vec_push(p_parse_type());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                generics.vec_push(p_parse_type());
            }
        }
        p_expect(TK_SYMBOL, ">", "Expected '>' in generic args");
    }
    
    let type_node = node_new(NK_NAMED_TYPE);
    node_set_data1(type_node, name);
    node_set_data2(type_node, generics);
    
    // Refinement predicate
    let has_refine = p_at(TK_SYMBOL, "!=") || p_at(TK_SYMBOL, "<") || p_at(TK_SYMBOL, ">") || p_at(TK_SYMBOL, "<=") || p_at(TK_SYMBOL, ">=");
    if (has_refine && p_can_start_refinement_expr()) {
        let op = tok_value(p_eat());
        let val_expr = p_parse_expression(0);
        let refine = node_new(NK_REFINEMENT_TYPE);
        node_set_data1(refine, type_node);
        node_set_data2(refine, op);
        node_set_data3(refine, val_expr);
        type_node = refine;
    }
    
    // Union types
    while (p_at(TK_SYMBOL, "|") || p_at(TK_SYMBOL, "|>")) {
        let is_extract = 0;
        if (p_at(TK_SYMBOL, "|>")) {
            is_extract = 1;
        }
        p_eat();
        let right = p_parse_type();
        let union_node = node_new(NK_UNION_TYPE);
        node_set_data1(union_node, type_node);
        node_set_data2(union_node, right);
        node_set_data3(union_node, is_extract);
        type_node = union_node;
    }
    
    type_node
}

fn p_parse_pattern() : I32 => {
    // Wildcard
    if (p_at(TK_SYMBOL, "_") || p_at(TK_IDENTIFIER, "_")) {
        p_eat();
        return node_new(NK_WILDCARD_PAT);
    }
    
    // Number literal
    if (p_at_kind(TK_NUMBER)) {
        let t = p_eat();
        let node = node_new(NK_LITERAL_PAT);
        node_set_data1(node, tok_value(t));
        return node;
    }
    
    // Bool literal
    if (p_at_kind(TK_BOOL)) {
        let t = p_eat();
        let node = node_new(NK_LITERAL_PAT);
        node_set_data1(node, tok_value(t));
        return node;
    }
    
    // Name or struct pattern
    let name = p_parse_identifier();
    
    if (p_at(TK_SYMBOL, "{")) {
        p_eat();
        let fields = vec_new();
        if (!p_at(TK_SYMBOL, "}")) {
            fields.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                fields.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, "}", "Expected '}' in pattern");
        let node = node_new(NK_STRUCT_PAT);
        node_set_data1(node, name);
        node_set_data2(node, fields);
        return node;
    }
    
    let node = node_new(NK_NAME_PAT);
    node_set_data1(node, name);
    node
}

out fn selfhost_parser_core_marker() : I32 => 0;
