// ============================================================================
// AST Node Kinds
// ============================================================================

let { tok_kind, tok_value, tok_line, tok_col, get_intern, vec_new, set_new } = selfhost::runtime_lexer;

let NK_PROGRAM : I32 = 1;
let NK_FN_DECL : I32 = 2;
let NK_STRUCT_DECL : I32 = 3;
let NK_TYPE_ALIAS : I32 = 4;
let NK_LET_DECL : I32 = 5;
let NK_IMPORT_DECL : I32 = 6;
let NK_EXPR_STMT : I32 = 7;
let NK_RETURN_STMT : I32 = 8;
let NK_IF_STMT : I32 = 9;
let NK_WHILE_STMT : I32 = 10;
let NK_FOR_STMT : I32 = 11;
let NK_BLOCK : I32 = 12;
let NK_ASSIGN_STMT : I32 = 13;
let NK_BREAK_STMT : I32 = 14;
let NK_CONTINUE_STMT : I32 = 15;
let NK_CLASS_FN_DECL : I32 = 16;
let NK_EXTERN_FN_DECL : I32 = 17;
let NK_EXTERN_LET_DECL : I32 = 18;
let NK_EXTERN_TYPE_DECL : I32 = 19;
let NK_EXPECT_FN_DECL : I32 = 61;
let NK_ACTUAL_FN_DECL : I32 = 62;
let NK_OBJECT_DECL : I32 = 63;
let NK_LOOP_STMT : I32 = 64;
let NK_CONTRACT_DECL : I32 = 65;
let NK_INTO_STMT : I32 = 66;
let NK_LIFETIME_STMT : I32 = 67;
let NK_STMT_LIST : I32 = 68;
let NK_EXTERN_IMPORT_DECL : I32 = 69;
let NK_ENUM_DECL : I32 = 60;

let NK_NUMBER_LIT : I32 = 20;
let NK_BOOL_LIT : I32 = 21;
let NK_STRING_LIT : I32 = 22;
let NK_CHAR_LIT : I32 = 23;
let NK_IDENTIFIER : I32 = 24;
let NK_BINARY_EXPR : I32 = 25;
let NK_UNARY_EXPR : I32 = 26;
let NK_CALL_EXPR : I32 = 27;
let NK_MEMBER_EXPR : I32 = 28;
let NK_INDEX_EXPR : I32 = 29;
let NK_STRUCT_INIT : I32 = 30;
let NK_IF_EXPR : I32 = 31;
let NK_MATCH_EXPR : I32 = 32;
let NK_IS_EXPR : I32 = 33;
let NK_UNWRAP_EXPR : I32 = 34;
let NK_LAMBDA_EXPR : I32 = 35;
let NK_FN_EXPR : I32 = 36;
let NK_TUPLE_EXPR : I32 = 37;

let NK_NAMED_TYPE : I32 = 40;
let NK_POINTER_TYPE : I32 = 41;
let NK_ARRAY_TYPE : I32 = 42;
let NK_TUPLE_TYPE : I32 = 43;
let NK_REFINEMENT_TYPE : I32 = 44;
let NK_UNION_TYPE : I32 = 45;
let NK_FUNCTION_TYPE : I32 = 46;

let NK_WILDCARD_PAT : I32 = 50;
let NK_LITERAL_PAT : I32 = 51;
let NK_NAME_PAT : I32 = 52;
let NK_STRUCT_PAT : I32 = 53;

// ============================================================================
// AST Storage (array-based)
// ============================================================================

let node_kinds : Vec<I32> = vec_new();
let node_data1 : Vec<I32> = vec_new();  // Generic data slot 1
let node_data2 : Vec<I32> = vec_new();  // Generic data slot 2
let node_data3 : Vec<I32> = vec_new();  // Generic data slot 3
let node_data4 : Vec<I32> = vec_new();  // Generic data slot 4
let node_data5 : Vec<I32> = vec_new();  // Generic data slot 5
let node_toks  : Vec<I32> = vec_new();  // Token index at parse time (for line/col)
let node_count : I32 = 1;

out fn node_new(kind: I32) : I32 => {
    let idx = node_count;
    node_kinds.vec_push(kind);
    node_data1.vec_push(0);
    node_data2.vec_push(0);
    node_data3.vec_push(0);
    node_data4.vec_push(0);
    node_data5.vec_push(0);
    node_toks.vec_push(parse_pos);
    node_count = node_count + 1;
    idx
}

out fn node_kind(idx: I32) : I32 => node_kinds.vec_get(idx);

extern type AnyValue;
out fn node_set_data1(idx: I32, v: AnyValue) : I32 => { node_data1.vec_set(idx, v); 0 }
out fn node_set_data2(idx: I32, v: AnyValue) : I32 => { node_data2.vec_set(idx, v); 0 }
out fn node_set_data3(idx: I32, v: AnyValue) : I32 => { node_data3.vec_set(idx, v); 0 }
out fn node_set_data4(idx: I32, v: AnyValue) : I32 => { node_data4.vec_set(idx, v); 0 }
out fn node_set_data5(idx: I32, v: AnyValue) : I32 => { node_data5.vec_set(idx, v); 0 }
out fn node_get_data1(idx: I32) : I32 => node_data1.vec_get(idx);
out fn node_get_data2(idx: I32) : I32 => node_data2.vec_get(idx);
out fn node_get_data3(idx: I32) : I32 => node_data3.vec_get(idx);
out fn node_get_data4(idx: I32) : I32 => node_data4.vec_get(idx);
out fn node_get_data5(idx: I32) : I32 => node_data5.vec_get(idx);
out fn node_get_line(idx: I32) : I32 => tok_line(node_toks.vec_get(idx));
out fn node_get_col(idx: I32) : I32 => tok_col(node_toks.vec_get(idx));

// ============================================================================
// Parser
// ============================================================================

let parse_pos : I32 = 0;
let parse_exports : *mut Set<*Str> = set_new();

out fn parse_init() : I32 => {
    parse_pos = 0;
    parse_exports = set_new();
    // Clear node arrays for fresh compilation
    node_kinds.vec_clear();
    node_data1.vec_clear();
    node_data2.vec_clear();
    node_data3.vec_clear();
    node_data4.vec_clear();
    node_data5.vec_clear();
    node_toks.vec_clear();
    // Reserve index 0 as null/sentinel node.
    node_kinds.vec_push(0);
    node_data1.vec_push(0);
    node_data2.vec_push(0);
    node_data3.vec_push(0);
    node_data4.vec_push(0);
    node_data5.vec_push(0);
    node_toks.vec_push(0);
    node_count = 1;
    0
}

out fn p_peek(offset: I32) : I32 => {
    let idx = parse_pos + offset;
    if (idx >= tok_count) {
        tok_count - 1
    } else {
        idx
    }
}

out fn p_mark() : I32 => parse_pos;
out fn p_restore(mark: I32) : I32 => { parse_pos = mark; 0 }

out fn p_at_kind(kind: I32) : Bool => tok_kind(p_peek(0)) == kind;

out fn p_at_value(val: *Str) : Bool => {
    let v = tok_value(p_peek(0));
    intern_map.map_has(val) && intern_map.map_get(val) == v
}

out fn p_at(kind: I32, val: *Str) : Bool => p_at_kind(kind) && p_at_value(val);

out fn p_eat() : I32 => {
    let t = p_peek(0);
    parse_pos = parse_pos + 1;
    t
}

fn p_token_kind_name(knd: I32) : *Str => {
    if (knd == TK_EOF) { return "eof"; }
    if (knd == TK_KEYWORD) { return "keyword"; }
    if (knd == TK_IDENTIFIER) { return "identifier"; }
    if (knd == TK_NUMBER) { return "number"; }
    if (knd == TK_STRING) { return "string"; }
    if (knd == TK_BOOL) { return "bool"; }
    if (knd == TK_SYMBOL) { return "symbol"; }
    if (knd == TK_CHAR) { return "char"; }
    "token"
}

fn p_token_value_for_error(t: I32) : *Str => {
    let knd = tok_kind(t);
    if (knd == TK_BOOL) {
        if (tok_value(t) == 0) { return "false"; }
        return "true";
    }
    if (
        knd == TK_KEYWORD ||
        knd == TK_IDENTIFIER ||
        knd == TK_NUMBER ||
        knd == TK_STRING ||
        knd == TK_SYMBOL ||
        knd == TK_CHAR ||
        knd == TK_EOF
    ) {
        return get_intern(tok_value(t));
    }
    "<unknown>"
}

out fn p_error_with_token_context(msg: *Str) : I32 => {
    let t = p_peek(0);
    let found_kind = p_token_kind_name(tok_kind(t));
    let value = p_token_value_for_error(t);
    let line = int_to_string(tok_line(t));
    let col = int_to_string(tok_col(t));
    panic(msg
        .str_concat(" (found ")
        .str_concat(found_kind)
        .str_concat(":")
        .str_concat(value)
        .str_concat(" at ")
        .str_concat(line)
        .str_concat(":")
        .str_concat(col)
        .str_concat(")"));
    0
}

out fn p_expect_kind(kind: I32, msg: *Str) : I32 => {
    if (!p_at_kind(kind)) {
        p_error_with_token_context(msg);
    }
    p_eat()
}

out fn p_expect(kind: I32, val: *Str, msg: *Str) : I32 => {
    if (!p_at(kind, val)) {
        p_error_with_token_context(msg);
    }
    p_eat()
}

out fn p_parse_identifier() : I32 => {
    let t = p_expect_kind(TK_IDENTIFIER, "Expected identifier");
    tok_value(t)
}

// Note: No forward declarations needed - JS hoists functions

out fn p_can_start_type_tok() : Bool => {
    if (p_at_kind(TK_IDENTIFIER)) { return true; }
    if (p_at(TK_SYMBOL, "*")) { return true; }
    if (p_at(TK_SYMBOL, "[")) { return true; }
    if (p_at(TK_SYMBOL, "(")) { return true; }
    false
}

out fn p_can_start_type_tok_at(offset: I32) : Bool => {
    let idx = p_peek(offset);
    let k = tok_kind(idx);
    if (k == TK_IDENTIFIER) {
        return true;
    }
    if (k == TK_SYMBOL) {
        let s = get_intern(tok_value(idx));
        if (s.str_eq("*") || s.str_eq("[") || s.str_eq("(")) {
            return true;
        }
    }
    false
}

out fn p_can_start_type_after_lifetime_tok_at(offset: I32) : Bool => {
    let idx = p_peek(offset);
    let k = tok_kind(idx);
    if (k == TK_IDENTIFIER) {
        return true;
    }
    if (k == TK_SYMBOL) {
        let s = get_intern(tok_value(idx));
        if (s.str_eq("*") || s.str_eq("[") || s.str_eq("(")) {
            return true;
        }
    }
    if (k == TK_KEYWORD) {
        let kw = get_intern(tok_value(idx));
        if (kw.str_eq("mut") || kw.str_eq("move") || kw.str_eq("out") || kw.str_eq("uninit")) {
            return true;
        }
    }
    false
}

out fn p_can_start_refinement_expr() : Bool => {
    if (p_at_kind(TK_NUMBER)) { return true; }
    if (p_at_kind(TK_IDENTIFIER)) { return true; }
    if (p_at_kind(TK_BOOL)) { return true; }
    if (p_at_kind(TK_STRING)) { return true; }
    if (p_at(TK_SYMBOL, "(")) { return true; }
    if (p_at(TK_SYMBOL, "-")) { return true; }
    if (p_at(TK_SYMBOL, "!")) { return true; }
    false
}

out fn p_can_start_refinement_expr_at(offset: I32) : Bool => {
    let idx = p_peek(offset);
    let k = tok_kind(idx);
    if (k == TK_NUMBER || k == TK_IDENTIFIER || k == TK_BOOL || k == TK_STRING || k == TK_CHAR) {
        return true;
    }
    if (k == TK_SYMBOL) {
        let s = get_intern(tok_value(idx));
        if (s.str_eq("(") || s.str_eq("-") || s.str_eq("!")) {
            return true;
        }
    }
    false
}

out fn p_parse_type_primary() : I32 => {
        // Pointer type
        if (p_at(TK_SYMBOL, "*")) {
            p_eat();
            let mutable = 0;
            let move_ptr = 0;
            let life_name = 0;
            let progressed = true;
            while (progressed) {
                progressed = false;
                if (mutable == 0 && p_at(TK_KEYWORD, "mut")) {
                    p_eat();
                    mutable = 1;
                    progressed = true;
                } else if (move_ptr == 0 && p_at(TK_KEYWORD, "move")) {
                    p_eat();
                    move_ptr = 1;
                    progressed = true;
                } else if (life_name == 0 && p_at_kind(TK_IDENTIFIER) && p_can_start_type_after_lifetime_tok_at(1)) {
                    life_name = tok_value(p_eat());
                    progressed = true;
                }
            }
            let inner = p_parse_type_primary();
            let node = node_new(NK_POINTER_TYPE);
            node_set_data1(node, mutable);
            node_set_data2(node, inner);
            node_set_data3(node, move_ptr);
            node_set_data4(node, life_name);
            return node;
        }
        
        // Array type
        if (p_at(TK_SYMBOL, "[")) {
            p_eat();
            let elem = p_parse_type();
            let init = 0;
            let total = 0;
            if (p_at(TK_SYMBOL, ";")) {
                p_eat();
                init = p_parse_expression(0);
                p_expect(TK_SYMBOL, ";", "Expected ';' in array type");
                total = p_parse_expression(0);
            }
            p_expect(TK_SYMBOL, "]", "Expected ']'");
            let node = node_new(NK_ARRAY_TYPE);
            node_set_data1(node, elem);
            node_set_data2(node, init);
            node_set_data3(node, total);
            return node;
        }
        
        // Tuple type
        if (p_at(TK_SYMBOL, "(")) {
            p_eat();
            let members = vec_new();
            if (!p_at(TK_SYMBOL, ")")) {
                if (tok_kind(p_peek(0)) == TK_IDENTIFIER && tok_kind(p_peek(1)) == TK_SYMBOL) {
                    let sym0 = get_intern(tok_value(p_peek(1)));
                    if (sym0.str_eq(":")) {
                        p_eat();
                        p_eat();
                    }
                }
                members.vec_push(p_parse_type());
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    if (tok_kind(p_peek(0)) == TK_IDENTIFIER && tok_kind(p_peek(1)) == TK_SYMBOL) {
                        let sym = get_intern(tok_value(p_peek(1)));
                        if (sym.str_eq(":")) {
                            p_eat();
                            p_eat();
                        }
                    }
                    members.vec_push(p_parse_type());
                }
            }
            p_expect(TK_SYMBOL, ")", "Expected ')' in tuple type");
            if (p_at(TK_SYMBOL, "=>")) {
                p_eat();
                let ret = p_parse_type();
                let fnty = node_new(NK_FUNCTION_TYPE);
                node_set_data1(fnty, members);
                node_set_data2(fnty, ret);
                return fnty;
            }
            let node = node_new(NK_TUPLE_TYPE);
            node_set_data1(node, members);
            return node;
        }

        // Type-level nullable pointer sentinel: 0 or 0USize
        if (p_at_kind(TK_NUMBER)) {
            let t = p_eat();
            let raw = get_intern(tok_value(t));
            if (!(raw.str_eq("0USize") || raw.str_eq("0"))) {
                panic("Only 0 or 0USize is supported as a type-level numeric sentinel");
            }
            let base = node_new(NK_NAMED_TYPE);
            node_set_data1(base, intern("USize"));
            node_set_data2(base, vec_new());
            let lit = node_new(NK_NUMBER_LIT);
            node_set_data1(lit, tok_value(t));
            let refine = node_new(NK_REFINEMENT_TYPE);
            node_set_data1(refine, base);
            node_set_data2(refine, intern("=="));
            node_set_data3(refine, lit);
            return refine;
        }
        
        // Named type with optional generics
        let name = p_parse_identifier();
        let generics = vec_new();
        
        // Handle :: path
        while (p_at(TK_SYMBOL, "::")) {
            p_eat();
            let part = p_parse_identifier();
            // Combine names - for now just track them
        }
        
        // Generic args
        let would_be_member_refine = false;
        if (p_at(TK_SYMBOL, "<")) {
            let k1 = tok_kind(p_peek(1));
            let k2 = tok_kind(p_peek(2));
            if (k1 == TK_IDENTIFIER && k2 == TK_SYMBOL) {
                let s2 = get_intern(tok_value(p_peek(2)));
                if (s2.str_eq(".")) {
                    would_be_member_refine = true;
                }
            }
        }
        if (p_at(TK_SYMBOL, "<") && p_can_start_type_tok_at(1) && !would_be_member_refine) {
            p_eat();
            if (!p_at(TK_SYMBOL, ">")) {
                generics.vec_push(p_parse_type());
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    generics.vec_push(p_parse_type());
                }
            }
            p_expect(TK_SYMBOL, ">", "Expected '>' in generic args");
        }
        
        let type_node = node_new(NK_NAMED_TYPE);
        node_set_data1(type_node, name);
        node_set_data2(type_node, generics);
        return type_node;
}

out fn p_parse_type() : I32 => {

    let type_node = p_parse_type_primary();
    
    // Refinement predicate
    let has_refine = p_at(TK_SYMBOL, "!=") || p_at(TK_SYMBOL, "<") || p_at(TK_SYMBOL, ">") || p_at(TK_SYMBOL, "<=") || p_at(TK_SYMBOL, ">=");
    let starts_generic_call_suffix = false;
    if (p_at(TK_SYMBOL, ">") && tok_kind(p_peek(1)) == TK_SYMBOL) {
        let next_sym = get_intern(tok_value(p_peek(1)));
        if (next_sym.str_eq("(")) {
            starts_generic_call_suffix = true;
        }
    }
    if (has_refine && p_can_start_refinement_expr_at(1) && !starts_generic_call_suffix) {
        let op = tok_value(p_eat());
        let val_expr = p_parse_expression(0);
        let refine = node_new(NK_REFINEMENT_TYPE);
        node_set_data1(refine, type_node);
        node_set_data2(refine, op);
        node_set_data3(refine, val_expr);
        type_node = refine;
    }

    // Arithmetic type/value expressions used in annotations (e.g. SizeOf<T> * L)
    while (
        p_at(TK_SYMBOL, "+") ||
        p_at(TK_SYMBOL, "-") ||
        p_at(TK_SYMBOL, "*") ||
        p_at(TK_SYMBOL, "/") ||
        p_at(TK_SYMBOL, "%")
    ) {
        let op = tok_value(p_eat());
        let right = p_parse_type_primary();
        let bin = node_new(NK_BINARY_EXPR);
        node_set_data1(bin, op);
        node_set_data2(bin, type_node);
        node_set_data3(bin, right);
        type_node = bin;
    }
    
    // Union types
    while (p_at(TK_SYMBOL, "|") || p_at(TK_SYMBOL, "|>")) {
        let is_extract = 0;
        if (p_at(TK_SYMBOL, "|>")) {
            is_extract = 1;
        }
        p_eat();
        let right = p_parse_type_primary();
        let union_node = node_new(NK_UNION_TYPE);
        node_set_data1(union_node, type_node);
        node_set_data2(union_node, right);
        node_set_data3(union_node, is_extract);
        type_node = union_node;
    }
    
    type_node
}

out fn p_parse_pattern() : I32 => {
    // Wildcard
    if (p_at(TK_SYMBOL, "_") || p_at(TK_IDENTIFIER, "_")) {
        p_eat();
        return node_new(NK_WILDCARD_PAT);
    }
    
    // Number literal
    if (p_at_kind(TK_NUMBER)) {
        let t = p_eat();
        let node = node_new(NK_LITERAL_PAT);
        node_set_data1(node, tok_value(t));
        return node;
    }
    
    // Bool literal
    if (p_at_kind(TK_BOOL)) {
        let t = p_eat();
        let node = node_new(NK_LITERAL_PAT);
        node_set_data1(node, tok_value(t));
        return node;
    }
    
    // Name or struct pattern
    let name = p_parse_identifier();

    // Optional generic qualifiers in pattern position: Some<T>, Foo<A, B>
    if (p_at(TK_SYMBOL, "<") && p_can_start_type_tok_at(1)) {
        p_eat();
        if (!p_at(TK_SYMBOL, ">")) {
            p_parse_type();
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                p_parse_type();
            }
        }
        p_expect(TK_SYMBOL, ">", "Expected '>' in pattern generic args");
    }
    
    if (p_at(TK_SYMBOL, "{")) {
        p_eat();
        let fields = vec_new();
        if (!p_at(TK_SYMBOL, "}")) {
            fields.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                fields.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, "}", "Expected '}' in pattern");
        let node = node_new(NK_STRUCT_PAT);
        node_set_data1(node, name);
        node_set_data2(node, fields);
        return node;
    }
    
    let node = node_new(NK_NAME_PAT);
    node_set_data1(node, name);
    node
}

out fn selfhost_parser_core_marker() : I32 => 0;
