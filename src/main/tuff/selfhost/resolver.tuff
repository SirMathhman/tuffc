// ============================================================================
// Name Resolution - skip for now, minimal implementation
// ============================================================================

let { get_interned_str, set_new, vec_new } = selfhost::runtime_lexer;
let { node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5 } = selfhost::parser_core;

fn fn_type_sig(t: I32) : *Str => {
    if (t == 0) {
        return "_";
    }
    let k = node_kind(t);
    if (k == NK_NAMED_TYPE) {
        return get_interned_str(node_get_data1(t));
    }
    if (k == NK_POINTER_TYPE) {
        let mutv = node_get_data1(t);
        let inner = fn_type_sig(node_get_data2(t));
        if (mutv == 1) { return "*mut ".str_concat(inner); }
        return "*".str_concat(inner);
    }
    if (k == NK_ARRAY_TYPE) {
        return "Array";
    }
    if (k == NK_TUPLE_TYPE) {
        return "Tuple";
    }
    if (k == NK_REFINEMENT_TYPE) {
        return "Ref<".str_concat(fn_type_sig(node_get_data1(t))).str_concat(">");
    }
    if (k == NK_UNION_TYPE) {
        return fn_type_sig(node_get_data1(t)).str_concat("|").str_concat(fn_type_sig(node_get_data2(t)));
    }
    if (k == NK_FUNCTION_TYPE) {
        let parts = vec_new();
        let ps = node_get_data1(t);
        let i = 0;
        while (i < ps.vec_length()) {
            parts.vec_push(fn_type_sig(ps.vec_get(i)));
            i = i + 1;
        }
        return "(".str_concat(parts.vec_join(",")).str_concat(")=>").str_concat(fn_type_sig(node_get_data2(t)));
    }
    "Unknown"
}

fn fn_decl_sig(n: I32) : *Str => {
    let gens = node_get_data2(n);
    let params = node_get_data3(n);
    let ret = node_get_data4(n);
    let pparts = vec_new();
    let i = 0;
    while (i < params.vec_length()) {
        let p = params.vec_get(i);
        let pname = get_interned_str(p.vec_get(0));
        let ptype = fn_type_sig(p.vec_get(1));
        pparts.vec_push(pname.str_concat(":").str_concat(ptype));
        i = i + 1;
    }
    let gcount = int_to_string(gens.vec_length());
    return "g=".str_concat(gcount).str_concat(";p=").str_concat(pparts.vec_join(",")).str_concat(";r=").str_concat(fn_type_sig(ret));
}

fn validate_expect_actual_pairs(body: Vec) : I32 => {
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        let stmt = body.vec_get(i);
        let kind = node_kind(stmt);
        if (kind == NK_EXPECT_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
            let name = get_interned_str(node_get_data1(stmt));
            let expect_count = 0;
            let actual_count = 0;
            let expect_node = 0;
            let actual_node = 0;
            let j = 0;
            while (j < len) {
                let cand = body.vec_get(j);
                let ck = node_kind(cand);
                if ((ck == NK_EXPECT_FN_DECL || ck == NK_ACTUAL_FN_DECL) && get_interned_str(node_get_data1(cand)).str_eq(name)) {
                    if (ck == NK_EXPECT_FN_DECL) {
                        expect_count = expect_count + 1;
                        expect_node = cand;
                    } else {
                        actual_count = actual_count + 1;
                        actual_node = cand;
                    }
                }
                j = j + 1;
            }
            if (expect_count != 1 || actual_count != 1) {
                panic_with_code(
                    "E_EXPECT_ACTUAL_PAIRING",
                    "expect/actual pairing requires exactly one expect and one actual for '".str_concat(name).str_concat("'"),
                    "Platform declarations require exactly one expect and one actual declaration for each symbol.",
                    "Declare exactly one 'expect fn' and one matching 'actual fn' for each platform symbol."
                );
            }
            if (!fn_decl_sig(expect_node).str_eq(fn_decl_sig(actual_node))) {
                panic_with_code(
                    "E_EXPECT_ACTUAL_SIGNATURE_MISMATCH",
                    "expect/actual signatures do not match for '".str_concat(name).str_concat("'"),
                    "An expect declaration and its actual implementation have different signatures.",
                    "Make generic params, parameter list, and return type identical between expect and actual declarations."
                );
            }
        }
        i = i + 1;
    }
    0
}

fn scope_define(scopes: Vec, depth: I32, name: *Str) : I32 => {
    let scope = scopes.vec_get(depth);
    if (scope.set_has(name)) {
        panic_with_code(
            "E_RESOLVE_SHADOWING",
            "Variable shadowing/redeclaration is not allowed: ".str_concat(name),
            "A name was declared multiple times in the same lexical scope.",
            "Rename one of the bindings or move it to a different scope."
        );
    }
    scope.set_add(name);
    0
}

fn scope_has(scopes: Vec, depth: I32, name: *Str) : Bool => {
    let i = depth;
    while (i >= 0) {
        if (scopes.vec_get(i).set_has(name)) {
            return true;
        }
        i = i - 1;
    }
    false
}

fn resolve_expr(n: I32, globals: *mut Set, scopes: Vec, depth: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_IDENTIFIER) {
        let name = get_interned_str(node_get_data1(n));
        if (!scope_has(scopes, depth, name) && !globals.set_has(name)) {
            panic_with_code(
                "E_RESOLVE_UNKNOWN_IDENTIFIER",
                "Unknown identifier: ".str_concat(name),
                "The identifier is not declared in local scope, global declarations, or imports.",
                "Declare the identifier before use or import it from the correct module."
            );
        }
        return 0;
    }

    if (kind == NK_BINARY_EXPR) {
        resolve_expr(node_get_data2(n), globals, scopes, depth);
        resolve_expr(node_get_data3(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
        resolve_expr(node_get_data2(n), globals, scopes, depth);
        if (kind == NK_UNWRAP_EXPR) {
            resolve_expr(node_get_data1(n), globals, scopes, depth);
        }
        return 0;
    }

    if (kind == NK_CALL_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        let args = node_get_data2(n);
        let i = 0;
        let len = args.vec_length();
        while (i < len) {
            resolve_expr(args.vec_get(i), globals, scopes, depth);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_MEMBER_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_INDEX_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_expr(node_get_data2(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_STRUCT_INIT) {
        let type_name = get_interned_str(node_get_data1(n));
        if (!globals.set_has(type_name)) {
            panic_with_code(
                "E_RESOLVE_UNKNOWN_STRUCT",
                "Unknown struct/type in initializer: ".str_concat(type_name),
                "A struct initializer referenced a type that is not declared in the merged module scope.",
                "Declare the struct/type first or import the module that defines it."
            );
        }
        let fields = node_get_data2(n);
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            resolve_expr(field.vec_get(1), globals, scopes, depth);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IF_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_stmt(node_get_data2(n), globals, scopes, depth);
        if (node_get_data3(n) != 0) {
            resolve_stmt(node_get_data3(n), globals, scopes, depth);
        }
        return 0;
    }

    if (kind == NK_MATCH_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        let cases = node_get_data2(n);
        let i = 0;
        let len = cases.vec_length();
        while (i < len) {
            let case_node = cases.vec_get(i);
            let pat = case_node.vec_get(0);
            let body = case_node.vec_get(1);

            let next_depth = depth + 1;
            scopes.vec_push(set_new());

            if (node_kind(pat) == NK_STRUCT_PAT) {
                let fields = node_get_data2(pat);
                let j = 0;
                let fLen = fields.vec_length();
                while (j < fLen) {
                    scope_define(scopes, next_depth, get_interned_str(fields.vec_get(j)));
                    j = j + 1;
                }
            } else if (node_kind(pat) == NK_NAME_PAT) {
                let pat_name = get_interned_str(node_get_data1(pat));
                if (!globals.set_has(pat_name)) {
                    scope_define(scopes, next_depth, pat_name);
                }
            }

            resolve_stmt(body, globals, scopes, next_depth);
            scopes.vec_pop();
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IS_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_LAMBDA_EXPR) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        let params = node_get_data1(n);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let param = params.vec_get(i);
            scope_define(scopes, next_depth, get_interned_str(param.vec_get(0)));
            i = i + 1;
        }
        resolve_stmt(node_get_data2(n), globals, scopes, next_depth);
        scopes.vec_pop();
        return 0;
    }

    if (kind == NK_FN_EXPR) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        let fname_idx = node_get_data1(n);
        if (fname_idx != 0) {
            scope_define(scopes, next_depth, get_interned_str(fname_idx));
        }
        let params = node_get_data3(n);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let param = params.vec_get(i);
            scope_define(scopes, next_depth, get_interned_str(param.vec_get(0)));
            i = i + 1;
        }
        resolve_stmt(node_get_data5(n), globals, scopes, next_depth);
        scopes.vec_pop();
        return 0;
    }

    0
}

fn resolve_stmt(n: I32, globals: *mut Set, scopes: Vec, depth: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_BLOCK) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        let stmts = node_get_data1(n);
        let i = 0;
        let len = stmts.vec_length();
        while (i < len) {
            resolve_stmt(stmts.vec_get(i), globals, scopes, next_depth);
            i = i + 1;
        }
        scopes.vec_pop();
        return 0;
    }

    if (kind == NK_EXPECT_FN_DECL) {
        return 0;
    }

    if (kind == NK_CONTRACT_DECL) {
        return 0;
    }

    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
        let fnScopes = vec_new();
        fnScopes.vec_push(set_new());
        let params = node_get_data3(n);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let param = params.vec_get(i);
            scope_define(fnScopes, 0, get_interned_str(param.vec_get(0)));
            i = i + 1;
        }
        resolve_stmt(node_get_data5(n), globals, fnScopes, 0);
        return 0;
    }

    if (kind == NK_LET_DECL) {
        resolve_expr(node_get_data3(n), globals, scopes, depth);
        scope_define(scopes, depth, get_interned_str(node_get_data1(n)));
        return 0;
    }

    if (kind == NK_IMPORT_DECL) {
        let names = node_get_data1(n);
        let i = 0;
        let len = names.vec_length();
        while (i < len) {
            scope_define(scopes, depth, get_interned_str(names.vec_get(i)));
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_EXPR_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_ASSIGN_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_expr(node_get_data2(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_RETURN_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_IF_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_stmt(node_get_data2(n), globals, scopes, depth);
        if (node_get_data3(n) != 0) {
            resolve_stmt(node_get_data3(n), globals, scopes, depth);
        }
        return 0;
    }

    if (kind == NK_FOR_STMT) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        scope_define(scopes, next_depth, get_interned_str(node_get_data1(n)));
        resolve_expr(node_get_data2(n), globals, scopes, next_depth);
        resolve_expr(node_get_data3(n), globals, scopes, next_depth);
        resolve_stmt(node_get_data4(n), globals, scopes, next_depth);
        scopes.vec_pop();
        return 0;
    }

    if (kind == NK_WHILE_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_stmt(node_get_data2(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_LOOP_STMT) {
        resolve_stmt(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_INTO_STMT) {
        let cname = get_interned_str(node_get_data1(n));
        if (!globals.set_has(cname)) {
            panic_with_code(
                "E_RESOLVE_UNKNOWN_IDENTIFIER",
                "Unknown contract: ".str_concat(cname),
                "An into statement referenced a contract that is not declared in scope.",
                "Declare the contract before using 'into'."
            );
        }
        return 0;
    }

    // Fallback: treat unmatched nodes as expressions.
    resolve_expr(n, globals, scopes, depth);
    0
}

out fn resolve_names(program: I32) : I32 => {
    let globals = set_new();
    let body = node_get_data1(program);

    validate_expect_actual_pairs(body);

    // Predeclare global symbols.
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        let stmt = body.vec_get(i);
        let kind = node_kind(stmt);
        if (
            kind == NK_FN_DECL ||
            kind == NK_CLASS_FN_DECL ||
            kind == NK_ACTUAL_FN_DECL ||
            kind == NK_STRUCT_DECL ||
            kind == NK_ENUM_DECL ||
            kind == NK_OBJECT_DECL ||
            kind == NK_CONTRACT_DECL ||
            kind == NK_TYPE_ALIAS ||
            kind == NK_LET_DECL ||
            kind == NK_EXTERN_FN_DECL ||
            kind == NK_EXTERN_LET_DECL ||
            kind == NK_EXTERN_TYPE_DECL
        ) {
            let gname = get_interned_str(node_get_data1(stmt));
            if (globals.set_has(gname)) {
                panic_with_code(
                    "E_RESOLVE_SHADOWING",
                    "Variable shadowing/redeclaration is not allowed: ".str_concat(gname),
                    "A global declaration with the same name already exists.",
                    "Rename one of the global declarations or split conflicting declarations into separate modules."
                );
            }
            globals.set_add(gname);
        }
        i = i + 1;
    }

    // Resolve top-level statements.
    let topScopes = vec_new();
    topScopes.vec_push(set_new());
    i = 0;
    while (i < len) {
        resolve_stmt(body.vec_get(i), globals, topScopes, 0);
        i = i + 1;
    }

    program
}

out fn selfhost_resolver_marker() : I32 => 0;
