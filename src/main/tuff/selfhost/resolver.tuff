 // ============================================================================
 // Name Resolution - skip for now, minimal implementation
 // ============================================================================
let {
    getInternedStr, setNew, vecNew, mapNew, intToString, perfNow, printError
}
 = selfhost::runtimeLexer;
let {
    nodeKind, nodeGetData1, nodeGetData2, nodeGetData3, nodeGetData4, nodeGetData5,
    nodeGetLine, nodeGetCol
}
 = selfhost::parserCore;
let {
    rslvUtilsFindDidYouMean, rslvUtilsValidateExpectActualPairs, rslvUtilsScopeDefine,
    rslvUtilsScopeHas, rslvUtilsIsHostBuiltinName, rslvUtilsResolveTypeLifetimes
}
 = selfhost::resolverUtils;
let {
    Ok, Err, Result
}
 = selfhost::Result;
let {
    ResolveError
}
 = selfhost::errors::ResolveError;
 // Current AST node being resolved — set at each resolve_expr/resolve_stmt entry.
let rslvCurrentNode : I32 = 0;
 // Scope Set pool — recycle cleared Sets instead of allocating new ones each scope.
let scopePool : Vec<*mut Set<*Str>> = vecNew();
fn scopePoolGet() : *mut Set<*Str> => {
    if (scopePool.vecLength() > 0) {
        scopePool.vecPop()
    }
    else {
        setNew()
    }
}
fn scopePoolReturn(s: *mut Set<*Str>) => {
    s.setClear();
    scopePool.vecPush(s);
}
fn rslvPanicLoc(code: *Str, msg: *Str, reason: *Str, fix: *Str) : Result<I32, ResolveError> => {
    Err<ResolveError> {
        error: ResolveError {
            code: code,
            message: msg,
            reason: reason,
            fix: fix,
            line: nodeGetLine(rslvCurrentNode),
            col: nodeGetCol(rslvCurrentNode)
        }
    }
}
let resolveLifetimeScopes : Vec<*mut Set<*Str>> = vecNew();
 // Track first declaration node for each global name (for shadowing error messages).
let resolveGlobalDeclNodes : Map<*Str, I32> = mapNew();
 // Parallel list of declared global names so we can iterate for "did you mean?" suggestions.
let resolveGlobalNamesList : Vec<*Str> = vecNew();
let resolveStmtTotalCalls : I32 = 0;
let resolveStmtTotalMs : I32 = 0;
let resolveStmtBlockCalls : I32 = 0;
let resolveStmtBlockMs : I32 = 0;
let resolveStmtFnCalls : I32 = 0;
let resolveStmtFnMs : I32 = 0;
let resolveStmtLetImportCalls : I32 = 0;
let resolveStmtLetImportMs : I32 = 0;
let resolveStmtFlowCalls : I32 = 0;
let resolveStmtFlowMs : I32 = 0;
let resolveStmtLifetimeIntoCalls : I32 = 0;
let resolveStmtLifetimeIntoMs : I32 = 0;
let resolveStmtDeclSkipCalls : I32 = 0;
let resolveStmtDeclSkipMs : I32 = 0;
let resolveStmtFallbackExprCalls : I32 = 0;
let resolveStmtFallbackExprMs : I32 = 0;
let resolveBlockPredeclareMs : I32 = 0;
let resolveBlockBodyMs : I32 = 0;
let resolveExprIdentifierCalls : I32 = 0;
let resolveExprBinaryCalls : I32 = 0;
let resolveExprUnaryOrUnwrapCalls : I32 = 0;
let resolveExprCallCalls : I32 = 0;
let resolveExprMemberCalls : I32 = 0;
let resolveExprIndexCalls : I32 = 0;
let resolveExprStructInitCalls : I32 = 0;
let resolveExprTupleCalls : I32 = 0;
let resolveExprIfCalls : I32 = 0;
let resolveExprMatchCalls : I32 = 0;
let resolveExprIsCalls : I32 = 0;
let resolveExprLambdaCalls : I32 = 0;
let resolveExprFnExprCalls : I32 = 0;
let resolveExprOtherCalls : I32 = 0;
let resolveExprOtherKindCounts : Map<I32, I32> = mapNew();
let resolveExprOtherKindKeys : Vec<I32> = vecNew();
fn resolveLogStep(name: *Str, stepStart: I32, totalStart: I32) : I32 => {
    let now = perfNow();
    let stepDt = now - stepStart;
    let totalDt = now - totalStart;
    printError(
    "[selfhost][resolve] ".strConcat(name)
    .strConcat(" dt=")
    .strConcat(intToString(stepDt))
    .strConcat("ms total=")
    .strConcat(intToString(totalDt))
    .strConcat("ms\n")
    );
    now
}
fn resolveLogBucket(name: *Str, calls: I32, ms: I32) : I32 => {
    if (calls <= 0) {
        return 0;
    }
    printError(
    "[selfhost][resolve][bucket] ".strConcat(name)
    .strConcat(" calls=")
    .strConcat(intToString(calls))
    .strConcat(" ms=")
    .strConcat(intToString(ms))
    .strConcat("\n")
    );
    0
}
fn resolveLogCount(name: *Str, count: I32) : I32 => {
    if (count <= 0) {
        return 0;
    }
    printError(
    "[selfhost][resolve][count] ".strConcat(name)
    .strConcat(" calls=")
    .strConcat(intToString(count))
    .strConcat("\n")
    );
    0
}
fn resolveExprIdentifier(n: I32, globals: *mut Set<*Str>, scopes: Vec<*mut Set<*Str>>, depth: I32) : Result<I32, ResolveError> => {
    let name = getInternedStr(nodeGetData1(n))?;
    if (!rslvUtilsScopeHas(scopes, depth, name) && !globals.setHas(name) &&
    !rslvUtilsIsHostBuiltinName(name)) {
        let suggestion = rslvUtilsFindDidYouMean(name, resolveGlobalNamesList);
        let fixMsg = "Declare the identifier before use or import it from the correct module.";
        if (!suggestion.strEq("")) {
            fixMsg = "Did you mean '".strConcat(suggestion).strConcat("'? Declare or import it from the correct module.");
        }
        return rslvPanicLoc("E_RESOLVE_UNKNOWN_IDENTIFIER", "Unknown identifier: ".strConcat(name), "The identifier is not declared in local scope, global declarations, or imports.",
        fixMsg
        );
    }
    Ok<I32> {
        value: 0
    }
}
fn resolveExprCall(n: I32, globals: *mut Set<*Str>, scopes: Vec<*mut Set<*Str>>, depth: I32) : Result<I32, ResolveError> => {
    let callee = nodeGetData1(n)?;
    if (nodeKind(callee) == NK_IDENTIFIER && getInternedStr(nodeGetData1(callee)).strEq("drop")) {
        let args = nodeGetData2(n);
        if (args.vecLength() != 1) {
            return rslvPanicLoc("E_RESOLVE_UNKNOWN_IDENTIFIER", "drop expects exactly one argument", "Built-in drop requires exactly one receiver value.", "Use drop(value) or value.drop() with exactly one receiver value.");
        }
        resolveExpr(args.vecGet(0), globals, scopes, depth)?;
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (nodeKind(callee) == NK_IDENTIFIER && getInternedStr(nodeGetData1(callee)).strEq("into") && nodeGetData3(n) == 1) {
        let args = nodeGetData2(n);
        if (args.vecLength() < 1) {
            return rslvPanicLoc("E_RESOLVE_UNKNOWN_IDENTIFIER", "into conversion requires a receiver", "Method-sugar into conversion requires a source value as receiver.", "Use value.into<Contract>(...) with a receiver value.");
        }
        let typeArgs = nodeGetData4(n);
        let contractName = "";
        if (typeArgs.vecLength() == 1 && nodeKind(typeArgs.vecGet(0)) == NK_NAMED_TYPE) {
            contractName = getInternedStr(nodeGetData1(typeArgs.vecGet(0)));
        }
        let contractDeclared = false;
        if (!contractName.strEq("")) {
            contractDeclared = globals.setHas(contractName);
        }
        if (contractName.strEq("") || !contractDeclared) {
            let contractLabel = contractName;
            if (contractLabel.strEq("")) {
                contractLabel = "<missing>";
            }
            return rslvPanicLoc("E_RESOLVE_UNKNOWN_IDENTIFIER", "Unknown contract '".strConcat(contractLabel).strConcat("'"), "An into conversion referenced a contract that is not declared in scope.", "Use value.into<Contract>(...) with a declared contract name.");
        }
        resolveExpr(args.vecGet(0), globals, scopes, depth)?;
        let i = 1;
        let len = args.vecLength();
        while (i < len) {
            resolveExpr(args.vecGet(i), globals, scopes, depth)?;
            i = i + 1;
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (nodeGetData3(n) != 1) {
        resolveExpr(nodeGetData1(n), globals, scopes, depth)?;
    }
    let args = nodeGetData2(n);
    let i = 0;
    let len = args.vecLength();
    while (i < len) {
        resolveExpr(args.vecGet(i), globals, scopes, depth)?;
        i = i + 1;
    }
    Ok<I32> {
        value: 0
    }
}
fn resolveExprMatch (n: I32, globals: *mut Set<*Str>, scopes: Vec<*mut Set<*Str>>, depth: I32) : Result<I32, ResolveError> => {
    resolveExpr(nodeGetData1(n), globals, scopes, depth)?;
    let cases = nodeGetData2(n);
    let i = 0;
    let len = cases.vecLength();
    while (i < len) {
        let caseNode = cases.vecGet(i);
        let pat = caseNode.vecGet(0);
        let body = caseNode.vecGet(1);
        let nextDepth = depth + 1;
        scopes.vecPush(scopePoolGet());
        if (nodeKind(pat) == NK_STRUCT_PAT) {
            let fields = nodeGetData2(pat);
            let j = 0;
            let fLen = fields.vecLength();
            while (j < fLen) {
                rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr(fields.vecGet(j)),
                pat);
                j = j + 1;
            }
        }
        else if (nodeKind(pat) == NK_NAME_PAT) {
            let patName = getInternedStr(nodeGetData1(pat));
            if (!globals.setHas(patName)) {
                rslvUtilsScopeDefine(scopes, nextDepth, patName, pat);
            }
        }
        resolveStmt(body, globals, scopes, nextDepth)?;
        scopePoolReturn(scopes.vecPop());
        i = i + 1;
    }
    Ok<I32> {
        value: 0
    }
}
fn resolveExprLambda(n: I32, globals: *mut Set<*Str>, scopes: Vec<*mut Set<*Str>>, depth: I32) : Result<I32, ResolveError> => {
    let nextDepth = depth + 1;
    scopes.vecPush(scopePoolGet());
    let params = nodeGetData1(n);
    let i = 0;
    let len = params.vecLength();
    while (i < len) {
        let param = params.vecGet(i);
        rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr(param.vecGet(0)), n);
        i = i + 1;
    }
    resolveStmt(nodeGetData2(n), globals, scopes, nextDepth)?;
    scopePoolReturn(scopes.vecPop());
    Ok<I32> {
        value: 0
    }
}
fn resolveExprFnExpr(n: I32, globals: *mut Set<*Str>, scopes: Vec<*mut Set<*Str>>, depth: I32) : Result<I32, ResolveError> => {
    let nextDepth = depth + 1;
    scopes.vecPush(scopePoolGet());
    let fnameIdx = nodeGetData1(n);
    if (fnameIdx != 0) {
        rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr(fnameIdx), n);
    }
    let params = nodeGetData3(n);
    let i = 0;
    let len = params.vecLength();
    while (i < len) {
        let param = params.vecGet(i);
        rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr(param.vecGet(0)), n);
        i = i + 1;
    }
    resolveStmt(nodeGetData5(n), globals, scopes, nextDepth)?;
    scopePoolReturn(scopes.vecPop());
    Ok<I32> {
        value: 0
    }
}
fn resolveStmtBlock(n: I32, globals: *mut Set<*Str>, scopes: Vec<*mut Set<*Str>>, depth: I32) : Result<I32, ResolveError> => {
    let nextDepth = depth + 1;
    scopes.vecPush(scopePoolGet());
    let stmts = nodeGetData1(n);
    let i = 0;
    let len = stmts.vecLength();
    let predeclareT0 = perfNow();
    while (i < len) {
        let stmt = stmts.vecGet(i);
        let stmtKind = nodeKind(stmt);
        if (stmtKind == NK_FN_DECL || stmtKind == NK_CLASS_FN_DECL || stmtKind = =
        NK_ACTUAL_FN_DECL) {
            rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr(nodeGetData1(stmt)),
            stmt);
        }
        i = i + 1;
    }
    resolveBlockPredeclareMs = resolveBlockPredeclareMs + (perfNow() - predeclareT0);
    let bodyT0 = perfNow();
    i = 0;
    while (i < len) {
        resolveStmt(stmts.vecGet(i), globals, scopes, nextDepth)?;
        i = i + 1;
    }
    resolveBlockBodyMs = resolveBlockBodyMs + (perfNow() - bodyT0);
    scopePoolReturn(scopes.vecPop());
    Ok<I32> {
        value: 0
    }
}
fn resolveStmtFnDecl(n: I32, globals: *mut Set<*Str>, scopes: Vec<*mut Set<*Str>>, depth: I32) : Result<I32, ResolveError> => {
    let nextDepth = depth + 1;
    scopes.vecPush(scopePoolGet());
    let params = nodeGetData3(n);
    let i = 0;
    let len = params.vecLength();
    while (i < len) {
        let param = params.vecGet(i);
        rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr(param.vecGet(0)), n);
        rslvUtilsResolveTypeLifetimes(param.vecGet(1), resolveLifetimeScopes, n);
        i = i + 1;
    }
    rslvUtilsResolveTypeLifetimes(nodeGetData4(n), resolveLifetimeScopes, n);
    resolveStmt(nodeGetData5(n), globals, scopes, nextDepth)?;
    scopePoolReturn(scopes.vecPop());
    Ok<I32> {
        value: 0
    }
}
fn resolveStmtLetOrImport(n: I32, globals: *mut Set<*Str>, scopes: Vec<*mut Set<*Str>>, depth: I32) : Result<I32, ResolveError> => {
    let kind = nodeKind(n)?;
    if (kind == NK_LET_DECL) {
        if (nodeGetData2(n) != 0) {
            rslvUtilsResolveTypeLifetimes(nodeGetData2(n), resolveLifetimeScopes, n);
        }
        resolveExpr(nodeGetData3(n), globals, scopes, depth)?;
        rslvUtilsScopeDefine(scopes, depth, getInternedStr(nodeGetData1(n)), n);
        return Ok<I32> {
            value: 1
        }
        ;
    }
    if (kind == NK_IMPORT_DECL) {
        let names = nodeGetData1(n);
        let i = 0;
        let len = names.vecLength();
        while (i < len) {
            rslvUtilsScopeDefine(scopes, depth, getInternedStr(names.vecGet(i)), n);
            i = i + 1;
        }
        return Ok<I32> {
            value: 1
        }
        ;
    }
    if (kind == NK_EXTERN_IMPORT_DECL) {
        return Ok<I32> {
            value: 1
        }
        ;
    }
    Ok<I32> {
        value: 0
    }
}
fn resolveStmtFlow(n: I32, globals: *mut Set<*Str>, scopes: Vec<*mut Set<*Str>>, depth: I32) : Result<I32, ResolveError> => {
    let kind = nodeKind(n)?;
    if (kind == NK_EXPR_STMT) {
        resolveExpr(nodeGetData1(n), globals, scopes, depth)?;
        return Ok<I32> {
            value: 1
        }
        ;
    }
    if (kind == NK_ASSIGN_STMT) {
        resolveExpr(nodeGetData1(n), globals, scopes, depth)?;
        resolveExpr(nodeGetData2(n), globals, scopes, depth)?;
        return Ok<I32> {
            value: 1
        }
        ;
    }
    if (kind == NK_RETURN_STMT) {
        resolveExpr(nodeGetData1(n), globals, scopes, depth)?;
        return Ok<I32> {
            value: 1
        }
        ;
    }
    if (kind == NK_IF_STMT) {
        resolveExpr(nodeGetData1(n), globals, scopes, depth)?;
        resolveStmt(nodeGetData2(n), globals, scopes, depth)?;
        if (nodeGetData3(n) != 0) {
            resolveStmt(nodeGetData3(n), globals, scopes, depth)?;
        }
        return Ok<I32> {
            value: 1
        }
        ;
    }
    if (kind == NK_FOR_STMT) {
        let nextDepth = depth + 1;
        scopes.vecPush(scopePoolGet());
        rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr(nodeGetData1(n)), n);
        resolveExpr(nodeGetData2(n), globals, scopes, nextDepth)?;
        resolveExpr(nodeGetData3(n), globals, scopes, nextDepth)?;
        resolveStmt(nodeGetData4(n), globals, scopes, nextDepth)?;
        scopePoolReturn(scopes.vecPop());
        return Ok<I32> {
            value: 1
        }
        ;
    }
    if (kind == NK_WHILE_STMT) {
        resolveExpr(nodeGetData1(n), globals, scopes, depth)?;
        resolveStmt(nodeGetData2(n), globals, scopes, depth)?;
        return Ok<I32> {
            value: 1
        }
        ;
    }
    if (kind == NK_LOOP_STMT) {
        resolveStmt(nodeGetData1(n), globals, scopes, depth)?;
        return Ok<I32> {
            value: 1
        }
        ;
    }
    Ok<I32> {
        value: 0
    }
}
fn resolveStmtLifetimeOrInto(n: I32, globals: *mut Set<*Str>, scopes: Vec<*mut Set<*Str>>, depth: I32) : Result<I32, ResolveError> => {
    let kind = nodeKind(n)?;
    if (kind == NK_LIFETIME_STMT) {
        let nextDepth = depth + 1;
        scopes.vecPush(scopePoolGet());
        let lifetimeNames = nodeGetData1(n);
        let lifetimeScope = setNew();
        let i = 0;
        let len = lifetimeNames.vecLength();
        while (i < len) {
            let lname = getInternedStr(lifetimeNames.vecGet(i));
            if (lifetimeScope.setHas(lname)) {
                return rslvPanicLoc("E_RESOLVE_DUPLICATE_LIFETIME", "Duplicate lifetime name '".strConcat(lname).strConcat("' in lifetime block"), "A lifetime block contains duplicate lifetime names.", "Use unique lifetime names within a lifetime declaration block."
                );
            }
            lifetimeScope.setAdd(lname);
            rslvUtilsScopeDefine(scopes, nextDepth, lname, n);
            i = i + 1;
        }
        resolveLifetimeScopes.vecPush(lifetimeScope);
        resolveStmt(nodeGetData2(n), globals, scopes, nextDepth)?;
        resolveLifetimeScopes.vecPop();
        scopePoolReturn(scopes.vecPop());
        return Ok<I32> {
            value: 1
        }
        ;
    }
    if (kind == NK_INTO_STMT) {
        let cname = getInternedStr(nodeGetData1(n));
        if (!globals.setHas(cname)) {
            return rslvPanicLoc("E_RESOLVE_UNKNOWN_IDENTIFIER", "Unknown contract: ".strConcat(cname), "An into statement referenced a contract that is not declared in scope.", "Declare the contract before using 'into'.");
        }
        return Ok<I32> {
            value: 1
        }
        ;
    }
    Ok<I32> {
        value: 0
    }
}
fn resolveExpr(n: I32, globals: *mut Set<*Str>, scopes: Vec<*mut Set<*Str>>, depth: I32) : Result<I32, ResolveError> => {
    if (n == 0) {
        return Ok<I32> {
            value: 0
        }
        ;
    }
    rslvCurrentNode = n;
    let kind = nodeKind(n);
    if (kind == NK_IDENTIFIER) {
        resolveExprIdentifierCalls = resolveExprIdentifierCalls + 1;
        return resolveExprIdentifier(n, globals, scopes, depth);
    }
    if (kind == NK_BINARY_EXPR) {
        resolveExprBinaryCalls = resolveExprBinaryCalls + 1;
        resolveExpr(nodeGetData2(n), globals, scopes, depth)?;
        resolveExpr(nodeGetData3(n), globals, scopes, depth)?;
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
        resolveExprUnaryOrUnwrapCalls = resolveExprUnaryOrUnwrapCalls + 1;
        resolveExpr(nodeGetData2(n), globals, scopes, depth)?;
        if (kind == NK_UNWRAP_EXPR) {
            resolveExpr(nodeGetData1(n), globals, scopes, depth)?;
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_CALL_EXPR) {
        resolveExprCallCalls = resolveExprCallCalls + 1;
        return resolveExprCall(n, globals, scopes, depth);
    }
    if (kind == NK_MEMBER_EXPR) {
        resolveExprMemberCalls = resolveExprMemberCalls + 1;
        resolveExpr(nodeGetData1(n), globals, scopes, depth)?;
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_INDEX_EXPR) {
        resolveExprIndexCalls = resolveExprIndexCalls + 1;
        resolveExpr(nodeGetData1(n), globals, scopes, depth)?;
        resolveExpr(nodeGetData2(n), globals, scopes, depth)?;
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_STRUCT_INIT) {
        resolveExprStructInitCalls = resolveExprStructInitCalls + 1;
        let typeName = getInternedStr(nodeGetData1(n));
        if (!globals.setHas(typeName)) {
            return rslvPanicLoc("E_RESOLVE_UNKNOWN_STRUCT", "Unknown struct/type in initializer: ".strConcat(typeName), "A struct initializer referenced a type that is not declared in the merged module scope.", "Declare the struct/type first or import the module that defines it."
            );
        }
        let fields = nodeGetData2(n);
        let i = 0;
        let len = fields.vecLength();
        while (i < len) {
            let field = fields.vecGet(i);
            resolveExpr(field.vecGet(1), globals, scopes, depth)?;
            i = i + 1;
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_TUPLE_EXPR) {
        resolveExprTupleCalls = resolveExprTupleCalls + 1;
        let items = nodeGetData1(n);
        let i = 0;
        let len = items.vecLength();
        while (i < len) {
            resolveExpr(items.vecGet(i), globals, scopes, depth)?;
            i = i + 1;
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_IF_EXPR) {
        resolveExprIfCalls = resolveExprIfCalls + 1;
        resolveExpr(nodeGetData1(n), globals, scopes, depth)?;
        resolveStmt(nodeGetData2(n), globals, scopes, depth)?;
        if (nodeGetData3(n) != 0) {
            let kindKey = intToString(kind);
            if (!resolveExprOtherKindCounts.mapHas(kindKey)) {
                resolveExprOtherKindCounts.mapSet(kindKey, 0);
                resolveExprOtherKindKeys.vecPush(kindKey);
            }
            resolveExprOtherKindCounts.mapSet(kindKey, resolveExprOtherKindCounts.mapGet(kindKey) + 1);
            resolveStmt(nodeGetData3(n), globals, scopes, depth)?;
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_MATCH_EXPR) {
        resolveExprMatchCalls = resolveExprMatchCalls + 1;
        return resolveExprMatch (n, globals, scopes, depth);
    }
    if (kind == NK_IS_EXPR) {
        resolveExprIsCalls = resolveExprIsCalls + 1;
        resolveExpr(nodeGetData1(n), globals, scopes, depth)?;
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_LAMBDA_EXPR) {
        resolveExprLambdaCalls = resolveExprLambdaCalls + 1;
        return resolveExprLambda(n, globals, scopes, depth);
    }
    if (kind == NK_FN_EXPR) {
        resolveExprFnExprCalls = resolveExprFnExprCalls + 1;
        return resolveExprFnExpr(n, globals, scopes, depth);
    }
    resolveExprOtherCalls = resolveExprOtherCalls + 1;
    Ok<I32> {
        value: 0
    }
}
fn resolveStmt(n: I32, globals: *mut Set<*Str>, scopes: Vec<*mut Set<*Str>>, depth: I32) : Result<I32, ResolveError> => {
    if (n == 0) {
        return Ok<I32> {
            value: 0
        }
        ;
    }
    let stmtT0 = perfNow();
    resolveStmtTotalCalls = resolveStmtTotalCalls + 1;
    rslvCurrentNode = n;
    let kind = nodeKind(n);
    let resultValue : I32 = 0;
    let catName : *Str = "";
     // Dispatch by kind: each branch sets category and executes logic
    if (kind == NK_BLOCK) {
        resultValue = resolveStmtBlock(n, globals, scopes, depth)?;
        catName = "block";
    }
    else if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
        resultValue = resolveStmtFnDecl(n, globals, scopes, depth)?;
        catName = "fn";
    }
    else if (resolveStmtLetOrImport(n, globals, scopes, depth)? == 1) {
        catName = "let";
    }
    else if (resolveStmtFlow(n, globals, scopes, depth)? == 1) {
        catName = "flow";
    }
    else if (resolveStmtLifetimeOrInto(n, globals, scopes, depth)? == 1) {
        catName = "lifetime";
    }
    else if (kind == NK_TYPE_ALIAS || kind == NK_DEP_TYPE_ALIAS ||
    kind == NK_STRUCT_DECL || kind == NK_ENUM_DECL ||
    kind == NK_EXTERN_LET_DECL ||
    kind == NK_EXTERN_TYPE_DECL || kind == NK_EXTERN_IMPORT_DECL ||
    kind == NK_OBJECT_DECL || kind == NK_CONTRACT_DECL ||
    kind == NK_EXPECT_FN_DECL) {
        catName = "decl";
    }
    else {
         // Fallback: treat unmatched nodes as expressions.
        resolveExpr(n, globals, scopes, depth)?;
        catName = "expr";
    }
     // Single timing accumulation point (eliminates 7-8 redundant perfNow calls)
    let dt = perfNow() - stmtT0;
    resolveStmtTotalMs = resolveStmtTotalMs + dt;
    if (catName.strEq("block")) {
        resolveStmtBlockCalls = resolveStmtBlockCalls + 1;
        resolveStmtBlockMs = resolveStmtBlockMs + dt;
    }
    else if (catName.strEq("fn")) {
        resolveStmtFnCalls = resolveStmtFnCalls + 1;
        resolveStmtFnMs = resolveStmtFnMs + dt;
    }
    else if (catName.strEq("let")) {
        resolveStmtLetImportCalls = resolveStmtLetImportCalls + 1;
        resolveStmtLetImportMs = resolveStmtLetImportMs + dt;
    }
    else if (catName.strEq("flow")) {
        resolveStmtFlowCalls = resolveStmtFlowCalls + 1;
        resolveStmtFlowMs = resolveStmtFlowMs + dt;
    }
    else if (catName.strEq("lifetime")) {
        resolveStmtLifetimeIntoCalls = resolveStmtLifetimeIntoCalls + 1;
        resolveStmtLifetimeIntoMs = resolveStmtLifetimeIntoMs + dt;
    }
    else if (catName.strEq("decl")) {
        resolveStmtDeclSkipCalls = resolveStmtDeclSkipCalls + 1;
        resolveStmtDeclSkipMs = resolveStmtDeclSkipMs + dt;
    }
    else if (catName.strEq("expr")) {
        resolveStmtFallbackExprCalls = resolveStmtFallbackExprCalls + 1;
        resolveStmtFallbackExprMs = resolveStmtFallbackExprMs + dt;
    }
    Ok<I32> {
        value: resultValue
    }
}
out fn resolveNames(program: I32) : Result<I32, ResolveError> => {
    let resolveTotalStart = perfNow();
    let resolveStepStart = resolveTotalStart;
    resolveLifetimeScopes.vecClear();
    resolveGlobalNamesList.vecClear();
    resolveGlobalDeclNodes = resolveGlobalDeclNodes.mapClear();
    resolveStmtTotalCalls = 0;
    resolveStmtTotalMs = 0;
    resolveStmtBlockCalls = 0;
    resolveStmtBlockMs = 0;
    resolveStmtFnCalls = 0;
    resolveStmtFnMs = 0;
    resolveStmtLetImportCalls = 0;
    resolveStmtLetImportMs = 0;
    resolveStmtFlowCalls = 0;
    resolveStmtFlowMs = 0;
    resolveStmtLifetimeIntoCalls = 0;
    resolveStmtLifetimeIntoMs = 0;
    resolveStmtDeclSkipCalls = 0;
    resolveStmtDeclSkipMs = 0;
    resolveStmtFallbackExprCalls = 0;
    resolveStmtFallbackExprMs = 0;
    resolveBlockPredeclareMs = 0;
    resolveBlockBodyMs = 0;
    resolveExprIdentifierCalls = 0;
    resolveExprBinaryCalls = 0;
    resolveExprUnaryOrUnwrapCalls = 0;
    resolveExprCallCalls = 0;
    resolveExprMemberCalls = 0;
    resolveExprIndexCalls = 0;
    resolveExprStructInitCalls = 0;
    resolveExprTupleCalls = 0;
    resolveExprIfCalls = 0;
    resolveExprMatchCalls = 0;
    resolveExprIsCalls = 0;
    resolveExprLambdaCalls = 0;
    resolveExprFnExprCalls = 0;
    resolveExprOtherCalls = 0;
    resolveExprOtherKindCounts = resolveExprOtherKindCounts.mapClear();
    resolveExprOtherKindKeys.vecClear();
    resolveStepStart = resolveLogStep("reset-state", resolveStepStart, resolveTotalStart);
    let globals = setNew();
    let body = nodeGetData1(program);
    rslvUtilsValidateExpectActualPairs(body);
    resolveStepStart = resolveLogStep("validate-expect-actual", resolveStepStart, resolveTotalStart);
     // Predeclare global symbols.
    let i = 0;
    let len = body.vecLength();
    while (i < len) {
        let stmt = body.vecGet(i);
        let kind = nodeKind(stmt);
        if (
        kind == NK_FN_DECL ||
        kind == NK_CLASS_FN_DECL ||
        kind == NK_ACTUAL_FN_DECL ||
        kind == NK_STRUCT_DECL ||
        kind == NK_ENUM_DECL ||
        kind == NK_OBJECT_DECL ||
        kind == NK_CONTRACT_DECL ||
        kind == NK_TYPE_ALIAS ||
        kind == NK_DEP_TYPE_ALIAS ||
        kind == NK_LET_DECL ||
        kind == NK_EXTERN_LET_DECL ||
        kind == NK_EXTERN_TYPE_DECL
        ) {
            let gname = getInternedStr(nodeGetData1(stmt));
            if (globals.setHas(gname)) {
                let firstNode = resolveGlobalDeclNodes.mapGet(gname);
                let firstLine = intToString(nodeGetLine(firstNode));
                let firstCol = intToString(nodeGetCol(firstNode));
                rslvPanicLoc(
                "E_RESOLVE_SHADOWING",
                "Duplicate global declaration: ".strConcat(gname),
                "First declared at line ".strConcat(firstLine).strConcat(", col ").strConcat(firstCol).strConcat("."),
                "Rename one of the global declarations or split conflicting declarations into separate modules."
                );
            }
            globals.setAdd(gname);
            resolveGlobalNamesList.vecPush(gname);
            resolveGlobalDeclNodes.mapSet(gname, stmt);
        }
        i = i + 1;
    }
    resolveStepStart = resolveLogStep("predeclare-globals", resolveStepStart, resolveTotalStart);
     // Resolve top-level statements.
    let topScopes = vecNew();
    topScopes.vecPush(setNew());
    resolveStepStart = resolveLogStep("init-top-scope", resolveStepStart, resolveTotalStart);
    i = 0;
    while (i < len) {
        let topStmt = body.vecGet(i);
        let topKind = nodeKind(topStmt);
        let topName = "";
        if (
        topKind == NK_FN_DECL ||
        topKind == NK_CLASS_FN_DECL ||
        topKind == NK_ACTUAL_FN_DECL ||
        topKind == NK_STRUCT_DECL ||
        topKind == NK_ENUM_DECL ||
        topKind == NK_OBJECT_DECL ||
        topKind == NK_CONTRACT_DECL ||
        topKind == NK_TYPE_ALIAS ||
        topKind == NK_DEP_TYPE_ALIAS ||
        topKind == NK_LET_DECL ||
        topKind == NK_EXTERN_LET_DECL ||
        topKind == NK_EXTERN_TYPE_DECL
        ) {
            topName = getInternedStr(nodeGetData1(topStmt));
        }
        printError(
        "[selfhost][resolve] top-stmt:start i=".strConcat(intToString(i))
        .strConcat(" kind=")
        .strConcat(intToString(topKind))
        .strConcat(" name=")
        .strConcat(topName)
        .strConcat("\n")
        );
        resolveStmt(topStmt, globals, topScopes, 0)?;
        printError(
        "[selfhost][resolve] top-stmt:done i=".strConcat(intToString(i))
        .strConcat(" kind=")
        .strConcat(intToString(topKind))
        .strConcat("\n")
        );
        i = i + 1;
    }
    resolveStepStart = resolveLogStep("resolve-top-level", resolveStepStart, resolveTotalStart);
    resolveLogBucket("stmt-total", resolveStmtTotalCalls, resolveStmtTotalMs);
    resolveLogBucket("stmt-block", resolveStmtBlockCalls, resolveStmtBlockMs);
    resolveLogBucket("stmt-fn-decl", resolveStmtFnCalls, resolveStmtFnMs);
    resolveLogBucket("stmt-let-import", resolveStmtLetImportCalls, resolveStmtLetImportMs);
    resolveLogBucket("stmt-flow", resolveStmtFlowCalls, resolveStmtFlowMs);
    resolveLogBucket("stmt-lifetime-into", resolveStmtLifetimeIntoCalls, resolveStmtLifetimeIntoMs);
    resolveLogBucket("stmt-decl-skip", resolveStmtDeclSkipCalls, resolveStmtDeclSkipMs);
    resolveLogBucket("stmt-fallback-expr", resolveStmtFallbackExprCalls, resolveStmtFallbackExprMs);
    resolveLogBucket("block-predeclare", resolveStmtBlockCalls, resolveBlockPredeclareMs);
    resolveLogBucket("block-body", resolveStmtBlockCalls, resolveBlockBodyMs);
    resolveLogCount("expr-identifier", resolveExprIdentifierCalls);
    resolveLogCount("expr-binary", resolveExprBinaryCalls);
    resolveLogCount("expr-unary-or-unwrap", resolveExprUnaryOrUnwrapCalls);
    resolveLogCount("expr-call", resolveExprCallCalls);
    resolveLogCount("expr-member", resolveExprMemberCalls);
    resolveLogCount("expr-index", resolveExprIndexCalls);
    resolveLogCount("expr-struct-init", resolveExprStructInitCalls);
    resolveLogCount("expr-tuple", resolveExprTupleCalls);
    resolveLogCount("expr-if", resolveExprIfCalls);
    resolveLogCount("expr-match", resolveExprMatchCalls);
    resolveLogCount("expr-is", resolveExprIsCalls);
    resolveLogCount("expr-lambda", resolveExprLambdaCalls);
    resolveLogCount("expr-fn-expr", resolveExprFnExprCalls);
    resolveLogCount("expr-other", resolveExprOtherCalls);
    let j = 0;
    let jLen = resolveExprOtherKindKeys.vecLength();
    while (j < jLen) {
        let kindKey = resolveExprOtherKindKeys.vecGet(j);
        let kindCount = resolveExprOtherKindCounts.mapGet(kindKey);
        resolveLogCount("expr-other-kind=".strConcat(intToString(kindKey)), kindCount);
        j = j + 1;
    }
    Ok<I32> {
        value: program
    }
}
out fn selfhostResolverMarker() : I32 => 0;
