 // ============================================================================
 // Name Resolution - skip for now, minimal implementation
 // ============================================================================
let {
    get_interned_str, set_new, vec_new, map_new, int_to_string
}
 = selfhost::runtime_lexer;
let {
    node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5,
    node_get_line, node_get_col
}
 = selfhost::parser_core;
let {
    rslv_utils_find_did_you_mean, rslv_utils_validate_expect_actual_pairs, rslv_utils_scope_define,
    rslv_utils_scope_has, rslv_utils_is_host_builtin_name, rslv_utils_resolve_type_lifetimes
}
 = selfhost::resolver_utils;
let {
    Ok, Err, Result
}
 = selfhost::Result;
let {
    ResolveError
}
 = selfhost::errors::ResolveError;

 // Current AST node being resolved â€” set at each resolve_expr/resolve_stmt entry.
let rslv_current_node : I32 = 0;
fn rslv_panic_loc(code: *Str, msg: *Str, reason: *Str, fix: *Str) : Result<I32, ResolveError> => {
    Err<ResolveError> {
        error: ResolveError {
            code: code,
            message: msg,
            reason: reason,
            fix: fix,
            line: node_get_line(rslv_current_node),
            col: node_get_col(rslv_current_node)
        }
    }
}
let resolve_lifetime_scopes : Vec<I32> = vec_new();
 // Track first declaration node for each global name (for shadowing error messages).
let resolve_global_decl_nodes : Map<I32, I32> = map_new();
 // Parallel list of declared global names so we can iterate for "did you mean?" suggestions.
let resolve_global_names_list : Vec<I32> = vec_new();
fn resolve_expr_identifier(n: I32, globals: *mut Set<I32>, scopes: Vec<I32>, depth: I32) : Result<I32, ResolveError> => {
    let name = get_interned_str(node_get_data1(n))?;
    if (!rslv_utils_scope_has(scopes, depth, name) && !globals.set_has(name) &&
    !rslv_utils_is_host_builtin_name(name)) {
        let suggestion = rslv_utils_find_did_you_mean(name, resolve_global_names_list);
        let fix_msg = "Declare the identifier before use or import it from the correct module.";
        if (!suggestion.str_eq("")) {
            fix_msg = "Did you mean '".str_concat(suggestion).str_concat("'? Declare or import it from the correct module.");
        }
        return rslv_panic_loc("E_RESOLVE_UNKNOWN_IDENTIFIER", "Unknown identifier: ".str_concat(name), "The identifier is not declared in local scope, global declarations, or imports.",
        fix_msg
        );
    }
    Ok<I32> { value: 0 }
}
fn resolve_expr_call(n: I32, globals: *mut Set<I32>, scopes: Vec<I32>, depth: I32) : Result<I32, ResolveError> => {
    let callee = node_get_data1(n)?;
    if (node_kind(callee) == NK_IDENTIFIER && get_interned_str(node_get_data1(callee)).str_eq("drop")) {
        let args = node_get_data2(n);
        if (args.vec_length() != 1) {
            return rslv_panic_loc("E_RESOLVE_UNKNOWN_IDENTIFIER", "drop expects exactly one argument", "Built-in drop requires exactly one receiver value.", "Use drop(value) or value.drop() with exactly one receiver value.");
        }
        resolve_expr(args.vec_get(0), globals, scopes, depth)?;
        return Ok<I32> { value: 0 };
    }
    if (node_kind(callee) == NK_IDENTIFIER && get_interned_str(node_get_data1(callee)).str_eq("into") && node_get_data3(n) == 1) {
        let args = node_get_data2(n);
        if (args.vec_length() < 1) {
            return rslv_panic_loc("E_RESOLVE_UNKNOWN_IDENTIFIER", "into conversion requires a receiver", "Method-sugar into conversion requires a source value as receiver.", "Use value.into<Contract>(...) with a receiver value.");
        }
        let type_args = node_get_data4(n);
        let contract_name = "";
        if (type_args.vec_length() == 1 && node_kind(type_args.vec_get(0)) == NK_NAMED_TYPE) {
            contract_name = get_interned_str(node_get_data1(type_args.vec_get(0)));
        }
        let contract_label = contract_name;
        if (contract_label.str_eq("")) {
            contract_label = "<missing>";
        }
        if (contract_name.str_eq("") || !globals.set_has(contract_name)) {
            return rslv_panic_loc("E_RESOLVE_UNKNOWN_IDENTIFIER", "Unknown contract '".str_concat(contract_label).str_concat("'"), "An into conversion referenced a contract that is not declared in scope.", "Use value.into<Contract>(...) with a declared contract name.");
        }
        resolve_expr(args.vec_get(0), globals, scopes, depth)?;
        let i = 1;
        let len = args.vec_length();
        while (i < len) {
            resolve_expr(args.vec_get(i), globals, scopes, depth)?;
            i = i + 1;
        }
        return Ok<I32> { value: 0 };
    }
    if (node_get_data3(n) != 1) {
        resolve_expr(node_get_data1(n), globals, scopes, depth)?;
    }
    let args = node_get_data2(n);
    let i = 0;
    let len = args.vec_length();
    while (i < len) {
        resolve_expr(args.vec_get(i), globals, scopes, depth)?;
        i = i + 1;
    }
    Ok<I32> { value: 0 }
}
fn resolve_expr_match (n: I32, globals: *mut Set<I32>, scopes: Vec<I32>, depth: I32) : Result<I32, ResolveError> => {
    resolve_expr(node_get_data1(n), globals, scopes, depth)?;
    let cases = node_get_data2(n);
    let i = 0;
    let len = cases.vec_length();
    while (i < len) {
        let case_node = cases.vec_get(i);
        let pat = case_node.vec_get(0);
        let body = case_node.vec_get(1);
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        if (node_kind(pat) == NK_STRUCT_PAT) {
            let fields = node_get_data2(pat);
            let j = 0;
            let fLen = fields.vec_length();
            while (j < fLen) {
                rslv_utils_scope_define(scopes, next_depth, get_interned_str(fields.vec_get(j)),
                pat);
                j = j + 1;
            }
        }
        else if (node_kind(pat) == NK_NAME_PAT) {
            let pat_name = get_interned_str(node_get_data1(pat));
            if (!globals.set_has(pat_name)) {
                rslv_utils_scope_define(scopes, next_depth, pat_name, pat);
            }
        }
        resolve_stmt(body, globals, scopes, next_depth)?;
        scopes.vec_pop();
        i = i + 1;
    }
    Ok<I32> { value: 0 }
}
fn resolve_expr_lambda(n: I32, globals: *mut Set<I32>, scopes: Vec<I32>, depth: I32) : Result<I32, ResolveError> => {
    let next_depth = depth + 1;
    scopes.vec_push(set_new());
    let params = node_get_data1(n);
    let i = 0;
    let len = params.vec_length();
    while (i < len) {
        let param = params.vec_get(i);
        rslv_utils_scope_define(scopes, next_depth, get_interned_str(param.vec_get(0)), n);
        i = i + 1;
    }
    resolve_stmt(node_get_data2(n), globals, scopes, next_depth)?;
    scopes.vec_pop();
    Ok<I32> { value: 0 }
}
fn resolve_expr_fn_expr(n: I32, globals: *mut Set<I32>, scopes: Vec<I32>, depth: I32) : Result<I32, ResolveError> => {
    let next_depth = depth + 1;
    scopes.vec_push(set_new());
    let fname_idx = node_get_data1(n);
    if (fname_idx != 0) {
        rslv_utils_scope_define(scopes, next_depth, get_interned_str(fname_idx), n);
    }
    let params = node_get_data3(n);
    let i = 0;
    let len = params.vec_length();
    while (i < len) {
        let param = params.vec_get(i);
        rslv_utils_scope_define(scopes, next_depth, get_interned_str(param.vec_get(0)), n);
        i = i + 1;
    }
    resolve_stmt(node_get_data5(n), globals, scopes, next_depth)?;
    scopes.vec_pop();
    Ok<I32> { value: 0 }
}
fn resolve_stmt_block(n: I32, globals: *mut Set<I32>, scopes: Vec<I32>, depth: I32) : Result<I32, ResolveError> => {
    let next_depth = depth + 1;
    scopes.vec_push(set_new());
    let stmts = node_get_data1(n);
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let stmt_kind = node_kind(stmt);
        if (stmt_kind == NK_FN_DECL || stmt_kind == NK_CLASS_FN_DECL || stmt_kind ==
        NK_ACTUAL_FN_DECL) {
            rslv_utils_scope_define(scopes, next_depth, get_interned_str(node_get_data1(stmt)),
            stmt);
        }
        i = i + 1;
    }
    i = 0;
    while (i < len) {
        resolve_stmt(stmts.vec_get(i), globals, scopes, next_depth)?;
        i = i + 1;
    }
    scopes.vec_pop();
    Ok<I32> { value: 0 }
}
fn resolve_stmt_fn_decl(n: I32, globals: *mut Set<I32>, scopes: Vec<I32>, depth: I32) : Result<I32, ResolveError> => {
    let next_depth = depth + 1;
    scopes.vec_push(set_new());
    let params = node_get_data3(n);
    let i = 0;
    let len = params.vec_length();
    while (i < len) {
        let param = params.vec_get(i);
        rslv_utils_scope_define(scopes, next_depth, get_interned_str(param.vec_get(0)), n);
        rslv_utils_resolve_type_lifetimes(param.vec_get(1), resolve_lifetime_scopes, n);
        i = i + 1;
    }
    rslv_utils_resolve_type_lifetimes(node_get_data4(n), resolve_lifetime_scopes, n);
    resolve_stmt(node_get_data5(n), globals, scopes, next_depth)?;
    scopes.vec_pop();
    Ok<I32> { value: 0 }
}
fn resolve_stmt_let_or_import(n: I32, globals: *mut Set<I32>, scopes: Vec<I32>, depth: I32) : Result<I32, ResolveError> => {
    let kind = node_kind(n)?;
    if (kind == NK_LET_DECL) {
        if (node_get_data2(n) != 0) {
            rslv_utils_resolve_type_lifetimes(node_get_data2(n), resolve_lifetime_scopes, n);
        }
        resolve_expr(node_get_data3(n), globals, scopes, depth)?;
        rslv_utils_scope_define(scopes, depth, get_interned_str(node_get_data1(n)), n);
        return Ok<I32> { value: 1 };
    }
    if (kind == NK_IMPORT_DECL) {
        let names = node_get_data1(n);
        let i = 0;
        let len = names.vec_length();
        while (i < len) {
            rslv_utils_scope_define(scopes, depth, get_interned_str(names.vec_get(i)), n);
            i = i + 1;
        }
        return Ok<I32> { value: 1 };
    }
    if (kind == NK_EXTERN_IMPORT_DECL) {
        return Ok<I32> { value: 1 };
    }
    Ok<I32> { value: 0 }
}
fn resolve_stmt_flow(n: I32, globals: *mut Set<I32>, scopes: Vec<I32>, depth: I32) : Result<I32, ResolveError> => {
    let kind = node_kind(n)?;
    if (kind == NK_EXPR_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth)?;
        return Ok<I32> { value: 1 };
    }
    if (kind == NK_ASSIGN_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth)?;
        resolve_expr(node_get_data2(n), globals, scopes, depth)?;
        return Ok<I32> { value: 1 };
    }
    if (kind == NK_RETURN_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth)?;
        return Ok<I32> { value: 1 };
    }
    if (kind == NK_IF_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth)?;
        resolve_stmt(node_get_data2(n), globals, scopes, depth)?;
        if (node_get_data3(n) != 0) {
            resolve_stmt(node_get_data3(n), globals, scopes, depth)?;
        }
        return Ok<I32> { value: 1 };
    }
    if (kind == NK_FOR_STMT) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        rslv_utils_scope_define(scopes, next_depth, get_interned_str(node_get_data1(n)), n);
        resolve_expr(node_get_data2(n), globals, scopes, next_depth)?;
        resolve_expr(node_get_data3(n), globals, scopes, next_depth)?;
        resolve_stmt(node_get_data4(n), globals, scopes, next_depth)?;
        scopes.vec_pop();
        return Ok<I32> { value: 1 };
    }
    if (kind == NK_WHILE_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth)?;
        resolve_stmt(node_get_data2(n), globals, scopes, depth)?;
        return Ok<I32> { value: 1 };
    }
    if (kind == NK_LOOP_STMT) {
        resolve_stmt(node_get_data1(n), globals, scopes, depth)?;
        return Ok<I32> { value: 1 };
    }
    Ok<I32> { value: 0 }
}
fn resolve_stmt_lifetime_or_into(n: I32, globals: *mut Set<I32>, scopes: Vec<I32>, depth: I32) : Result<I32, ResolveError> => {
    let kind = node_kind(n)?;
    if (kind == NK_LIFETIME_STMT) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        let lifetime_names = node_get_data1(n);
        let lifetime_scope = set_new();
        let i = 0;
        let len = lifetime_names.vec_length();
        while (i < len) {
            let lname = get_interned_str(lifetime_names.vec_get(i));
            if (lifetime_scope.set_has(lname)) {
                return rslv_panic_loc("E_RESOLVE_DUPLICATE_LIFETIME", "Duplicate lifetime name '".str_concat(lname).str_concat("' in lifetime block"), "A lifetime block contains duplicate lifetime names.", "Use unique lifetime names within a lifetime declaration block."
                );
            }
            lifetime_scope.set_add(lname);
            rslv_utils_scope_define(scopes, next_depth, lname, n);
            i = i + 1;
        }
        resolve_lifetime_scopes.vec_push(lifetime_scope);
        resolve_stmt(node_get_data2(n), globals, scopes, next_depth)?;
        resolve_lifetime_scopes.vec_pop();
        scopes.vec_pop();
        return Ok<I32> { value: 1 };
    }
    if (kind == NK_INTO_STMT) {
        let cname = get_interned_str(node_get_data1(n));
        if (!globals.set_has(cname)) {
            return rslv_panic_loc("E_RESOLVE_UNKNOWN_IDENTIFIER", "Unknown contract: ".str_concat(cname), "An into statement referenced a contract that is not declared in scope.", "Declare the contract before using 'into'.");
        }
        return Ok<I32> { value: 1 };
    }
    Ok<I32> { value: 0 }
}
fn resolve_expr(n: I32, globals: *mut Set<I32>, scopes: Vec<I32>, depth: I32) : Result<I32, ResolveError> => {
    if (n == 0) {
        return Ok<I32> { value: 0 };
    }
    rslv_current_node = n;
    let kind = node_kind(n);
    if (kind == NK_IDENTIFIER) {
        return resolve_expr_identifier(n, globals, scopes, depth);
    }
    if (kind == NK_BINARY_EXPR) {
        resolve_expr(node_get_data2(n), globals, scopes, depth)?;
        resolve_expr(node_get_data3(n), globals, scopes, depth)?;
        return Ok<I32> { value: 0 };
    }
    if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
        resolve_expr(node_get_data2(n), globals, scopes, depth)?;
        if (kind == NK_UNWRAP_EXPR) {
            resolve_expr(node_get_data1(n), globals, scopes, depth)?;
        }
        return Ok<I32> { value: 0 };
    }
    if (kind == NK_CALL_EXPR) {
        return resolve_expr_call(n, globals, scopes, depth);
    }
    if (kind == NK_MEMBER_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth)?;
        return Ok<I32> { value: 0 };
    }
    if (kind == NK_INDEX_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth)?;
        resolve_expr(node_get_data2(n), globals, scopes, depth)?;
        return Ok<I32> { value: 0 };
    }
    if (kind == NK_STRUCT_INIT) {
        let type_name = get_interned_str(node_get_data1(n));
        if (!globals.set_has(type_name)) {
            return rslv_panic_loc("E_RESOLVE_UNKNOWN_STRUCT", "Unknown struct/type in initializer: ".str_concat(type_name), "A struct initializer referenced a type that is not declared in the merged module scope.", "Declare the struct/type first or import the module that defines it."
            );
        }
        let fields = node_get_data2(n);
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            resolve_expr(field.vec_get(1), globals, scopes, depth)?;
            i = i + 1;
        }
        return Ok<I32> { value: 0 };
    }
    if (kind == NK_TUPLE_EXPR) {
        let items = node_get_data1(n);
        let i = 0;
        let len = items.vec_length();
        while (i < len) {
            resolve_expr(items.vec_get(i), globals, scopes, depth)?;
            i = i + 1;
        }
        return Ok<I32> { value: 0 };
    }
    if (kind == NK_IF_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth)?;
        resolve_stmt(node_get_data2(n), globals, scopes, depth)?;
        if (node_get_data3(n) != 0) {
            resolve_stmt(node_get_data3(n), globals, scopes, depth)?;
        }
        return Ok<I32> { value: 0 };
    }
    if (kind == NK_MATCH_EXPR) {
        return resolve_expr_match (n, globals, scopes, depth);
    }
    if (kind == NK_IS_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth)?;
        return Ok<I32> { value: 0 };
    }
    if (kind == NK_LAMBDA_EXPR) {
        return resolve_expr_lambda(n, globals, scopes, depth);
    }
    if (kind == NK_FN_EXPR) {
        return resolve_expr_fn_expr(n, globals, scopes, depth);
    }
    Ok<I32> { value: 0 }
}
fn resolve_stmt(n: I32, globals: *mut Set<I32>, scopes: Vec<I32>, depth: I32) : Result<I32, ResolveError> => {
    if (n == 0) {
        return Ok<I32> { value: 0 };
    }
    rslv_current_node = n;
    let kind = node_kind(n);
    if (kind == NK_BLOCK) {
        return resolve_stmt_block(n, globals, scopes, depth);
    }
    if (kind == NK_EXPECT_FN_DECL) {
        return Ok<I32> { value: 0 };
    }
    if (kind == NK_CONTRACT_DECL) {
        return Ok<I32> { value: 0 };
    }
    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
        return resolve_stmt_fn_decl(n, globals, scopes, depth);
    }
    if (resolve_stmt_let_or_import(n, globals, scopes, depth) == 1) {
        return Ok<I32> { value: 0 };
    }
    if (resolve_stmt_flow(n, globals, scopes, depth) == 1) {
        return Ok<I32> { value: 0 };
    }
    if (resolve_stmt_lifetime_or_into(n, globals, scopes, depth) == 1) {
        return Ok<I32> { value: 0 };
    }
    if (kind == NK_TYPE_ALIAS || kind == NK_DEP_TYPE_ALIAS ||
    kind == NK_STRUCT_DECL || kind == NK_ENUM_DECL ||
    kind == NK_EXTERN_LET_DECL ||
    kind == NK_EXTERN_TYPE_DECL || kind == NK_EXTERN_IMPORT_DECL ||
    kind == NK_OBJECT_DECL || kind == NK_CONTRACT_DECL ||
    kind == NK_EXPECT_FN_DECL) {
        return Ok<I32> { value: 0 };
    }
     // Fallback: treat unmatched nodes as expressions.
    resolve_expr(n, globals, scopes, depth)?;
    Ok<I32> { value: 0 }
}
out fn resolve_names(program: I32) : Result<I32, ResolveError> => {
    resolve_lifetime_scopes.vec_clear();
    resolve_global_names_list.vec_clear();
    resolve_global_decl_nodes = map_new();
    let globals = set_new();
    let body = node_get_data1(program);
    rslv_utils_validate_expect_actual_pairs(body);
     // Predeclare global symbols.
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        let stmt = body.vec_get(i);
        let kind = node_kind(stmt);
        if (
        kind == NK_FN_DECL ||
        kind == NK_CLASS_FN_DECL ||
        kind == NK_ACTUAL_FN_DECL ||
        kind == NK_STRUCT_DECL ||
        kind == NK_ENUM_DECL ||
        kind == NK_OBJECT_DECL ||
        kind == NK_CONTRACT_DECL ||
        kind == NK_TYPE_ALIAS ||
        kind == NK_DEP_TYPE_ALIAS ||
        kind == NK_LET_DECL ||
        kind == NK_EXTERN_LET_DECL ||
        kind == NK_EXTERN_TYPE_DECL
        ) {
            let gname = get_interned_str(node_get_data1(stmt));
            if (globals.set_has(gname)) {
                let first_node = resolve_global_decl_nodes.map_get(gname);
                let first_line = int_to_string(node_get_line(first_node));
                let first_col = int_to_string(node_get_col(first_node));
                rslv_panic_loc(
                "E_RESOLVE_SHADOWING",
                "Duplicate global declaration: ".str_concat(gname),
                "First declared at line ".str_concat(first_line).str_concat(", col ").str_concat(first_col).str_concat("."),
                "Rename one of the global declarations or split conflicting declarations into separate modules."
                );
            }
            globals.set_add(gname);
            resolve_global_names_list.vec_push(gname);
            resolve_global_decl_nodes.map_set(gname, stmt);
        }
        i = i + 1;
    }
     // Resolve top-level statements.
    let topScopes = vec_new();
    topScopes.vec_push(set_new());
    i = 0;
    while (i < len) {
        resolve_stmt(body.vec_get(i), globals, topScopes, 0)?;
        i = i + 1;
    }
    Ok<I32> { value: program }
}
out fn selfhost_resolver_marker() : I32 => 0;
