// ============================================================================
// Name Resolution - skip for now, minimal implementation
// ============================================================================

let { get_interned_str, set_new, vec_new } = selfhost::runtime_lexer;
let { node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5 } = selfhost::parser_core;

let resolve_lifetime_scopes : Vec = vec_new();

// Parallel list of declared global names so we can iterate for "did you mean?" suggestions.
let resolve_global_names_list : Vec = vec_new();

// Compute Levenshtein edit distance between two strings (two-row DP).
fn levenshtein_distance(a: *Str, b: *Str) : I32 => {
    let an = 0 + a.str_length();
    let bn = 0 + b.str_length();
    if (an == 0) { return bn; }
    if (bn == 0) { return an; }
    // Build two rows: prev[0..=bn], curr[0..=bn]
    let prev = vec_new();
    let curr = vec_new();
    let j = 0;
    while (j <= bn) {
        prev.vec_push(j);
        curr.vec_push(0);
        j = j + 1;
    }
    let i = 1;
    while (i <= an) {
        curr.vec_set(0, i);
        let j2 = 1;
        while (j2 <= bn) {
            let cost = 0;
            if (a.str_char_at(i - 1) != b.str_char_at(j2 - 1)) {
                cost = 1;
            }
            let del_cost = prev.vec_get(j2) + 1;
            let ins_cost = curr.vec_get(j2 - 1) + 1;
            let rep_cost = prev.vec_get(j2 - 1) + cost;
            let best = del_cost;
            if (ins_cost < best) { best = ins_cost; }
            if (rep_cost < best) { best = rep_cost; }
            curr.vec_set(j2, best);
            j2 = j2 + 1;
        }
        // Copy curr into prev for next iteration
        let k = 0;
        while (k <= bn) {
            prev.vec_set(k, curr.vec_get(k));
            k = k + 1;
        }
        i = i + 1;
    }
    prev.vec_get(bn)
}

// Return the closest candidate within threshold distance, or "" if none.
fn find_did_you_mean(name: *Str, candidates: Vec) : *Str => {
    let best = "";
    let best_dist = 9999;
    let name_len = 0 + name.str_length();
    let threshold = name_len / 3 + 1;
    if (threshold > 3) { threshold = 3; }
    let n = candidates.vec_length();
    let ci = 0;
    while (ci < n) {
        let cand = candidates.vec_get(ci);
        let dist = levenshtein_distance(name, cand);
        if (dist <= threshold && dist < best_dist) {
            best_dist = dist;
            best = cand;
        }
        ci = ci + 1;
    }
    best
}

fn lifetime_scope_has(name: *Str) : Bool => {
    let len = resolve_lifetime_scopes.vec_length();
    let mut i : I32 = 0;
    while (i < len) {
        if (resolve_lifetime_scopes.vec_get(i).set_has(name)) {
            return true;
        }
        i = i + 1;
    }
    false
}

fn resolve_type_lifetimes(t: I32) : I32 => {
    if (t == 0) {
        return 0;
    }
    let k = node_kind(t);
    if (k == NK_POINTER_TYPE) {
        let life_idx = node_get_data4(t);
        if (life_idx != 0) {
            let lname = get_interned_str(life_idx);
            if (!lifetime_scope_has(lname)) {
                panic_with_code(
                    "E_RESOLVE_UNDEFINED_LIFETIME",
                    "Undefined lifetime '".str_concat(lname).str_concat("'"),
                    "A pointer type annotation references a lifetime name that is not declared in any active lifetime block.",
                    "Declare the lifetime in an enclosing `lifetime ... { ... }` block before using it in pointer types."
                );
            }
        }
        resolve_type_lifetimes(node_get_data2(t));
        return 0;
    }
    if (k == NK_ARRAY_TYPE) {
        resolve_type_lifetimes(node_get_data1(t));
        return 0;
    }
    if (k == NK_REFINEMENT_TYPE) {
        resolve_type_lifetimes(node_get_data1(t));
        return 0;
    }
    if (k == NK_UNION_TYPE) {
        resolve_type_lifetimes(node_get_data1(t));
        resolve_type_lifetimes(node_get_data2(t));
        return 0;
    }
    if (k == NK_TUPLE_TYPE) {
        let members = node_get_data1(t);
        let i = 0;
        let len = members.vec_length();
        while (i < len) {
            resolve_type_lifetimes(members.vec_get(i));
            i = i + 1;
        }
        return 0;
    }
    if (k == NK_FUNCTION_TYPE) {
        let ps = node_get_data1(t);
        let i = 0;
        while (i < ps.vec_length()) {
            resolve_type_lifetimes(ps.vec_get(i));
            i = i + 1;
        }
        resolve_type_lifetimes(node_get_data2(t));
        return 0;
    }
    0
}

fn fn_type_sig(t: I32) : *Str => {
    if (t == 0) {
        return "_";
    }
    let k = node_kind(t);
    if (k == NK_NAMED_TYPE) {
        return get_interned_str(node_get_data1(t));
    }
    if (k == NK_POINTER_TYPE) {
        let mutv = node_get_data1(t);
        let inner = fn_type_sig(node_get_data2(t));
        let life_idx = node_get_data4(t);
        let life_prefix = "";
        if (life_idx != 0) {
            life_prefix = get_interned_str(life_idx).str_concat(" ");
        }
        if (mutv == 1) { return "*".str_concat(life_prefix).str_concat("mut ").str_concat(inner); }
        return "*".str_concat(life_prefix).str_concat(inner);
    }
    if (k == NK_ARRAY_TYPE) {
        return "Array";
    }
    if (k == NK_TUPLE_TYPE) {
        return "Tuple";
    }
    if (k == NK_REFINEMENT_TYPE) {
        return "Ref<".str_concat(fn_type_sig(node_get_data1(t))).str_concat(">");
    }
    if (k == NK_UNION_TYPE) {
        return fn_type_sig(node_get_data1(t)).str_concat("|").str_concat(fn_type_sig(node_get_data2(t)));
    }
    if (k == NK_FUNCTION_TYPE) {
        let parts = vec_new();
        let ps = node_get_data1(t);
        let i = 0;
        while (i < ps.vec_length()) {
            parts.vec_push(fn_type_sig(ps.vec_get(i)));
            i = i + 1;
        }
        return "(".str_concat(parts.vec_join(",")).str_concat(")=>").str_concat(fn_type_sig(node_get_data2(t)));
    }
    "Unknown"
}

fn fn_decl_sig(n: I32) : *Str => {
    let gens = node_get_data2(n);
    let params = node_get_data3(n);
    let ret = node_get_data4(n);
    let pparts = vec_new();
    let i = 0;
    while (i < params.vec_length()) {
        let p = params.vec_get(i);
        let pname = get_interned_str(p.vec_get(0));
        let ptype = fn_type_sig(p.vec_get(1));
        pparts.vec_push(pname.str_concat(":").str_concat(ptype));
        i = i + 1;
    }
    let gcount_len: I32 = 0;  // TODO: Fix USize to I32 conversion for gens.vec_length()
    let gcount = int_to_string(gcount_len);
    return "g=".str_concat(gcount).str_concat(";p=").str_concat(pparts.vec_join(",")).str_concat(";r=").str_concat(fn_type_sig(ret));
}

fn validate_expect_actual_pairs(body: Vec) : I32 => {
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        let stmt = body.vec_get(i);
        let kind = node_kind(stmt);
        if (kind == NK_EXPECT_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
            let name = get_interned_str(node_get_data1(stmt));
            let expect_count = 0;
            let actual_count = 0;
            let expect_node = 0;
            let actual_node = 0;
            let j = 0;
            while (j < len) {
                let cand = body.vec_get(j);
                let ck = node_kind(cand);
                if ((ck == NK_EXPECT_FN_DECL || ck == NK_ACTUAL_FN_DECL) && get_interned_str(node_get_data1(cand)).str_eq(name)) {
                    if (ck == NK_EXPECT_FN_DECL) {
                        expect_count = expect_count + 1;
                        expect_node = cand;
                    } else {
                        actual_count = actual_count + 1;
                        actual_node = cand;
                    }
                }
                j = j + 1;
            }
            if (expect_count != 1 || actual_count != 1) {
                panic_with_code(
                    "E_EXPECT_ACTUAL_PAIRING",
                    "expect/actual pairing requires exactly one expect and one actual for '".str_concat(name).str_concat("'"),
                    "Platform declarations require exactly one expect and one actual declaration for each symbol.",
                    "Declare exactly one 'expect fn' and one matching 'actual fn' for each platform symbol."
                );
            }
            if (!fn_decl_sig(expect_node).str_eq(fn_decl_sig(actual_node))) {
                panic_with_code(
                    "E_EXPECT_ACTUAL_SIGNATURE_MISMATCH",
                    "expect/actual signatures do not match for '".str_concat(name).str_concat("'"),
                    "An expect declaration and its actual implementation have different signatures.",
                    "Make generic params, parameter list, and return type identical between expect and actual declarations."
                );
            }
        }
        i = i + 1;
    }
    0
}

fn scope_define(scopes: Vec, depth: I32, name: *Str) : I32 => {
    let scope = scopes.vec_get(depth);
    if (scope.set_has(name)) {
        panic_with_code(
            "E_RESOLVE_SHADOWING",
            "Variable shadowing/redeclaration is not allowed: ".str_concat(name),
            "A name was declared multiple times in the same lexical scope.",
            "Rename one of the bindings or move it to a different scope."
        );
    }
    scope.set_add(name);
    0
}

fn scope_has(scopes: Vec, depth: I32, name: *Str) : Bool => {
    let i = depth;
    while (i >= 0) {
        if (scopes.vec_get(i).set_has(name)) {
            return true;
        }
        i = i - 1;
    }
    false
}

fn is_host_builtin_name(name: *Str) : Bool => {
    name.str_eq("sizeOf") ||
    name.str_eq("malloc") ||
    name.str_eq("realloc") ||
    name.str_eq("free") ||
    name.str_eq("memcpy") ||
    name.str_eq("memset") ||
    name.str_eq("drop") ||
    name.str_eq("panic") ||
    name.str_eq("this")
}

fn resolve_expr(n: I32, globals: *mut Set, scopes: Vec, depth: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_IDENTIFIER) {
        let name = get_interned_str(node_get_data1(n));
        if (!scope_has(scopes, depth, name) && !globals.set_has(name) && !is_host_builtin_name(name)) {
            let suggestion = find_did_you_mean(name, resolve_global_names_list);
            let fix_msg = "Declare the identifier before use or import it from the correct module.";
            if (!suggestion.str_eq("")) {
                fix_msg = "Did you mean '".str_concat(suggestion).str_concat("'? Declare or import it from the correct module.");
            }
            panic_with_code(
                "E_RESOLVE_UNKNOWN_IDENTIFIER",
                "Unknown identifier: ".str_concat(name),
                "The identifier is not declared in local scope, global declarations, or imports.",
                fix_msg
            );
        }
        return 0;
    }

    if (kind == NK_BINARY_EXPR) {
        resolve_expr(node_get_data2(n), globals, scopes, depth);
        resolve_expr(node_get_data3(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
        resolve_expr(node_get_data2(n), globals, scopes, depth);
        if (kind == NK_UNWRAP_EXPR) {
            resolve_expr(node_get_data1(n), globals, scopes, depth);
        }
        return 0;
    }

    if (kind == NK_CALL_EXPR) {
        let callee = node_get_data1(n);
        if (node_kind(callee) == NK_IDENTIFIER && get_interned_str(node_get_data1(callee)).str_eq("drop")) {
            let args = node_get_data2(n);
            if (args.vec_length() != 1) {
                panic_with_code(
                    "E_RESOLVE_UNKNOWN_IDENTIFIER",
                    "drop expects exactly one argument",
                    "Built-in drop requires exactly one receiver value.",
                    "Use drop(value) or value.drop() with exactly one receiver value."
                );
            }
            resolve_expr(args.vec_get(0), globals, scopes, depth);
            return 0;
        }

        if (node_kind(callee) == NK_IDENTIFIER && get_interned_str(node_get_data1(callee)).str_eq("into") && node_get_data3(n) == 1) {
            let args = node_get_data2(n);
            if (args.vec_length() < 1) {
                panic_with_code(
                    "E_RESOLVE_UNKNOWN_IDENTIFIER",
                    "into conversion requires a receiver",
                    "Method-sugar into conversion requires a source value as receiver.",
                    "Use value.into<Contract>(...) with a receiver value."
                );
            }

            let type_args = node_get_data4(n);
            let contract_name = "";
            if (type_args.vec_length() == 1 && node_kind(type_args.vec_get(0)) == NK_NAMED_TYPE) {
                contract_name = get_interned_str(node_get_data1(type_args.vec_get(0)));
            }
            let contract_label = contract_name;
            if (contract_label.str_eq("")) {
                contract_label = "<missing>";
            }

            if (contract_name.str_eq("") || !globals.set_has(contract_name)) {
                panic_with_code(
                    "E_RESOLVE_UNKNOWN_IDENTIFIER",
                    "Unknown contract '".str_concat(contract_label).str_concat("'"),
                    "An into conversion referenced a contract that is not declared in scope.",
                    "Use value.into<Contract>(...) with a declared contract name."
                );
            }

            resolve_expr(args.vec_get(0), globals, scopes, depth);
            let i = 1;
            let len = args.vec_length();
            while (i < len) {
                resolve_expr(args.vec_get(i), globals, scopes, depth);
                i = i + 1;
            }
            return 0;
        }

        if (node_get_data3(n) != 1) {
            resolve_expr(node_get_data1(n), globals, scopes, depth);
        }
        let args = node_get_data2(n);
        let i = 0;
        let len = args.vec_length();
        while (i < len) {
            resolve_expr(args.vec_get(i), globals, scopes, depth);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_MEMBER_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_INDEX_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_expr(node_get_data2(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_STRUCT_INIT) {
        let type_name = get_interned_str(node_get_data1(n));
        if (!globals.set_has(type_name)) {
            panic_with_code(
                "E_RESOLVE_UNKNOWN_STRUCT",
                "Unknown struct/type in initializer: ".str_concat(type_name),
                "A struct initializer referenced a type that is not declared in the merged module scope.",
                "Declare the struct/type first or import the module that defines it."
            );
        }
        let fields = node_get_data2(n);
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            resolve_expr(field.vec_get(1), globals, scopes, depth);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_TUPLE_EXPR) {
        let items = node_get_data1(n);
        let i = 0;
        let len = items.vec_length();
        while (i < len) {
            resolve_expr(items.vec_get(i), globals, scopes, depth);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IF_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_stmt(node_get_data2(n), globals, scopes, depth);
        if (node_get_data3(n) != 0) {
            resolve_stmt(node_get_data3(n), globals, scopes, depth);
        }
        return 0;
    }

    if (kind == NK_MATCH_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        let cases = node_get_data2(n);
        let i = 0;
        let len = cases.vec_length();
        while (i < len) {
            let case_node = cases.vec_get(i);
            let pat = case_node.vec_get(0);
            let body = case_node.vec_get(1);

            let next_depth = depth + 1;
            scopes.vec_push(set_new());

            if (node_kind(pat) == NK_STRUCT_PAT) {
                let fields = node_get_data2(pat);
                let j = 0;
                let fLen = fields.vec_length();
                while (j < fLen) {
                    scope_define(scopes, next_depth, get_interned_str(fields.vec_get(j)));
                    j = j + 1;
                }
            } else if (node_kind(pat) == NK_NAME_PAT) {
                let pat_name = get_interned_str(node_get_data1(pat));
                if (!globals.set_has(pat_name)) {
                    scope_define(scopes, next_depth, pat_name);
                }
            }

            resolve_stmt(body, globals, scopes, next_depth);
            scopes.vec_pop();
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IS_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_LAMBDA_EXPR) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        let params = node_get_data1(n);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let param = params.vec_get(i);
            scope_define(scopes, next_depth, get_interned_str(param.vec_get(0)));
            i = i + 1;
        }
        resolve_stmt(node_get_data2(n), globals, scopes, next_depth);
        scopes.vec_pop();
        return 0;
    }

    if (kind == NK_FN_EXPR) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        let fname_idx = node_get_data1(n);
        if (fname_idx != 0) {
            scope_define(scopes, next_depth, get_interned_str(fname_idx));
        }
        let params = node_get_data3(n);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let param = params.vec_get(i);
            scope_define(scopes, next_depth, get_interned_str(param.vec_get(0)));
            i = i + 1;
        }
        resolve_stmt(node_get_data5(n), globals, scopes, next_depth);
        scopes.vec_pop();
        return 0;
    }

    0
}

fn resolve_stmt(n: I32, globals: *mut Set, scopes: Vec, depth: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_BLOCK) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        let stmts = node_get_data1(n);
        let i = 0;
        let len = stmts.vec_length();

        // Predeclare local functions for forward references within the same block.
        while (i < len) {
            let stmt = stmts.vec_get(i);
            let stmt_kind = node_kind(stmt);
            if (stmt_kind == NK_FN_DECL || stmt_kind == NK_CLASS_FN_DECL || stmt_kind == NK_ACTUAL_FN_DECL) {
                scope_define(scopes, next_depth, get_interned_str(node_get_data1(stmt)));
            }
            i = i + 1;
        }

        i = 0;
        while (i < len) {
            resolve_stmt(stmts.vec_get(i), globals, scopes, next_depth);
            i = i + 1;
        }
        scopes.vec_pop();
        return 0;
    }

    if (kind == NK_EXPECT_FN_DECL) {
        return 0;
    }

    if (kind == NK_CONTRACT_DECL) {
        return 0;
    }

    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        let params = node_get_data3(n);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let param = params.vec_get(i);
            scope_define(scopes, next_depth, get_interned_str(param.vec_get(0)));
            resolve_type_lifetimes(param.vec_get(1));
            i = i + 1;
        }
        resolve_type_lifetimes(node_get_data4(n));
        resolve_stmt(node_get_data5(n), globals, scopes, next_depth);
        scopes.vec_pop();
        return 0;
    }

    if (kind == NK_LET_DECL) {
        if (node_get_data2(n) != 0) {
            resolve_type_lifetimes(node_get_data2(n));
        }
        resolve_expr(node_get_data3(n), globals, scopes, depth);
        scope_define(scopes, depth, get_interned_str(node_get_data1(n)));
        return 0;
    }

    if (kind == NK_IMPORT_DECL) {
        let names = node_get_data1(n);
        let i = 0;
        let len = names.vec_length();
        while (i < len) {
            scope_define(scopes, depth, get_interned_str(names.vec_get(i)));
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_EXTERN_IMPORT_DECL) {
        return 0;
    }

    if (kind == NK_EXPR_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_ASSIGN_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_expr(node_get_data2(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_RETURN_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_IF_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_stmt(node_get_data2(n), globals, scopes, depth);
        if (node_get_data3(n) != 0) {
            resolve_stmt(node_get_data3(n), globals, scopes, depth);
        }
        return 0;
    }

    if (kind == NK_FOR_STMT) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        scope_define(scopes, next_depth, get_interned_str(node_get_data1(n)));
        resolve_expr(node_get_data2(n), globals, scopes, next_depth);
        resolve_expr(node_get_data3(n), globals, scopes, next_depth);
        resolve_stmt(node_get_data4(n), globals, scopes, next_depth);
        scopes.vec_pop();
        return 0;
    }

    if (kind == NK_WHILE_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_stmt(node_get_data2(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_LOOP_STMT) {
        resolve_stmt(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_LIFETIME_STMT) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());

        let lifetime_names = node_get_data1(n);
        let lifetime_scope = set_new();
        let i = 0;
        let len = lifetime_names.vec_length();
        while (i < len) {
            let lname = get_interned_str(lifetime_names.vec_get(i));
            if (lifetime_scope.set_has(lname)) {
                panic_with_code(
                    "E_RESOLVE_DUPLICATE_LIFETIME",
                    "Duplicate lifetime name '".str_concat(lname).str_concat("' in lifetime block"),
                    "A lifetime block contains duplicate lifetime names.",
                    "Use unique lifetime names within a lifetime declaration block."
                );
            }
            lifetime_scope.set_add(lname);
            scope_define(scopes, next_depth, lname);
            i = i + 1;
        }

        resolve_lifetime_scopes.vec_push(lifetime_scope);
        resolve_stmt(node_get_data2(n), globals, scopes, next_depth);
        resolve_lifetime_scopes.vec_pop();
        scopes.vec_pop();
        return 0;
    }

    if (kind == NK_INTO_STMT) {
        let cname = get_interned_str(node_get_data1(n));
        if (!globals.set_has(cname)) {
            panic_with_code(
                "E_RESOLVE_UNKNOWN_IDENTIFIER",
                "Unknown contract: ".str_concat(cname),
                "An into statement referenced a contract that is not declared in scope.",
                "Declare the contract before using 'into'."
            );
        }
        return 0;
    }

    // Fallback: treat unmatched nodes as expressions.
    resolve_expr(n, globals, scopes, depth);
    0
}

out fn resolve_names(program: I32) : I32 => {
    resolve_lifetime_scopes.vec_clear();
    resolve_global_names_list.vec_clear();

    let globals = set_new();
    let body = node_get_data1(program);

    validate_expect_actual_pairs(body);

    // Predeclare global symbols.
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        let stmt = body.vec_get(i);
        let kind = node_kind(stmt);
        if (
            kind == NK_FN_DECL ||
            kind == NK_CLASS_FN_DECL ||
            kind == NK_ACTUAL_FN_DECL ||
            kind == NK_STRUCT_DECL ||
            kind == NK_ENUM_DECL ||
            kind == NK_OBJECT_DECL ||
            kind == NK_CONTRACT_DECL ||
            kind == NK_TYPE_ALIAS ||
            kind == NK_LET_DECL ||
            kind == NK_EXTERN_FN_DECL ||
            kind == NK_EXTERN_LET_DECL ||
            kind == NK_EXTERN_TYPE_DECL
        ) {
            let gname = get_interned_str(node_get_data1(stmt));
            if (globals.set_has(gname)) {
                panic_with_code(
                    "E_RESOLVE_SHADOWING",
                    "Variable shadowing/redeclaration is not allowed: ".str_concat(gname),
                    "A global declaration with the same name already exists.",
                    "Rename one of the global declarations or split conflicting declarations into separate modules."
                );
            }
            globals.set_add(gname);
            resolve_global_names_list.vec_push(gname);
        }
        i = i + 1;
    }

    // Resolve top-level statements.
    let topScopes = vec_new();
    topScopes.vec_push(set_new());
    i = 0;
    while (i < len) {
        resolve_stmt(body.vec_get(i), globals, topScopes, 0);
        i = i + 1;
    }

    program
}

out fn selfhost_resolver_marker() : I32 => 0;
