let { get_interned_str, vec_new } = selfhost::runtime_lexer;
let { node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5 } = selfhost::parser_core;

fn emit_stmt(n: I32) : *Str => {
    let kind = node_kind(n);
    
    if (kind == NK_LET_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        let value = emit_expr(node_get_data3(n));
        return "let ".str_concat(name).str_concat(" = ").str_concat(value.str_concat(";"));
    }
    
    if (kind == NK_IMPORT_DECL) {
        return "// import placeholder";
    }
    
    if (kind == NK_EXPR_STMT) {
        return emit_expr(node_get_data1(n)).str_concat(";");
    }
    
    if (kind == NK_ASSIGN_STMT) {
        let target = emit_expr(node_get_data1(n));
        let value = emit_expr(node_get_data2(n));
        return target.str_concat(" = ").str_concat(value).str_concat(";");
    }
    
    if (kind == NK_RETURN_STMT) {
        let value = node_get_data1(n);
        if (value == 0) {
            return "return;";
        }
        return "return ".str_concat(emit_expr(value).str_concat(";"));
    }
    
    if (kind == NK_IF_STMT) {
        let cond = emit_expr(node_get_data1(n));
        let then_b = emit_block(node_get_data2(n));
        let else_b = node_get_data3(n);
        if (else_b == 0) {
            return "if (".str_concat(cond).str_concat(") ".str_concat(then_b));
        }
        return str_concat("if (".str_concat(cond).str_concat(") ").str_concat(then_b), " else ".str_concat(emit_stmt_or_block(else_b)));
    }
    
    // IfExpr used as statement (e.g., in else-if chains)
    if (kind == NK_IF_EXPR) {
        let cond = emit_expr(node_get_data1(n));
        let then_b = node_get_data2(n);
        let else_b = node_get_data3(n);
        let then_str = emit_stmt_or_block(then_b);
        if (else_b == 0) {
            return "if (".str_concat(cond).str_concat(") ".str_concat(then_str));
        }
        return str_concat("if (".str_concat(cond).str_concat(") ").str_concat(then_str), " else ".str_concat(emit_stmt_or_block(else_b)));
    }
    
    if (kind == NK_WHILE_STMT) {
        let cond = emit_expr(node_get_data1(n));
        let body = emit_block(node_get_data2(n));
        return "while (".str_concat(cond).str_concat(") ".str_concat(body));
    }
    
    if (kind == NK_FOR_STMT) {
        let iter_idx = node_get_data1(n);
        let iter = get_interned_str(iter_idx);
        let start = emit_expr(node_get_data2(n));
        let end = emit_expr(node_get_data3(n));
        let body = emit_block(node_get_data4(n));
        return str_concat(str_concat(str_concat(str_concat("for (let ".str_concat(iter).str_concat(" = ").str_concat(start), "; ".str_concat(iter)), " < ".str_concat(end)), "; ".str_concat(iter.str_concat("++) "))), body);
    }
    
    if (kind == NK_BREAK_STMT) {
        return "break;";
    }
    
    if (kind == NK_CONTINUE_STMT) {
        return "continue;";
    }
    
    if (kind == NK_BLOCK) {
        return emit_block(n);
    }
    
    if (kind == NK_EXPECT_FN_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// expect fn ".str_concat(name);
    }

    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        let params = node_get_data3(n);
        let body = node_get_data5(n);
        
        let param_names = vec_new();
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let param = params.vec_get(i);
            param_names.vec_push(get_interned_str(param.vec_get(0)));
            i = i + 1;
        }
        let params_str = param_names.vec_join(", ");
        
        if (node_kind(body) == NK_BLOCK) {
            return "function ".str_concat(name).str_concat("(".str_concat(params_str)).str_concat(") ".str_concat(emit_fn_block(body)));
        }
        return str_concat("function ".str_concat(name).str_concat("(".str_concat(params_str)).str_concat(") { return "), emit_expr(body).str_concat("; }"));
    }
    
    if (kind == NK_STRUCT_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        let fields = node_get_data3(n);
        let sb = sb_new();
        sb_append(sb, "function ");
        sb_append(sb, name);
        sb_append(sb, "(fields = {}) { return { __tag: \"");
        sb_append(sb, name);
        sb_append(sb, "\"");
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            let fname = get_interned_str(field.vec_get(0));
            sb_append(sb, ", ");
            sb_append(sb, fname);
            sb_append(sb, ": fields.");
            sb_append(sb, fname);
            i = i + 1;
        }
        sb_append(sb, " }; }");
        return sb_build(sb);
    }
    
    if (kind == NK_TYPE_ALIAS) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// type ".str_concat(name).str_concat(" = ...");
    }

    if (kind == NK_ENUM_DECL) {
        let name = get_interned_str(node_get_data1(n));
        let variants = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "const ");
        sb_append(sb, name);
        sb_append(sb, " = { ");
        let i = 0;
        let len = variants.vec_length();
        while (i < len) {
            if (i > 0) {
                sb_append(sb, ", ");
            }
            let v = get_interned_str(variants.vec_get(i));
            sb_append(sb, v);
            sb_append(sb, ": { __tag: \"");
            sb_append(sb, v);
            sb_append(sb, "\" }");
            i = i + 1;
        }
        sb_append(sb, " }; ");
        return sb_build(sb);
    }
    
    if (kind == NK_EXTERN_FN_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// extern fn ".str_concat(name);
    }
    
    if (kind == NK_EXTERN_LET_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// extern let ".str_concat(name);
    }
    
    if (kind == NK_EXTERN_TYPE_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// extern type ".str_concat(name);
    }
    
    ""
}

fn emit_stmt_or_block(n: I32) : *Str => {
    if (node_kind(n) == NK_BLOCK) {
        return emit_block(n);
    }
    "{ ".str_concat(emit_stmt(n).str_concat(" }"))
}

fn emit_block(n: I32) : *Str => {
    let stmts = node_get_data1(n);
    let sb = sb_new();
    sb_append(sb, "{\n");
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        sb_append(sb, "  ");
        sb_append(sb, emit_stmt(stmts.vec_get(i)));
        sb_append(sb, "\n");
        i = i + 1;
    }
    sb_append(sb, "}");
    sb_build(sb)
}

// Emit a block wrapped in an IIFE for use in expressions
fn emit_block_as_iife(n: I32) : *Str => {
    let stmts = node_get_data1(n);
    let len = stmts.vec_length();
    if (len == 0) {
        return "(() => undefined)()";
    }
    let sb = sb_new();
    sb_append(sb, "(() => {\n");
    let i = 0;
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let is_last = i == len - 1;
        let kind = node_kind(stmt);
        if (is_last && kind == NK_EXPR_STMT) {
            sb_append(sb, "  return ");
            sb_append(sb, emit_expr(node_get_data1(stmt)));
            sb_append(sb, ";\n");
        } else if (is_last && (kind == NK_IF_STMT || kind == NK_IF_EXPR)) {
            sb_append(sb, "  return ");
            sb_append(sb, emit_if_as_expr(stmt));
            sb_append(sb, ";\n");
        } else {
            sb_append(sb, "  ");
            sb_append(sb, emit_stmt(stmt));
            sb_append(sb, "\n");
        }
        i = i + 1;
    }
    sb_append(sb, "})()");
    sb_build(sb)
}

fn emit_fn_block(n: I32) : *Str => {
    let stmts = node_get_data1(n);
    let len = stmts.vec_length();
    if (len == 0) {
        return "{\n}";
    }
    let sb = sb_new();
    sb_append(sb, "{\n");
    let i = 0;
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let is_last = i == len - 1;
        let kind = node_kind(stmt);
        if (is_last && kind == NK_EXPR_STMT) {
            sb_append(sb, "  return ");
            sb_append(sb, emit_expr(node_get_data1(stmt)));
            sb_append(sb, ";\n");
        } else if (is_last && (kind == NK_IF_STMT || kind == NK_IF_EXPR)) {
            // Return the result of the if expression
            sb_append(sb, "  return ");
            sb_append(sb, emit_if_as_expr(stmt));
            sb_append(sb, ";\n");
        } else {
            sb_append(sb, "  ");
            sb_append(sb, emit_stmt(stmt));
            sb_append(sb, "\n");
        }
        i = i + 1;
    }
    sb_append(sb, "}");
    sb_build(sb)
}

// Emit an if statement as a ternary expression
fn emit_if_as_expr(n: I32) : *Str => {
    let cond = emit_expr(node_get_data1(n));
    let then_branch = node_get_data2(n);
    let else_branch = node_get_data3(n);
    
    let then_code = emit_branch_as_expr(then_branch);
    let else_code = if (else_branch == 0) { "undefined" } else { emit_branch_as_expr(else_branch) };
    
    str_concat("((".str_concat(cond).str_concat(") ? ").str_concat(then_code.str_concat(" : ")), else_code.str_concat(")"))
}

fn emit_branch_as_expr(n: I32) : *Str => {
    let kind = node_kind(n);
    if (kind == NK_BLOCK) {
        // Wrap block in IIFE
        let stmts = node_get_data1(n);
        let len = stmts.vec_length();
        if (len == 0) {
            return "undefined";
        }
        let sb = sb_new();
        sb_append(sb, "(() => {\n");
        let i = 0;
        while (i < len) {
            let stmt = stmts.vec_get(i);
            let is_last = i == len - 1;
            let stmt_kind = node_kind(stmt);
            if (is_last && stmt_kind == NK_EXPR_STMT) {
                sb_append(sb, "    return ");
                sb_append(sb, emit_expr(node_get_data1(stmt)));
                sb_append(sb, ";\n");
            } else if (is_last && (stmt_kind == NK_IF_STMT || stmt_kind == NK_IF_EXPR)) {
                sb_append(sb, "    return ");
                sb_append(sb, emit_if_as_expr(stmt));
                sb_append(sb, ";\n");
            } else {
                sb_append(sb, "    ");
                sb_append(sb, emit_stmt(stmt));
                sb_append(sb, "\n");
            }
            i = i + 1;
        }
        sb_append(sb, "  })()");
        return sb_build(sb);
    }
    if (kind == NK_IF_STMT || kind == NK_IF_EXPR) {
        return emit_if_as_expr(n);
    }
    emit_expr(n)
}

out fn generate_js(program: I32) : *Str => {
    let stmts = node_get_data1(program);
    let sb = sb_new();
    sb_append(sb, "\"use strict\";\n\n");
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        sb_append(sb, emit_stmt(stmts.vec_get(i)));
        sb_append(sb, "\n\n");
        i = i + 1;
    }
    sb_build(sb)
}

out fn selfhost_codegen_stmt_marker() : I32 => 0;
