let { get_interned_str, vec_new, map_new } = selfhost::runtime_lexer;
let { node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5 } = selfhost::parser_core;

// === JS emit context stack for tracking 'this' ===
// Each frame: [has_explicit_this: I32, fn_name: *Str]
let js_fn_stack = vec_new();

fn js_fn_stack_push(has_explicit_this: I32, fn_name: *Str) : Void => {
    let frame = vec_new();
    let _a = frame.vec_push(has_explicit_this);
    let _b = frame.vec_push(fn_name);
    let _c = js_fn_stack.vec_push(frame);
}

fn js_fn_stack_pop() : Void => {
    // Use let binding to discard the popped value, avoiding Void/I32 return mismatch.
    let _pop = js_fn_stack.vec_pop();
}

fn js_stack_in_synthetic_this() : Bool => {
    let h = js_fn_stack.vec_length();
    if (h == 0) { return false; }
    let frame = js_fn_stack.vec_get(h - 1);
    frame.vec_get(0) == 0
}

fn js_this_expr() : *Str => {
    let h = js_fn_stack.vec_length();
    if (h == 0) { return "__tuff_this"; }
    let frame = js_fn_stack.vec_get(h - 1);
    if (frame.vec_get(0) == 1) { return "__this_param"; }
    "__tuff_this"
}

fn js_ident_stmt(name: *Str) : *Str => {
    // 'this' is a reserved word in JavaScript; use context-aware resolution.
    if (name.str_eq("this")) {
        return js_this_expr();
    }
    name
}

fn emit_stmt(n: I32) : *Str => {
    let kind = node_kind(n);
    
    if (kind == NK_LET_DECL) {
        let name_idx = node_get_data1(n);
        let name = js_ident_stmt(get_interned_str(name_idx));
        let value = emit_expr(node_get_data3(n));
        let decl = "let ".str_concat(name).str_concat(" = ").str_concat(value.str_concat(";"));
        if (name.str_eq("__this_param")) {
            return decl;
        }
        return decl.str_concat(" if (typeof __tuff_this !== 'undefined') __tuff_this.").str_concat(name).str_concat(" = ").str_concat(name).str_concat(";");
    }
    
    if (kind == NK_IMPORT_DECL) {
        return "// import placeholder";
    }
    
    if (kind == NK_EXPR_STMT) {
        return emit_expr(node_get_data1(n)).str_concat(";");
    }
    
    if (kind == NK_ASSIGN_STMT) {
        let target_node = node_get_data1(n);
        let target = emit_expr(target_node);
        let value = emit_expr(node_get_data2(n));
        let assign = target.str_concat(" = ").str_concat(value).str_concat(";");
        
        if (node_kind(target_node) == NK_IDENTIFIER) {
            let name = get_interned_str(node_get_data1(target_node));
            let js_name = js_ident_stmt(name);
            if (!js_name.str_eq("__this_param")) {
                return assign.str_concat(" if (typeof __tuff_this !== 'undefined') __tuff_this.").str_concat(js_name).str_concat(" = ").str_concat(js_name).str_concat(";");
            }
        }
        
        if (node_kind(target_node) == NK_MEMBER_EXPR) {
            let obj_node = node_get_data1(target_node);
            if (node_kind(obj_node) == NK_IDENTIFIER) {
                let obj_name = get_interned_str(node_get_data1(obj_node));
                if (obj_name.str_eq("this")) {
                    let prop = get_interned_str(node_get_data2(target_node));
                    return "if (typeof __this_param !== 'undefined') { __this_param.".str_concat(prop).str_concat(" = ").str_concat(value).str_concat("; } else { ").str_concat(prop).str_concat(" = ").str_concat(value).str_concat("; if (typeof __tuff_this !== 'undefined') __tuff_this.").str_concat(prop).str_concat(" = ").str_concat(prop).str_concat("; }");
                }
            }
        }
        
        return assign;
    }
    
    if (kind == NK_RETURN_STMT) {
        let value = node_get_data1(n);
        if (value == 0) {
            return "return;";
        }
        return "return ".str_concat(emit_expr(value).str_concat(";"));
    }
    
    if (kind == NK_IF_STMT) {
        let cond = emit_expr(node_get_data1(n));
        let then_b = emit_block(node_get_data2(n));
        let else_b = node_get_data3(n);
        if (else_b == 0) {
            return "if (".str_concat(cond).str_concat(") ".str_concat(then_b));
        }
        return str_concat("if (".str_concat(cond).str_concat(") ").str_concat(then_b), " else ".str_concat(emit_stmt_or_block(else_b)));
    }
    
    // IfExpr used as statement (e.g., in else-if chains)
    if (kind == NK_IF_EXPR) {
        let cond = emit_expr(node_get_data1(n));
        let then_b = node_get_data2(n);
        let else_b = node_get_data3(n);
        let then_str = emit_stmt_or_block(then_b);
        if (else_b == 0) {
            return "if (".str_concat(cond).str_concat(") ".str_concat(then_str));
        }
        return str_concat("if (".str_concat(cond).str_concat(") ").str_concat(then_str), " else ".str_concat(emit_stmt_or_block(else_b)));
    }
    
    if (kind == NK_WHILE_STMT) {
        let cond = emit_expr(node_get_data1(n));
        let body = emit_block(node_get_data2(n));
        return "while (".str_concat(cond).str_concat(") ".str_concat(body));
    }
    
    if (kind == NK_FOR_STMT) {
        let iter_idx = node_get_data1(n);
        let iter = js_ident_stmt(get_interned_str(iter_idx));
        let start = emit_expr(node_get_data2(n));
        let end = emit_expr(node_get_data3(n));
        let body = emit_block(node_get_data4(n));
        return str_concat(str_concat(str_concat(str_concat("for (let ".str_concat(iter).str_concat(" = ").str_concat(start), "; ".str_concat(iter)), " < ".str_concat(end)), "; ".str_concat(iter.str_concat("++) "))), body);
    }

    if (kind == NK_LOOP_STMT) {
        let body = emit_block(node_get_data1(n));
        return "while (true) ".str_concat(body);
    }
    
    if (kind == NK_BREAK_STMT) {
        return "break;";
    }
    
    if (kind == NK_CONTINUE_STMT) {
        return "continue;";
    }

    if (kind == NK_INTO_STMT) {
        let cname = get_interned_str(node_get_data1(n));
        return "// into ".str_concat(cname);
    }

    if (kind == NK_LIFETIME_STMT) {
        return emit_block(node_get_data2(n));
    }
    
    if (kind == NK_BLOCK) {
        return emit_block(n);
    }
    
    if (kind == NK_EXPECT_FN_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// expect fn ".str_concat(name);
    }

    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        let params = node_get_data3(n);
        let body = node_get_data5(n);
        
        let param_names = vec_new();
        let has_explicit_this = 0;
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let param = params.vec_get(i);
            let pname = get_interned_str(param.vec_get(0));
            if (pname.str_eq("this")) {
                has_explicit_this = 1;
                // Explicit this param always becomes __this_param in JS signature
                param_names.vec_push("__this_param");
            } else {
                param_names.vec_push(pname);
            }
            i = i + 1;
        }
        let params_str = param_names.vec_join(", ");
        
        let capture_var = "__tuff_outer_for_".str_concat(name);
        let preamble = "";
        let init_this = "";
        let suffix = "";
        
        if (has_explicit_this == 1) {
            // Alias __tuff_this to __this_param so body 'this' refs work,
            // but mark as non-mirrorable by using typeof undefined check below.
            init_this = "let __tuff_this = undefined;\n";
        } else {
            preamble = "const ".str_concat(capture_var).str_concat(" = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;\n");
            let fields = vec_new();
            let j = 0;
            while (j < len) {
                let param = params.vec_get(j);
                let pname = get_interned_str(param.vec_get(0));
                if (!pname.str_eq("this")) {
                    fields.vec_push(pname.str_concat(": ").str_concat(pname));
                }
                j = j + 1;
            }
            fields.vec_push("this: ".str_concat(capture_var));
            init_this = "let __tuff_this = { ".str_concat(fields.vec_join(", ")).str_concat(" };\n");
            suffix = "\nif (typeof __tuff_this !== 'undefined') __tuff_this.".str_concat(name).str_concat(" = ").str_concat(name).str_concat(";");
        }
        
        if (node_kind(body) == NK_BLOCK) {
            return preamble.str_concat("function ".str_concat(name).str_concat("(".str_concat(params_str)).str_concat(") ".str_concat(emit_fn_block_with_init(body, init_this)))).str_concat(suffix);
        }
        return preamble.str_concat("function ".str_concat(name).str_concat("(".str_concat(params_str)).str_concat(") {\n  ").str_concat(init_this).str_concat("  return ").str_concat(emit_expr(body)).str_concat(";\n}")).str_concat(suffix);
    }
    
    if (kind == NK_STRUCT_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        let fields = node_get_data3(n);
        let sb = sb_new();
        sb_append(sb, "function ");
        sb_append(sb, name);
        sb_append(sb, "(fields = {}) { return { __tag: \"");
        sb_append(sb, name);
        sb_append(sb, "\"");
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            let fname = get_interned_str(field.vec_get(0));
            sb_append(sb, ", ");
            sb_append(sb, fname);
            sb_append(sb, ": fields.");
            sb_append(sb, fname);
            i = i + 1;
        }
        sb_append(sb, " }; }");
        return sb_build(sb);
    }
    
    if (kind == NK_TYPE_ALIAS) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// type ".str_concat(name).str_concat(" = ...");
    }

    if (kind == NK_ENUM_DECL) {
        let name = get_interned_str(node_get_data1(n));
        let variants = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "const ");
        sb_append(sb, name);
        sb_append(sb, " = { ");
        let i = 0;
        let len = variants.vec_length();
        while (i < len) {
            if (i > 0) {
                sb_append(sb, ", ");
            }
            let v = get_interned_str(variants.vec_get(i));
            sb_append(sb, v);
            sb_append(sb, ": { __tag: \"");
            sb_append(sb, v);
            sb_append(sb, "\" }");
            i = i + 1;
        }
        sb_append(sb, " }; ");
        return sb_build(sb);
    }

    if (kind == NK_OBJECT_DECL) {
        let name = get_interned_str(node_get_data1(n));
        let inputs = node_get_data3(n);
        if (inputs == 0 || inputs.vec_length() == 0) {
            return "const ".str_concat(name).str_concat(" = { __tag: \"").str_concat(name).str_concat("\" }; ");
        }

        let sb = sb_new();
        sb_append(sb, "const ");
        sb_append(sb, name);
        sb_append(sb, " = (() => { const __cache = new Map(); return (fields = {}) => { const __key = JSON.stringify([");

        let i = 0;
        let len = inputs.vec_length();
        while (i < len) {
            if (i > 0) {
                sb_append(sb, ", ");
            }
            let input_field = inputs.vec_get(i);
            let fname = get_interned_str(input_field.vec_get(0));
            sb_append(sb, "fields.");
            sb_append(sb, fname);
            i = i + 1;
        }

        sb_append(sb, "]); const __cached = __cache.get(__key); if (__cached !== undefined) return __cached; const __value = { __tag: \"");
        sb_append(sb, name);
        sb_append(sb, "\"");

        i = 0;
        while (i < len) {
            let input_field = inputs.vec_get(i);
            let fname = get_interned_str(input_field.vec_get(0));
            sb_append(sb, ", ");
            sb_append(sb, fname);
            sb_append(sb, ": fields.");
            sb_append(sb, fname);
            i = i + 1;
        }

        sb_append(sb, " }; __cache.set(__key, __value); return __value; }; })();");
        return sb_build(sb);
    }

    if (kind == NK_CONTRACT_DECL) {
        let name = get_interned_str(node_get_data1(n));
        return "// contract ".str_concat(name);
    }
    
    if (kind == NK_EXTERN_FN_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// extern fn ".str_concat(name);
    }
    
    if (kind == NK_EXTERN_LET_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// extern let ".str_concat(name);
    }
    
    if (kind == NK_EXTERN_TYPE_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// extern type ".str_concat(name);
    }

    if (kind == NK_EXTERN_IMPORT_DECL) {
        let parts = node_get_data2(n);
        let i = 0;
        let source = "";
        while (i < parts.vec_length()) {
            if (i > 0) {
                source = source.str_concat("::");
            }
            source = source.str_concat(get_interned_str(parts.vec_get(i)));
            i = i + 1;
        }
        return "// extern from ".str_concat(source);
    }
    
    ""
}

fn emit_stmt_or_block(n: I32) : *Str => {
    if (node_kind(n) == NK_BLOCK) {
        return emit_block(n);
    }
    "{ ".str_concat(emit_stmt(n).str_concat(" }"))
}

fn emit_block(n: I32) : *Str => {
    let stmts = node_get_data1(n);
    let sb = sb_new();
    sb_append(sb, "{\n");
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        sb_append(sb, "  ");
        sb_append(sb, emit_stmt(stmts.vec_get(i)));
        sb_append(sb, "\n");
        i = i + 1;
    }
    sb_append(sb, "}");
    sb_build(sb)
}

// Emit a block wrapped in an IIFE for use in expressions
fn emit_block_as_iife(n: I32) : *Str => {
    let stmts = node_get_data1(n);
    let len = stmts.vec_length();
    if (len == 0) {
        return "(() => undefined)()";
    }
    let sb = sb_new();
    sb_append(sb, "(() => {\n");
    let i = 0;
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let is_last = i == len - 1;
        let kind = node_kind(stmt);
        if (is_last && kind == NK_EXPR_STMT) {
            sb_append(sb, "  return ");
            sb_append(sb, emit_expr(node_get_data1(stmt)));
            sb_append(sb, ";\n");
        } else if (is_last && (kind == NK_IF_STMT || kind == NK_IF_EXPR)) {
            sb_append(sb, "  return ");
            sb_append(sb, emit_if_as_expr(stmt));
            sb_append(sb, ";\n");
        } else {
            sb_append(sb, "  ");
            sb_append(sb, emit_stmt(stmt));
            sb_append(sb, "\n");
        }
        i = i + 1;
    }
    sb_append(sb, "})()");
    sb_build(sb)
}

fn emit_fn_block_with_init(n: I32, init_this: *Str) : *Str => {
    let stmts = node_get_data1(n);
    let len = stmts.vec_length();
    let sb = sb_new();
    sb_append(sb, "{\n");
    if (!init_this.str_eq("")) {
        sb_append(sb, "  ");
        sb_append(sb, init_this);
    }
    if (len == 0) {
        sb_append(sb, "}");
        return sb_build(sb);
    }

    // Pass 1: collect type aliases with destructors
    let dtor_type_map = map_new();
    let si = 0;
    while (si < len) {
        let stmt = stmts.vec_get(si);
        if (node_kind(stmt) == NK_TYPE_ALIAS && node_get_data5(stmt) != 0) {
            let alias_name = get_interned_str(node_get_data1(stmt));
            let dtor_name = get_interned_str(node_get_data5(stmt));
            dtor_type_map.map_set(alias_name, dtor_name);
        }
        si = si + 1;
    }

    // Pass 2: collect let-declared variables that have a destructor type
    let dtor_var_names = vec_new();
    let dtor_var_dtors = vec_new();
    si = 0;
    while (si < len) {
        let stmt = stmts.vec_get(si);
        if (node_kind(stmt) == NK_LET_DECL) {
            let type_node = node_get_data2(stmt);
            if (type_node != 0 && node_kind(type_node) == 40) {
                let type_name = get_interned_str(node_get_data1(type_node));
                if (dtor_type_map.map_has(type_name)) {
                    dtor_var_names.vec_push(get_interned_str(node_get_data1(stmt)));
                    dtor_var_dtors.vec_push(dtor_type_map.map_get(type_name));
                }
            }
        }
        si = si + 1;
    }

    // Build destructor call string (reverse order = LIFO destruction)
    let dtor_calls = "";
    let dtor_count = dtor_var_names.vec_length();
    if (dtor_count > 0) {
        let di = dtor_count - 1;
        while (di >= 0) {
            let vn = dtor_var_names.vec_get(di);
            let dn = dtor_var_dtors.vec_get(di);
            dtor_calls = dtor_calls.str_concat(dn).str_concat("(").str_concat(vn).str_concat(");\n  ");
            di = di - 1;
        }
    }

    let i = 0;
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let is_last = i == len - 1;
        let kind = node_kind(stmt);
        if (is_last && kind == NK_EXPR_STMT) {
            if (!dtor_calls.str_eq("")) {
                sb_append(sb, "  ");
                sb_append(sb, dtor_calls);
            }
            sb_append(sb, "  return ");
            sb_append(sb, emit_expr(node_get_data1(stmt)));
            sb_append(sb, ";\n");
        } else if (is_last && (kind == NK_IF_STMT || kind == NK_IF_EXPR)) {
            // Return the result of the if expression
            if (!dtor_calls.str_eq("")) {
                sb_append(sb, "  ");
                sb_append(sb, dtor_calls);
            }
            sb_append(sb, "  return ");
            sb_append(sb, emit_if_as_expr(stmt));
            sb_append(sb, ";\n");
        } else {
            sb_append(sb, "  ");
            sb_append(sb, emit_stmt(stmt));
            sb_append(sb, "\n");
        }
        i = i + 1;
    }
    sb_append(sb, "}");
    return sb_build(sb);
}

fn emit_fn_block_with_preamble(n: I32, preamble: *Str) : *Str => {
    let stmts = node_get_data1(n);
    let len = stmts.vec_length();
    if (len == 0) {
        if (preamble.str_eq("")) {
            return "{\n}";
        }
        return "{\n  ".str_concat(preamble).str_concat("\n}");
    }
    let sb = sb_new();
    sb_append(sb, "{\n");
    if (!preamble.str_eq("")) {
        sb_append(sb, "  ");
        sb_append(sb, preamble);
        sb_append(sb, "\n");
    }
    let i = 0;
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let is_last = i == len - 1;
        let kind = node_kind(stmt);
        if (is_last && kind == NK_EXPR_STMT) {
            sb_append(sb, "  return ");
            sb_append(sb, emit_expr(node_get_data1(stmt)));
            sb_append(sb, ";\n");
        } else if (is_last && (kind == NK_IF_STMT || kind == NK_IF_EXPR)) {
            sb_append(sb, "  return ");
            sb_append(sb, emit_if_as_expr(stmt));
            sb_append(sb, ";\n");
        } else {
            sb_append(sb, "  ");
            sb_append(sb, emit_stmt(stmt));
            sb_append(sb, "\n");
        }
        i = i + 1;
    }
    sb_append(sb, "}");
    sb_build(sb)
}

fn emit_fn_block(n: I32) : *Str => emit_fn_block_with_preamble(n, "");

// Emit an if statement as a ternary expression
fn emit_if_as_expr(n: I32) : *Str => {
    let cond = emit_expr(node_get_data1(n));
    let then_branch = node_get_data2(n);
    let else_branch = node_get_data3(n);
    
    let then_code = emit_branch_as_expr(then_branch);
    let else_code = "undefined";
    if (else_branch != 0) {
        else_code = emit_branch_as_expr(else_branch);
    }
    
    str_concat("((".str_concat(cond).str_concat(") ? ").str_concat(then_code.str_concat(" : ")), else_code.str_concat(")"))
}

fn emit_branch_as_expr(n: I32) : *Str => {
    let kind = node_kind(n);
    if (kind == NK_BLOCK) {
        // Wrap block in IIFE
        let stmts = node_get_data1(n);
        let len = stmts.vec_length();
        if (len == 0) {
            return "undefined";
        }
        let sb = sb_new();
        sb_append(sb, "(() => {\n");
        let i = 0;
        while (i < len) {
            let stmt = stmts.vec_get(i);
            let is_last = i == len - 1;
            let stmt_kind = node_kind(stmt);
            if (is_last && stmt_kind == NK_EXPR_STMT) {
                sb_append(sb, "    return ");
                sb_append(sb, emit_expr(node_get_data1(stmt)));
                sb_append(sb, ";\n");
            } else if (is_last && (stmt_kind == NK_IF_STMT || stmt_kind == NK_IF_EXPR)) {
                sb_append(sb, "    return ");
                sb_append(sb, emit_if_as_expr(stmt));
                sb_append(sb, ";\n");
            } else {
                sb_append(sb, "    ");
                sb_append(sb, emit_stmt(stmt));
                sb_append(sb, "\n");
            }
            i = i + 1;
        }
        sb_append(sb, "  })()");
        return sb_build(sb);
    }
    if (kind == NK_IF_STMT || kind == NK_IF_EXPR) {
        return emit_if_as_expr(n);
    }
    emit_expr(n)
}

out fn generate_js(program: I32) : *Str => {
    let stmts = node_get_data1(program);
    let sb = sb_new();
    sb_append(sb, "\"use strict\";\n\n");
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        sb_append(sb, emit_stmt(stmts.vec_get(i)));
        sb_append(sb, "\n\n");
        i = i + 1;
    }
    sb_build(sb)
}

out fn selfhost_codegen_stmt_marker() : I32 => 0;
