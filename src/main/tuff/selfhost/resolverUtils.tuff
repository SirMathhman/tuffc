let {
    getInternedStr, vecNew, intToString, setNew
}
 = selfhost::runtimeLexer;
let {
    nodeKind, nodeGetData1, nodeGetData2, nodeGetData3, nodeGetData4, nodeGetLine,
    nodeGetCol
}
 = selfhost::parserCore;
fn rslvUtilsPanicNode(errNode: I32, code: *Str, msg: *Str, reason: *Str, fix: *Str) : I32 =>
panicWithCodeLoc(code, msg, reason, fix, nodeGetLine(errNode), nodeGetCol(errNode));
 // Initialize host builtins set once at module load for O(1) lookup
fn initHostBuiltins() : *mut Set<*Str> => {
    let builtins = setNew();
    builtins.setAdd("sizeOf");
    builtins.setAdd("malloc");
    builtins.setAdd("realloc");
    builtins.setAdd("free");
    builtins.setAdd("memcpy");
    builtins.setAdd("memset");
    builtins.setAdd("drop");
    builtins.setAdd("panic");
    builtins.setAdd("this");
     // Runtime bridge functions (extern fn bindings used by actual fn implementations).
     // Without these, the resolver computes levenshtein "did you mean?" for every reference,
     // which is O(N * M) where N = call-sites and M = global names â€” a major bottleneck.
    builtins.setAdd("print");
    builtins.setAdd("parseInt");
    builtins.setAdd("charCode");
    builtins.setAdd("strConcat");
    builtins.setAdd("strFromCharCode");
    builtins.setAdd("readFile");
    builtins.setAdd("writeFile");
    builtins.setAdd("pathJoin");
    builtins.setAdd("pathDirname");
    builtins.setAdd("getArgc");
    builtins.setAdd("getArgv");
    builtins.setAdd("panicWithCode");
    builtins.setAdd("panicWithCodeLoc");
    builtins.setAdd("profileMark");
    builtins.setAdd("sbNew");
    builtins.setAdd("sbAppend");
    builtins.setAdd("sbAppendChar");
    builtins.setAdd("sbBuild");
    builtins.setAdd("__vec_new");
    builtins.setAdd("__vec_push");
    builtins.setAdd("__vec_pop");
    builtins.setAdd("__vec_get");
    builtins.setAdd("__vec_set");
    builtins.setAdd("__vec_length");
    builtins.setAdd("__vec_init");
    builtins.setAdd("__vec_capacity");
    builtins.setAdd("__vec_clear");
    builtins.setAdd("__vec_clone");
    builtins.setAdd("__vec_includes");
    builtins.setAdd("__vec_join");
    builtins.setAdd("__set_new");
    builtins.setAdd("__map_new");
    builtins.setAdd("__int_to_string");
    builtins.setAdd("__str_index_of");
    builtins.setAdd("__perf_now");
    builtins.setAdd("__print_error");
    builtins.setAdd("__profile_take_json");
    builtins.setAdd("__host_get_c_substrate");
    builtins.setAdd("__host_get_c_runtime_prelude_source");
    builtins
}
;
let HOST_BUILTINS : *mut Set<*Str> = initHostBuiltins();
 // Compute Levenshtein edit distance between two strings (two-row DP).
fn levenshteinDistance(a: *Str, b: *Str) : I32 => {
    let an = 0 + a.strLength();
    let bn = 0 + b.strLength();
    if (an == 0) {
        return bn;
    }
    if (bn == 0) {
        return an;
    }
    let prev = vecNew();
    let curr = vecNew();
    let j = 0;
    while (j <= bn) {
        prev.vecPush(j);
        curr.vecPush(0);
        j = j + 1;
    }
    let i = 1;
    while (i <= an) {
        curr.vecSet(0, i);
        let j2 = 1;
        while (j2 <= bn) {
            let cost = 0;
            if (a.strCharAt(i - 1) != b.strCharAt(j2 - 1)) {
                cost = 1;
            }
            let delCost = prev.vecGet(j2) + 1;
            let insCost = curr.vecGet(j2 - 1) + 1;
            let repCost = prev.vecGet(j2 - 1) + cost;
            let best = delCost;
            if (insCost < best) {
                best = insCost;
            }
            if (repCost < best) {
                best = repCost;
            }
            curr.vecSet(j2, best);
            j2 = j2 + 1;
        }
        let k = 0;
        while (k <= bn) {
            prev.vecSet(k, curr.vecGet(k));
            k = k + 1;
        }
        i = i + 1;
    }
    prev.vecGet(bn)
}
out fn rslvUtilsFindDidYouMean(name: *Str, candidates: Vec<*Str>) : *Str => {
    let best = "";
    let bestDist = 9999;
    let nameLen = 0 + name.strLength();
    let threshold = nameLen / 3 + 1;
    if (threshold > 3) {
        threshold = 3;
    }
    let n = candidates.vecLength();
    let ci = 0;
    while (ci < n) {
        let cand = candidates.vecGet(ci);
        let dist = levenshteinDistance(name, cand);
        if (dist <= threshold && dist < bestDist) {
            bestDist = dist;
            best = cand;
        }
        ci = ci + 1;
    }
    best
}
fn fnTypeSig(t: I32) : *Str => {
    if (t == 0) {
        return "_";
    }
    let k = nodeKind(t);
    if (k == NK_NAMED_TYPE) {
        return getInternedStr(nodeGetData1(t));
    }
    if (k == NK_POINTER_TYPE) {
        let mutv = nodeGetData1(t);
        let inner = fnTypeSig(nodeGetData2(t));
        let lifeIdx = nodeGetData4(t);
        let lifePrefix = "";
        if (lifeIdx != 0) {
            lifePrefix = getInternedStr(lifeIdx).strConcat(" ");
        }
        if (mutv == 1) {
            return "*".strConcat(lifePrefix).strConcat("mut ").strConcat(inner);
        }
        return "*".strConcat(lifePrefix).strConcat(inner);
    }
    if (k == NK_ARRAY_TYPE) {
        return "Array";
    }
    if (k == NK_TUPLE_TYPE) {
        return "Tuple";
    }
    if (k == NK_REFINEMENT_TYPE) {
        return "Ref<".strConcat(fnTypeSig(nodeGetData1(t))).strConcat(">");
    }
    if (k == NK_APPLIED_TYPE) {
        return getInternedStr(nodeGetData1(t)).strConcat("(...)");
    }
    if (k == NK_UNION_TYPE) {
        return fnTypeSig(nodeGetData1(t)).strConcat("|").strConcat(fnTypeSig(nodeGetData2(t)));
    }
    if (k == NK_FUNCTION_TYPE) {
        let parts = vecNew();
        let ps = nodeGetData1(t);
        let i = 0;
        let __len2 = ps.vecLength();
        while (i < __len2) {
            parts.vecPush(fnTypeSig(ps.vecGet(i)));
            i = i + 1;
        }
        return "(".strConcat(parts.vecJoin(",")).strConcat(")=>").strConcat(fnTypeSig(nodeGetData2(t)));
    }
    "Unknown"
}
fn fnDeclSig(n: I32) : *Str => {
    let gens = nodeGetData2(n);
    let params = nodeGetData3(n);
    let ret = nodeGetData4(n);
    let pparts = vecNew();
    let i = 0;
    let __len1 = params.vecLength();
    while (i < __len1) {
        let p = params.vecGet(i);
        let pname = getInternedStr(p.vecGet(0));
        let ptype = fnTypeSig(p.vecGet(1));
        pparts.vecPush(pname.strConcat(":").strConcat(ptype));
        i = i + 1;
    }
    let gcount = intToString(gens.vecLength());
    return "g=".strConcat(gcount).strConcat(";p=").strConcat(pparts.vecJoin(",")).strConcat(";r=").strConcat(fnTypeSig(ret));
}
out fn rslvUtilsValidateExpectActualPairs(body: Vec<I32>) : I32 => {
    let i = 0;
    let len = body.vecLength();
    while (i < len) {
        let stmt = body.vecGet(i);
        let kind = nodeKind(stmt);
        if (kind == NK_EXPECT_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
            let name = getInternedStr(nodeGetData1(stmt));
            let expectCount = 0;
            let actualCount = 0;
            let expectNode = 0;
            let actualNode = 0;
            let j = 0;
            while (j < len) {
                let cand = body.vecGet(j);
                let ck = nodeKind(cand);
                if ((ck == NK_EXPECT_FN_DECL || ck == NK_ACTUAL_FN_DECL) &&
                getInternedStr(nodeGetData1(cand)).strEq(name)) {
                    if (ck == NK_EXPECT_FN_DECL) {
                        expectCount = expectCount + 1;
                        expectNode = cand;
                    }
                    else {
                        actualCount = actualCount + 1;
                        actualNode = cand;
                    }
                }
                j = j + 1;
            }
            if (expectCount != 1 || actualCount != 1) {
                rslvUtilsPanicNode(
                stmt,
                "E_EXPECT_ACTUAL_PAIRING",
                "expect/actual pairing requires exactly one expect and one actual for '".strConcat(name).strConcat("'"),
                "Platform declarations require exactly one expect and one actual declaration for each symbol.",
                "Declare exactly one 'expect fn' and one matching 'actual fn' for each platform symbol."
                );
            }
            if (!fnDeclSig(expectNode).strEq(fnDeclSig(actualNode))) {
                rslvUtilsPanicNode(
                stmt,
                "E_EXPECT_ACTUAL_SIGNATURE_MISMATCH",
                "expect/actual signatures do not match for '".strConcat(name).strConcat("'"),
                "An expect declaration and its actual implementation have different signatures.",
                "Make generic params, parameter list, and return type identical between expect and actual declarations."
                );
            }
        }
        i = i + 1;
    }
    0
}
out fn rslvUtilsScopeDefine(scopes: Vec<*mut Set<*Str>>, depth: I32, name: *Str, errNode: I32) : I32 => {
    let scope = scopes.vecGet(depth);
    if (scope.setHas(name)) {
        rslvUtilsPanicNode(
        errNode,
        "E_RESOLVE_SHADOWING",
        "Variable shadowing/redeclaration is not allowed: ".strConcat(name),
        "A name was declared multiple times in the same lexical scope.",
        "Rename one of the bindings or move it to a different scope."
        );
    }
    scope.setAdd(name);
    0
}
out fn rslvUtilsScopeHas(scopes: Vec<*mut Set<*Str>>, depth: I32, name: *Str) : Bool => {
    let i = depth;
    while (i >= 0) {
        if (scopes.vecGet(i).setHas(name)) {
            return true;
        }
        i = i - 1;
    }
    false
}
out fn rslvUtilsIsHostBuiltinName(name: *Str) : Bool => HOST_BUILTINS.setHas(name);
fn lifetimeScopeHas(resolveLifetimeScopes: Vec<*mut Set<*Str>>, name: *Str) : Bool => {
    let len = resolveLifetimeScopes.vecLength();
    let mut i : I32 = 0;
    while (i < len) {
        if (resolveLifetimeScopes.vecGet(i).setHas(name)) {
            return true;
        }
        i = i + 1;
    }
    false
}
out fn rslvUtilsResolveTypeLifetimes(t: I32, resolveLifetimeScopes: Vec<*mut Set<*Str>>, errNode: I32) : I32
=> {
    if (t == 0) {
        return 0;
    }
    let k = nodeKind(t);
    if (k == NK_POINTER_TYPE) {
        let lifeIdx = nodeGetData4(t);
        if (lifeIdx != 0) {
            let lname = getInternedStr(lifeIdx);
            if (!lifetimeScopeHas(resolveLifetimeScopes, lname)) {
                rslvUtilsPanicNode(
                errNode,
                "E_RESOLVE_UNDEFINED_LIFETIME",
                "Undefined lifetime '".strConcat(lname).strConcat("'"),
                "A pointer type annotation references a lifetime name that is not declared in any active lifetime block.",
                "Declare the lifetime in an enclosing `lifetime ... { ... }` block before using it in pointer types."
                );
            }
        }
        rslvUtilsResolveTypeLifetimes(nodeGetData2(t), resolveLifetimeScopes, errNode);
        return 0;
    }
    if (k == NK_ARRAY_TYPE) {
        rslvUtilsResolveTypeLifetimes(nodeGetData1(t), resolveLifetimeScopes, errNode);
        return 0;
    }
    if (k == NK_REFINEMENT_TYPE) {
        rslvUtilsResolveTypeLifetimes(nodeGetData1(t), resolveLifetimeScopes, errNode);
        return 0;
    }
    if (k == NK_UNION_TYPE) {
        rslvUtilsResolveTypeLifetimes(nodeGetData1(t), resolveLifetimeScopes, errNode);
        rslvUtilsResolveTypeLifetimes(nodeGetData2(t), resolveLifetimeScopes, errNode);
        return 0;
    }
    if (k == NK_TUPLE_TYPE) {
        let members = nodeGetData1(t);
        let i = 0;
        let len = members.vecLength();
        while (i < len) {
            rslvUtilsResolveTypeLifetimes(members.vecGet(i), resolveLifetimeScopes,
            errNode);
            i = i + 1;
        }
        return 0;
    }
    if (k == NK_FUNCTION_TYPE) {
        let ps = nodeGetData1(t);
        let i = 0;
        let __len = ps.vecLength();
        while (i < __len) {
            rslvUtilsResolveTypeLifetimes(ps.vecGet(i), resolveLifetimeScopes, errNode);
            i = i + 1;
        }
        rslvUtilsResolveTypeLifetimes(nodeGetData2(t), resolveLifetimeScopes, errNode);
        return 0;
    }
    0
}
out fn selfhostResolverUtilsMarker() : I32 => 0;
