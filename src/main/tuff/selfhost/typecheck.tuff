// ============================================================================
// Typecheck - skip for now, minimal implementation
// ============================================================================

let { get_interned_str } = selfhost::runtime_lexer;
let { node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5 } = selfhost::parser_core;

fn type_name_from_type_node(t: I32) : *Str => {
    if (t == 0) {
        return "Unknown";
    }
    let k = node_kind(t);
    if (k == NK_NAMED_TYPE) {
        return get_interned_str(node_get_data1(t));
    }
    if (k == NK_POINTER_TYPE) {
        let mutable = node_get_data1(t);
        let inner = type_name_from_type_node(node_get_data2(t));
        if (mutable == 1) {
            return "*mut ".str_concat(inner);
        }
        return "*".str_concat(inner);
    }
    if (k == NK_REFINEMENT_TYPE) {
        return type_name_from_type_node(node_get_data1(t));
    }
    if (k == NK_UNION_TYPE) {
        let left = type_name_from_type_node(node_get_data1(t));
        let right = type_name_from_type_node(node_get_data2(t));
        return left.str_concat("|").str_concat(right);
    }
    "Unknown"
}

fn pointer_types_compatible(expected: *Str, actual: *Str) : Bool => {
    if (expected.str_eq(actual)) {
        return true;
    }

    if (expected.str_includes("|")) {
        if (expected.str_starts_with(actual.str_concat("|")) || str_ends_with_local(expected, "|".str_concat(actual)) || expected.str_includes("|".str_concat(actual).str_concat("|"))) {
            return true;
        }
    }

    // Allow *mut T where *T is expected.
    if (expected.str_starts_with("*") && !expected.str_starts_with("*mut ") && actual.str_starts_with("*mut ")) {
        let expected_inner = expected.str_slice(1, expected.str_length());
        let actual_inner = actual.str_slice(5, actual.str_length());
        return expected_inner.str_eq(actual_inner);
    }
    false
}

fn str_ends_with_local(s: *Str, suffix: *Str) : Bool => {
    let ns = s.str_length();
    let nf = suffix.str_length();
    if (nf > ns) {
        return false;
    }
    s.str_slice(ns - nf, ns).str_eq(suffix)
}

fn is_number_literal_with_suffix(n: I32, suffix: *Str) : Bool => {
    if (n == 0 || node_kind(n) != NK_NUMBER_LIT) {
        return false;
    }
    let text = get_interned_str(node_get_data1(n));
    str_ends_with_local(text, suffix)
}

fn is_usize_zero_literal_node(n: I32) : Bool => {
    if (!is_number_literal_with_suffix(n, "USize")) {
        return false;
    }
    get_interned_str(node_get_data1(n)).str_eq("0USize")
}

fn is_nullable_pointer_type_name(name: *Str) : Bool => {
    if (!name.str_includes("|")) {
        return false;
    }
    if (name.str_starts_with("*") && str_ends_with_local(name, "|USize")) {
        return true;
    }
    if (name.str_starts_with("USize|*") && name.str_includes("*")) {
        return true;
    }
    false
}

fn numeric_types_compatible(expected: *Str, actual: *Str, rhs: I32) : Bool => {
    if (expected.str_eq(actual)) {
        return true;
    }

    // Allow unsigned targets from non-negative numeric literals.
    if (expected.str_eq("USize") && actual.str_eq("I32") && rhs != 0 && node_kind(rhs) == NK_NUMBER_LIT) {
        let lit = get_interned_str(node_get_data1(rhs));
        return !lit.str_starts_with("-");
    }

    false
}

fn infer_expr_type_name(n: I32, fn_return_types: Map, local_types: Map) : *Str => {
    if (n == 0) {
        return "Unknown";
    }
    let kind = node_kind(n);
    if (kind == NK_NUMBER_LIT) {
        let text = get_interned_str(node_get_data1(n));
        if (str_ends_with_local(text, "USize")) {
            return "USize";
        }
        return "I32";
    }
    if (kind == NK_BOOL_LIT) { return "Bool"; }
    if (kind == NK_STRING_LIT) { return "*Str"; }
    if (kind == NK_CHAR_LIT) { return "Char"; }
    if (kind == NK_IDENTIFIER) {
        let name = get_interned_str(node_get_data1(n));
        if (local_types.map_has(name)) {
            return local_types.map_get(name);
        }
        return "Unknown";
    }
    if (kind == NK_CALL_EXPR) {
        let callee = node_get_data1(n);
        if (node_kind(callee) == NK_IDENTIFIER) {
            let fname = get_interned_str(node_get_data1(callee));
            if (fn_return_types.map_has(fname)) {
                return fn_return_types.map_get(fname);
            }
        }
    }
    "Unknown"
}

fn expr_is_number_literal_nonzero(n: I32) : Bool => {
    if (n == 0 || node_kind(n) != NK_NUMBER_LIT) {
        return false;
    }
    !get_interned_str(node_get_data1(n)).str_eq("0")
}

fn typecheck_expr(n: I32, fn_arities: Map, fn_return_types: Map, local_types: Map, nonnull_ptrs: Map, strict_safety: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_BINARY_EXPR) {
        typecheck_expr(node_get_data2(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        typecheck_expr(node_get_data3(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        if (strict_safety == 1) {
            let op = get_interned_str(node_get_data1(n));
            if (op.str_eq("/") && !expr_is_number_literal_nonzero(node_get_data3(n))) {
                panic_with_code(
                    "E_SAFETY_DIV_BY_ZERO",
                    "Division by zero cannot be ruled out at compile time",
                    "The denominator is not proven non-zero under strict safety checks.",
                    "Prove denominator != 0 via refinement type or control-flow guard."
                );
            }
        }
        return 0;
    }

    if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
        if (kind == NK_UNARY_EXPR) {
            typecheck_expr(node_get_data2(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        } else {
            typecheck_expr(node_get_data1(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        }
        return 0;
    }

    if (kind == NK_CALL_EXPR) {
        let callee = node_get_data1(n);
        let args = node_get_data2(n);
        let actual = args.vec_length();
        let fname = "";

        if (node_kind(callee) == NK_IDENTIFIER) {
            fname = get_interned_str(node_get_data1(callee));
            if (fn_arities.map_has(fname)) {
                let expected = fn_arities.map_get(fname);
                if (expected != actual) {
                    let msg = "Function ".str_concat(fname).str_concat(" expects ".str_concat(int_to_string(expected))).str_concat(" args, got ".str_concat(int_to_string(actual)));
                    panic_with_code(
                        "E_TYPE_ARG_COUNT",
                        msg,
                        "A function call provided a different number of arguments than the function signature requires.",
                        "Pass exactly the number of parameters declared by the function."
                    );
                }
            }
        }

        typecheck_expr(callee, fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        let i = 0;
        while (i < actual) {
            typecheck_expr(args.vec_get(i), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_MEMBER_EXPR) {
        if (strict_safety == 1) {
            let obj = node_get_data1(n);
            let obj_name = infer_expr_type_name(obj, fn_return_types, local_types);
            if (is_nullable_pointer_type_name(obj_name)) {
                let guarded = false;
                if (node_kind(obj) == NK_IDENTIFIER) {
                    let oname = get_interned_str(node_get_data1(obj));
                    guarded = nonnull_ptrs.map_has(oname);
                }
                if (!guarded) {
                    panic_with_code(
                        "E_SAFETY_NULLABLE_POINTER_GUARD",
                        "Nullable pointer access requires guard",
                        "A nullable pointer must be proven non-null before pointer-consuming operations.",
                        "Guard with if (p != 0USize) or if (0USize != p) before member access."
                    );
                }
            }
        }
        typecheck_expr(node_get_data1(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    if (kind == NK_INDEX_EXPR) {
        if (strict_safety == 1) {
            let target_node = node_get_data1(n);
            let target_name = infer_expr_type_name(target_node, fn_return_types, local_types);
            if (is_nullable_pointer_type_name(target_name)) {
                let guarded = false;
                if (node_kind(target_node) == NK_IDENTIFIER) {
                    let tname = get_interned_str(node_get_data1(target_node));
                    guarded = nonnull_ptrs.map_has(tname);
                }
                if (!guarded) {
                    panic_with_code(
                        "E_SAFETY_NULLABLE_POINTER_GUARD",
                        "Nullable pointer indexing requires guard",
                        "A nullable pointer must be proven non-null before pointer-consuming operations.",
                        "Guard with if (p != 0USize) or if (0USize != p) before indexing."
                    );
                }
            }
        }
        typecheck_expr(node_get_data1(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        typecheck_expr(node_get_data2(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    if (kind == NK_STRUCT_INIT) {
        let fields = node_get_data2(n);
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            typecheck_expr(field.vec_get(1), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IF_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        typecheck_stmt(node_get_data2(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        if (node_get_data3(n) != 0) {
            typecheck_stmt(node_get_data3(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        }
        return 0;
    }

    if (kind == NK_MATCH_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        let cases = node_get_data2(n);
        let i = 0;
        let len = cases.vec_length();
        while (i < len) {
            let case_node = cases.vec_get(i);
            typecheck_stmt(case_node.vec_get(1), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IS_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    0
}

fn typecheck_stmt(n: I32, fn_arities: Map, fn_return_types: Map, local_types: Map, nonnull_ptrs: Map, strict_safety: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_BLOCK) {
        let stmts = node_get_data1(n);
        let i = 0;
        let len = stmts.vec_length();
        while (i < len) {
            typecheck_stmt(stmts.vec_get(i), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL) {
        let params = node_get_data3(n);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let p = params.vec_get(i);
            let pname = get_interned_str(p.vec_get(0));
            let ptype = p.vec_get(1);
            if (ptype != 0) {
                local_types.map_set(pname, type_name_from_type_node(ptype));
            }
            i = i + 1;
        }
        typecheck_stmt(node_get_data5(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    if (kind == NK_LET_DECL) {
        let declared_type = node_get_data2(n);
        let rhs = node_get_data3(n);
        typecheck_expr(rhs, fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);

        let rhs_name = infer_expr_type_name(rhs, fn_return_types, local_types);
        if (declared_type != 0) {
            let declared_name = type_name_from_type_node(declared_type);
            if (!declared_name.str_eq("Unknown") && !rhs_name.str_eq("Unknown") && !pointer_types_compatible(declared_name, rhs_name) && !numeric_types_compatible(declared_name, rhs_name, rhs)) {
                let vname = get_interned_str(node_get_data1(n));
                let msg = "Type mismatch for let ".str_concat(vname).str_concat(": expected ").str_concat(declared_name).str_concat(", got ").str_concat(rhs_name);
                panic_with_code(
                    "E_TYPE_LET_MISMATCH",
                    msg,
                    "An explicit let type annotation does not match the assigned RHS expression type.",
                    "Update the explicit type annotation or change the RHS expression to match."
                );
            }
            local_types.map_set(get_interned_str(node_get_data1(n)), declared_name);
        } else if (!rhs_name.str_eq("Unknown")) {
            local_types.map_set(get_interned_str(node_get_data1(n)), rhs_name);
        }
        return 0;
    }

    if (kind == NK_EXPR_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    if (kind == NK_ASSIGN_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        typecheck_expr(node_get_data2(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    if (kind == NK_RETURN_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    if (kind == NK_IF_STMT) {
        let cond = node_get_data1(n);
        typecheck_expr(cond, fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        let then_nonnull = map_new();
        let else_nonnull = map_new();
        let copied = false;
        if (node_kind(cond) == NK_BINARY_EXPR) {
            let op = get_interned_str(node_get_data1(cond));
            let left = node_get_data2(cond);
            let right = node_get_data3(cond);
            if (op.str_eq("!=")) {
                if (node_kind(left) == NK_IDENTIFIER && is_usize_zero_literal_node(right)) {
                    then_nonnull.map_set(get_interned_str(node_get_data1(left)), 1);
                    copied = true;
                }
                if (node_kind(right) == NK_IDENTIFIER && is_usize_zero_literal_node(left)) {
                    then_nonnull.map_set(get_interned_str(node_get_data1(right)), 1);
                    copied = true;
                }
            }
        }
        if (!copied) {
            then_nonnull = nonnull_ptrs;
        }
        else_nonnull = nonnull_ptrs;
        typecheck_stmt(node_get_data2(n), fn_arities, fn_return_types, local_types, then_nonnull, strict_safety);
        if (node_get_data3(n) != 0) {
            typecheck_stmt(node_get_data3(n), fn_arities, fn_return_types, local_types, else_nonnull, strict_safety);
        }
        return 0;
    }

    if (kind == NK_FOR_STMT) {
        typecheck_expr(node_get_data2(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        typecheck_expr(node_get_data3(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        typecheck_stmt(node_get_data4(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    if (kind == NK_WHILE_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        typecheck_stmt(node_get_data2(n), fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    // Fallback: treat unmatched nodes as expressions.
    typecheck_expr(n, fn_arities, fn_return_types, local_types, nonnull_ptrs, strict_safety);
    0
}

out fn typecheck_program_with_options(program: I32, strict_safety: I32) : I32 => {
    let fn_arities = map_new();
    let fn_return_types = map_new();
    let local_types = map_new();
    let body = node_get_data1(program);

    // Collect function signatures (including extern fns).
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        let stmt = body.vec_get(i);
        let kind = node_kind(stmt);
        if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_EXTERN_FN_DECL) {
            let name = get_interned_str(node_get_data1(stmt));
            let params = node_get_data3(stmt);
            fn_arities.map_set(name, params.vec_length());
            let ret_type = node_get_data4(stmt);
            fn_return_types.map_set(name, type_name_from_type_node(ret_type));
        }
        if (kind == NK_EXTERN_LET_DECL) {
            let vname = get_interned_str(node_get_data1(stmt));
            let vtype = node_get_data2(stmt);
            local_types.map_set(vname, type_name_from_type_node(vtype));
        }
        i = i + 1;
    }

    // Check calls across whole program.
    i = 0;
    while (i < len) {
        typecheck_stmt(body.vec_get(i), fn_arities, fn_return_types, local_types, map_new(), strict_safety);
        i = i + 1;
    }

    program
}

out fn typecheck_program(program: I32) : I32 => {
    typecheck_program_with_options(program, 0)
}

out fn selfhost_typecheck_marker() : I32 => 0;
