// ============================================================================
// Typecheck - skip for now, minimal implementation
// ============================================================================

let { get_interned_str } = selfhost::runtime_lexer;
let { node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5 } = selfhost::parser_core;

fn expr_is_number_literal_nonzero(n: I32) : Bool => {
    if (n == 0 || node_kind(n) != NK_NUMBER_LIT) {
        return false;
    }
    !get_interned_str(node_get_data1(n)).str_eq("0")
}

fn typecheck_expr(n: I32, fn_arities: Map, strict_safety: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_BINARY_EXPR) {
        typecheck_expr(node_get_data2(n), fn_arities, strict_safety);
        typecheck_expr(node_get_data3(n), fn_arities, strict_safety);
        if (strict_safety == 1) {
            let op = get_interned_str(node_get_data1(n));
            if (op.str_eq("/") && !expr_is_number_literal_nonzero(node_get_data3(n))) {
                panic_with_code(
                    "E_SAFETY_DIV_BY_ZERO",
                    "Division by zero cannot be ruled out at compile time",
                    "The denominator is not proven non-zero under strict safety checks.",
                    "Prove denominator != 0 via refinement type or control-flow guard."
                );
            }
        }
        return 0;
    }

    if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
        if (kind == NK_UNARY_EXPR) {
            typecheck_expr(node_get_data2(n), fn_arities, strict_safety);
        } else {
            typecheck_expr(node_get_data1(n), fn_arities, strict_safety);
        }
        return 0;
    }

    if (kind == NK_CALL_EXPR) {
        let callee = node_get_data1(n);
        let args = node_get_data2(n);
        let actual = args.vec_length();

        if (node_kind(callee) == NK_IDENTIFIER) {
            let fname = get_interned_str(node_get_data1(callee));
            if (fn_arities.map_has(fname)) {
                let expected = fn_arities.map_get(fname);
                if (expected != actual) {
                    let msg = "Function ".str_concat(fname).str_concat(" expects ".str_concat(int_to_string(expected))).str_concat(" args, got ".str_concat(int_to_string(actual)));
                    panic_with_code(
                        "E_TYPE_ARG_COUNT",
                        msg,
                        "A function call provided a different number of arguments than the function signature requires.",
                        "Pass exactly the number of parameters declared by the function."
                    );
                }
            }
        }

        typecheck_expr(callee, fn_arities, strict_safety);
        let i = 0;
        while (i < actual) {
            typecheck_expr(args.vec_get(i), fn_arities, strict_safety);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_MEMBER_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities, strict_safety);
        return 0;
    }

    if (kind == NK_INDEX_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities, strict_safety);
        typecheck_expr(node_get_data2(n), fn_arities, strict_safety);
        return 0;
    }

    if (kind == NK_STRUCT_INIT) {
        let fields = node_get_data2(n);
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            typecheck_expr(field.vec_get(1), fn_arities, strict_safety);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IF_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities, strict_safety);
        typecheck_stmt(node_get_data2(n), fn_arities, strict_safety);
        if (node_get_data3(n) != 0) {
            typecheck_stmt(node_get_data3(n), fn_arities, strict_safety);
        }
        return 0;
    }

    if (kind == NK_MATCH_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities, strict_safety);
        let cases = node_get_data2(n);
        let i = 0;
        let len = cases.vec_length();
        while (i < len) {
            let case_node = cases.vec_get(i);
            typecheck_stmt(case_node.vec_get(1), fn_arities, strict_safety);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IS_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities, strict_safety);
        return 0;
    }

    0
}

fn typecheck_stmt(n: I32, fn_arities: Map, strict_safety: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_BLOCK) {
        let stmts = node_get_data1(n);
        let i = 0;
        let len = stmts.vec_length();
        while (i < len) {
            typecheck_stmt(stmts.vec_get(i), fn_arities, strict_safety);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL) {
        typecheck_stmt(node_get_data5(n), fn_arities, strict_safety);
        return 0;
    }

    if (kind == NK_LET_DECL) {
        typecheck_expr(node_get_data3(n), fn_arities, strict_safety);
        return 0;
    }

    if (kind == NK_EXPR_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities, strict_safety);
        return 0;
    }

    if (kind == NK_ASSIGN_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities, strict_safety);
        typecheck_expr(node_get_data2(n), fn_arities, strict_safety);
        return 0;
    }

    if (kind == NK_RETURN_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities, strict_safety);
        return 0;
    }

    if (kind == NK_IF_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities, strict_safety);
        typecheck_stmt(node_get_data2(n), fn_arities, strict_safety);
        if (node_get_data3(n) != 0) {
            typecheck_stmt(node_get_data3(n), fn_arities, strict_safety);
        }
        return 0;
    }

    if (kind == NK_FOR_STMT) {
        typecheck_expr(node_get_data2(n), fn_arities, strict_safety);
        typecheck_expr(node_get_data3(n), fn_arities, strict_safety);
        typecheck_stmt(node_get_data4(n), fn_arities, strict_safety);
        return 0;
    }

    if (kind == NK_WHILE_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities, strict_safety);
        typecheck_stmt(node_get_data2(n), fn_arities, strict_safety);
        return 0;
    }

    // Fallback: treat unmatched nodes as expressions.
    typecheck_expr(n, fn_arities, strict_safety);
    0
}

out fn typecheck_program_with_options(program: I32, strict_safety: I32) : I32 => {
    let fn_arities = map_new();
    let body = node_get_data1(program);

    // Collect function signatures (including extern fns).
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        let stmt = body.vec_get(i);
        let kind = node_kind(stmt);
        if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_EXTERN_FN_DECL) {
            let name = get_interned_str(node_get_data1(stmt));
            let params = node_get_data3(stmt);
            fn_arities.map_set(name, params.vec_length());
        }
        i = i + 1;
    }

    // Check calls across whole program.
    i = 0;
    while (i < len) {
        typecheck_stmt(body.vec_get(i), fn_arities, strict_safety);
        i = i + 1;
    }

    program
}

out fn typecheck_program(program: I32) : I32 => {
    typecheck_program_with_options(program, 0)
}

out fn selfhost_typecheck_marker() : I32 => 0;
