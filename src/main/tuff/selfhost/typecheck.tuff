// ============================================================================
// Typecheck - skip for now, minimal implementation
// ============================================================================

let { get_interned_str, map_new, set_new, vec_new, str_includes, str_starts_with } = selfhost::runtime_lexer;
let { node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5 } = selfhost::parser_core;

fn type_name_from_type_node(t: I32) : *Str => {
    if (t == 0) {
        return "Unknown";
    }
    let k = node_kind(t);
    if (k == 40) {
        return get_interned_str(node_get_data1(t));
    }
    if (k == 41) {
        let mutable = node_get_data1(t);
        let inner = type_name_from_type_node(node_get_data2(t));
        let move_ptr = node_get_data3(t);
        let life_idx = node_get_data4(t);
        let life_prefix = "";
        if (life_idx != 0) {
            life_prefix = get_interned_str(life_idx).str_concat(" ");
        }
        if (move_ptr == 1) {
            return "*".str_concat(life_prefix).str_concat("move ").str_concat(inner);
        }
        if (mutable == 1) {
            return "*".str_concat(life_prefix).str_concat("mut ").str_concat(inner);
        }
        return "*".str_concat(life_prefix).str_concat(inner);
    }
    if (k == 44) {
        return type_name_from_type_node(node_get_data1(t));
    }
    if (k == 45) {
        let left = type_name_from_type_node(node_get_data1(t));
        let right = type_name_from_type_node(node_get_data2(t));
        return left.str_concat("|").str_concat(right);
    }
    "Unknown"
}

fn pointer_types_compatible(expected: *Str, actual: *Str) : Bool => {
    if (expected.str_eq(actual)) {
        return true;
    }

    if (expected.str_includes("|")) {
        if (expected.str_starts_with(actual.str_concat("|")) || str_ends_with_local(expected, "|".str_concat(actual)) || expected.str_includes("|".str_concat(actual).str_concat("|"))) {
            return true;
        }
    }

    // Allow *mut T where *T is expected (including lifetime-prefixed forms like *a T / *a mut T).
    if (expected.str_starts_with("*") && actual.str_starts_with("*")) {
        let expected_body = expected.str_slice(1, expected.str_length());
        let actual_body = actual.str_slice(1, actual.str_length());

        let expected_has_life = !expected_body.str_starts_with("mut ") && !expected_body.str_starts_with("move ") && expected_body.str_includes(" ");
        let actual_has_life = !actual_body.str_starts_with("mut ") && !actual_body.str_starts_with("move ") && actual_body.str_includes(" ");

        if (expected_has_life) {
            let i = 0;
            let n = expected_body.str_length();
            while (i < n && expected_body.str_char_at(i) != 32) {
                i = i + 1;
            }
            if (i < n) {
                expected_body = expected_body.str_slice(i + 1, n);
            }
        }

        if (actual_has_life) {
            let j = 0;
            let m = actual_body.str_length();
            while (j < m && actual_body.str_char_at(j) != 32) {
                j = j + 1;
            }
            if (j < m) {
                actual_body = actual_body.str_slice(j + 1, m);
            }
        }

        if (!expected_body.str_starts_with("mut ") && actual_body.str_starts_with("mut ")) {
            let expected_inner = expected_body;
            let actual_inner = actual_body.str_slice(4, actual_body.str_length());
            return expected_inner.str_eq(actual_inner);
        }

        if (expected_body.str_starts_with("mut ") && !actual_body.str_starts_with("mut ")) {
            return false;
        }

        return expected_body.str_eq(actual_body);
    }
    false
}

fn str_ends_with_local(s: *Str, suffix: *Str) : Bool => {
    let ns = s.str_length();
    let nf = suffix.str_length();
    if (nf > ns) {
        return false;
    }
    s.str_slice(ns - nf, ns).str_eq(suffix)
}

fn is_number_literal_with_suffix(n: I32, suffix: *Str) : Bool => {
    if (n == 0 || node_kind(n) != NK_NUMBER_LIT) {
        return false;
    }
    let text = get_interned_str(node_get_data1(n));
    str_ends_with_local(text, suffix)
}

fn is_usize_zero_literal_node(n: I32) : Bool => {
    if (!is_number_literal_with_suffix(n, "USize")) {
        return false;
    }
    get_interned_str(node_get_data1(n)).str_eq("0USize")
}

fn is_nullable_pointer_type_name(name: *Str) : Bool => {
    if (!name.str_includes("|")) {
        return false;
    }
    if (name.str_starts_with("*") && str_ends_with_local(name, "|USize")) {
        return true;
    }
    if (name.str_starts_with("USize|*") && name.str_includes("*")) {
        return true;
    }
    false
}

fn numeric_types_compatible(expected: *Str, actual: *Str, rhs: I32) : Bool => {
    if (expected.str_eq(actual)) {
        return true;
    }

    // Allow unsigned targets from non-negative numeric literals.
    if (expected.str_eq("USize") && actual.str_eq("I32") && rhs != 0 && node_kind(rhs) == NK_NUMBER_LIT) {
        let lit = get_interned_str(node_get_data1(rhs));
        return !lit.str_starts_with("-");
    }

    false
}

fn is_type_variable_name(name: *Str) : Bool => {
    if (name.str_length() != 1) {
        return false;
    }
    let ch = char_code(name);
    (ch >= 65 && ch <= 90)
}

fn type_names_compatible(expected: *Str, actual: *Str, rhs: I32) : Bool => {
    if (expected.str_eq("Unknown") || actual.str_eq("Unknown")) {
        return true;
    }
    if (expected.str_eq("AnyValue") || actual.str_eq("AnyValue")) {
        return true;
    }
    if (expected.str_eq(actual)) {
        return true;
    }
    if (is_type_variable_name(expected) || is_type_variable_name(actual)) {
        return true;
    }
    if (pointer_types_compatible(expected, actual)) {
        return true;
    }
    if (numeric_types_compatible(expected, actual, rhs)) {
        return true;
    }
    false
}

fn infer_expr_type_name(n: I32, fn_return_types: Map, local_types: Map) : *Str => {
    if (n == 0) {
        return "Unknown";
    }
    let kind = node_kind(n);
    if (kind == 20) {
        let text = get_interned_str(node_get_data1(n));
        if (str_ends_with_local(text, "USize")) {
            return "USize";
        }
        return "I32";
    }
    if (kind == 21) { return "Bool"; }
    if (kind == 22) { return "*Str"; }
    if (kind == 23) { return "Char"; }
    if (kind == 24) {
        let name = get_interned_str(node_get_data1(n));
        if (local_types.map_has(name)) {
            return local_types.map_get(name);
        }
        if (tc_global_value_types.map_has(name)) {
            return tc_global_value_types.map_get(name);
        }
        return "Unknown";
    }
    if (kind == 26) {
        let op = get_interned_str(node_get_data1(n));
        let inner = infer_expr_type_name(node_get_data2(n), fn_return_types, local_types);
        if (op.str_eq("&")) {
            return "*".str_concat(inner);
        }
        if (op.str_eq("&mut")) {
            return "*mut ".str_concat(inner);
        }
        if (op.str_eq("!")) {
            return "Bool";
        }
        return inner;
    }
    if (kind == 25) {
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("==") || op.str_eq("!=") || op.str_eq("<") || op.str_eq("<=") || op.str_eq(">") || op.str_eq(">=") || op.str_eq("&&") || op.str_eq("||")) {
            return "Bool";
        }
        if (op.str_eq("..")) {
            return "Iter";
        }
        return infer_expr_type_name(node_get_data2(n), fn_return_types, local_types);
    }
    if (kind == 27) {
        let callee = node_get_data1(n);
        if (node_kind(callee) == 24) {
            let fname = get_interned_str(node_get_data1(callee));
            if (fname.str_eq("into") && node_get_data3(n) == 1) {
                let type_args = node_get_data4(n);
                if (type_args.vec_length() == 1 && node_kind(type_args.vec_get(0)) == NK_NAMED_TYPE) {
                    let cname = get_interned_str(node_get_data1(type_args.vec_get(0)));
                    return "__dyn_".str_concat(cname);
                }
                return "Unknown";
            }
            if (fn_return_types.map_has(fname)) {
                return fn_return_types.map_get(fname);
            }
        }
    }
    if (kind == NK_TUPLE_EXPR) {
        return "Unknown";
    }
    "Unknown"
}

fn expr_is_number_literal_nonzero(n: I32) : Bool => {
    if (n == 0 || node_kind(n) != NK_NUMBER_LIT) {
        return false;
    }
    !get_interned_str(node_get_data1(n)).str_eq("0")
}

fn is_decimal_digits(s: *Str) : Bool => {
    let i = 0;
    let n = s.str_length();
    if (n == 0) {
        return false;
    }
    while (i < n) {
        let ch = s.str_char_at(i);
        if (ch < 48 || ch > 57) {
            return false;
        }
        i = i + 1;
    }
    true
}

fn try_get_decimal_literal_value(n: I32) : I32 => {
    if (n == 0 || node_kind(n) != NK_NUMBER_LIT) {
        return 0;
    }
    let text = get_interned_str(node_get_data1(n));
    if (!is_decimal_digits(text)) {
        return 0;
    }
    parse_int(text)
}

fn is_decimal_zero_literal(n: I32) : Bool => {
    if (n == 0 || node_kind(n) != NK_NUMBER_LIT) {
        return false;
    }
    get_interned_str(node_get_data1(n)).str_eq("0")
}

// Temporary typecheck context maps used for strict array bounds proofs.
let tc_array_init_bounds : Map = map_new();
let tc_index_upper_bounds : Map = map_new();
let tc_global_value_types : Map = map_new();
let tc_alias_union_tags : Map = map_new();
let tc_type_alias_names : *mut Set = set_new();
let tc_contract_names : *mut Set = set_new();
let tc_destructor_alias_by_alias : Map = map_new();
let tc_destructor_alias_names : Vec = vec_new();

fn type_node_is_destructor_receiver(t: I32, alias_name: *Str) : Bool => {
    if (t == 0) {
        return false;
    }

    // Preferred form: alias receiver value (e.g. Alloc<...>)
    if (node_kind(t) == NK_NAMED_TYPE && get_interned_str(node_get_data1(t)).str_eq(alias_name)) {
        return true;
    }

    // Back-compat: *move Alias
    if (node_kind(t) == NK_POINTER_TYPE && node_get_data3(t) == 1) {
        return type_name_from_type_node(node_get_data2(t)).str_eq(alias_name);
    }

    false
}

fn collect_union_named_tags(type_node: I32, tags: Vec) : I32 => {
    if (type_node == 0) {
        return 0;
    }
    let kind = node_kind(type_node);
    if (kind == NK_UNION_TYPE) {
        collect_union_named_tags(node_get_data1(type_node), tags);
        collect_union_named_tags(node_get_data2(type_node), tags);
        return 0;
    }
    if (kind == NK_NAMED_TYPE) {
        tags.vec_push(get_interned_str(node_get_data1(type_node)));
        return 0;
    }
    if (kind == NK_REFINEMENT_TYPE) {
        collect_union_named_tags(node_get_data1(type_node), tags);
    }
    0
}

fn try_get_nonnegative_integer_literal(n: I32) : I32 => {
    if (n == 0 || node_kind(n) != NK_NUMBER_LIT) {
        return -1;
    }
    let text = get_interned_str(node_get_data1(n));
    if (str_ends_with_local(text, "USize")) {
        let len = text.str_length();
        let raw = text.str_slice(0, len - 5);
        if (!is_decimal_digits(raw)) {
            return -1;
        }
        return parse_int(raw);
    }
    if (!is_decimal_digits(text)) {
        return -1;
    }
    parse_int(text)
}

fn try_get_array_init_bound_from_type_node(t: I32) : I32 => {
    if (t == 0) {
        return -1;
    }
    let k = node_kind(t);
    if (k == NK_REFINEMENT_TYPE) {
        return try_get_array_init_bound_from_type_node(node_get_data1(t));
    }
    if (k == NK_POINTER_TYPE) {
        return try_get_array_init_bound_from_type_node(node_get_data2(t));
    }
    if (k == NK_ARRAY_TYPE) {
        return try_get_nonnegative_integer_literal(node_get_data2(t));
    }
    -1
}

fn try_get_index_upper_bound_from_type_node(t: I32) : I32 => {
    if (t == 0 || node_kind(t) != NK_REFINEMENT_TYPE) {
        return -1;
    }
    let base = node_get_data1(t);
    if (base == 0 || node_kind(base) != NK_NAMED_TYPE) {
        return -1;
    }
    let base_name = get_interned_str(node_get_data1(base));
    if (!base_name.str_eq("USize")) {
        return -1;
    }
    let lit = try_get_nonnegative_integer_literal(node_get_data3(t));
    if (lit < 0) {
        return -1;
    }
    let op = get_interned_str(node_get_data2(t));
    if (op.str_eq("<")) {
        return lit - 1;
    }
    if (op.str_eq("<=")) {
        return lit;
    }
    -1
}

fn is_zero_numeric_literal_node(n: I32) : Bool => {
    if (n == 0 || node_kind(n) != NK_NUMBER_LIT) {
        return false;
    }
    let text = get_interned_str(node_get_data1(n));
    text.str_eq("0") || text.str_eq("0USize")
}

fn expr_is_proven_nonzero(n: I32, nonnull_ptrs: Map) : Bool => {
    if (expr_is_number_literal_nonzero(n)) {
        return true;
    }
    if (n != 0 && node_kind(n) == NK_IDENTIFIER) {
        let name = get_interned_str(node_get_data1(n));
        return nonnull_ptrs.map_has(name);
    }
    false
}

fn type_node_proves_nonzero(t: I32) : Bool => {
    if (t == 0 || node_kind(t) != NK_REFINEMENT_TYPE) {
        return false;
    }
    let op = get_interned_str(node_get_data2(t));
    if (!op.str_eq("!=")) {
        return false;
    }
    is_zero_numeric_literal_node(node_get_data3(t))
}

fn typecheck_expr(n: I32, fn_arities: Map, fn_param_types: Map, fn_return_types: Map, local_types: Map, nonnull_ptrs: Map, strict_safety: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_BINARY_EXPR) {
        typecheck_expr(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        typecheck_expr(node_get_data3(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("/") && !expr_is_proven_nonzero(node_get_data3(n), nonnull_ptrs)) {
            let denom_node = node_get_data3(n);
            let denom_desc = "denominator";
            if (node_kind(denom_node) == NK_IDENTIFIER) {
                denom_desc = "denominator `".str_concat(get_interned_str(node_get_data1(denom_node))).str_concat("`");
            }
            panic_with_code(
                "E_SAFETY_DIV_BY_ZERO",
                "Division by zero cannot be ruled out at compile time",
                "The ".str_concat(denom_desc).str_concat(" is not proven non-zero; any value including 0 is possible."),
                "Prove denominator != 0 via refinement type or control-flow guard."
            );
        }
        if (op.str_eq("%") && !expr_is_proven_nonzero(node_get_data3(n), nonnull_ptrs)) {
            let mod_node = node_get_data3(n);
            let mod_desc = "modulo denominator";
            if (node_kind(mod_node) == NK_IDENTIFIER) {
                mod_desc = "modulo denominator `".str_concat(get_interned_str(node_get_data1(mod_node))).str_concat("`");
            }
            panic_with_code(
                "E_SAFETY_MOD_BY_ZERO",
                "Modulo by zero cannot be ruled out at compile time",
                "The ".str_concat(mod_desc).str_concat(" is not proven non-zero; any value including 0 is possible."),
                "Prove denominator != 0 via refinement type or control-flow guard."
            );
        }

        if (op.str_eq("+") || op.str_eq("-") || op.str_eq("*")) {
            let lnode = node_get_data2(n);
            let rnode = node_get_data3(n);
            let left = try_get_decimal_literal_value(lnode);
            let right = try_get_decimal_literal_value(rnode);

            if (left != 0 || is_decimal_zero_literal(lnode)) {
                if (right != 0 || is_decimal_zero_literal(rnode)) {
                    let result = 0;
                    if (op.str_eq("+")) {
                        result = left + right;
                    } else if (op.str_eq("-")) {
                        result = left - right;
                    } else {
                        result = left * right;
                    }

                    if (result < -2147483648 || result > 2147483647) {
                        let witness = int_to_string(left).str_concat(" ").str_concat(op).str_concat(" ").str_concat(int_to_string(right)).str_concat(" = ").str_concat(int_to_string(result)).str_concat(", which is outside I32 range [-2147483648, 2147483647]");
                        panic_with_code(
                            "E_SAFETY_OVERFLOW",
                            "Integer overflow/underflow proven possible for '".str_concat(op).str_concat("'"),
                            witness,
                            "Constrain operands or use a wider intermediate type before narrowing."
                        );
                    }
                }
            }
        }
        return 0;
    }

    if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
        if (kind == NK_UNARY_EXPR) {
            typecheck_expr(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        } else {
            typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        }
        return 0;
    }

    if (kind == NK_CALL_EXPR) {
        let callee = node_get_data1(n);
        let args = node_get_data2(n);
        let arg_count = args.vec_length();
        let fname = "";

        if (node_kind(callee) == NK_IDENTIFIER) {
            fname = get_interned_str(node_get_data1(callee));

            if (fname.str_eq("drop")) {
                if (arg_count != 1) {
                    panic_with_code(
                        "E_TYPE_ARG_COUNT",
                        "drop expects exactly one argument",
                        "The drop builtin requires one argument representing the value to drop.",
                        "Call drop(value) with exactly one argument."
                    );
                }
                let target = args.vec_get(0);
                let target_name = infer_expr_type_name(target, fn_return_types, local_types);
                if (!tc_destructor_alias_by_alias.map_has(target_name)) {
                    panic_with_code(
                        "E_TYPE_DESTRUCTOR_NOT_FOUND",
                        "Type '".str_concat(target_name).str_concat("' does not have an associated destructor"),
                        "drop can only be called for values whose alias type declares a destructor.",
                        "Define `type Alias = Base then destructorName;` and use that alias for dropped values."
                    );
                }
                return 0;
            }

            if (fname.str_eq("into") && node_get_data3(n) == 1) {
                if (arg_count < 1) {
                    panic_with_code(
                        "E_TYPE_ARG_COUNT",
                        "into conversion requires a receiver",
                        "Method-sugar into conversion requires a source value as receiver.",
                        "Use value.into<Contract>(...) with a receiver value."
                    );
                }

                let type_args = node_get_data4(n);
                let cname = "";
                if (type_args.vec_length() == 1 && node_kind(type_args.vec_get(0)) == NK_NAMED_TYPE) {
                    cname = get_interned_str(node_get_data1(type_args.vec_get(0)));
                }
                let cname_label = cname;
                if (cname_label.str_eq("")) {
                    cname_label = "<missing>";
                }
                if (cname.str_eq("") || !tc_contract_names.set_has(cname)) {
                    panic_with_code(
                        "E_TYPE_INTO_UNKNOWN_CONTRACT",
                        "Unknown contract '".str_concat(cname_label).str_concat("' in into conversion"),
                        "An into conversion referenced a contract that is not declared.",
                        "Declare the contract before converting with into."
                    );
                }

                typecheck_expr(args.vec_get(0), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
                let j = 1;
                while (j < arg_count) {
                    typecheck_expr(args.vec_get(j), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
                    j = j + 1;
                }
                return 0;
            }

            if (fn_arities.map_has(fname)) {
                let expected = fn_arities.map_get(fname);
                if (expected != arg_count) {
                    let msg = "Function ".str_concat(fname).str_concat(" expects ".str_concat(int_to_string(expected))).str_concat(" args, got ".str_concat(int_to_string(arg_count)));
                    panic_with_code(
                        "E_TYPE_ARG_COUNT",
                        msg,
                        "A function call provided a different number of arguments than the function signature requires.",
                        "Pass exactly the number of parameters declared by the function."
                    );
                }
            }

            if (fn_param_types.map_has(fname)) {
                let expected_types = fn_param_types.map_get(fname);
                let j = 0;
                while (j < arg_count) {
                    let arg_node = args.vec_get(j);
                    let arg_name = infer_expr_type_name(arg_node, fn_return_types, local_types);
                    let expected_name = expected_types.vec_get(j);

                    if (
                        expected_name.str_starts_with("*") &&
                        is_nullable_pointer_type_name(arg_name)
                    ) {
                        panic_with_code(
                            "E_SAFETY_NULLABLE_POINTER_GUARD",
                            "Call requires nullable pointer guard",
                            "A nullable pointer argument must be proven non-null before pointer-consuming calls.",
                            "Guard pointer use with if (p != 0USize) or if (0USize != p) before the call."
                        );
                    }

                    if (!type_names_compatible(expected_name, arg_name, arg_node)) {
                        let msg = "Type mismatch in call to ".str_concat(fname)
                            .str_concat(" arg ").str_concat(int_to_string(j + 1))
                            .str_concat(": expected ").str_concat(expected_name)
                            .str_concat(", got ").str_concat(arg_name);
                        panic_with_code(
                            "E_TYPE_ARG_MISMATCH",
                            msg,
                            "A function argument type does not match the corresponding parameter type.",
                            "Update the call argument or function parameter type so both sides are compatible."
                        );
                    }

                    j = j + 1;
                }
            }
        }

        typecheck_expr(callee, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        let i = 0;
        while (i < arg_count) {
            typecheck_expr(args.vec_get(i), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_MEMBER_EXPR) {
        let obj = node_get_data1(n);
        let obj_name = infer_expr_type_name(obj, fn_return_types, local_types);
        if (is_nullable_pointer_type_name(obj_name)) {
            let guarded = false;
            if (node_kind(obj) == NK_IDENTIFIER) {
                let oname = get_interned_str(node_get_data1(obj));
                guarded = nonnull_ptrs.map_has(oname);
            }
            if (!guarded) {
                panic_with_code(
                    "E_SAFETY_NULLABLE_POINTER_GUARD",
                    "Nullable pointer access requires guard",
                    "A nullable pointer must be proven non-null before pointer-consuming operations.",
                    "Guard with if (p != 0USize) or if (0USize != p) before member access."
                );
            }
        }
        typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    if (kind == NK_INDEX_EXPR) {
        let target_node = node_get_data1(n);
        let target_name = infer_expr_type_name(target_node, fn_return_types, local_types);
        if (is_nullable_pointer_type_name(target_name)) {
            let guarded = false;
            if (node_kind(target_node) == NK_IDENTIFIER) {
                let tname = get_interned_str(node_get_data1(target_node));
                guarded = nonnull_ptrs.map_has(tname);
            }
            if (!guarded) {
                panic_with_code(
                    "E_SAFETY_NULLABLE_POINTER_GUARD",
                    "Nullable pointer indexing requires guard",
                    "A nullable pointer must be proven non-null before pointer-consuming operations.",
                    "Guard with if (p != 0USize) or if (0USize != p) before indexing."
                );
            }
        }

        if (strict_safety == 1 && node_kind(target_node) == NK_IDENTIFIER) {
            let tname = get_interned_str(node_get_data1(target_node));
            if (tc_array_init_bounds.map_has(tname)) {
                let bound = tc_array_init_bounds.map_get(tname);
                if (bound >= 0) {
                    let index_node = node_get_data2(n);
                    let index_max = -1;
                    if (node_kind(index_node) == NK_IDENTIFIER) {
                        let iname = get_interned_str(node_get_data1(index_node));
                        if (tc_index_upper_bounds.map_has(iname)) {
                            index_max = tc_index_upper_bounds.map_get(iname);
                        }
                    }
                    if (index_max < 0) {
                        index_max = try_get_nonnegative_integer_literal(index_node);
                    }
                    if (index_max < 0) {
                        panic_with_code(
                            "E_SAFETY_ARRAY_BOUNDS_UNPROVEN",
                            "Cannot prove array index bound safety",
                            "The array index does not have a proven upper bound under strict safety checks.",
                            "Guard index with 'if (i < arr.length)' before indexing."
                        );
                    }
                    if (index_max >= bound) {
                        panic_with_code(
                            "E_SAFETY_ARRAY_BOUNDS",
                            "Array index may be out of bounds",
                            "The proven index upper bound can exceed initialized array length.",
                            "Ensure 0 <= index < initialized length."
                        );
                    }
                }
            }
        }

        typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        typecheck_expr(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    if (kind == NK_STRUCT_INIT) {
        let fields = node_get_data2(n);
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            typecheck_expr(field.vec_get(1), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_TUPLE_EXPR) {
        let items = node_get_data1(n);
        let i = 0;
        let len = items.vec_length();
        while (i < len) {
            typecheck_expr(items.vec_get(i), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IF_EXPR) {
        let cond = node_get_data1(n);
        typecheck_expr(cond, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        let cond_name = infer_expr_type_name(cond, fn_return_types, local_types);
        if (!cond_name.str_eq("Bool") && !cond_name.str_eq("Unknown")) {
            panic_with_code(
                "E_TYPE_IF_CONDITION",
                "if condition must be Bool",
                "Conditional branches require a boolean predicate.",
                "Return or compute a Bool expression in the if condition."
            );
        }
        typecheck_stmt(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety, "Unknown");
        if (node_get_data3(n) != 0) {
            typecheck_stmt(node_get_data3(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety, "Unknown");
        }
        return 0;
    }

    if (kind == NK_MATCH_EXPR) {
        let target = node_get_data1(n);
        typecheck_expr(target, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);

        let target_name = infer_expr_type_name(target, fn_return_types, local_types);
        let expected_tags = vec_new();
        if (tc_alias_union_tags.map_has(target_name)) {
            expected_tags = tc_alias_union_tags.map_get(target_name);
        }

        let cases = node_get_data2(n);
        let i = 0;
        let len = cases.vec_length();
        let seen_tags = set_new();
        let has_wildcard = false;
        while (i < len) {
            let case_node = cases.vec_get(i);
            let pat = case_node.vec_get(0);
            if (node_kind(pat) == NK_WILDCARD_PAT) {
                has_wildcard = true;
            }
            if (node_kind(pat) == NK_NAME_PAT || node_kind(pat) == NK_STRUCT_PAT) {
                seen_tags.set_add(get_interned_str(node_get_data1(pat)));
            }
            typecheck_stmt(case_node.vec_get(1), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety, "Unknown");
            i = i + 1;
        }

        if (strict_safety == 1 && expected_tags.vec_length() > 0 && !has_wildcard) {
            let j = 0;
            let jlen = expected_tags.vec_length();
            while (j < jlen) {
                let tag = expected_tags.vec_get(j);
                if (!seen_tags.set_has(tag)) {
                    panic_with_code(
                        "E_MATCH_NON_EXHAUSTIVE",
                        "Non-exhaustive match: missing case for ".str_concat(tag),
                        "A match expression over a known union type does not handle all variants.",
                        "Add missing case arms or include a wildcard case '_'."
                    );
                }
                j = j + 1;
            }
        }
        return 0;
    }

    if (kind == NK_IS_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    0
}

fn typecheck_stmt(n: I32, fn_arities: Map, fn_param_types: Map, fn_return_types: Map, local_types: Map, nonnull_ptrs: Map, strict_safety: I32, expected_return_type: *Str) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_BLOCK) {
        let stmts = node_get_data1(n);
        let i = 0;
        let len = stmts.vec_length();
        while (i < len) {
            typecheck_stmt(stmts.vec_get(i), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety, expected_return_type);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_EXPECT_FN_DECL) {
        return 0;
    }

    if (kind == NK_CONTRACT_DECL) {
        return 0;
    }

    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
        let prev_array_bounds = tc_array_init_bounds;
        let prev_index_bounds = tc_index_upper_bounds;
        tc_array_init_bounds = map_new();
        tc_index_upper_bounds = map_new();

        let fn_local_types = map_new();
        let fn_nonnull_ptrs = map_new();
        let params = node_get_data3(n);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let p = params.vec_get(i);
            let pname = get_interned_str(p.vec_get(0));
            let ptype = p.vec_get(1);
            if (ptype != 0) {
                fn_local_types.map_set(pname, type_name_from_type_node(ptype));

                let arr_init_bound = try_get_array_init_bound_from_type_node(ptype);
                if (arr_init_bound >= 0) {
                    tc_array_init_bounds.map_set(pname, arr_init_bound);
                }

                let index_upper_bound = try_get_index_upper_bound_from_type_node(ptype);
                if (index_upper_bound >= 0) {
                    tc_index_upper_bounds.map_set(pname, index_upper_bound);
                }

                if (type_node_proves_nonzero(ptype)) {
                    fn_nonnull_ptrs.map_set(pname, 1);
                }
            }
            i = i + 1;
        }

        let expected_name = type_name_from_type_node(node_get_data4(n));
        typecheck_stmt(node_get_data5(n), fn_arities, fn_param_types, fn_return_types, fn_local_types, fn_nonnull_ptrs, strict_safety, expected_name);

        let body = node_get_data5(n);
        if (node_kind(body) != NK_BLOCK) {
            let body_name = infer_expr_type_name(body, fn_return_types, fn_local_types);
            if (!type_names_compatible(expected_name, body_name, body)) {
                let fname = get_interned_str(node_get_data1(n));
                panic_with_code(
                    "E_TYPE_RETURN_MISMATCH",
                    "Function ".str_concat(fname).str_concat(" return type mismatch: expected ").str_concat(expected_name).str_concat(", got ").str_concat(body_name),
                    "The function body expression type does not match the declared return type.",
                    "Update the function return type annotation or adjust the returned expression."
                );
            }
        }

        tc_array_init_bounds = prev_array_bounds;
        tc_index_upper_bounds = prev_index_bounds;
        return 0;
    }

    if (kind == NK_LET_DECL) {
        let declared_type = node_get_data2(n);
        let rhs = node_get_data3(n);
        typecheck_expr(rhs, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);

        let rhs_name = infer_expr_type_name(rhs, fn_return_types, local_types);
        if (declared_type != 0) {
            let declared_name = type_name_from_type_node(declared_type);
            if (!declared_name.str_eq("Unknown") && !rhs_name.str_eq("Unknown") && !pointer_types_compatible(declared_name, rhs_name) && !numeric_types_compatible(declared_name, rhs_name, rhs) && !tc_type_alias_names.set_has(declared_name)) {
                let vname = get_interned_str(node_get_data1(n));
                let msg = "Type mismatch for let ".str_concat(vname).str_concat(": expected ").str_concat(declared_name).str_concat(", got ").str_concat(rhs_name);
                panic_with_code(
                    "E_TYPE_LET_MISMATCH",
                    msg,
                    "An explicit let type annotation does not match the assigned RHS expression type.",
                    "Update the explicit type annotation or change the RHS expression to match."
                );
            }
            let lname = get_interned_str(node_get_data1(n));
            local_types.map_set(lname, declared_name);

            let arr_init_bound = try_get_array_init_bound_from_type_node(declared_type);
            if (arr_init_bound >= 0) {
                tc_array_init_bounds.map_set(lname, arr_init_bound);
            }

            let index_upper_bound = try_get_index_upper_bound_from_type_node(declared_type);
            if (index_upper_bound >= 0) {
                tc_index_upper_bounds.map_set(lname, index_upper_bound);
            }
        } else if (!rhs_name.str_eq("Unknown")) {
            local_types.map_set(get_interned_str(node_get_data1(n)), rhs_name);
        }
        return 0;
    }

    if (kind == NK_EXTERN_IMPORT_DECL) {
        return 0;
    }

    if (kind == NK_EXPR_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        return 0;
    }

    if (kind == NK_ASSIGN_STMT) {
        let target = node_get_data1(n);
        let value = node_get_data2(n);
        typecheck_expr(target, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        typecheck_expr(value, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);

        if (node_kind(target) == NK_IDENTIFIER) {
            let tname = get_interned_str(node_get_data1(target));
            if (local_types.map_has(tname)) {
                let expected_name = local_types.map_get(tname);
                let value_name = infer_expr_type_name(value, fn_return_types, local_types);
                if (!type_names_compatible(expected_name, value_name, value) && !tc_type_alias_names.set_has(expected_name)) {
                    panic_with_code(
                        "E_TYPE_ASSIGN_MISMATCH",
                        "Assignment mismatch for ".str_concat(tname).str_concat(": expected ").str_concat(expected_name).str_concat(", got ").str_concat(value_name),
                        "The assigned value type is incompatible with the declared variable type.",
                        "Assign a compatible value or change the variable type declaration."
                    );
                }
            }
        }
        return 0;
    }

    if (kind == NK_RETURN_STMT) {
        let value = node_get_data1(n);
        typecheck_expr(value, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        if (!expected_return_type.str_eq("Unknown")) {
            let value_name = infer_expr_type_name(value, fn_return_types, local_types);
            if (!type_names_compatible(expected_return_type, value_name, value)) {
                panic_with_code(
                    "E_TYPE_RETURN_MISMATCH",
                    "Return type mismatch: expected ".str_concat(expected_return_type).str_concat(", got ").str_concat(value_name),
                    "A return statement produced a value incompatible with the function's declared return type.",
                    "Return a value of the declared type or adjust the function return annotation."
                );
            }
        }
        return 0;
    }

    if (kind == NK_IF_STMT) {
        let cond = node_get_data1(n);
        typecheck_expr(cond, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        let cond_name = infer_expr_type_name(cond, fn_return_types, local_types);
        if (!cond_name.str_eq("Bool") && !cond_name.str_eq("Unknown")) {
            panic_with_code(
                "E_TYPE_IF_CONDITION",
                "if condition must be Bool",
                "Conditional branches require a boolean predicate.",
                "Return or compute a Bool expression in the if condition."
            );
        }
        let then_nonnull = map_new();
        let else_nonnull = map_new();
        let copied_then = false;
        let copied_else = false;
        if (node_kind(cond) == NK_BINARY_EXPR) {
            let op = get_interned_str(node_get_data1(cond));
            let left = node_get_data2(cond);
            let right = node_get_data3(cond);
            if (op.str_eq("!=")) {
                if (node_kind(left) == NK_IDENTIFIER && is_usize_zero_literal_node(right)) {
                    then_nonnull.map_set(get_interned_str(node_get_data1(left)), 1);
                    copied_then = true;
                }
                if (node_kind(right) == NK_IDENTIFIER && is_usize_zero_literal_node(left)) {
                    then_nonnull.map_set(get_interned_str(node_get_data1(right)), 1);
                    copied_then = true;
                }
                if (node_kind(left) == NK_IDENTIFIER && is_zero_numeric_literal_node(right)) {
                    then_nonnull.map_set(get_interned_str(node_get_data1(left)), 1);
                    copied_then = true;
                }
                if (node_kind(right) == NK_IDENTIFIER && is_zero_numeric_literal_node(left)) {
                    then_nonnull.map_set(get_interned_str(node_get_data1(right)), 1);
                    copied_then = true;
                }
            }
            if (op.str_eq("==")) {
                if (node_kind(left) == NK_IDENTIFIER && is_zero_numeric_literal_node(right)) {
                    else_nonnull.map_set(get_interned_str(node_get_data1(left)), 1);
                    copied_else = true;
                }
                if (node_kind(right) == NK_IDENTIFIER && is_zero_numeric_literal_node(left)) {
                    else_nonnull.map_set(get_interned_str(node_get_data1(right)), 1);
                    copied_else = true;
                }
            }
        }
        if (!copied_then) {
            then_nonnull = nonnull_ptrs;
        }
        if (!copied_else) {
            else_nonnull = nonnull_ptrs;
        }

        // Basic pattern narrowing: if (x is Variant) { ... }
        let narrowed_ident = "";
        let had_prev_narrowed = 0;
        let prev_narrowed_type = "";
        if (node_kind(cond) == NK_IS_EXPR) {
            let subject = node_get_data1(cond);
            let pat = node_get_data2(cond);
            if (node_kind(subject) == NK_IDENTIFIER && (node_kind(pat) == NK_NAME_PAT || node_kind(pat) == NK_STRUCT_PAT)) {
                narrowed_ident = get_interned_str(node_get_data1(subject));
                let narrowed_type = get_interned_str(node_get_data1(pat));
                if (local_types.map_has(narrowed_ident)) {
                    had_prev_narrowed = 1;
                    prev_narrowed_type = local_types.map_get(narrowed_ident);
                }
                local_types.map_set(narrowed_ident, narrowed_type);
            }
        }

        typecheck_stmt(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, then_nonnull, strict_safety, expected_return_type);

        if (!narrowed_ident.str_eq("")) {
            if (had_prev_narrowed == 1) {
                local_types.map_set(narrowed_ident, prev_narrowed_type);
            } else {
                local_types.map_set(narrowed_ident, "Unknown");
            }
        }

        if (node_get_data3(n) != 0) {
            typecheck_stmt(node_get_data3(n), fn_arities, fn_param_types, fn_return_types, local_types, else_nonnull, strict_safety, expected_return_type);
        }
        return 0;
    }

    if (kind == NK_FOR_STMT) {
        typecheck_expr(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        typecheck_expr(node_get_data3(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        typecheck_stmt(node_get_data4(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety, expected_return_type);
        return 0;
    }

    if (kind == NK_WHILE_STMT) {
        let cond = node_get_data1(n);
        typecheck_expr(cond, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
        let cond_name = infer_expr_type_name(cond, fn_return_types, local_types);
        if (!cond_name.str_eq("Bool") && !cond_name.str_eq("Unknown")) {
            panic_with_code(
                "E_TYPE_IF_CONDITION",
                "if condition must be Bool",
                "Conditional branches require a boolean predicate.",
                "Return or compute a Bool expression in the condition."
            );
        }
        typecheck_stmt(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety, expected_return_type);
        return 0;
    }

    if (kind == NK_LOOP_STMT) {
        typecheck_stmt(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety, expected_return_type);
        return 0;
    }

    if (kind == NK_LIFETIME_STMT) {
        typecheck_stmt(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety, expected_return_type);
        return 0;
    }

    if (kind == NK_INTO_STMT) {
        let cname = get_interned_str(node_get_data1(n));
        if (!tc_contract_names.set_has(cname)) {
            panic_with_code(
                "E_TYPE_UNKNOWN_CONTRACT",
                "Unknown contract '".str_concat(cname).str_concat("' in into statement"),
                "An into statement referenced a contract that is not declared.",
                "Declare the contract before using 'into'."
            );
        }
        return 0;
    }

    // Fallback: treat unmatched nodes as expressions.
    typecheck_expr(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, strict_safety);
    0
}

out fn typecheck_program_with_options(program: I32, strict_safety: I32) : I32 => {
    let fn_arities = map_new();
    let fn_param_types = map_new();
    let fn_return_types = map_new();
    let fn_nodes = map_new();
    let local_types = map_new();
    tc_global_value_types = map_new();
    tc_alias_union_tags = map_new();
    tc_type_alias_names = set_new();
    tc_contract_names = set_new();
    tc_destructor_alias_by_alias = map_new();
    tc_destructor_alias_names = vec_new();
    let body = node_get_data1(program);

    // Collect function signatures (including extern fns).
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        let stmt = body.vec_get(i);
        let kind = node_kind(stmt);
        if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_EXTERN_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
            let name = get_interned_str(node_get_data1(stmt));
            fn_nodes.map_set(name, stmt);
            let params = node_get_data3(stmt);
            fn_arities.map_set(name, params.vec_length());

            let param_types = vec_new();
            let p = 0;
            while (p < params.vec_length()) {
                let param = params.vec_get(p);
                let param_type_node = param.vec_get(1);
                param_types.vec_push(type_name_from_type_node(param_type_node));
                p = p + 1;
            }
            fn_param_types.map_set(name, param_types);

            let ret_type = node_get_data4(stmt);
            fn_return_types.map_set(name, type_name_from_type_node(ret_type));
        }
        if (kind == NK_EXTERN_LET_DECL) {
            let vname = get_interned_str(node_get_data1(stmt));
            let vtype = node_get_data2(stmt);
            let tname = type_name_from_type_node(vtype);
            local_types.map_set(vname, tname);
            tc_global_value_types.map_set(vname, tname);
        }
        if (kind == NK_TYPE_ALIAS) {
            let alias_name = get_interned_str(node_get_data1(stmt));
            tc_type_alias_names.set_add(alias_name);
            let alias_type = node_get_data3(stmt);
            let tags = vec_new();
            collect_union_named_tags(alias_type, tags);
            if (tags.vec_length() > 0) {
                tc_alias_union_tags.map_set(alias_name, tags);
            }

            let destructor_name_idx = node_get_data5(stmt);
            if (destructor_name_idx != 0) {
                let destructor_name = get_interned_str(destructor_name_idx);
                tc_destructor_alias_by_alias.map_set(alias_name, destructor_name);
                tc_destructor_alias_names.vec_push(alias_name);
            }
        }
        if (kind == NK_EXTERN_TYPE_DECL) {
            tc_type_alias_names.set_add(get_interned_str(node_get_data1(stmt)));
        }
        if (kind == NK_CONTRACT_DECL) {
            tc_contract_names.set_add(get_interned_str(node_get_data1(stmt)));
        }
        if (kind == NK_LET_DECL) {
            let vname = get_interned_str(node_get_data1(stmt));
            let vtype = node_get_data2(stmt);
            if (vtype != 0) {
                tc_global_value_types.map_set(vname, type_name_from_type_node(vtype));
            }
        }
        i = i + 1;
    }

    // Validate destructor declarations/signatures irrespective of strict mode.
    i = 0;
    let destructor_alias_count = tc_destructor_alias_names.vec_length();
    while (i < destructor_alias_count) {
        let alias_name = tc_destructor_alias_names.vec_get(i);
        let destructor_name = tc_destructor_alias_by_alias.map_get(alias_name);
        if (!fn_nodes.map_has(destructor_name)) {
            panic_with_code(
                "E_TYPE_DESTRUCTOR_NOT_FOUND",
                "Destructor '".str_concat(destructor_name).str_concat("' for alias '").str_concat(alias_name).str_concat("' was not found"),
                "A type alias referenced a destructor function that does not exist.",
                "Declare the destructor function before using it in 'type Alias = ... then destructor'."
            );
        }

        let fn_node = fn_nodes.map_get(destructor_name);
        let params = node_get_data3(fn_node);
        let valid = true;
        if (params.vec_length() != 1) {
            valid = false;
        } else {
            let p0 = params.vec_get(0);
            let pname = get_interned_str(p0.vec_get(0));
            let ptype = p0.vec_get(1);
            if (!pname.str_eq("this")) {
                valid = false;
            }
            if (!type_node_is_destructor_receiver(ptype, alias_name)) {
                valid = false;
            }
        }

        let ret_name = type_name_from_type_node(node_get_data4(fn_node));
        if (!ret_name.str_eq("Void")) {
            valid = false;
        }

        if (!valid) {
            panic_with_code(
                "E_TYPE_DESTRUCTOR_SIGNATURE",
                "Destructor '".str_concat(destructor_name).str_concat("' must have signature fn ").str_concat(destructor_name).str_concat("(this : ").str_concat(alias_name).str_concat("<...>) : Void"),
                "Destructor signatures must follow the required receiver and return type contract.",
                "Use exactly one receiver parameter named 'this' with the alias type (or legacy '*move AliasType') and return Void."
            );
        }

        i = i + 1;
    }

    if (strict_safety != 1) {
        return program;
    }

    // Check calls across whole program.
    i = 0;
    while (i < len) {
        typecheck_stmt(body.vec_get(i), fn_arities, fn_param_types, fn_return_types, local_types, map_new(), strict_safety, "Unknown");
        i = i + 1;
    }

    program
}

out fn typecheck_program(program: I32) : I32 => {
    typecheck_program_with_options(program, 1)
}

out fn selfhost_typecheck_marker() : I32 => 0;
