let {
    getInternedStr, lintEffectiveLineCount, mapNew, setNew, vecNew, strStartsWith, intToString
}
 = selfhost::runtimeLexer;
let {
    nodeKind, nodeGetData1, nodeGetData2, nodeGetData3, nodeGetData4, nodeGetData5, nodeGetLine, nodeGetCol
}
 = selfhost::parserCore;
let {
    sourcemapLookup
}
 = selfhost::moduleSourcemap;
let lintIssueRecords : Vec<*Str> = vecNew();
fn lintIssueSepField() : *Str => "\u001f";
fn lintIssueSepRecord() : *Str => "\u001e";
fn lintIssueEncode(code: *Str, message: *Str, reason: *Str, fix: *Str, line: I32, col: I32, filePath: *Str) : *Str => {
    code
    .strConcat(lintIssueSepField())
    .strConcat(message)
    .strConcat(lintIssueSepField())
    .strConcat(reason)
    .strConcat(lintIssueSepField())
    .strConcat(fix)
    .strConcat(lintIssueSepField())
    .strConcat(filePath)
    .strConcat(lintIssueSepField())
    .strConcat(intToString(col))
}
fn lintAddIssue(code: *Str, message: *Str, reason: *Str, fix: *Str) : I32 => {
    lintIssueRecords.vecPush(lintIssueEncode(code, message, reason, fix, 0, 0, "<unknown>"));
    0
}
fn lintAddIssueAt(code: *Str, message: *Str, reason: *Str, fix: *Str, line: I32, col: I32) : I32 => {
    let filePath = sourcemapLookup(line);
    lintIssueRecords.vecPush(lintIssueEncode(code, message, reason, fix, line, col, filePath));
    0
}
out fn lintReset() : I32 => {
    lintIssueRecords.vecClear();
    0
}
out fn lintTakeIssues() : *Str => {
    let s = lintIssueRecords.vecJoin(lintIssueSepRecord());
    lintIssueRecords.vecClear();
    s
}
fn lintCheckFileLength(filePath: *Str, maxEffectiveLines: I32) : I32 => {
    let count = lintEffectiveLineCount();
    if (count > maxEffectiveLines) {
        lintAddIssue(
        "E_LINT_FILE_TOO_LONG",
        "File '".strConcat(filePath).strConcat("' exceeds ").strConcat(intToString(maxEffectiveLines)).strConcat(" effective lines (").strConcat(intToString(count)).strConcat(")"),
        "Large files are harder to review and maintain; this file exceeds the maximum effective line budget after excluding comments and blank lines.",
        "Split this file into smaller modules so each file has at most ".strConcat(intToString(maxEffectiveLines)).strConcat(" non-comment, non-whitespace lines.")
        );
    }
    0
}
out fn lintCheckCurrentFileLength(filePath: *Str, maxEffectiveLines: I32) : I32 => {
    lintCheckFileLength(filePath, maxEffectiveLines)
}
fn lintIsExternFnDecl(stmt: I32) : Bool => {
    let kind = nodeKind(stmt);
    kind == NK_FN_DECL && nodeGetData5(stmt) == 0
}
fn lintMarkLine(lines: *mut Set<I32>, line: I32) : I32 => {
    let key = intToString(line);
    if (!lines.setHas(key)) {
        lines.setAdd(key);
        return 1;
    }
    0
}
fn lintCollectEffectiveLinesExpr(expr: I32, lines: *mut Set<I32>) : I32 => {
    if (expr == 0) {
        return 0;
    }
    let added = lintMarkLine(lines, nodeGetLine(expr));
    let kind = nodeKind(expr);
    if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
        added = added + lintCollectEffectiveLinesExpr(nodeGetData2(expr), lines);
        if (kind == NK_UNWRAP_EXPR) {
            added = added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines);
        }
        return added;
    }
    if (kind == NK_BINARY_EXPR) {
        added = added + lintCollectEffectiveLinesExpr(nodeGetData2(expr), lines);
        added = added + lintCollectEffectiveLinesExpr(nodeGetData3(expr), lines);
        return added;
    }
    if (kind == NK_CALL_EXPR) {
        added = added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines);
        let args = nodeGetData2(expr);
        let i = 0;
        let __len25 = args.vecLength();
        while (i < __len25) {
            added = added + lintCollectEffectiveLinesExpr(args.vecGet(i), lines);
            i = i + 1;
        }
        return added;
    }
    if (kind == NK_MEMBER_EXPR) {
        return added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines);
    }
    if (kind == NK_INDEX_EXPR) {
        added = added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines);
        added = added + lintCollectEffectiveLinesExpr(nodeGetData2(expr), lines);
        return added;
    }
    if (kind == NK_STRUCT_INIT) {
        let fields = nodeGetData2(expr);
        let i = 0;
        let __len24 = fields.vecLength();
        while (i < __len24) {
            let field = fields.vecGet(i);
            added = added + lintCollectEffectiveLinesExpr(field.vecGet(1), lines);
            i = i + 1;
        }
        return added;
    }
    if (kind == NK_IF_EXPR) {
        added = added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines);
        added = added + lintCollectEffectiveLinesStmt(nodeGetData2(expr), lines);
        if (nodeGetData3(expr) != 0) {
            added = added + lintCollectEffectiveLinesStmt(nodeGetData3(expr), lines);
        }
        return added;
    }
    if (kind == NK_MATCH_EXPR) {
        added = added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines);
        let cases = nodeGetData2(expr);
        let i = 0;
        let __len23 = cases.vecLength();
        while (i < __len23) {
            let c = cases.vecGet(i);
            added = added + lintCollectEffectiveLinesStmt(c.vecGet(1), lines);
            i = i + 1;
        }
        return added;
    }
    if (kind == NK_IS_EXPR) {
        return added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines);
    }
    if (kind == NK_FN_EXPR) {
        return added + lintCollectEffectiveLinesStmt(nodeGetData5(expr), lines);
    }
    if (kind == NK_LAMBDA_EXPR) {
        return added + lintCollectEffectiveLinesStmt(nodeGetData2(expr), lines);
    }
    if (kind == NK_TUPLE_EXPR) {
        let items = nodeGetData1(expr);
        let i = 0;
        let __len22 = items.vecLength();
        while (i < __len22) {
            added = added + lintCollectEffectiveLinesExpr(items.vecGet(i), lines);
            i = i + 1;
        }
        return added;
    }
    added
}
fn lintCollectEffectiveLinesStmt(stmt: I32, lines: *mut Set<I32>) : I32 => {
    if (stmt == 0) {
        return 0;
    }
    let added = lintMarkLine(lines, nodeGetLine(stmt));
    let kind = nodeKind(stmt);
    if (kind == NK_LET_DECL) {
        added = added + lintCollectEffectiveLinesExpr(nodeGetData2(stmt), lines);
        added = added + lintCollectEffectiveLinesExpr(nodeGetData3(stmt), lines);
        return added;
    }
    if (kind == NK_BLOCK) {
        let stmts = nodeGetData1(stmt);
        let i = 0;
        let __len21 = stmts.vecLength();
        while (i < __len21) {
            added = added + lintCollectEffectiveLinesStmt(stmts.vecGet(i), lines);
            i = i + 1;
        }
        return added;
    }
    if (kind == NK_EXPR_STMT) {
        return added + lintCollectEffectiveLinesExpr(nodeGetData1(stmt), lines);
    }
    if (kind == NK_ASSIGN_STMT) {
        added = added + lintCollectEffectiveLinesExpr(nodeGetData1(stmt), lines);
        added = added + lintCollectEffectiveLinesExpr(nodeGetData2(stmt), lines);
        return added;
    }
    if (kind == NK_RETURN_STMT) {
        return added + lintCollectEffectiveLinesExpr(nodeGetData1(stmt), lines);
    }
    if (kind == NK_IF_STMT) {
        added = added + lintCollectEffectiveLinesExpr(nodeGetData1(stmt), lines);
        added = added + lintCollectEffectiveLinesStmt(nodeGetData2(stmt), lines);
        added = added + lintCollectEffectiveLinesStmt(nodeGetData3(stmt), lines);
        return added;
    }
    if (kind == NK_FOR_STMT) {
        added = added + lintCollectEffectiveLinesExpr(nodeGetData2(stmt), lines);
        added = added + lintCollectEffectiveLinesExpr(nodeGetData3(stmt), lines);
        added = added + lintCollectEffectiveLinesStmt(nodeGetData4(stmt), lines);
        return added;
    }
    if (kind == NK_WHILE_STMT) {
        added = added + lintCollectEffectiveLinesExpr(nodeGetData1(stmt), lines);
        added = added + lintCollectEffectiveLinesStmt(nodeGetData2(stmt), lines);
        return added;
    }
    if (kind == NK_LOOP_STMT) {
        return added + lintCollectEffectiveLinesStmt(nodeGetData1(stmt), lines);
    }
    if (kind == NK_LIFETIME_STMT) {
        return added + lintCollectEffectiveLinesStmt(nodeGetData2(stmt), lines);
    }
    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
        added = added + lintCollectEffectiveLinesExpr(nodeGetData4(stmt), lines);
        added = added + lintCollectEffectiveLinesStmt(nodeGetData5(stmt), lines);
        return added;
    }
    if (kind == NK_STMT_LIST) {
        let items = nodeGetData1(stmt);
        let i = 0;
        let __len20 = items.vecLength();
        while (i < __len20) {
            added = added + lintCollectEffectiveLinesStmt(items.vecGet(i), lines);
            i = i + 1;
        }
        return added;
    }
    if (kind == NK_INTO_STMT || kind == NK_BREAK_STMT || kind == NK_CONTINUE_STMT || kind ==
    NK_EXTERN_IMPORT_DECL || lintIsExternFnDecl(stmt) || kind == NK_EXTERN_LET_DECL || kind == NK_EXTERN_TYPE_DECL) {
        return added;
    }
    added + lintCollectEffectiveLinesExpr(stmt, lines)
}
fn lintCheckFunctionLength(stmt: I32, maxEffectiveLines: I32) : I32 => {
    let kind = nodeKind(stmt);
    if (!(kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL)) {
        return 0;
    }
    let body = nodeGetData5(stmt);
    if (body == 0) {
        return 0;
    }
    let lines = setNew();
    let count = lintMarkLine(lines, nodeGetLine(stmt));
    count = count + lintCollectEffectiveLinesStmt(body, lines);
    if (count >= maxEffectiveLines) {
        let fnName = getInternedStr(nodeGetData1(stmt));
        lintAddIssue(
        "E_LINT_FUNCTION_TOO_LONG",
        "Function '".strConcat(fnName).strConcat("' has ").strConcat(intToString(maxEffectiveLines)).strConcat(" or more effective lines (").strConcat(intToString(count)).strConcat(")"),
        "This function has at least ".strConcat(intToString(maxEffectiveLines)).strConcat(" non-comment, non-whitespace lines, which increases complexity and reduces readability."),
        "Split function '".strConcat(fnName).strConcat("' into smaller helper functions so each function stays below ").strConcat(intToString(maxEffectiveLines)).strConcat(" effective lines.")
        );
    }
    0
}
fn lintCollectExpr(expr: I32, receiverExternFns: *mut Set<I32>, reads: *mut Set<I32>) : I32 => {
    if (expr == 0) {
        return 0;
    }
    let kind = nodeKind(expr);
    if (kind == NK_IDENTIFIER) {
        reads.setAdd(getInternedStr(nodeGetData1(expr)));
        return 0;
    }
    if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
        lintCollectExpr(nodeGetData2(expr), receiverExternFns, reads);
        if (kind == NK_UNWRAP_EXPR) {
            lintCollectExpr(nodeGetData1(expr), receiverExternFns, reads);
        }
        return 0;
    }
    if (kind == NK_BINARY_EXPR) {
        lintCollectExpr(nodeGetData2(expr), receiverExternFns, reads);
        lintCollectExpr(nodeGetData3(expr), receiverExternFns, reads);
        return 0;
    }
    if (kind == NK_CALL_EXPR) {
        let callee = nodeGetData1(expr);
        let args = nodeGetData2(expr);
        if (nodeKind(callee) == NK_IDENTIFIER && args.vecLength() > 0) {
            let name = getInternedStr(nodeGetData1(callee));
            let callStyle = nodeGetData3(expr);
            if (receiverExternFns.setHas(name) && callStyle != 1) {
                lintAddIssue(
                "E_LINT_PREFER_RECEIVER_CALL",
                "Prefer receiver-call syntax for '".strConcat(name).strConcat("'"),
                "This extern function declares a receiver as its first 'this' parameter, so calling it as a free function is less idiomatic.",
                "Rewrite '".strConcat(name).strConcat("(x, ...)' as 'x.").strConcat(name).strConcat("(...)'.")
                );
            }
        }
        lintCollectExpr(callee, receiverExternFns, reads);
        let i = 0;
        let len = args.vecLength();
        while (i < len) {
            lintCollectExpr(args.vecGet(i), receiverExternFns, reads);
            i = i + 1;
        }
        return 0;
    }
    if (kind == NK_MEMBER_EXPR) {
        lintCollectExpr(nodeGetData1(expr), receiverExternFns, reads);
        return 0;
    }
    if (kind == NK_INDEX_EXPR) {
        lintCollectExpr(nodeGetData1(expr), receiverExternFns, reads);
        lintCollectExpr(nodeGetData2(expr), receiverExternFns, reads);
        return 0;
    }
    if (kind == NK_STRUCT_INIT) {
        let fields = nodeGetData2(expr);
        let i = 0;
        let len = fields.vecLength();
        while (i < len) {
            let field = fields.vecGet(i);
            lintCollectExpr(field.vecGet(1), receiverExternFns, reads);
            i = i + 1;
        }
        return 0;
    }
    if (kind == NK_IF_EXPR) {
        let cond = nodeGetData1(expr);
        if (nodeKind(cond) == NK_BOOL_LIT) {
            lintAddIssue(
            "E_LINT_CONSTANT_CONDITION",
            "Constant condition in if-expression/statement",
            "A constant condition means one branch is unreachable, which usually indicates dead or unintended code.",
            "Use a non-constant condition, or simplify by keeping only the branch that will execute."
            );
        }
        lintCollectExpr(cond, receiverExternFns, reads);
        lintCollectStmt(nodeGetData2(expr), receiverExternFns, reads, setNew(), vecNew());
        if (nodeGetData3(expr) != 0) {
            lintCollectStmt(nodeGetData3(expr), receiverExternFns, reads, setNew(),
            vecNew());
        }
        return 0;
    }
    if (kind == NK_MATCH_EXPR) {
        lintCollectExpr(nodeGetData1(expr), receiverExternFns, reads);
        let cases = nodeGetData2(expr);
        let i = 0;
        let len = cases.vecLength();
        while (i < len) {
            let c = cases.vecGet(i);
            lintCollectStmt(c.vecGet(1), receiverExternFns, reads, setNew(), vecNew());
            i = i + 1;
        }
        return 0;
    }
    if (kind == NK_IS_EXPR) {
        lintCollectExpr(nodeGetData1(expr), receiverExternFns, reads);
    }
    0
}
fn lintCollectStmt(stmt: I32, receiverExternFns: *mut Set<I32>, reads: *mut Set<I32>, declaredSet: *mut
Set<I32>, declaredNames: Vec<I32>) : I32 => {
    if (stmt == 0) {
        return 0;
    }
    let kind = nodeKind(stmt);
    if (kind == NK_LET_DECL) {
        let name = getInternedStr(nodeGetData1(stmt));
        if (!declaredSet.setHas(name)) {
            declaredSet.setAdd(name);
            declaredNames.vecPush(stmt);
        }
        lintCollectExpr(nodeGetData3(stmt), receiverExternFns, reads);
        return 0;
    }
    if (kind == NK_BLOCK) {
        let stmts = nodeGetData1(stmt);
        if (stmts.vecLength() == 0) {
            lintAddIssue(
            "E_LINT_EMPTY_BLOCK",
            "Empty block has no effect",
            "An empty block executes no statements, which is often accidental and can hide incomplete logic.",
            "Add the intended statements to the block, or remove the block if it is unnecessary."
            );
        }
        let i = 0;
        let len = stmts.vecLength();
        while (i < len) {
            lintCollectStmt(stmts.vecGet(i), receiverExternFns, reads, declaredSet,
            declaredNames);
            i = i + 1;
        }
        return 0;
    }
    if (kind == NK_EXPR_STMT) {
        lintCollectExpr(nodeGetData1(stmt), receiverExternFns, reads);
        return 0;
    }
    if (kind == NK_EXTERN_IMPORT_DECL) {
        return 0;
    }
    if (kind == NK_ASSIGN_STMT) {
        lintCollectExpr(nodeGetData1(stmt), receiverExternFns, reads);
        lintCollectExpr(nodeGetData2(stmt), receiverExternFns, reads);
        return 0;
    }
    if (kind == NK_RETURN_STMT) {
        lintCollectExpr(nodeGetData1(stmt), receiverExternFns, reads);
        return 0;
    }
    if (kind == NK_IF_STMT) {
        let cond = nodeGetData1(stmt);
        if (nodeKind(cond) == NK_BOOL_LIT) {
            lintAddIssue(
            "E_LINT_CONSTANT_CONDITION",
            "Constant condition in if-expression/statement",
            "A constant condition means one branch is unreachable, which usually indicates dead or unintended code.",
            "Use a non-constant condition, or simplify by keeping only the branch that will execute."
            );
        }
        lintCollectExpr(cond, receiverExternFns, reads);
        lintCollectStmt(nodeGetData2(stmt), receiverExternFns, reads, declaredSet,
        declaredNames);
        lintCollectStmt(nodeGetData3(stmt), receiverExternFns, reads, declaredSet,
        declaredNames);
        return 0;
    }
    if (kind == NK_FOR_STMT) {
        lintCollectExpr(nodeGetData2(stmt), receiverExternFns, reads);
        lintCollectExpr(nodeGetData3(stmt), receiverExternFns, reads);
        lintCollectStmt(nodeGetData4(stmt), receiverExternFns, reads, declaredSet,
        declaredNames);
        return 0;
    }
    if (kind == NK_WHILE_STMT) {
        lintCollectExpr(nodeGetData1(stmt), receiverExternFns, reads);
        lintCollectStmt(nodeGetData2(stmt), receiverExternFns, reads, declaredSet,
        declaredNames);
        return 0;
    }
    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL) {
        lintCollectStmt(nodeGetData5(stmt), receiverExternFns, reads, declaredSet,
        declaredNames);
        return 0;
    }
    lintCollectExpr(stmt, receiverExternFns, reads);
    0
}
out fn lintAddCircularImportIssue(cycleText: *Str) : I32 => {
    lintAddIssue(
    "E_LINT_CIRCULAR_IMPORT",
    "Circular import detected: ".strConcat(cycleText),
    "Circular dependencies between modules make dependency flow harder to understand and maintain.",
    "Refactor shared declarations into a third module and have each side import that shared module instead."
    )
}
fn lintAstdupKindName(kind: I32) : *Str => {
    if (kind == NK_BLOCK) {
        return "block";
    }
    if (kind == NK_IF_STMT) {
        return "if-stmt";
    }
    if (kind == NK_WHILE_STMT) {
        return "while-stmt";
    }
    if (kind == NK_FOR_STMT) {
        return "for-stmt";
    }
    if (kind == NK_LOOP_STMT) {
        return "loop-stmt";
    }
    if (kind == NK_ASSIGN_STMT) {
        return "assign-stmt";
    }
    if (kind == NK_RETURN_STMT) {
        return "return-stmt";
    }
    if (kind == NK_BINARY_EXPR) {
        return "binary-expr";
    }
    if (kind == NK_CALL_EXPR) {
        return "call-expr";
    }
    if (kind == NK_IF_EXPR) {
        return "if-expr";
    }
    if (kind == NK_MATCH_EXPR) {
        return "match-expr";
    }
    if (kind == NK_STRUCT_INIT) {
        return "struct-init";
    }
    if (kind == NK_LAMBDA_EXPR) {
        return "lambda-expr";
    }
    "node-kind-".strConcat(intToString(kind))
}
fn lintAstdupLoc(n: I32) : *Str => {
    sourcemapLookup(nodeGetLine(n)).strConcat(":").strConcat(intToString(nodeGetCol(n)))
}
fn lintAstdupPreview(fp: *Str) : *Str => {
    let maxLen = 120;
    if (fp.strLength() <= maxLen) {
        return fp;
    }
    fp.strSliceWindow(0, maxLen).strConcat("...")
}
fn lintAstdupReportableKind(kind: I32) : Bool => {
    kind == NK_BLOCK ||
    kind == NK_IF_STMT ||
    kind == NK_WHILE_STMT ||
    kind == NK_FOR_STMT ||
    kind == NK_LOOP_STMT ||
    kind == NK_ASSIGN_STMT ||
    kind == NK_EXPR_STMT ||
    kind == NK_RETURN_STMT ||
    kind == NK_BINARY_EXPR ||
    kind == NK_UNARY_EXPR ||
    kind == NK_CALL_EXPR ||
    kind == NK_MEMBER_EXPR ||
    kind == NK_INDEX_EXPR ||
    kind == NK_STRUCT_INIT ||
    kind == NK_IF_EXPR ||
    kind == NK_MATCH_EXPR ||
    kind == NK_IS_EXPR ||
    kind == NK_UNWRAP_EXPR ||
    kind == NK_TUPLE_EXPR ||
    kind == NK_LAMBDA_EXPR ||
    kind == NK_FN_EXPR
}
fn lintAstdupVecFp(vecNodes: Vec<I32>, fpCache: Map<I32, I32>, sizeCache: Map<I32, I32>, seenNodes: Vec<I32>) : *Str => {
    let i = 0;
    let acc = "[";
    let __len19 = vecNodes.vecLength();
    while (i < __len19) {
        acc = acc.strConcat(lintAstdupFp(vecNodes.vecGet(i), fpCache, sizeCache, seenNodes));
        if (i + 1 < vecNodes.vecLength()) {
            acc = acc.strConcat(",");
        }
        i = i + 1;
    }
    acc.strConcat("]")
}
fn lintAstdupVecSize(vecNodes: Vec<I32>, sizeCache: Map<I32, I32>) : I32 => {
    let i = 0;
    let total = 0;
    let __len18 = vecNodes.vecLength();
    while (i < __len18) {
        let node = vecNodes.vecGet(i);
        if (node != 0 && sizeCache.mapHas(node)) {
            total = total + sizeCache.mapGet(node);
        }
        i = i + 1;
    }
    total
}
fn lintAstdupParamsFp(params: Vec<I32>, fpCache: Map<I32, I32>, sizeCache: Map<I32, I32>, seenNodes: Vec<I32>) : *Str => {
    let i = 0;
    let acc = "(";
    let __len17 = params.vecLength();
    while (i < __len17) {
        let p = params.vecGet(i);
        let ptype = p.vecGet(1);
        acc = acc
        .strConcat("{p:ID:t:")
        .strConcat(lintAstdupFp(ptype, fpCache, sizeCache, seenNodes))
        .strConcat("}");
        if (i + 1 < params.vecLength()) {
            acc = acc.strConcat(",");
        }
        i = i + 1;
    }
    acc.strConcat(")")
}
fn lintAstdupParamsSize(params: Vec<I32>, sizeCache: Map<I32, I32>) : I32 => {
    let i = 0;
    let total = 0;
    let __len16 = params.vecLength();
    while (i < __len16) {
        let p = params.vecGet(i);
        let ptype = p.vecGet(1);
        if (ptype != 0 && sizeCache.mapHas(ptype)) {
            total = total + sizeCache.mapGet(ptype);
        }
        i = i + 1;
    }
    total
}
fn lintAstdupNamedTypeFieldsFp(fields: Vec<I32>, fpCache: Map<I32, I32>, sizeCache: Map<I32, I32>, seenNodes: Vec<I32>)
: *Str => {
    let i = 0;
    let acc = "{";
    let __len15 = fields.vecLength();
    while (i < __len15) {
        let f = fields.vecGet(i);
        acc = acc
        .strConcat("{n:ID:t:")
        .strConcat(lintAstdupFp(f.vecGet(1), fpCache, sizeCache, seenNodes))
        .strConcat("}");
        if (i + 1 < fields.vecLength()) {
            acc = acc.strConcat(",");
        }
        i = i + 1;
    }
    acc.strConcat("}")
}
fn lintAstdupNamedTypeFieldsSize(fields: Vec<I32>, sizeCache: Map<I32, I32>) : I32 => {
    let i = 0;
    let total = 0;
    let __len14 = fields.vecLength();
    while (i < __len14) {
        let f = fields.vecGet(i);
        let t = f.vecGet(1);
        if (t != 0 && sizeCache.mapHas(t)) {
            total = total + sizeCache.mapGet(t);
        }
        i = i + 1;
    }
    total
}
fn lintAstdupStructInitFieldsFp(fields: Vec<I32>, fpCache: Map<I32, I32>, sizeCache: Map<I32, I32>, seenNodes: Vec<I32>)
: *Str => {
    let i = 0;
    let acc = "{";
    let __len13 = fields.vecLength();
    while (i < __len13) {
        let f = fields.vecGet(i);
        acc = acc
        .strConcat("{n:ID:v:")
        .strConcat(lintAstdupFp(f.vecGet(1), fpCache, sizeCache, seenNodes))
        .strConcat("}");
        if (i + 1 < fields.vecLength()) {
            acc = acc.strConcat(",");
        }
        i = i + 1;
    }
    acc.strConcat("}")
}
fn lintAstdupStructInitFieldsSize(fields: Vec<I32>, sizeCache: Map<I32, I32>) : I32 => {
    let i = 0;
    let total = 0;
    let __len12 = fields.vecLength();
    while (i < __len12) {
        let f = fields.vecGet(i);
        let v = f.vecGet(1);
        if (v != 0 && sizeCache.mapHas(v)) {
            total = total + sizeCache.mapGet(v);
        }
        i = i + 1;
    }
    total
}
fn lintAstdupCasesFp(cases: Vec<I32>, fpCache: Map<I32, I32>, sizeCache: Map<I32, I32>, seenNodes: Vec<I32>) : *Str => {
    let i = 0;
    let acc = "[";
    let __len11 = cases.vecLength();
    while (i < __len11) {
        let c = cases.vecGet(i);
        acc = acc
        .strConcat("{p:")
        .strConcat(lintAstdupFp(c.vecGet(0), fpCache, sizeCache, seenNodes))
        .strConcat(":b:")
        .strConcat(lintAstdupFp(c.vecGet(1), fpCache, sizeCache, seenNodes))
        .strConcat("}");
        if (i + 1 < cases.vecLength()) {
            acc = acc.strConcat(",");
        }
        i = i + 1;
    }
    acc.strConcat("]")
}
fn lintAstdupCasesSize(cases: Vec<I32>, sizeCache: Map<I32, I32>) : I32 => {
    let i = 0;
    let total = 0;
    let __len10 = cases.vecLength();
    while (i < __len10) {
        let c = cases.vecGet(i);
        let p = c.vecGet(0);
        let b = c.vecGet(1);
        if (p != 0 && sizeCache.mapHas(p)) {
            total = total + sizeCache.mapGet(p);
        }
        if (b != 0 && sizeCache.mapHas(b)) {
            total = total + sizeCache.mapGet(b);
        }
        i = i + 1;
    }
    total
}
fn lintAstdupContractMethodsFp(methods: Vec<I32>, fpCache: Map<I32, I32>, sizeCache: Map<I32, I32>, seenNodes: Vec<I32>)
: *Str => {
    let i = 0;
    let acc = "[";
    let __len9 = methods.vecLength();
    while (i < __len9) {
        let m = methods.vecGet(i);
        acc = acc
        .strConcat("{m:ID:g:")
        .strConcat(intToString(m.vecGet(1).vecLength()))
        .strConcat(":p:")
        .strConcat(lintAstdupParamsFp(m.vecGet(2), fpCache, sizeCache, seenNodes))
        .strConcat(":r:")
        .strConcat(lintAstdupFp(m.vecGet(3), fpCache, sizeCache, seenNodes))
        .strConcat("}");
        if (i + 1 < methods.vecLength()) {
            acc = acc.strConcat(",");
        }
        i = i + 1;
    }
    acc.strConcat("]")
}
fn lintAstdupContractMethodsSize(methods: Vec<I32>, sizeCache: Map<I32, I32>) : I32 => {
    let i = 0;
    let total = 0;
    let __len8 = methods.vecLength();
    while (i < __len8) {
        let m = methods.vecGet(i);
        total = total + lintAstdupParamsSize(m.vecGet(2), sizeCache);
        let ret = m.vecGet(3);
        if (ret != 0 && sizeCache.mapHas(ret)) {
            total = total + sizeCache.mapGet(ret);
        }
        i = i + 1;
    }
    total
}
fn lintAstdupFp(n: I32, fpCache: Map<I32, I32>, sizeCache: Map<I32, I32>, seenNodes: Vec<I32>) : *Str => {
    if (n == 0) {
        return "0";
    }
    if (fpCache.mapHas(n)) {
        return fpCache.mapGet(n);
    }
    let kind = nodeKind(n);
    let fp = "K".strConcat(intToString(kind));
    let size = 1;
    if (kind == NK_IDENTIFIER || kind == NK_NAME_PAT || kind == NK_NAMED_TYPE) {
        fp = fp.strConcat("(ID)");
    }
    else if (kind == NK_NUMBER_LIT || kind == NK_STRING_LIT || kind == NK_CHAR_LIT || kind == NK_LITERAL_PAT) {
        fp = fp.strConcat("(LIT)");
    }
    else if (kind == NK_BOOL_LIT) {
        fp = fp.strConcat("(BOOL)");
    }
    else if (kind == NK_WILDCARD_PAT || kind == NK_BREAK_STMT || kind == NK_CONTINUE_STMT) {
        fp = fp.strConcat("()");
    }
    else if (kind == NK_UNARY_EXPR) {
        fp = fp
        .strConcat("(")
        .strConcat(getInternedStr(nodeGetData1(n)))
        .strConcat(":")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData2(n));
    }
    else if (kind == NK_UNWRAP_EXPR) {
        fp = fp
        .strConcat("(")
        .strConcat(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData1(n));
    }
    else if (kind == NK_BINARY_EXPR) {
        fp = fp
        .strConcat("(")
        .strConcat(getInternedStr(nodeGetData1(n)))
        .strConcat(":")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(":")
        .strConcat(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData2(n)) + sizeCache.mapGet(nodeGetData3(n));
    }
    else if (kind == NK_CALL_EXPR) {
        fp = fp
        .strConcat("(callee:")
        .strConcat(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(":args:")
        .strConcat(lintAstdupVecFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(":style:")
        .strConcat(intToString(nodeGetData3(n)))
        .strConcat(":targs:")
        .strConcat(lintAstdupVecFp(nodeGetData4(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData1(n));
        size = size + lintAstdupVecSize(nodeGetData2(n), sizeCache);
        size = size + lintAstdupVecSize(nodeGetData4(n), sizeCache);
    }
    else if (kind == NK_MEMBER_EXPR) {
        fp = fp
        .strConcat("(obj:")
        .strConcat(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(":member:ID)");
        size = size + sizeCache.mapGet(nodeGetData1(n));
    }
    else if (kind == NK_INDEX_EXPR) {
        fp = fp
        .strConcat("(target:")
        .strConcat(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(":index:")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData1(n)) + sizeCache.mapGet(nodeGetData2(n));
    }
    else if (kind == NK_STRUCT_INIT) {
        fp = fp
        .strConcat("(name:ID:fields:")
        .strConcat(lintAstdupStructInitFieldsFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(":targs:")
        .strConcat(lintAstdupVecFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + lintAstdupStructInitFieldsSize(nodeGetData2(n), sizeCache);
        size = size + lintAstdupVecSize(nodeGetData3(n), sizeCache);
    }
    else if (kind == NK_IF_EXPR || kind == NK_IF_STMT) {
        fp = fp
        .strConcat("(c:")
        .strConcat(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(":t:")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(":e:")
        .strConcat(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData1(n));
        size = size + sizeCache.mapGet(nodeGetData2(n));
        if (nodeGetData3(n) != 0) {
            size = size + sizeCache.mapGet(nodeGetData3(n));
        }
    }
    else if (kind == NK_MATCH_EXPR) {
        fp = fp
        .strConcat("(target:")
        .strConcat(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(":cases:")
        .strConcat(lintAstdupCasesFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData1(n));
        size = size + lintAstdupCasesSize(nodeGetData2(n), sizeCache);
    }
    else if (kind == NK_IS_EXPR) {
        fp = fp
        .strConcat("(subject:")
        .strConcat(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(":pat:")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData1(n)) + sizeCache.mapGet(nodeGetData2(n));
    }
    else if (kind == NK_TUPLE_EXPR || kind == NK_TUPLE_TYPE || kind == NK_BLOCK || kind == NK_STMT_LIST || kind == NK_PROGRAM) {
        fp = fp.strConcat(lintAstdupVecFp(nodeGetData1(n), fpCache, sizeCache, seenNodes));
        size = size + lintAstdupVecSize(nodeGetData1(n), sizeCache);
    }
    else if (kind == NK_FN_EXPR) {
        fp = fp
        .strConcat("(name:ID:g:")
        .strConcat(intToString(nodeGetData2(n).vecLength()))
        .strConcat(":p:")
        .strConcat(lintAstdupParamsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(":r:")
        .strConcat(lintAstdupFp(nodeGetData4(n), fpCache, sizeCache, seenNodes))
        .strConcat(":b:")
        .strConcat(lintAstdupFp(nodeGetData5(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + lintAstdupParamsSize(nodeGetData3(n), sizeCache);
        if (nodeGetData4(n) != 0) {
            size = size + sizeCache.mapGet(nodeGetData4(n));
        }
        size = size + sizeCache.mapGet(nodeGetData5(n));
    }
    else if (kind == NK_LAMBDA_EXPR) {
        fp = fp
        .strConcat("(p:")
        .strConcat(lintAstdupParamsFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(":b:")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + lintAstdupParamsSize(nodeGetData1(n), sizeCache);
        size = size + sizeCache.mapGet(nodeGetData2(n));
    }
    else if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL || kind == NK_EXPECT_FN_DECL) {
        fp = fp
        .strConcat("(name:ID:g:")
        .strConcat(intToString(nodeGetData2(n).vecLength()))
        .strConcat(":p:")
        .strConcat(lintAstdupParamsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(":r:")
        .strConcat(lintAstdupFp(nodeGetData4(n), fpCache, sizeCache, seenNodes))
        .strConcat(":b:")
        .strConcat(lintAstdupFp(nodeGetData5(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + lintAstdupParamsSize(nodeGetData3(n), sizeCache);
        if (nodeGetData4(n) != 0) {
            size = size + sizeCache.mapGet(nodeGetData4(n));
        }
        if (nodeGetData5(n) != 0) {
            size = size + sizeCache.mapGet(nodeGetData5(n));
        }
    }
    else if (kind == NK_LET_DECL || kind == NK_EXTERN_LET_DECL) {
        fp = fp
        .strConcat("(name:ID:t:")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(":v:")
        .strConcat(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        if (nodeGetData2(n) != 0) {
            size = size + sizeCache.mapGet(nodeGetData2(n));
        }
        if (nodeGetData3(n) != 0) {
            size = size + sizeCache.mapGet(nodeGetData3(n));
        }
    }
    else if (kind == NK_FOR_STMT) {
        fp = fp
        .strConcat("(iter:ID:s:")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(":e:")
        .strConcat(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(":b:")
        .strConcat(lintAstdupFp(nodeGetData4(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData2(n));
        size = size + sizeCache.mapGet(nodeGetData3(n));
        size = size + sizeCache.mapGet(nodeGetData4(n));
    }
    else if (kind == NK_WHILE_STMT || kind == NK_LOOP_STMT || kind == NK_RETURN_STMT || kind == NK_EXPR_STMT) {
        fp = fp
        .strConcat("(")
        .strConcat(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        if (nodeGetData1(n) != 0) {
            size = size + sizeCache.mapGet(nodeGetData1(n));
        }
    }
    else if (kind == NK_ASSIGN_STMT) {
        fp = fp
        .strConcat("(t:")
        .strConcat(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(":v:")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData1(n)) + sizeCache.mapGet(nodeGetData2(n));
    }
    else if (kind == NK_LIFETIME_STMT) {
        fp = fp
        .strConcat("(names:")
        .strConcat(intToString(nodeGetData1(n).vecLength()))
        .strConcat(":b:")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData2(n));
    }
    else if (kind == NK_POINTER_TYPE) {
        fp = fp
        .strConcat("(mut:")
        .strConcat(intToString(nodeGetData1(n)))
        .strConcat(":inner:")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(":move:")
        .strConcat(intToString(nodeGetData3(n)))
        .strConcat(":life:ID)");
        size = size + sizeCache.mapGet(nodeGetData2(n));
    }
    else if (kind == NK_ARRAY_TYPE) {
        fp = fp
        .strConcat("(e:")
        .strConcat(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(":i:")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(":t:")
        .strConcat(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData1(n));
        if (nodeGetData2(n) != 0) {
            size = size + sizeCache.mapGet(nodeGetData2(n));
        }
        if (nodeGetData3(n) != 0) {
            size = size + sizeCache.mapGet(nodeGetData3(n));
        }
    }
    else if (kind == NK_REFINEMENT_TYPE) {
        fp = fp
        .strConcat("(b:")
        .strConcat(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(":op:")
        .strConcat(getInternedStr(nodeGetData2(n)))
        .strConcat(":v:")
        .strConcat(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData1(n));
        size = size + sizeCache.mapGet(nodeGetData3(n));
    }
    else if (kind == NK_UNION_TYPE) {
        fp = fp
        .strConcat("(l:")
        .strConcat(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(":r:")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(":x:")
        .strConcat(intToString(nodeGetData3(n)))
        .strConcat(")");
        size = size + sizeCache.mapGet(nodeGetData1(n)) + sizeCache.mapGet(nodeGetData2(n));
    }
    else if (kind == NK_FUNCTION_TYPE) {
        fp = fp
        .strConcat("(p:")
        .strConcat(lintAstdupVecFp(nodeGetData1(n), fpCache, sizeCache, seenNodes))
        .strConcat(":r:")
        .strConcat(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + lintAstdupVecSize(nodeGetData1(n), sizeCache);
        size = size + sizeCache.mapGet(nodeGetData2(n));
    }
    else if (kind == NK_APPLIED_TYPE) {
        fp = fp
        .strConcat("(name:ID:args:")
        .strConcat(lintAstdupVecFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + lintAstdupVecSize(nodeGetData2(n), sizeCache);
    }
    else if (kind == NK_IMPORT_DECL || kind == NK_EXTERN_IMPORT_DECL) {
        fp = fp
        .strConcat("(names:")
        .strConcat(intToString(nodeGetData1(n).vecLength()))
        .strConcat(":parts:")
        .strConcat(intToString(nodeGetData2(n).vecLength()))
        .strConcat(")");
    }
    else if (kind == NK_STRUCT_DECL) {
        fp = fp
        .strConcat("(name:ID:g:")
        .strConcat(intToString(nodeGetData2(n).vecLength()))
        .strConcat(":f:")
        .strConcat(lintAstdupNamedTypeFieldsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(":copy:")
        .strConcat(intToString(nodeGetData4(n)))
        .strConcat(")");
        size = size + lintAstdupNamedTypeFieldsSize(nodeGetData3(n), sizeCache);
    }
    else if (kind == NK_OBJECT_DECL) {
        fp = fp
        .strConcat("(name:ID:g:")
        .strConcat(intToString(nodeGetData2(n).vecLength()))
        .strConcat(":in:")
        .strConcat(lintAstdupNamedTypeFieldsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + lintAstdupNamedTypeFieldsSize(nodeGetData3(n), sizeCache);
    }
    else if (kind == NK_CONTRACT_DECL) {
        fp = fp
        .strConcat("(name:ID:m:")
        .strConcat(lintAstdupContractMethodsFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(")");
        size = size + lintAstdupContractMethodsSize(nodeGetData2(n), sizeCache);
    }
    else if (kind == NK_ENUM_DECL) {
        fp = fp
        .strConcat("(name:ID:v:")
        .strConcat(intToString(nodeGetData2(n).vecLength()))
        .strConcat(")");
    }
    else if (kind == NK_TYPE_ALIAS) {
        fp = fp
        .strConcat("(name:ID:g:")
        .strConcat(intToString(nodeGetData2(n).vecLength()))
        .strConcat(":a:")
        .strConcat(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(":copy:")
        .strConcat(intToString(nodeGetData4(n)))
        .strConcat(":d:ID)");
        size = size + sizeCache.mapGet(nodeGetData3(n));
    }
    else if (kind == NK_DEP_TYPE_ALIAS) {
        fp = fp
        .strConcat("(name:ID:p:")
        .strConcat(lintAstdupParamsFp(nodeGetData2(n), fpCache, sizeCache, seenNodes))
        .strConcat(":a:")
        .strConcat(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes))
        .strConcat(":copy:")
        .strConcat(intToString(nodeGetData4(n)))
        .strConcat(":d:ID)");
        size = size + lintAstdupParamsSize(nodeGetData2(n), sizeCache);
        size = size + sizeCache.mapGet(nodeGetData3(n));
    }
    else if (kind == NK_EXTERN_TYPE_DECL) {
        fp = fp
        .strConcat("(name:ID:g:")
        .strConcat(intToString(nodeGetData2(n).vecLength()))
        .strConcat(":d:ID)");
    }
    else if (kind == NK_STRUCT_PAT) {
        fp = fp
        .strConcat("(name:ID:fields:")
        .strConcat(intToString(nodeGetData2(n).vecLength()))
        .strConcat(")");
    }
    else {
        fp = fp
        .strConcat("(d1:")
        .strConcat(intToString(nodeGetData1(n)))
        .strConcat(":d2:")
        .strConcat(intToString(nodeGetData2(n)))
        .strConcat(":d3:")
        .strConcat(intToString(nodeGetData3(n)))
        .strConcat(":d4:")
        .strConcat(intToString(nodeGetData4(n)))
        .strConcat(":d5:")
        .strConcat(intToString(nodeGetData5(n)))
        .strConcat(")");
    }
    fpCache.mapSet(n, fp);
    sizeCache.mapSet(n, size);
    seenNodes.vecPush(n);
    fp
}
fn lintAstdupNormLeafKind(kind: I32) : *Str => {
    if (kind == NK_IDENTIFIER || kind == NK_NAME_PAT || kind == NK_NAMED_TYPE) {
        return "ID";
    }
    if (kind == NK_NUMBER_LIT || kind == NK_STRING_LIT || kind == NK_CHAR_LIT || kind == NK_LITERAL_PAT) {
        return "LIT";
    }
    if (kind == NK_BOOL_LIT) {
        return "BOOL";
    }
    intToString(kind)
}
fn lintAstdupFallbackBinary(program: I32) : I32 => {
    let body = nodeGetData1(program);
    let stack = vecNew();
    let i = 0;
    let __len7 = body.vecLength();
    while (i < __len7) {
        stack.vecPush(body.vecGet(i));
        i = i + 1;
    }
    let keys = vecNew();
    let counts = vecNew();
    let firstNodes = vecNew();
    let secondNodes = vecNew();
    while (stack.vecLength() > 0) {
        let n = stack.vecGet(stack.vecLength() - 1);
        stack.vecPop();
        if (n == 0) {
            continue;
        }
        let kind = nodeKind(n);
        if (kind == NK_BINARY_EXPR) {
            let op = getInternedStr(nodeGetData1(n));
            let leftKind = lintAstdupNormLeafKind(nodeKind(nodeGetData2(n)));
            let rightKind = lintAstdupNormLeafKind(nodeKind(nodeGetData3(n)));
            let key = op.strConcat(":").strConcat(leftKind).strConcat(":").strConcat(rightKind);
            let found = -1;
            let k = 0;
            let __len6 = keys.vecLength();
            while (k < __len6) {
                if (keys.vecGet(k).strEq(key)) {
                    found = k;
                    break;
                }
                k = k + 1;
            }
            if (found == -1) {
                keys.vecPush(key);
                counts.vecPush(1);
                firstNodes.vecPush(n);
                secondNodes.vecPush(0);
            }
            else {
                let nextCount = counts.vecGet(found) + 1;
                counts.vecSet(found, nextCount);
                if (secondNodes.vecGet(found) == 0) {
                    secondNodes.vecSet(found, n);
                }
            }
        }
        if (kind == NK_PROGRAM || kind == NK_BLOCK || kind == NK_STMT_LIST || kind == NK_TUPLE_EXPR || kind == NK_TUPLE_TYPE) {
            let items = nodeGetData1(n);
            let j = 0;
            let __len5 = items.vecLength();
            while (j < __len5) {
                stack.vecPush(items.vecGet(j));
                j = j + 1;
            }
            continue;
        }
        if (kind == NK_LET_DECL || kind == NK_ASSIGN_STMT || kind == NK_BINARY_EXPR || kind == NK_INDEX_EXPR || kind == NK_IS_EXPR) {
            stack.vecPush(nodeGetData1(n));
            stack.vecPush(nodeGetData2(n));
            if (kind == NK_LET_DECL || kind == NK_BINARY_EXPR) {
                stack.vecPush(nodeGetData3(n));
            }
            continue;
        }
        if (kind == NK_EXPR_STMT || kind == NK_RETURN_STMT || kind == NK_WHILE_STMT || kind == NK_LOOP_STMT || kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR || kind == NK_MEMBER_EXPR) {
            stack.vecPush(nodeGetData1(n));
            if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
                stack.vecPush(nodeGetData2(n));
            }
            continue;
        }
        if (kind == NK_IF_STMT || kind == NK_IF_EXPR) {
            stack.vecPush(nodeGetData1(n));
            stack.vecPush(nodeGetData2(n));
            stack.vecPush(nodeGetData3(n));
            continue;
        }
        if (kind == NK_FOR_STMT) {
            stack.vecPush(nodeGetData2(n));
            stack.vecPush(nodeGetData3(n));
            stack.vecPush(nodeGetData4(n));
            continue;
        }
        if (kind == NK_CALL_EXPR) {
            stack.vecPush(nodeGetData1(n));
            let args = nodeGetData2(n);
            let a = 0;
            let __len4 = args.vecLength();
            while (a < __len4) {
                stack.vecPush(args.vecGet(a));
                a = a + 1;
            }
        }
    }
    let emitted = 0;
    let k = 0;
    while (k < keys.vecLength() && emitted < 5) {
        let count = counts.vecGet(k);
        if (count >= 3) {
            let key = keys.vecGet(k);
            let first = firstNodes.vecGet(k);
            let second = secondNodes.vecGet(k);
            let firstLoc = lintAstdupLoc(first);
            let secondLoc = "unknown";
            if (second != 0) {
                secondLoc = lintAstdupLoc(second);
            }
            lintAddIssue(
            "E_LINT_AST_DUPLICATE_SUBTREE",
            "Duplicate AST subtree detected (binary-expr) with ".strConcat(intToString(count)).strConcat(" occurrences"),
            "Normalized shape '".strConcat(key).strConcat("' repeats (identifier/literal values normalized), indicating copy-paste structure that is likely extractable."),
            "Consider extracting the repeated expression shape into a helper/local binding. Example locations: ".strConcat(firstLoc).strConcat(" and ").strConcat(secondLoc).strConcat(".")
            );
            emitted = emitted + 1;
        }
        k = k + 1;
    }
    0
}
fn lintCheckAstDuplicates(program: I32) : I32 => {
    let fpCache = mapNew();
    let sizeCache = mapNew();
    let seenNodes = vecNew();
    let body = nodeGetData1(program);
    let scanI = 0;
    let __len3 = body.vecLength();
    while (scanI < __len3) {
        lintAstdupFp(body.vecGet(scanI), fpCache, sizeCache, seenNodes);
        scanI = scanI + 1;
    }
    let keys = vecNew();
    let buckets = vecNew();
    let i = 0;
    let __len2 = seenNodes.vecLength();
    while (i < __len2) {
        let n = seenNodes.vecGet(i);
        let kind = nodeKind(n);
        let size = sizeCache.mapGet(n);
        if (size >= 6 && lintAstdupReportableKind(kind)) {
            let fp = fpCache.mapGet(n);
            let found = -1;
            let j = 0;
            let __len1 = keys.vecLength();
            while (j < __len1) {
                if (keys.vecGet(j).strEq(fp)) {
                    found = j;
                    break;
                }
                j = j + 1;
            }
            if (found == -1) {
                keys.vecPush(fp);
                let bucket = vecNew();
                bucket.vecPush(n);
                buckets.vecPush(bucket);
            }
            else {
                let bucket = buckets.vecGet(found);
                bucket.vecPush(n);
                buckets.vecSet(found, bucket);
            }
        }
        i = i + 1;
    }
    i = 0;
    let __len = keys.vecLength();
    while (i < __len) {
        let fp = keys.vecGet(i);
        let bucket = buckets.vecGet(i);
        if (bucket.vecLength() > 1) {
            let first = bucket.vecGet(0);
            let second = bucket.vecGet(1);
            let kindName = lintAstdupKindName(nodeKind(first));
            let count = bucket.vecLength();
            let firstLoc = lintAstdupLoc(first);
            let secondLoc = lintAstdupLoc(second);
            let shape = lintAstdupPreview(fp);
            lintAddIssue(
            "E_LINT_AST_DUPLICATE_SUBTREE",
            "Duplicate AST subtree detected (".strConcat(kindName).strConcat(") with ").strConcat(intToString(count)).strConcat(" occurrences"),
            "A structurally identical subtree appears multiple times (identifier/literal values normalized). Shape preview: '".strConcat(shape).strConcat("'."),
            "Extract shared logic into a helper function. Example locations: ".strConcat(firstLoc).strConcat(" and ").strConcat(secondLoc).strConcat(".")
            );
        }
        i = i + 1;
    }
    lintAstdupFallbackBinary(program);
    0
}
out fn lintProgram(program: I32, filePath: *Str, maxEffectiveLines: I32, enforceFileLength:
I32, astDupEnabled: I32) : I32 => {
    if (enforceFileLength == 1) {
        lintCheckFileLength(filePath, maxEffectiveLines);
    }
    let receiverExternFns = setNew();
    let reads = setNew();
    let declaredSet = setNew();
    let declaredNames = vecNew();
    let body = nodeGetData1(program);
    let i = 0;
    let len = body.vecLength();
    while (i < len) {
        let stmt = body.vecGet(i);
        if (lintIsExternFnDecl(stmt)) {
            let params = nodeGetData3(stmt);
            if (params.vecLength() > 0) {
                let p0 = params.vecGet(0);
                let p0name = getInternedStr(p0.vecGet(0));
                if (p0name.strEq("this")) {
                    receiverExternFns.setAdd(getInternedStr(nodeGetData1(stmt)));
                }
            }
        }
        i = i + 1;
    }
    i = 0;
    while (i < len) {
        let stmt = body.vecGet(i);
        lintCheckFunctionLength(stmt, maxEffectiveLines);
        lintCollectStmt(stmt, receiverExternFns, reads, declaredSet, declaredNames);
        i = i + 1;
    }
    i = 0;
    let dlen = declaredNames.vecLength();
    while (i < dlen) {
        let declNode = declaredNames.vecGet(i);
        let name = getInternedStr(nodeGetData1(declNode));
        if (!name.strStartsWith("_") && !reads.setHas(name)) {
            lintAddIssueAt(
            "E_LINT_UNUSED_BINDING",
            "Unused binding '".strConcat(name).strConcat("'"),
            "Unused bindings increase cognitive load and can indicate leftover or incomplete code paths.",
            "Remove the binding if unused, use it intentionally, or rename it to start with '_' to mark it as intentionally unused.",
            nodeGetLine(declNode),
            nodeGetCol(declNode)
            );
        }
        i = i + 1;
    }
    if (astDupEnabled == 1) {
        lintCheckAstDuplicates(program);
    }
    0
}
out fn selfhostLinterMarker() : I32 => 0;
