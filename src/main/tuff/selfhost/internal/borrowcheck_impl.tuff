let {
    get_interned_str, map_new, set_new, vec_new, str_includes, str_starts_with
}
 = selfhost::runtime_lexer;
let {
    node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5,
    node_get_line, node_get_col
}
 = selfhost::parser_core;
 // Current AST node being borrow-checked; updated at check_expr/check_stmt entry.
let bc_current_node : I32 = 0;
let bc_global_value_types : Map = map_new();
let bc_copy_types : *mut Set = set_new();
let bc_copy_alias_types : Map = map_new();
let bc_copy_alias_names : Vec = vec_new();
let bc_destructor_aliases : Map = map_new();
let bc_destructor_alias_names : Vec = vec_new();
fn bc_str_ends_with_local(s: *Str, suffix: *Str) : Bool => {
    let ns = s.str_length();
    let nf = suffix.str_length();
    if (nf > ns) {
        return false;
    }
    s.str_slice(ns - nf, ns).str_eq(suffix)
}
fn bc_type_name_from_type_node(t: I32) : *Str => {
    if (t == 0) {
        return "Unknown";
    }
    let k = node_kind(t);
    if (k == NK_NAMED_TYPE) {
        return get_interned_str(node_get_data1(t));
    }
    if (k == NK_REFINEMENT_TYPE) {
        return bc_type_name_from_type_node(node_get_data1(t));
    }
    if (k == NK_POINTER_TYPE) {
        let mutable = node_get_data1(t);
        let inner = bc_type_name_from_type_node(node_get_data2(t));
        let move_ptr = node_get_data3(t);
        let life_idx = node_get_data4(t);
        let life_prefix = "";
        if (life_idx != 0) {
            life_prefix = get_interned_str(life_idx).str_concat(" ");
        }
        if (move_ptr == 1) {
            return "*".str_concat(life_prefix).str_concat("move ").str_concat(inner);
        }
        if (mutable == 1) {
            return "*".str_concat(life_prefix).str_concat("mut ").str_concat(inner);
        }
        return "*".str_concat(life_prefix).str_concat(inner);
    }
    if (k == NK_UNION_TYPE) {
        let left = bc_type_name_from_type_node(node_get_data1(t));
        let right = bc_type_name_from_type_node(node_get_data2(t));
        return left.str_concat("|").str_concat(right);
    }
    "Unknown"
}
fn is_copy_primitive(name: *Str) : Bool => {
    name.str_eq("I8") || name.str_eq("I16") || name.str_eq("I32") || name.str_eq("I64") || name.str_eq("I128") || name.str_eq("U8") || name.str_eq("U16") || name.str_eq("U32") || name.str_eq("U64") || name.str_eq("U128") || name.str_eq("USize") || name.str_eq("ISize") || name.str_eq("F32") || name.str_eq("F64") ||
    name.str_eq("Bool") || name.str_eq("Char")
}
fn is_copy_type(type_name: *Str, extern_type_names: *mut Set) : Bool => {
    if (type_name.str_eq("Unknown")) {
        return false;
    }
    if (type_name.str_starts_with("*")) {
        return true;
    }
    if (is_copy_primitive(type_name)) {
        return true;
    }
    if (bc_destructor_aliases.map_has(type_name)) {
        return false;
    }
    if (type_name.str_eq("Vec") || type_name.str_eq("Map") || type_name.str_eq("Set")) {
        return true;
    }
    if (bc_copy_types.set_has(type_name)) {
        return true;
    }
    if (extern_type_names.set_has(type_name)) {
        return false;
    }
    false
}
fn bc_find_copy_alias_type(name: *Str) : I32 => {
    if (bc_copy_alias_types.map_has(name)) {
        return bc_copy_alias_types.map_get(name);
    }
    0
}
fn bc_type_node_is_copyable(t: I32, extern_type_names: *mut Set, visiting_aliases: *mut Set) : Bool
=> {
    if (t == 0) {
        return false;
    }
    let k = node_kind(t);
    if (k == NK_NAMED_TYPE) {
        let name = get_interned_str(node_get_data1(t));
        if (bc_destructor_aliases.map_has(name)) {
            return false;
        }
        if (is_copy_primitive(name)) {
            return true;
        }
        if (name.str_eq("Vec") || name.str_eq("Map") || name.str_eq("Set")) {
            return true;
        }
        if (bc_copy_types.set_has(name)) {
            return true;
        }
        if (extern_type_names.set_has(name)) {
            return false;
        }
        let alias_type = bc_find_copy_alias_type(name);
        if (alias_type != 0) {
            if (visiting_aliases.set_has(name)) {
                return false;
            }
            visiting_aliases.set_add(name);
            let ok = bc_type_node_is_copyable(alias_type, extern_type_names, visiting_aliases);
            visiting_aliases.set_delete(name);
            return ok;
        }
        return false;
    }
    if (k == NK_REFINEMENT_TYPE) {
        return bc_type_node_is_copyable(node_get_data1(t), extern_type_names, visiting_aliases);
    }
    if (k == NK_POINTER_TYPE) {
        return true;
    }
    if (k == NK_UNION_TYPE) {
        return bc_type_node_is_copyable(node_get_data1(t), extern_type_names, visiting_aliases) &&
        bc_type_node_is_copyable(node_get_data2(t), extern_type_names, visiting_aliases);
    }
    if (k == NK_TUPLE_TYPE) {
        let members = node_get_data1(t);
        let i = 0;
        let len = members.vec_length();
        while (i < len) {
            if (!bc_type_node_is_copyable(members.vec_get(i), extern_type_names, visiting_aliases))
            {
                return false;
            }
            i = i + 1;
        }
        return true;
    }
    false
}
fn bc_type_node_is_destructor_receiver(t: I32, alias_name: *Str) : Bool => {
    if (t == 0) {
        return false;
    }
     // Preferred form: alias receiver value (e.g. Alloc<...>)
    if (node_kind(t) == NK_NAMED_TYPE && get_interned_str(node_get_data1(t)).str_eq(alias_name)) {
        return true;
    }
     // Back-compat: *move Alias
    if (node_kind(t) == NK_POINTER_TYPE && node_get_data3(t) == 1) {
        return bc_type_name_from_type_node(node_get_data2(t)).str_eq(alias_name);
    }
    false
}
fn bc_infer_expr_type_name(n: I32, env_types: Map, fn_return_types: Map) : *Str => {
    if (n == 0) {
        return "Unknown";
    }
    let kind = node_kind(n);
    if (kind == NK_NUMBER_LIT) {
        let text = get_interned_str(node_get_data1(n));
        if (bc_str_ends_with_local(text, "USize")) {
            return "USize";
        }
        return "I32";
    }
    if (kind == NK_BOOL_LIT) {
        return "Bool";
    }
    if (kind == NK_STRING_LIT) {
        return "*Str";
    }
    if (kind == NK_CHAR_LIT) {
        return "Char";
    }
    if (kind == NK_IDENTIFIER) {
        let name = get_interned_str(node_get_data1(n));
        if (env_types.map_has(name)) {
            return env_types.map_get(name);
        }
        if (bc_global_value_types.map_has(name)) {
            return bc_global_value_types.map_get(name);
        }
        return "Unknown";
    }
    if (kind == NK_UNARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        let inner = bc_infer_expr_type_name(node_get_data2(n), env_types, fn_return_types);
        if (op.str_eq("&")) {
            return "*".str_concat(inner);
        }
        if (op.str_eq("&mut")) {
            return "*mut ".str_concat(inner);
        }
        if (op.str_eq("!")) {
            return "Bool";
        }
        return inner;
    }
    if (kind == NK_BINARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("==") || op.str_eq("!=") || op.str_eq("<") || op.str_eq("<=") || op.str_eq(">") || op.str_eq(">=") || op.str_eq("&&") || op.str_eq("||")) {
            return "Bool";
        }
        return bc_infer_expr_type_name(node_get_data2(n), env_types, fn_return_types);
    }
    if (kind == NK_CALL_EXPR) {
        let callee = node_get_data1(n);
        if (node_kind(callee) == NK_IDENTIFIER) {
            let fname = get_interned_str(node_get_data1(callee));
            if (fn_return_types.map_has(fname)) {
                return fn_return_types.map_get(fname);
            }
        }
    }
    if (kind == NK_STRUCT_INIT) {
        return get_interned_str(node_get_data1(n));
    }
    "Unknown"
}
fn place_new(base: *Str, path: *Str) : Vec => {
    let p = vec_new();
    p.vec_push(base);
    p.vec_push(path);
    p
}
fn place_is_valid(p: Vec) : Bool => p.vec_length() == 2;
fn place_base(p: Vec) : *Str => p.vec_get(0);
fn place_path(p: Vec) : *Str => p.vec_get(1);
fn canonical_place(n: I32) : Vec => {
    if (n == 0) {
        return vec_new();
    }
    let kind = node_kind(n);
    if (kind == NK_IDENTIFIER) {
        let name = get_interned_str(node_get_data1(n));
        return place_new(name, name);
    }
    if (kind == NK_MEMBER_EXPR) {
        let base = canonical_place(node_get_data1(n));
        if (!place_is_valid(base)) {
            return vec_new();
        }
        let prop = get_interned_str(node_get_data2(n));
        return place_new(place_base(base), place_path(base).str_concat(".").str_concat(prop));
    }
    if (kind == NK_INDEX_EXPR) {
        let base = canonical_place(node_get_data1(n));
        if (!place_is_valid(base)) {
            return vec_new();
        }
        return place_new(place_base(base), place_path(base).str_concat("[]"));
    }
    vec_new()
}
fn places_conflict(a_base: *Str, a_path: *Str, b_base: *Str, b_path: *Str) : Bool => {
    if (!a_base.str_eq(b_base)) {
        return false;
    }
    if (a_path.str_eq(b_path)) {
        return true;
    }
    if (a_path.str_includes("[]") || b_path.str_includes("[]")) {
        return true;
    }
    a_path.str_starts_with(b_path.str_concat(".")) || b_path.str_starts_with(a_path.str_concat("."))
}
fn state_new() : Vec => {
     // [moved_set, moved_vec, loans_vec, scope_starts, dropped_set, dropped_vec]
    let s = vec_new();
    s.vec_push(set_new());
    s.vec_push(vec_new());
    s.vec_push(vec_new());
    s.vec_push(vec_new());
    s.vec_push(set_new());
    s.vec_push(vec_new());
    s
}
fn state_moved_set(state: Vec) : *mut Set => state.vec_get(0);
fn state_moved_vec(state: Vec) : Vec => state.vec_get(1);
fn state_loans(state: Vec) : Vec => state.vec_get(2);
fn state_scope_starts(state: Vec) : Vec => state.vec_get(3);
fn state_dropped_set(state: Vec) : *mut Set => state.vec_get(4);
fn state_dropped_vec(state: Vec) : Vec => state.vec_get(5);
fn state_moved_has(state: Vec, name: *Str) : Bool => state_moved_set(state).set_has(name);
fn state_dropped_has(state: Vec, name: *Str) : Bool => state_dropped_set(state).set_has(name);
fn state_moved_add(state: Vec, name: *Str) : I32 => {
    if (!state_moved_set(state).set_has(name)) {
        state_moved_set(state).set_add(name);
        state_moved_vec(state).vec_push(name);
    }
    0
}
fn state_moved_delete(state: Vec, name: *Str) : I32 => {
    state_moved_set(state).set_delete(name);
    0
}
fn state_dropped_add(state: Vec, name: *Str) : I32 => {
    if (!state_dropped_set(state).set_has(name)) {
        state_dropped_set(state).set_add(name);
        state_dropped_vec(state).vec_push(name);
    }
    0
}
fn state_dropped_delete(state: Vec, name: *Str) : I32 => {
    state_dropped_set(state).set_delete(name);
    0
}
fn state_begin_scope(state: Vec) : I32 => {
    state_scope_starts(state).vec_push(state_loans(state).vec_length());
    0
}
fn state_end_scope(state: Vec) : I32 => {
    let starts = state_scope_starts(state);
    if (starts.vec_length() == 0) {
        return 0;
    }
    let start = starts.vec_pop();
    let loans = state_loans(state);
    while (loans.vec_length() > start) {
        loans.vec_pop();
    }
    0
}
fn state_add_loan(state: Vec, kind: I32, base: *Str, path: *Str) : I32 => {
    let entry = vec_new();
    entry.vec_push(kind);
    entry.vec_push(base);
    entry.vec_push(path);
    state_loans(state).vec_push(entry);
    0
}
fn state_any_conflicting_loan(state: Vec, base: *Str, path: *Str) : Bool => {
    let loans = state_loans(state);
    let i = 0;
    let len = loans.vec_length();
    while (i < len) {
        let e = loans.vec_get(i);
        let eb = e.vec_get(1);
        let ep = e.vec_get(2);
        if (places_conflict(base, path, eb, ep)) {
            return true;
        }
        i = i + 1;
    }
    false
}
fn state_conflicting_mut_loan(state: Vec, base: *Str, path: *Str) : Bool => {
    let loans = state_loans(state);
    let i = 0;
    let len = loans.vec_length();
    while (i < len) {
        let e = loans.vec_get(i);
        if (e.vec_get(0) == 2) {
            let eb = e.vec_get(1);
            let ep = e.vec_get(2);
            if (places_conflict(base, path, eb, ep)) {
                return true;
            }
        }
        i = i + 1;
    }
    false
}
fn state_conflicting_immut_loan(state: Vec, base: *Str, path: *Str) : Bool => {
    let loans = state_loans(state);
    let i = 0;
    let len = loans.vec_length();
    while (i < len) {
        let e = loans.vec_get(i);
        if (e.vec_get(0) == 1) {
            let eb = e.vec_get(1);
            let ep = e.vec_get(2);
            if (places_conflict(base, path, eb, ep)) {
                return true;
            }
        }
        i = i + 1;
    }
    false
}
fn state_clone(src: Vec) : Vec => {
    let dst = state_new();
    let srcMoved = state_moved_vec(src);
    let i = 0;
    let len = srcMoved.vec_length();
    while (i < len) {
        state_moved_add(dst, srcMoved.vec_get(i));
        i = i + 1;
    }
    let srcLoans = state_loans(src);
    i = 0;
    len = srcLoans.vec_length();
    while (i < len) {
        let e = srcLoans.vec_get(i);
        state_add_loan(dst, e.vec_get(0), e.vec_get(1), e.vec_get(2));
        i = i + 1;
    }
    let srcScopes = state_scope_starts(src);
    i = 0;
    len = srcScopes.vec_length();
    while (i < len) {
        state_scope_starts(dst).vec_push(srcScopes.vec_get(i));
        i = i + 1;
    }
    let srcDropped = state_dropped_vec(src);
    i = 0;
    len = srcDropped.vec_length();
    while (i < len) {
        state_dropped_add(dst, srcDropped.vec_get(i));
        i = i + 1;
    }
    dst
}
fn state_merge_moved_from_branches(dst: Vec, a: Vec, b: Vec) : I32 => {
    let newSet = set_new();
    let newVec = vec_new();
    let av = state_moved_vec(a);
    let i = 0;
    let len = av.vec_length();
    while (i < len) {
        let n = av.vec_get(i);
        if (state_moved_set(a).set_has(n) && !newSet.set_has(n)) {
            newSet.set_add(n);
            newVec.vec_push(n);
        }
        i = i + 1;
    }
    let bv = state_moved_vec(b);
    i = 0;
    len = bv.vec_length();
    while (i < len) {
        let n = bv.vec_get(i);
        if (state_moved_set(b).set_has(n) && !newSet.set_has(n)) {
            newSet.set_add(n);
            newVec.vec_push(n);
        }
        i = i + 1;
    }
    dst.vec_set(0, newSet);
    dst.vec_set(1, newVec);
    let droppedSet = set_new();
    let droppedVec = vec_new();
    let adv = state_dropped_vec(a);
    i = 0;
    len = adv.vec_length();
    while (i < len) {
        let n = adv.vec_get(i);
        if (state_dropped_set(a).set_has(n) && !droppedSet.set_has(n)) {
            droppedSet.set_add(n);
            droppedVec.vec_push(n);
        }
        i = i + 1;
    }
    let bdv = state_dropped_vec(b);
    i = 0;
    len = bdv.vec_length();
    while (i < len) {
        let n = bdv.vec_get(i);
        if (state_dropped_set(b).set_has(n) && !droppedSet.set_has(n)) {
            droppedSet.set_add(n);
            droppedVec.vec_push(n);
        }
        i = i + 1;
    }
    dst.vec_set(4, droppedSet);
    dst.vec_set(5, droppedVec);
    0
}
fn panic_borrow(code: *Str, message: *Str, fix: *Str) : I32 => {
    panic_with_code_loc( code, message,
    "Borrowing and ownership rules require exclusive mutable access or shared immutable access, and disallow use-after-move.", fix, node_get_line(bc_current_node), node_get_col(bc_current_node)
    )
}
fn ensure_readable(expr: I32, state: Vec) : I32 => {
    let p = canonical_place(expr);
    if (!place_is_valid(p)) {
        return 0;
    }
    let base = place_base(p);
    if (bc_global_value_types.map_has(base)) {
        return 0;
    }
    if (state_dropped_has(state, base)) {
        panic_borrow( "E_BORROW_USE_AFTER_DROP",
        "Use of dropped value '".str_concat(base).str_concat("'"), "Do not use a value after explicit or implicit drop; move/copy before dropping if needed." );
    }
    if (state_moved_has(state, base)) {
        panic_borrow( "E_BORROW_USE_AFTER_MOVE", "Use of moved value '".str_concat(base).str_concat("'"),
        "Reinitialize the value before use, or borrow it before moving." );
    }
    0
}
fn consume_place(expr: I32, state: Vec, env_types: Map, fn_return_types: Map, extern_type_names:
*mut Set) : I32 => {
    let p = canonical_place(expr);
    if (!place_is_valid(p)) {
        return 0;
    }
    let base = place_base(p);
    let path = place_path(p);
     // Parser-generated tuple destructuring temporaries are read multiple times
     // by design (e.g. __tuple_tmp_n[0], __tuple_tmp_n[1]). Treat them as
     // ephemeral compiler temps, not user-visible move-tracked values.
    if (base.str_starts_with("__tuple_tmp_")) {
        return 0;
    }
    if (bc_global_value_types.map_has(base)) {
        return 0;
    }
    if (state_dropped_has(state, base)) {
        panic_borrow( "E_BORROW_USE_AFTER_DROP", "Use of dropped value '".str_concat(base).str_concat("'"),
        "Do not use a value after explicit or implicit drop; move/copy before dropping if needed." );
    }
    if (state_moved_has(state, base)) {
        panic_borrow( "E_BORROW_USE_AFTER_MOVE", "Use of moved value '".str_concat(base).str_concat("'"),
        "Reinitialize the value before use, or borrow it with '&' / '&mut' instead of moving." );
    }
    if (state_any_conflicting_loan(state, base, path)) {
        panic_borrow( "E_BORROW_MOVE_WHILE_BORROWED", "Cannot move '".str_concat(base).str_concat("' while it is borrowed"),
        "Ensure all borrows end before moving, or pass a borrow (&/&mut) instead." );
    }
    let ty = bc_infer_expr_type_name(expr, env_types, fn_return_types);
    if (!is_copy_type(ty, extern_type_names)) {
        state_moved_add(state, base);
    }
    0
}
fn check_expr(expr: I32, state: Vec, env_types: Map, fn_return_types: Map, extern_type_names: *mut
Set, global_fn_names: *mut Set, mode: *Str) : I32 => {
    if (expr == 0) {
        return 0;
    }
    bc_current_node = expr;
    if (mode.str_eq("move") && node_kind(expr) == NK_IDENTIFIER) {
        let nm = get_interned_str(node_get_data1(expr));
        if (global_fn_names.set_has(nm)) {
            return 0;
        }
    }
    if (node_kind(expr) == NK_UNARY_EXPR) {
        let op = get_interned_str(node_get_data1(expr));
        if (op.str_eq("&") || op.str_eq("&mut")) {
            let target = node_get_data2(expr);
            let p = canonical_place(target);
            if (!place_is_valid(p)) {
                if (node_kind(target) == NK_STRUCT_INIT) {
                    check_expr(target, state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
                    return 0;
                }
                panic_borrow( "E_BORROW_INVALID_TARGET",
                "Borrow target is not a place expression", "Borrow only identifiers, fields, or index places (e.g. &x, &obj.f, &arr[i])." );
            }
            ensure_readable(target, state);
            let base = place_base(p);
            let path = place_path(p);
            if (op.str_eq("&")) {
                if (state_conflicting_mut_loan(state, base, path)) {
                    panic_borrow( "E_BORROW_IMMUT_WHILE_MUT", "Cannot immutably borrow '".str_concat(base).str_concat("' because it is mutably borrowed"),
                    "End the mutable borrow first, or borrow mutably in a non-overlapping scope." );
                }
                state_add_loan(state, 1, base, path);
            }
            else {
                if (state_conflicting_mut_loan(state, base, path) ||
                state_conflicting_immut_loan(state, base, path)) {
                    panic_borrow( "E_BORROW_MUT_CONFLICT",
                    "Cannot mutably borrow '".str_concat(base).str_concat("' because it is already borrowed"), "Ensure no active borrows overlap this place before taking '&mut'." );
                }
                state_add_loan(state, 2, base, path);
            }
            return 0;
        }
    }
    let kind = node_kind(expr);
    if (kind == NK_IDENTIFIER || kind == NK_MEMBER_EXPR || kind == NK_INDEX_EXPR) {
        if (mode.str_eq("read")) {
            ensure_readable(expr, state);
            return 0;
        }
        consume_place(expr, state, env_types, fn_return_types, extern_type_names);
        return 0;
    }
    if (kind == NK_NUMBER_LIT || kind == NK_BOOL_LIT || kind == NK_STRING_LIT || kind ==
    NK_CHAR_LIT) {
        return 0;
    }
    if (kind == NK_UNARY_EXPR) {
        check_expr(node_get_data2(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
        return 0;
    }
    if (kind == NK_BINARY_EXPR) {
        check_expr(node_get_data2(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
        check_expr(node_get_data3(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
        return 0;
    }
    if (kind == NK_CALL_EXPR) {
        let callee = node_get_data1(expr);
        if (node_kind(callee) == NK_IDENTIFIER && get_interned_str(node_get_data1(callee)).str_eq("drop")) {
            let args = node_get_data2(expr);
            if (args.vec_length() != 1) {
                panic_borrow( "E_BORROW_INVALID_TARGET", "drop expects exactly one argument",
                "Call drop with exactly one local/place value such as drop(x) or x.drop()." );
            }
            let target = args.vec_get(0);
            let p = canonical_place(target);
            if (!place_is_valid(p)) {
                panic_borrow( "E_BORROW_INVALID_TARGET",
                "drop target must be a place expression", "Call drop with a local/place value such as drop(x) or x.drop()." );
            }
            let base = place_base(p);
            let path = place_path(p);
            if (state_dropped_has(state, base)) {
                panic_borrow(
                "E_BORROW_DOUBLE_DROP", "Double drop of '".str_concat(base).str_concat("'"), "Ensure each owned value is dropped exactly once." );
            }
            let target_type = bc_infer_expr_type_name(target, env_types, fn_return_types);
            if (!bc_destructor_aliases.map_has(target_type)) {
                panic_borrow( "E_BORROW_DROP_MISSING_DESTRUCTOR",
                "Type '".str_concat(target_type).str_concat("' has no associated destructor"), "Associate a destructor via 'type Alias = Base then destructorName;' and use that alias type." );
            }
            ensure_readable(target, state);
            if (state_any_conflicting_loan(state, base, path)) {
                panic_borrow( "E_BORROW_MOVE_WHILE_BORROWED",
                "Cannot drop '".str_concat(base).str_concat("' while it is borrowed"), "Ensure all borrows end before dropping the value." );
            }
            state_dropped_add(state, base);
            state_moved_add(state, base);
            return 0;
        }
        if (node_kind(callee) == NK_IDENTIFIER && get_interned_str(node_get_data1(callee)).str_eq("into") && node_get_data3(expr) == 1) {
            let args = node_get_data2(expr);
            if (args.vec_length() >= 1) {
                let receiver = args.vec_get(0);
                let receiver_mode = "read";
                if (place_is_valid(canonical_place(receiver))) {
                    receiver_mode = "move";
                }
                check_expr(receiver, state, env_types, fn_return_types, extern_type_names,
                global_fn_names, receiver_mode);
            }
            let i = 1;
            let len = args.vec_length();
            while (i < len) {
                check_expr(args.vec_get(i), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
                i = i + 1;
            }
            return 0;
        }
        if (!(node_kind(callee) == NK_IDENTIFIER &&
        global_fn_names.set_has(get_interned_str(node_get_data1(callee))))) {
            check_expr(callee, state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
        }
        let args = node_get_data2(expr);
        let i = 0;
        let len = args.vec_length();
        while (i < len) {
            check_expr(args.vec_get(i), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
            i = i + 1;
        }
        return 0;
    }
    if (kind == NK_STRUCT_INIT) {
        let fields = node_get_data2(expr);
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let f = fields.vec_get(i);
            check_expr(f.vec_get(1), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
            i = i + 1;
        }
        return 0;
    }
    if (kind == NK_TUPLE_EXPR) {
        let items = node_get_data1(expr);
        let i = 0;
        let len = items.vec_length();
        while (i < len) {
            check_expr(items.vec_get(i), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
            i = i + 1;
        }
        return 0;
    }
    if (kind == NK_IF_EXPR) {
        check_expr(node_get_data1(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
        let then_state = state_clone(state);
        check_stmt(node_get_data2(expr), then_state, env_types, fn_return_types, extern_type_names,
        global_fn_names);
        if (node_get_data3(expr) != 0) {
            let else_state = state_clone(state);
            check_stmt(node_get_data3(expr), else_state, env_types, fn_return_types,
            extern_type_names, global_fn_names);
            state_merge_moved_from_branches(state, then_state, else_state);
        }
        else {
            state_merge_moved_from_branches(state, then_state, state);
        }
        return 0;
    }
    if (kind == NK_MATCH_EXPR) {
        check_expr(node_get_data1(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
        let cases = node_get_data2(expr);
        let merged = state_clone(state);
        let i = 0;
        let len = cases.vec_length();
        while (i < len) {
            let c = cases.vec_get(i);
            let branch = state_clone(state);
            check_stmt(c.vec_get(1), branch, env_types, fn_return_types, extern_type_names,
            global_fn_names);
            state_merge_moved_from_branches(merged, merged, branch);
            i = i + 1;
        }
        state_merge_moved_from_branches(state, merged, state);
        return 0;
    }
    if (kind == NK_IS_EXPR) {
        check_expr(node_get_data1(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
        return 0;
    }
    if (kind == NK_UNWRAP_EXPR) {
        check_expr(node_get_data1(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
        return 0;
    }
    0
}
 // Returns true if the stmt or block definitely diverges (ends with a return).
 // Used to avoid propagating moved-state from dead branches into the parent scope.
fn bc_stmt_diverges(stmt: I32) : Bool => {
    if (stmt == 0) {
        return false;
    }
    let k = node_kind(stmt);
    if (k == NK_RETURN_STMT) {
        return true;
    }
    if (k == NK_BLOCK) {
        let stmts = node_get_data1(stmt);
        let len = stmts.vec_length();
        if (len == 0) {
            return false;
        }
        return bc_stmt_diverges(stmts.vec_get(len - 1));
    }
    false
}
fn check_block(block: I32, state: Vec, env_types: Map, fn_return_types: Map, extern_type_names: *mut
Set, global_fn_names: *mut Set) : I32 => {
    state_begin_scope(state);
    let stmts = node_get_data1(block);
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        check_stmt(stmts.vec_get(i), state, env_types, fn_return_types, extern_type_names,
        global_fn_names);
        i = i + 1;
    }
    state_end_scope(state)
}
fn check_stmt(stmt: I32, state: Vec, env_types: Map, fn_return_types: Map, extern_type_names: *mut
Set, global_fn_names: *mut Set) : I32 => {
    if (stmt == 0) {
        return 0;
    }
    bc_current_node = stmt;
    let kind = node_kind(stmt);
    if (kind == NK_LET_DECL) {
        let rhs = node_get_data3(stmt);
        let mode = "read";
        let p = canonical_place(rhs);
        if (place_is_valid(p)) {
            if (node_kind(rhs) == NK_IDENTIFIER) {
                mode = "move";
            }
            else {
                mode = "read";
            }
        }
        check_expr(rhs, state, env_types, fn_return_types, extern_type_names, global_fn_names,
        mode);
        let name = get_interned_str(node_get_data1(stmt));
        let tnode = node_get_data2(stmt);
        if (tnode != 0) {
            env_types.map_set(name, bc_type_name_from_type_node(tnode));
        }
        else {
            env_types.map_set(name, bc_infer_expr_type_name(rhs, env_types, fn_return_types));
        }
        state_moved_delete(state, name);
        state_dropped_delete(state, name);
        return 0;
    }
    if (kind == NK_EXTERN_IMPORT_DECL) {
        return 0;
    }
    if (kind == NK_ASSIGN_STMT) {
        let target = node_get_data1(stmt);
        let tplace = canonical_place(target);
        if (place_is_valid(tplace)) {
            let base = place_base(tplace);
            let path = place_path(tplace);
            if (state_any_conflicting_loan(state, base, path)) {
                panic_borrow(
                "E_BORROW_ASSIGN_WHILE_BORROWED", "Cannot assign to '".str_concat(base).str_concat("' while it is borrowed"), "End active borrows before assignment, or assign in a non-overlapping scope." );
            }
        }
        let rhs = node_get_data2(stmt);
        let mode = "read";
        let rhs_place = canonical_place(rhs);
        if (place_is_valid(rhs_place)) {
            mode = "move";
        }
        check_expr(rhs, state, env_types, fn_return_types, extern_type_names, global_fn_names,
        mode);
        if (node_kind(target) == NK_IDENTIFIER) {
            let target_name = get_interned_str(node_get_data1(target));
            state_moved_delete(state, target_name);
            state_dropped_delete(state, target_name);
        }
        return 0;
    }
    if (kind == NK_EXPR_STMT) {
        check_expr(node_get_data1(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names, "move");
        return 0;
    }
    if (kind == NK_RETURN_STMT) {
        let v = node_get_data1(stmt);
        if (v != 0) {
            let mode = "read";
            if (place_is_valid(canonical_place(v))) {
                mode = "move";
            }
            check_expr(v, state, env_types, fn_return_types, extern_type_names, global_fn_names,
            mode);
        }
        return 0;
    }
    if (kind == NK_IF_STMT) {
        check_expr(node_get_data1(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
        let then_branch = node_get_data2(stmt);
        let else_branch = node_get_data3(stmt);
        let then_state = state_clone(state);
        check_stmt(then_branch, then_state, env_types, fn_return_types, extern_type_names,
        global_fn_names);
        let then_diverges = bc_stmt_diverges(then_branch);
        if (else_branch != 0) {
            let else_state = state_clone(state);
            check_stmt(else_branch, else_state, env_types, fn_return_types, extern_type_names,
            global_fn_names);
            let else_diverges = bc_stmt_diverges(else_branch);
            if (then_diverges && else_diverges) {
                 // Both branches diverge — mark outer state as having all moves from either branch
                state_merge_moved_from_branches(state, then_state, else_state);
            }
            else if (then_diverges) {
                 // Then diverges — only else's state survives to the continuation
                state_merge_moved_from_branches(state, else_state, else_state);
            }
            else if (else_diverges) {
                 // Else diverges — only then's state survives to the continuation
                state_merge_moved_from_branches(state, then_state, then_state);
            }
            else {
                state_merge_moved_from_branches(state, then_state, else_state);
            }
        }
        else {
            if (then_diverges) {
                 // No else branch, then diverges — outer state unchanged (no merge needed)
                0;
            }
            else {
                state_merge_moved_from_branches(state, then_state, state);
            }
        }
        return 0;
    }
    if (kind == NK_FOR_STMT) {
        check_expr(node_get_data2(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
        check_expr(node_get_data3(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
        state_begin_scope(state);
        env_types.map_set(get_interned_str(node_get_data1(stmt)), "I32");
        check_stmt(node_get_data4(stmt), state, env_types, fn_return_types, extern_type_names,
        global_fn_names);
        state_end_scope(state);
        return 0;
    }
    if (kind == NK_WHILE_STMT) {
        check_expr(node_get_data1(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
        state_begin_scope(state);
        check_stmt(node_get_data2(stmt), state, env_types, fn_return_types, extern_type_names,
        global_fn_names);
        state_end_scope(state);
        return 0;
    }
    if (kind == NK_LOOP_STMT) {
        state_begin_scope(state);
        check_stmt(node_get_data1(stmt), state, env_types, fn_return_types, extern_type_names,
        global_fn_names);
        state_end_scope(state);
        return 0;
    }
    if (kind == NK_BLOCK) {
        check_block(stmt, state, env_types, fn_return_types, extern_type_names, global_fn_names);
        return 0;
    }
    if (kind == NK_LIFETIME_STMT) {
        check_stmt(node_get_data2(stmt), state, env_types, fn_return_types, extern_type_names,
        global_fn_names);
        return 0;
    }
    if (kind == NK_CONTRACT_DECL || kind == NK_INTO_STMT) {
        return 0;
    }
    if (kind == NK_FN_DECL) {
        let fn_state = state_new();
        let fn_env = map_new();
         // inherit global value types
         // (map iteration not available; globals are only needed via direct map_has in infer)
         // copy explicit parameters
        let params = node_get_data3(stmt);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let p = params.vec_get(i);
            let pname = get_interned_str(p.vec_get(0));
            let ptype = p.vec_get(1);
            fn_env.map_set(pname, bc_type_name_from_type_node(ptype));
            i = i + 1;
        }
        let body = node_get_data5(stmt);
        if (node_kind(body) == NK_BLOCK) {
            check_block(body, fn_state, fn_env, fn_return_types, extern_type_names,
            global_fn_names);
        }
        else {
            check_expr(body, fn_state, fn_env, fn_return_types, extern_type_names, global_fn_names, "move");
        }
        return 0;
    }
     // fallback
    check_expr(stmt, state, env_types, fn_return_types, extern_type_names, global_fn_names, "move");
    0
}
out fn borrowcheck_program_impl(program: I32) : I32 => {
    let fn_return_types = map_new();
    let extern_type_names = set_new();
    let global_type_by_name = map_new();
    let global_fn_names = set_new();
    let body = node_get_data1(program);
    bc_copy_types = set_new();
    bc_copy_alias_types = map_new();
    bc_copy_alias_names = vec_new();
    bc_destructor_aliases = map_new();
    bc_destructor_alias_names = vec_new();
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        let stmt = body.vec_get(i);
        let kind = node_kind(stmt);
        if (kind == NK_EXTERN_TYPE_DECL) {
            extern_type_names.set_add(get_interned_str(node_get_data1(stmt)));
        }
        if (kind == NK_FN_DECL || kind == NK_EXTERN_FN_DECL) {
            let fname = get_interned_str(node_get_data1(stmt));
            global_fn_names.set_add(fname);
            fn_return_types.map_set(fname, bc_type_name_from_type_node(node_get_data4(stmt)));
        }
        if (kind == NK_LET_DECL || kind == NK_EXTERN_LET_DECL) {
            global_type_by_name.map_set(get_interned_str(node_get_data1(stmt)),
            bc_type_name_from_type_node(node_get_data2(stmt)));
        }
        if (kind == NK_ENUM_DECL) {
            bc_copy_types.set_add(get_interned_str(node_get_data1(stmt)));
        }
        if (kind == NK_STRUCT_DECL && node_get_data4(stmt) == 1) {
            bc_copy_types.set_add(get_interned_str(node_get_data1(stmt)));
        }
        if (kind == NK_TYPE_ALIAS && node_get_data4(stmt) == 1) {
            let alias_name = get_interned_str(node_get_data1(stmt));
            bc_copy_alias_names.vec_push(alias_name);
            bc_copy_alias_types.map_set(alias_name, node_get_data3(stmt));
        }
        if (kind == NK_TYPE_ALIAS && node_get_data5(stmt) != 0) {
            let alias_name = get_interned_str(node_get_data1(stmt));
            let destructor_name = get_interned_str(node_get_data5(stmt));
            bc_destructor_aliases.map_set(alias_name, destructor_name);
            bc_destructor_alias_names.vec_push(alias_name);
        }
        if (kind == NK_EXTERN_TYPE_DECL && node_get_data5(stmt) != 0) {
            let alias_name = get_interned_str(node_get_data1(stmt));
            let destructor_name = get_interned_str(node_get_data5(stmt));
            bc_destructor_aliases.map_set(alias_name, destructor_name);
            bc_destructor_alias_names.vec_push(alias_name);
        }
        i = i + 1;
    }
     // Validate destructor declarations/signatures.
    i = 0;
    let dlen = bc_destructor_alias_names.vec_length();
    while (i < dlen) {
        let alias_name = bc_destructor_alias_names.vec_get(i);
        let destructor_name = bc_destructor_aliases.map_get(alias_name);
        let found = false;
        let j = 0;
        while (j < len) {
            let stmt = body.vec_get(j);
            let sk = node_kind(stmt);
            if ((sk == NK_FN_DECL || sk == NK_EXTERN_FN_DECL) &&
            get_interned_str(node_get_data1(stmt)).str_eq(destructor_name)) {
                found = true;
                let valid = true;
                let params = node_get_data3(stmt);
                if (params.vec_length() != 1) {
                    valid = false;
                }
                else {
                    let p0 = params.vec_get(0);
                    let pname = get_interned_str(p0.vec_get(0));
                    let ptype = p0.vec_get(1);
                    if (!pname.str_eq("this")) {
                        valid = false;
                    }
                    if (!bc_type_node_is_destructor_receiver(ptype, alias_name)) {
                        valid = false;
                    }
                }
                if (!bc_type_name_from_type_node(node_get_data4(stmt)).str_eq("Void")) {
                    valid = false;
                }
                if (!valid) {
                    panic_with_code( "E_TYPE_DESTRUCTOR_SIGNATURE", "Destructor '".str_concat(destructor_name).str_concat("' must have signature fn ").str_concat(destructor_name).str_concat("(this : ").str_concat(alias_name).str_concat("<...>) : Void"),
                    "Destructor signatures must use the alias receiver type (or legacy '*move Alias') and return Void.", "Use exactly one receiver parameter named 'this' with alias type and return Void." );
                }
                break;
            }
            j = j + 1;
        }
        if (!found) {
            panic_with_code( "E_TYPE_DESTRUCTOR_NOT_FOUND", "Destructor '".str_concat(destructor_name).str_concat("' for alias '").str_concat(alias_name).str_concat("' was not found"),
            "A type declaration referenced a destructor function that does not exist.", "Declare the destructor function before using it in 'type Alias = ... then destructor' or 'extern type Alias then destructor'." );
        }
        i = i + 1;
    }
    i = 0;
    let copy_alias_count = bc_copy_alias_names.vec_length();
    while (i < copy_alias_count) {
        let alias_name = bc_copy_alias_names.vec_get(i);
        let alias_type = bc_copy_alias_types.map_get(alias_name);
        let visiting = set_new();
        visiting.set_add(alias_name);
        if (!bc_type_node_is_copyable(alias_type, extern_type_names, visiting)) {
            panic_with_code( "E_BORROW_INVALID_COPY_ALIAS", "copy type ".str_concat(alias_name).str_concat(" must alias a copy-compatible type"), "A type alias marked 'copy' resolved to a non-copy type under move semantics.",
            "Only mark aliases as 'copy' when the aliased type is copy-compatible (primitives, pointers, enums, copy structs, or other copy aliases)." );
        }
        bc_copy_types.set_add(alias_name);
        i = i + 1;
    }
    let state = state_new();
    let env = global_type_by_name;
    bc_global_value_types = global_type_by_name;
    i = 0;
    while (i < len) {
        check_stmt(body.vec_get(i), state, env, fn_return_types, extern_type_names,
        global_fn_names);
        i = i + 1;
    }
    program
}
out fn selfhost_borrowcheck_impl_marker() : I32 => 0;
