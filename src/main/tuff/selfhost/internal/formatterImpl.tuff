let {
    lexInit, lexAll, lexTakeTrivia
}
 = selfhost::runtimeLexer;
let {
    parseInit
}
 = selfhost::parserCore;
let {
    pParseProgram, desugar
}
 = selfhost::parserDecls;
let {
    resolveNames
}
 = selfhost::resolver;
let {
    typecheckProgramWithOptions
}
 = selfhost::typecheck;
let {
    emitTuffFromTyped
}
 = selfhost::tuffPrinter;
out fn formatTuffSourceImpl(source: *Str) : *Str => {
    lexInit(source);
    lexAll();
    parseInit();
    let program = pParseProgram();
    let desugared = desugar(program);
    let resolvedResultAny = resolveNames(desugared);
    if (resolvedResultAny is struct Err) {
        panic("Formatter resolver error: ".strConcat(resolvedResultAny.error.message));
    }
    let resolved = 0;
    if (resolvedResultAny is struct Ok) {
        resolved = resolvedResultAny.value;
    }
    else {
        panic("Formatter resolver returned unexpected result variant");
    }
    let typedResultAny = typecheckProgramWithOptions(resolved);
    if (typedResultAny is struct Err) {
        panic("Formatter typechecker error: ".strConcat(typedResultAny.error.message));
    }
    let typed = 0;
    if (typedResultAny is struct Ok) {
        typed = typedResultAny.value;
    }
    else {
        panic("Formatter typechecker returned unexpected result variant");
    }
    emitTuffFromTyped(typed, source, lexTakeTrivia())
}
out fn selfhostFormatterImplMarker() : I32 => 0;
