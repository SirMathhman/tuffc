let {
    getInternedStr, mapNew, setNew, vecNew, strIncludes, strStartsWith
}
 = selfhost::runtimeLexer;
let {
    nodeKind, nodeGetData1, nodeGetData2, nodeGetData3, nodeGetData4, nodeGetData5,
    nodeGetLine, nodeGetCol
}
 = selfhost::parserCore;
 // Current AST node being borrow-checked; updated at check_expr/check_stmt entry.
let bcCurrentNode : I32 = 0;
let bcGlobalValueTypes : Map<I32, I32> = mapNew();
let bcCopyTypes : *mut Set<I32> = setNew();
let bcCopyAliasTypes : Map<I32, I32> = mapNew();
let bcCopyAliasNames : Vec<*Str> = vecNew();

let bcDestructorAliases : Map<I32, I32> = mapNew();
let bcDestructorAliasNames : Vec<*Str> = vecNew();
fn bcStrEndsWithLocal(s: *Str, suffix: *Str) : Bool => {
    let ns = s.strLength();
    let nf = suffix.strLength();
    if (nf > ns) {
        return false;
    }
    s.strSliceWindow(ns - nf, ns).strEq(suffix)
}
fn bcTypeNameFromTypeNode(t: I32) : *Str => {
    if (t == 0) {
        return "Unknown";
    }
    let k = nodeKind(t);
    if (k == NK_NAMED_TYPE) {
        return getInternedStr(nodeGetData1(t));
    }
    if (k == NK_REFINEMENT_TYPE) {
        return bcTypeNameFromTypeNode(nodeGetData1(t));
    }
    if (k == NK_POINTER_TYPE) {
        let mutable = nodeGetData1(t);
        let inner = bcTypeNameFromTypeNode(nodeGetData2(t));
        let movePtr = nodeGetData3(t);
        let lifeIdx = nodeGetData4(t);
        let lifePrefix = "";
        if (lifeIdx != 0) {
            lifePrefix = getInternedStr(lifeIdx).strConcat(" ");
        }
        if (movePtr == 1) {
            return "*".strConcat(lifePrefix).strConcat("move ").strConcat(inner);
        }
        if (mutable == 1) {
            return "*".strConcat(lifePrefix).strConcat("mut ").strConcat(inner);
        }
        return "*".strConcat(lifePrefix).strConcat(inner);
    }
    if (k == NK_UNION_TYPE) {
        let left = bcTypeNameFromTypeNode(nodeGetData1(t));
        let right = bcTypeNameFromTypeNode(nodeGetData2(t));
        return left.strConcat("|").strConcat(right);
    }
    "Unknown"
}
fn isCopyPrimitive(name: *Str) : Bool => {
    name.strEq("I8") || name.strEq("I16") || name.strEq("I32") || name.strEq("I64") || name.strEq("I128") || name.strEq("U8") || name.strEq("U16") || name.strEq("U32") || name.strEq("U64") || name.strEq("U128") || name.strEq("USize") || name.strEq("ISize") || name.strEq("F32") || name.strEq("F64") ||
    name.strEq("Bool") || name.strEq("Char")
}
fn isCopyType(typeName: *Str, externTypeNames: *mut Set<I32>) : Bool => {
    if (typeName.strEq("Unknown")) {
        return false;
    }
    if (typeName.strStartsWith("*")) {
        return true;
    }
    if (isCopyPrimitive(typeName)) {
        return true;
    }
    if (bcDestructorAliases.mapHas(typeName)) {
        return false;
    }
    if (typeName.strEq("Vec") || typeName.strEq("Map") || typeName.strEq("Set")) {
        return true;
    }
    if (bcCopyTypes.setHas(typeName)) {
        return true;
    }
    if (externTypeNames.setHas(typeName)) {
        return false;
    }
    false
}
fn bcFindCopyAliasType(name: *Str) : I32 => {
    if (bcCopyAliasTypes.mapHas(name)) {
        return bcCopyAliasTypes.mapGet(name);
    }
    0
}
fn bcTypeNodeIsCopyable(t: I32, externTypeNames: *mut Set<I32>, visitingAliases: *mut Set<I32>) : Bool
=> {
    if (t == 0) {
        return false;
    }
    let k = nodeKind(t);
    if (k == NK_NAMED_TYPE) {
        let name = getInternedStr(nodeGetData1(t));
        if (bcDestructorAliases.mapHas(name)) {
            return false;
        }
        if (isCopyPrimitive(name)) {
            return true;
        }
        if (name.strEq("Vec") || name.strEq("Map") || name.strEq("Set")) {
            return true;
        }
        if (bcCopyTypes.setHas(name)) {
            return true;
        }
        if (externTypeNames.setHas(name)) {
            return false;
        }
        let aliasType = bcFindCopyAliasType(name);
        if (aliasType != 0) {
            if (visitingAliases.setHas(name)) {
                return false;
            }
            visitingAliases.setAdd(name);
            let ok = bcTypeNodeIsCopyable(aliasType, externTypeNames, visitingAliases);
            visitingAliases.setDelete(name);
            return ok;
        }
        return false;
    }
    if (k == NK_REFINEMENT_TYPE) {
        return bcTypeNodeIsCopyable(nodeGetData1(t), externTypeNames, visitingAliases);
    }
    if (k == NK_POINTER_TYPE) {
        return true;
    }
    if (k == NK_UNION_TYPE) {
        return bcTypeNodeIsCopyable(nodeGetData1(t), externTypeNames, visitingAliases) &&
        bcTypeNodeIsCopyable(nodeGetData2(t), externTypeNames, visitingAliases);
    }
    if (k == NK_TUPLE_TYPE) {
        let members = nodeGetData1(t);
        let i = 0;
        let len = members.vecLength();
        while (i < len) {
            if (!bcTypeNodeIsCopyable(members.vecGet(i), externTypeNames, visitingAliases))
            {
                return false;
            }
            i = i + 1;
        }
        return true;
    }
    false
}
fn bcTypeNodeIsDestructorReceiver(t: I32, aliasName: *Str) : Bool => {
    if (t == 0) {
        return false;
    }
     // Preferred form: alias receiver value (e.g. Alloc<...>)
    if (nodeKind(t) == NK_NAMED_TYPE && getInternedStr(nodeGetData1(t)).strEq(aliasName)) {
        return true;
    }
     // Back-compat: *move Alias
    if (nodeKind(t) == NK_POINTER_TYPE && nodeGetData3(t) == 1) {
        return bcTypeNameFromTypeNode(nodeGetData2(t)).strEq(aliasName);
    }
    false
}
fn bcInferExprTypeName(n: I32, envTypes: Map<I32, I32>, fnReturnTypes: Map<I32, I32>) : *Str => {
    if (n == 0) {
        return "Unknown";
    }
    let kind = nodeKind(n);
    if (kind == NK_NUMBER_LIT) {
        let text = getInternedStr(nodeGetData1(n));
        if (bcStrEndsWithLocal(text, "USize")) {
            return "USize";
        }
        return "I32";
    }
    if (kind == NK_BOOL_LIT) {
        return "Bool";
    }
    if (kind == NK_STRING_LIT) {
        return "*Str";
    }
    if (kind == NK_CHAR_LIT) {
        return "Char";
    }
    if (kind == NK_IDENTIFIER) {
        let name = getInternedStr(nodeGetData1(n));
        if (envTypes.mapHas(name)) {
            return envTypes.mapGet(name);
        }
        if (bcGlobalValueTypes.mapHas(name)) {
            return bcGlobalValueTypes.mapGet(name);
        }
        return "Unknown";
    }
    if (kind == NK_UNARY_EXPR) {
        let op = getInternedStr(nodeGetData1(n));
        let inner = bcInferExprTypeName(nodeGetData2(n), envTypes, fnReturnTypes);
        if (op.strEq("&")) {
            return "*".strConcat(inner);
        }
        if (op.strEq("&mut")) {
            return "*mut ".strConcat(inner);
        }
        if (op.strEq("!")) {
            return "Bool";
        }
        return inner;
    }
    if (kind == NK_BINARY_EXPR) {
        let op = getInternedStr(nodeGetData1(n));
        if (op.strEq("==") || op.strEq("!=") || op.strEq("<") || op.strEq("<=") || op.strEq(">") || op.strEq(">=") || op.strEq("&&") || op.strEq("||")) {
            return "Bool";
        }
        return bcInferExprTypeName(nodeGetData2(n), envTypes, fnReturnTypes);
    }
    if (kind == NK_CALL_EXPR) {
        let callee = nodeGetData1(n);
        if (nodeKind(callee) == NK_IDENTIFIER) {
            let fname = getInternedStr(nodeGetData1(callee));
            if (fnReturnTypes.mapHas(fname)) {
                return fnReturnTypes.mapGet(fname);
            }
        }
    }
    if (kind == NK_STRUCT_INIT) {
        return getInternedStr(nodeGetData1(n));
    }
    "Unknown"
}
fn placeNew(base: *Str, path: *Str) : Vec<I32> => {
    let p = vecNew();
    p.vecPush(base);
    p.vecPush(path);
    p
}
fn placeIsValid(p: Vec<I32>) : Bool => p.vecLength() == 2;
fn placeBase(p: Vec<I32>) : *Str => p.vecGet(0);
fn placePath(p: Vec<I32>) : *Str => p.vecGet(1);
fn canonicalPlace(n: I32) : Vec<I32> => {
    if (n == 0) {
        return vecNew();
    }
    let kind = nodeKind(n);
    if (kind == NK_IDENTIFIER) {
        let name = getInternedStr(nodeGetData1(n));
        return placeNew(name, name);
    }
    if (kind == NK_MEMBER_EXPR) {
        let base = canonicalPlace(nodeGetData1(n));
        if (!placeIsValid(base)) {
            return vecNew();
        }
        let prop = getInternedStr(nodeGetData2(n));
        return placeNew(placeBase(base), placePath(base).strConcat(".").strConcat(prop));
    }
    if (kind == NK_INDEX_EXPR) {
        let base = canonicalPlace(nodeGetData1(n));
        if (!placeIsValid(base)) {
            return vecNew();
        }
        return placeNew(placeBase(base), placePath(base).strConcat("[]"));
    }
    vecNew()
}
fn placesConflict(aBase: *Str, aPath: *Str, bBase: *Str, bPath: *Str) : Bool => {
    if (!aBase.strEq(bBase)) {
        return false;
    }
    if (aPath.strEq(bPath)) {
        return true;
    }
    if (aPath.strIncludes("[]") || bPath.strIncludes("[]")) {
        return true;
    }
    aPath.strStartsWith(bPath.strConcat(".")) || bPath.strStartsWith(aPath.strConcat("."))
}
fn stateNew() : Vec<I32> => {
     // [moved_set, moved_vec, loans_vec, scope_starts, dropped_set, dropped_vec]
    let s = vecNew();
    s.vecPush(setNew());
    s.vecPush(vecNew());
    s.vecPush(vecNew());
    s.vecPush(vecNew());
    s.vecPush(setNew());
    s.vecPush(vecNew());
    s
}
fn stateMovedSet(state: Vec<I32>) : *mut Set<I32> => state.vecGet(0);
fn stateMovedVec(state: Vec<I32>) : Vec<I32> => state.vecGet(1);
fn stateLoans(state: Vec<I32>) : Vec<I32> => state.vecGet(2);
fn stateScopeStarts(state: Vec<I32>) : Vec<I32> => state.vecGet(3);
fn stateDroppedSet(state: Vec<I32>) : *mut Set<I32> => state.vecGet(4);
fn stateDroppedVec(state: Vec<I32>) : Vec<I32> => state.vecGet(5);
fn stateMovedHas(state: Vec<I32>, name: *Str) : Bool => stateMovedSet(state).setHas(name);
fn stateDroppedHas(state: Vec<I32>, name: *Str) : Bool => stateDroppedSet(state).setHas(name);
fn stateMovedAdd(state: Vec<I32>, name: *Str) : I32 => {
    if (!stateMovedSet(state).setHas(name)) {
        stateMovedSet(state).setAdd(name);
        stateMovedVec(state).vecPush(name);
    }
    0
}
fn stateMovedDelete(state: Vec<I32>, name: *Str) : I32 => {
    stateMovedSet(state).setDelete(name);
    0
}
fn stateDroppedAdd(state: Vec<I32>, name: *Str) : I32 => {
    if (!stateDroppedSet(state).setHas(name)) {
        stateDroppedSet(state).setAdd(name);
        stateDroppedVec(state).vecPush(name);
    }
    0
}
fn stateDroppedDelete(state: Vec<I32>, name: *Str) : I32 => {
    stateDroppedSet(state).setDelete(name);
    0
}
fn stateBeginScope(state: Vec<I32>) : I32 => {
    stateScopeStarts(state).vecPush(stateLoans(state).vecLength());
    0
}
fn stateEndScope(state: Vec<I32>) : I32 => {
    let starts = stateScopeStarts(state);
    if (starts.vecLength() == 0) {
        return 0;
    }
    let start = starts.vecPop();
    let loans = stateLoans(state);
    while (loans.vecLength() > start) {
        loans.vecPop();
    }
    0
}
fn stateAddLoan(state: Vec<I32>, kind: I32, base: *Str, path: *Str) : I32 => {
    let entry = vecNew();
    entry.vecPush(kind);
    entry.vecPush(base);
    entry.vecPush(path);
    stateLoans(state).vecPush(entry);
    0
}
fn stateAnyConflictingLoan(state: Vec<I32>, base: *Str, path: *Str) : Bool => {
    let loans = stateLoans(state);
    let i = 0;
    let len = loans.vecLength();
    while (i < len) {
        let e = loans.vecGet(i);
        let eb = e.vecGet(1);
        let ep = e.vecGet(2);
        if (placesConflict(base, path, eb, ep)) {
            return true;
        }
        i = i + 1;
    }
    false
}
fn stateConflictingMutLoan(state: Vec<I32>, base: *Str, path: *Str) : Bool => {
    let loans = stateLoans(state);
    let i = 0;
    let len = loans.vecLength();
    while (i < len) {
        let e = loans.vecGet(i);
        if (e.vecGet(0) == 2) {
            let eb = e.vecGet(1);
            let ep = e.vecGet(2);
            if (placesConflict(base, path, eb, ep)) {
                return true;
            }
        }
        i = i + 1;
    }
    false
}
fn stateConflictingImmutLoan(state: Vec<I32>, base: *Str, path: *Str) : Bool => {
    let loans = stateLoans(state);
    let i = 0;
    let len = loans.vecLength();
    while (i < len) {
        let e = loans.vecGet(i);
        if (e.vecGet(0) == 1) {
            let eb = e.vecGet(1);
            let ep = e.vecGet(2);
            if (placesConflict(base, path, eb, ep)) {
                return true;
            }
        }
        i = i + 1;
    }
    false
}
fn stateClone(src: Vec<I32>) : Vec<I32> => {
    let dst = stateNew();
    let srcMoved = stateMovedVec(src);
    let i = 0;
    let len = srcMoved.vecLength();
    while (i < len) {
        stateMovedAdd(dst, srcMoved.vecGet(i));
        i = i + 1;
    }
    let srcLoans = stateLoans(src);
    i = 0;
    len = srcLoans.vecLength();
    while (i < len) {
        let e = srcLoans.vecGet(i);
        stateAddLoan(dst, e.vecGet(0), e.vecGet(1), e.vecGet(2));
        i = i + 1;
    }
    let srcScopes = stateScopeStarts(src);
    i = 0;
    len = srcScopes.vecLength();
    while (i < len) {
        stateScopeStarts(dst).vecPush(srcScopes.vecGet(i));
        i = i + 1;
    }
    let srcDropped = stateDroppedVec(src);
    i = 0;
    len = srcDropped.vecLength();
    while (i < len) {
        stateDroppedAdd(dst, srcDropped.vecGet(i));
        i = i + 1;
    }
    dst
}
fn stateMergeMovedFromBranches(dst: Vec<I32>, a: Vec<I32>, b: Vec<I32>) : I32 => {
    let newSet = setNew();
    let newVec = vecNew();
    let av = stateMovedVec(a);
    let i = 0;
    let len = av.vecLength();
    while (i < len) {
        let n = av.vecGet(i);
        if (stateMovedSet(a).setHas(n) && !newSet.setHas(n)) {
            newSet.setAdd(n);
            newVec.vecPush(n);
        }
        i = i + 1;
    }
    let bv = stateMovedVec(b);
    i = 0;
    len = bv.vecLength();
    while (i < len) {
        let n = bv.vecGet(i);
        if (stateMovedSet(b).setHas(n) && !newSet.setHas(n)) {
            newSet.setAdd(n);
            newVec.vecPush(n);
        }
        i = i + 1;
    }
    dst.vecSet(0, newSet);
    dst.vecSet(1, newVec);
    let droppedSet = setNew();
    let droppedVec = vecNew();
    let adv = stateDroppedVec(a);
    i = 0;
    len = adv.vecLength();
    while (i < len) {
        let n = adv.vecGet(i);
        if (stateDroppedSet(a).setHas(n) && !droppedSet.setHas(n)) {
            droppedSet.setAdd(n);
            droppedVec.vecPush(n);
        }
        i = i + 1;
    }
    let bdv = stateDroppedVec(b);
    i = 0;
    len = bdv.vecLength();
    while (i < len) {
        let n = bdv.vecGet(i);
        if (stateDroppedSet(b).setHas(n) && !droppedSet.setHas(n)) {
            droppedSet.setAdd(n);
            droppedVec.vecPush(n);
        }
        i = i + 1;
    }
    dst.vecSet(4, droppedSet);
    dst.vecSet(5, droppedVec);
    0
}
fn panicBorrow(code: *Str, message: *Str, fix: *Str) : I32 => {
    panicWithCodeLoc( code, message,
    "Borrowing and ownership rules require exclusive mutable access or shared immutable access, and disallow use-after-move.", fix, nodeGetLine(bcCurrentNode), nodeGetCol(bcCurrentNode)
    )
}
fn ensureReadable(expr: I32, state: Vec<I32>) : I32 => {
    let p = canonicalPlace(expr);
    if (!placeIsValid(p)) {
        return 0;
    }
    let base = placeBase(p);
    if (bcGlobalValueTypes.mapHas(base)) {
        return 0;
    }
    if (stateDroppedHas(state, base)) {
        panicBorrow( "E_BORROW_USE_AFTER_DROP",
        "Use of dropped value '".strConcat(base).strConcat("'"), "Do not use a value after explicit or implicit drop; move/copy before dropping if needed." );
    }
    if (stateMovedHas(state, base)) {
        panicBorrow( "E_BORROW_USE_AFTER_MOVE", "Use of moved value '".strConcat(base).strConcat("'"),
        "Reinitialize the value before use, or borrow it before moving." );
    }
    0
}
fn consumePlace(expr: I32, state: Vec<I32>, envTypes: Map<I32, I32>, fnReturnTypes: Map<I32, I32>, externTypeNames:
*mut Set<I32>) : I32 => {
    let p = canonicalPlace(expr);
    if (!placeIsValid(p)) {
        return 0;
    }
    let base = placeBase(p);
    let path = placePath(p);
     // Parser-generated tuple destructuring temporaries are read multiple times
     // by design (e.g. __tuple_tmp_n[0], __tuple_tmp_n[1]). Treat them as
     // ephemeral compiler temps, not user-visible move-tracked values.
    if (base.strStartsWith("__tuple_tmp_")) {
        return 0;
    }
    if (bcGlobalValueTypes.mapHas(base)) {
        return 0;
    }
    if (stateDroppedHas(state, base)) {
        panicBorrow( "E_BORROW_USE_AFTER_DROP", "Use of dropped value '".strConcat(base).strConcat("'"),
        "Do not use a value after explicit or implicit drop; move/copy before dropping if needed." );
    }
    if (stateMovedHas(state, base)) {
        panicBorrow( "E_BORROW_USE_AFTER_MOVE", "Use of moved value '".strConcat(base).strConcat("'"),
        "Reinitialize the value before use, or borrow it with '&' / '&mut' instead of moving." );
    }
    if (stateAnyConflictingLoan(state, base, path)) {
        panicBorrow( "E_BORROW_MOVE_WHILE_BORROWED", "Cannot move '".strConcat(base).strConcat("' while it is borrowed"),
        "Ensure all borrows end before moving, or pass a borrow (&/&mut) instead." );
    }
    let ty = bcInferExprTypeName(expr, envTypes, fnReturnTypes);
    if (!isCopyType(ty, externTypeNames)) {
        stateMovedAdd(state, base);
    }
    0
}
fn checkExpr(expr: I32, state: Vec<I32>, envTypes: Map<I32, I32>, fnReturnTypes: Map<I32, I32>, externTypeNames: *mut
Set<I32>, globalFnNames: *mut Set<I32>, mode: *Str) : I32 => {
    if (expr == 0) {
        return 0;
    }
    bcCurrentNode = expr;
    if (mode.strEq("move") && nodeKind(expr) == NK_IDENTIFIER) {
        let nm = getInternedStr(nodeGetData1(expr));
        if (globalFnNames.setHas(nm)) {
            return 0;
        }
    }
    if (nodeKind(expr) == NK_UNARY_EXPR) {
        let op = getInternedStr(nodeGetData1(expr));
        if (op.strEq("&") || op.strEq("&mut")) {
            let target = nodeGetData2(expr);
            let p = canonicalPlace(target);
            if (!placeIsValid(p)) {
                if (nodeKind(target) == NK_STRUCT_INIT) {
                    checkExpr(target, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
                    return 0;
                }
                panicBorrow( "E_BORROW_INVALID_TARGET",
                "Borrow target is not a place expression", "Borrow only identifiers, fields, or index places (e.g. &x, &obj.f, &arr[i])." );
            }
            ensureReadable(target, state);
            let base = placeBase(p);
            let path = placePath(p);
            if (op.strEq("&")) {
                if (stateConflictingMutLoan(state, base, path)) {
                    panicBorrow( "E_BORROW_IMMUT_WHILE_MUT", "Cannot immutably borrow '".strConcat(base).strConcat("' because it is mutably borrowed"),
                    "End the mutable borrow first, or borrow mutably in a non-overlapping scope." );
                }
                stateAddLoan(state, 1, base, path);
            }
            else {
                if (stateConflictingMutLoan(state, base, path) ||
                stateConflictingImmutLoan(state, base, path)) {
                    panicBorrow( "E_BORROW_MUT_CONFLICT",
                    "Cannot mutably borrow '".strConcat(base).strConcat("' because it is already borrowed"), "Ensure no active borrows overlap this place before taking '&mut'." );
                }
                stateAddLoan(state, 2, base, path);
            }
            return 0;
        }
    }
    let kind = nodeKind(expr);
    if (kind == NK_IDENTIFIER || kind == NK_MEMBER_EXPR || kind == NK_INDEX_EXPR) {
        if (mode.strEq("read")) {
            ensureReadable(expr, state);
            return 0;
        }
        consumePlace(expr, state, envTypes, fnReturnTypes, externTypeNames);
        return 0;
    }
    if (kind == NK_NUMBER_LIT || kind == NK_BOOL_LIT || kind == NK_STRING_LIT || kind ==
    NK_CHAR_LIT) {
        return 0;
    }
    if (kind == NK_UNARY_EXPR) {
        checkExpr(nodeGetData2(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
        return 0;
    }
    if (kind == NK_BINARY_EXPR) {
        checkExpr(nodeGetData2(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
        checkExpr(nodeGetData3(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
        return 0;
    }
    if (kind == NK_CALL_EXPR) {
        let callee = nodeGetData1(expr);
        if (nodeKind(callee) == NK_IDENTIFIER && getInternedStr(nodeGetData1(callee)).strEq("drop")) {
            let args = nodeGetData2(expr);
            if (args.vecLength() != 1) {
                panicBorrow( "E_BORROW_INVALID_TARGET", "drop expects exactly one argument",
                "Call drop with exactly one local/place value such as drop(x) or x.drop()." );
            }
            let target = args.vecGet(0);
            let p = canonicalPlace(target);
            if (!placeIsValid(p)) {
                panicBorrow( "E_BORROW_INVALID_TARGET",
                "drop target must be a place expression", "Call drop with a local/place value such as drop(x) or x.drop()." );
            }
            let base = placeBase(p);
            let path = placePath(p);
            if (stateDroppedHas(state, base)) {
                panicBorrow(
                "E_BORROW_DOUBLE_DROP", "Double drop of '".strConcat(base).strConcat("'"), "Ensure each owned value is dropped exactly once." );
            }
            let targetType = bcInferExprTypeName(target, envTypes, fnReturnTypes);
            if (!bcDestructorAliases.mapHas(targetType)) {
                panicBorrow( "E_BORROW_DROP_MISSING_DESTRUCTOR",
                "Type '".strConcat(targetType).strConcat("' has no associated destructor"), "Associate a destructor via 'type Alias = Base then destructorName;' and use that alias type." );
            }
            ensureReadable(target, state);
            if (stateAnyConflictingLoan(state, base, path)) {
                panicBorrow( "E_BORROW_MOVE_WHILE_BORROWED",
                "Cannot drop '".strConcat(base).strConcat("' while it is borrowed"), "Ensure all borrows end before dropping the value." );
            }
            stateDroppedAdd(state, base);
            stateMovedAdd(state, base);
            return 0;
        }
        if (nodeKind(callee) == NK_IDENTIFIER && getInternedStr(nodeGetData1(callee)).strEq("into") && nodeGetData3(expr) == 1) {
            let args = nodeGetData2(expr);
            if (args.vecLength() >= 1) {
                let receiver = args.vecGet(0);
                let receiverMode = "read";
                if (placeIsValid(canonicalPlace(receiver))) {
                    receiverMode = "move";
                }
                checkExpr(receiver, state, envTypes, fnReturnTypes, externTypeNames,
                globalFnNames, receiverMode);
            }
            let i = 1;
            let len = args.vecLength();
            while (i < len) {
                checkExpr(args.vecGet(i), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
                i = i + 1;
            }
            return 0;
        }
        if (!(nodeKind(callee) == NK_IDENTIFIER &&
        globalFnNames.setHas(getInternedStr(nodeGetData1(callee))))) {
            checkExpr(callee, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
        }
        let args = nodeGetData2(expr);
        let i = 0;
        let len = args.vecLength();
        while (i < len) {
            checkExpr(args.vecGet(i), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
            i = i + 1;
        }
        return 0;
    }
    if (kind == NK_STRUCT_INIT) {
        let fields = nodeGetData2(expr);
        let i = 0;
        let len = fields.vecLength();
        while (i < len) {
            let f = fields.vecGet(i);
            checkExpr(f.vecGet(1), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
            i = i + 1;
        }
        return 0;
    }
    if (kind == NK_TUPLE_EXPR) {
        let items = nodeGetData1(expr);
        let i = 0;
        let len = items.vecLength();
        while (i < len) {
            checkExpr(items.vecGet(i), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
            i = i + 1;
        }
        return 0;
    }
    if (kind == NK_IF_EXPR) {
        checkExpr(nodeGetData1(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
        let thenState = stateClone(state);
        checkStmt(nodeGetData2(expr), thenState, envTypes, fnReturnTypes, externTypeNames,
        globalFnNames);
        if (nodeGetData3(expr) != 0) {
            let elseState = stateClone(state);
            checkStmt(nodeGetData3(expr), elseState, envTypes, fnReturnTypes,
            externTypeNames, globalFnNames);
            stateMergeMovedFromBranches(state, thenState, elseState);
        }
        else {
            stateMergeMovedFromBranches(state, thenState, state);
        }
        return 0;
    }
    if (kind == NK_MATCH_EXPR) {
        checkExpr(nodeGetData1(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
        let cases = nodeGetData2(expr);
        let merged = stateClone(state);
        let i = 0;
        let len = cases.vecLength();
        while (i < len) {
            let c = cases.vecGet(i);
            let branch = stateClone(state);
            checkStmt(c.vecGet(1), branch, envTypes, fnReturnTypes, externTypeNames,
            globalFnNames);
            stateMergeMovedFromBranches(merged, merged, branch);
            i = i + 1;
        }
        stateMergeMovedFromBranches(state, merged, state);
        return 0;
    }
    if (kind == NK_IS_EXPR) {
        checkExpr(nodeGetData1(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
        return 0;
    }
    if (kind == NK_UNWRAP_EXPR) {
        checkExpr(nodeGetData1(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
        return 0;
    }
    0
}
 // Returns true if the stmt or block definitely diverges (ends with a return).
 // Used to avoid propagating moved-state from dead branches into the parent scope.
fn bcStmtDiverges(stmt: I32) : Bool => {
    if (stmt == 0) {
        return false;
    }
    let k = nodeKind(stmt);
    if (k == NK_RETURN_STMT) {
        return true;
    }
    if (k == NK_BLOCK) {
        let stmts = nodeGetData1(stmt);
        let len = stmts.vecLength();
        if (len == 0) {
            return false;
        }
        return bcStmtDiverges(stmts.vecGet(len - 1));
    }
    false
}
fn checkBlock(block: I32, state: Vec<I32>, envTypes: Map<I32, I32>, fnReturnTypes: Map<I32, I32>, externTypeNames: *mut
Set<I32>, globalFnNames: *mut Set<I32>) : I32 => {
    stateBeginScope(state);
    let stmts = nodeGetData1(block);
    let i = 0;
    let len = stmts.vecLength();
    while (i < len) {
        checkStmt(stmts.vecGet(i), state, envTypes, fnReturnTypes, externTypeNames,
        globalFnNames);
        i = i + 1;
    }
    stateEndScope(state)
}
fn checkStmt(stmt: I32, state: Vec<I32>, envTypes: Map<I32, I32>, fnReturnTypes: Map<I32, I32>, externTypeNames: *mut
Set<I32>, globalFnNames: *mut Set<I32>) : I32 => {
    if (stmt == 0) {
        return 0;
    }
    bcCurrentNode = stmt;
    let kind = nodeKind(stmt);
    if (kind == NK_LET_DECL) {
        let rhs = nodeGetData3(stmt);
        let mode = "read";
        let p = canonicalPlace(rhs);
        if (placeIsValid(p)) {
            if (nodeKind(rhs) == NK_IDENTIFIER) {
                mode = "move";
            }
            else {
                mode = "read";
            }
        }
        checkExpr(rhs, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames,
        mode);
        let name = getInternedStr(nodeGetData1(stmt));
        let tnode = nodeGetData2(stmt);
        if (tnode != 0) {
            envTypes.mapSet(name, bcTypeNameFromTypeNode(tnode));
        }
        else {
            envTypes.mapSet(name, bcInferExprTypeName(rhs, envTypes, fnReturnTypes));
        }
        stateMovedDelete(state, name);
        stateDroppedDelete(state, name);
        return 0;
    }
    if (kind == NK_EXTERN_IMPORT_DECL) {
        return 0;
    }
    if (kind == NK_ASSIGN_STMT) {
        let target = nodeGetData1(stmt);
        let tplace = canonicalPlace(target);
        if (placeIsValid(tplace)) {
            let base = placeBase(tplace);
            let path = placePath(tplace);
            if (stateAnyConflictingLoan(state, base, path)) {
                panicBorrow(
                "E_BORROW_ASSIGN_WHILE_BORROWED", "Cannot assign to '".strConcat(base).strConcat("' while it is borrowed"), "End active borrows before assignment, or assign in a non-overlapping scope." );
            }
        }
        let rhs = nodeGetData2(stmt);
        let mode = "read";
        let rhsPlace = canonicalPlace(rhs);
        if (placeIsValid(rhsPlace)) {
            mode = "move";
        }
        checkExpr(rhs, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames,
        mode);
        if (nodeKind(target) == NK_IDENTIFIER) {
            let targetName = getInternedStr(nodeGetData1(target));
            stateMovedDelete(state, targetName);
            stateDroppedDelete(state, targetName);
        }
        return 0;
    }
    if (kind == NK_EXPR_STMT) {
        checkExpr(nodeGetData1(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "move");
        return 0;
    }
    if (kind == NK_RETURN_STMT) {
        let v = nodeGetData1(stmt);
        if (v != 0) {
            let mode = "read";
            if (placeIsValid(canonicalPlace(v))) {
                mode = "move";
            }
            checkExpr(v, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames,
            mode);
        }
        return 0;
    }
    if (kind == NK_IF_STMT) {
        checkExpr(nodeGetData1(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
        let thenBranch = nodeGetData2(stmt);
        let elseBranch = nodeGetData3(stmt);
        let thenState = stateClone(state);
        checkStmt(thenBranch, thenState, envTypes, fnReturnTypes, externTypeNames,
        globalFnNames);
        let thenDiverges = bcStmtDiverges(thenBranch);
        if (elseBranch != 0) {
            let elseState = stateClone(state);
            checkStmt(elseBranch, elseState, envTypes, fnReturnTypes, externTypeNames,
            globalFnNames);
            let elseDiverges = bcStmtDiverges(elseBranch);
            if (thenDiverges && elseDiverges) {
                 // Both branches diverge — mark outer state as having all moves from either branch
                stateMergeMovedFromBranches(state, thenState, elseState);
            }
            else if (thenDiverges) {
                 // Then diverges — only else's state survives to the continuation
                stateMergeMovedFromBranches(state, elseState, elseState);
            }
            else if (elseDiverges) {
                 // Else diverges — only then's state survives to the continuation
                stateMergeMovedFromBranches(state, thenState, thenState);
            }
            else {
                stateMergeMovedFromBranches(state, thenState, elseState);
            }
        }
        else {
            if (thenDiverges) {
                 // No else branch, then diverges — outer state unchanged (no merge needed)
                0;
            }
            else {
                stateMergeMovedFromBranches(state, thenState, state);
            }
        }
        return 0;
    }
    if (kind == NK_FOR_STMT) {
        checkExpr(nodeGetData2(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
        checkExpr(nodeGetData3(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
        stateBeginScope(state);
        envTypes.mapSet(getInternedStr(nodeGetData1(stmt)), "I32");
        checkStmt(nodeGetData4(stmt), state, envTypes, fnReturnTypes, externTypeNames,
        globalFnNames);
        stateEndScope(state);
        return 0;
    }
    if (kind == NK_WHILE_STMT) {
        checkExpr(nodeGetData1(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
        stateBeginScope(state);
        checkStmt(nodeGetData2(stmt), state, envTypes, fnReturnTypes, externTypeNames,
        globalFnNames);
        stateEndScope(state);
        return 0;
    }
    if (kind == NK_LOOP_STMT) {
        stateBeginScope(state);
        checkStmt(nodeGetData1(stmt), state, envTypes, fnReturnTypes, externTypeNames,
        globalFnNames);
        stateEndScope(state);
        return 0;
    }
    if (kind == NK_BLOCK) {
        checkBlock(stmt, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames);
        return 0;
    }
    if (kind == NK_LIFETIME_STMT) {
        checkStmt(nodeGetData2(stmt), state, envTypes, fnReturnTypes, externTypeNames,
        globalFnNames);
        return 0;
    }
    if (kind == NK_CONTRACT_DECL || kind == NK_INTO_STMT) {
        return 0;
    }
    if (kind == NK_FN_DECL) {
        let fnState = stateNew();
        let fnEnv = mapNew();
         // inherit global value types
         // (map iteration not available; globals are only needed via direct map_has in infer)
         // copy explicit parameters
        let params = nodeGetData3(stmt);
        let i = 0;
        let len = params.vecLength();
        while (i < len) {
            let p = params.vecGet(i);
            let pname = getInternedStr(p.vecGet(0));
            let ptype = p.vecGet(1);
            fnEnv.mapSet(pname, bcTypeNameFromTypeNode(ptype));
            i = i + 1;
        }
        let body = nodeGetData5(stmt);
        if (nodeKind(body) == NK_BLOCK) {
            checkBlock(body, fnState, fnEnv, fnReturnTypes, externTypeNames,
            globalFnNames);
        }
        else {
            checkExpr(body, fnState, fnEnv, fnReturnTypes, externTypeNames, globalFnNames, "move");
        }
        return 0;
    }
     // fallback
    checkExpr(stmt, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "move");
    0
}
out fn borrowcheckProgramImpl(program: I32) : I32 => {
    let fnReturnTypes = mapNew();
    let externTypeNames = setNew();
    let globalTypeByName = mapNew();
    let globalFnNames = setNew();
    let body = nodeGetData1(program);
    bcCopyTypes = setNew();
    bcCopyAliasTypes = mapNew();
    bcCopyAliasNames = vecNew();
    bcDestructorAliases = mapNew();
    bcDestructorAliasNames = vecNew();
    let i = 0;
    let len = body.vecLength();
    while (i < len) {
        let stmt = body.vecGet(i);
        let kind = nodeKind(stmt);
        if (kind == NK_EXTERN_TYPE_DECL) {
            externTypeNames.setAdd(getInternedStr(nodeGetData1(stmt)));
        }
        if (kind == NK_FN_DECL) {
            let fname = getInternedStr(nodeGetData1(stmt));
            globalFnNames.setAdd(fname);
            fnReturnTypes.mapSet(fname, bcTypeNameFromTypeNode(nodeGetData4(stmt)));
        }
        if (kind == NK_LET_DECL || kind == NK_EXTERN_LET_DECL) {
            globalTypeByName.mapSet(getInternedStr(nodeGetData1(stmt)),
            bcTypeNameFromTypeNode(nodeGetData2(stmt)));
        }
        if (kind == NK_ENUM_DECL) {
            bcCopyTypes.setAdd(getInternedStr(nodeGetData1(stmt)));
        }
        if (kind == NK_STRUCT_DECL && nodeGetData4(stmt) == 1) {
            bcCopyTypes.setAdd(getInternedStr(nodeGetData1(stmt)));
        }
        if (kind == NK_TYPE_ALIAS && nodeGetData4(stmt) == 1) {
            let aliasName = getInternedStr(nodeGetData1(stmt));
            bcCopyAliasNames.vecPush(aliasName);
            bcCopyAliasTypes.mapSet(aliasName, nodeGetData3(stmt));
        }
        if (kind == NK_TYPE_ALIAS && nodeGetData5(stmt) != 0) {
            let aliasName = getInternedStr(nodeGetData1(stmt));
            let destructorName = getInternedStr(nodeGetData5(stmt));
            bcDestructorAliases.mapSet(aliasName, destructorName);
            bcDestructorAliasNames.vecPush(aliasName);
        }
        if (kind == NK_EXTERN_TYPE_DECL && nodeGetData5(stmt) != 0) {
            let aliasName = getInternedStr(nodeGetData1(stmt));
            let destructorName = getInternedStr(nodeGetData5(stmt));
            bcDestructorAliases.mapSet(aliasName, destructorName);
            bcDestructorAliasNames.vecPush(aliasName);
        }
        i = i + 1;
    }
     // Validate destructor declarations/signatures.
    i = 0;
    let dlen = bcDestructorAliasNames.vecLength();
    while (i < dlen) {
        let aliasName = bcDestructorAliasNames.vecGet(i);
        let destructorName = bcDestructorAliases.mapGet(aliasName);
        let found = false;
        let j = 0;
        while (j < len) {
            let stmt = body.vecGet(j);
            let sk = nodeKind(stmt);
            if ((sk == NK_FN_DECL) &&
            getInternedStr(nodeGetData1(stmt)).strEq(destructorName)) {
                found = true;
                let valid = true;
                let params = nodeGetData3(stmt);
                if (params.vecLength() != 1) {
                    valid = false;
                }
                else {
                    let p0 = params.vecGet(0);
                    let pname = getInternedStr(p0.vecGet(0));
                    let ptype = p0.vecGet(1);
                    if (!pname.strEq("this")) {
                        valid = false;
                    }
                    if (!bcTypeNodeIsDestructorReceiver(ptype, aliasName)) {
                        valid = false;
                    }
                }
                if (!bcTypeNameFromTypeNode(nodeGetData4(stmt)).strEq("Void")) {
                    valid = false;
                }
                if (!valid) {
                    panicWithCode( "E_TYPE_DESTRUCTOR_SIGNATURE", "Destructor '".strConcat(destructorName).strConcat("' must have signature fn ").strConcat(destructorName).strConcat("(this : ").strConcat(aliasName).strConcat("<...>) : Void"),
                    "Destructor signatures must use the alias receiver type (or legacy '*move Alias') and return Void.", "Use exactly one receiver parameter named 'this' with alias type and return Void." );
                }
                break;
            }
            j = j + 1;
        }
        if (!found) {
            panicWithCode( "E_TYPE_DESTRUCTOR_NOT_FOUND", "Destructor '".strConcat(destructorName).strConcat("' for alias '").strConcat(aliasName).strConcat("' was not found"),
            "A type declaration referenced a destructor function that does not exist.", "Declare the destructor function before using it in 'type Alias = ... then destructor' or 'extern type Alias then destructor'." );
        }
        i = i + 1;
    }
    i = 0;
    let copyAliasCount = bcCopyAliasNames.vecLength();
    while (i < copyAliasCount) {
        let aliasName = bcCopyAliasNames.vecGet(i);
        let aliasType = bcCopyAliasTypes.mapGet(aliasName);
        let visiting = setNew();
        visiting.setAdd(aliasName);
        if (!bcTypeNodeIsCopyable(aliasType, externTypeNames, visiting)) {
            panicWithCode( "E_BORROW_INVALID_COPY_ALIAS", "copy type ".strConcat(aliasName).strConcat(" must alias a copy-compatible type"), "A type alias marked 'copy' resolved to a non-copy type under move semantics.",
            "Only mark aliases as 'copy' when the aliased type is copy-compatible (primitives, pointers, enums, copy structs, or other copy aliases)." );
        }
        bcCopyTypes.setAdd(aliasName);
        i = i + 1;
    }
    let state = stateNew();
    let env = globalTypeByName;
    bcGlobalValueTypes = globalTypeByName;
    i = 0;
    while (i < len) {
        checkStmt(body.vecGet(i), state, env, fnReturnTypes, externTypeNames,
        globalFnNames);
        i = i + 1;
    }
    program
}
out fn selfhostBorrowcheckImplMarker() : I32 => 0;
