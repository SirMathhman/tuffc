fn ensureTrailingNewline(text: *Str) : *Str => {
    if (text.strLength() = = 0) {
        return "\n";
    }
    if (text.strCharAt(text.strLength() - 1) = = 10) {
        return text;
    }
    text.strConcat("\n")
}
 // NOTE:
 // - `typed` is intentionally part of the signature to pin this as an AST printer API.
 // - `trivia_payload` is accepted for forward-compatible stable trivia anchoring.
 // - Phase 3 implementation keeps byte-level trivia intact by preserving source text
 //   and only normalizing trailing newline policy.
out fn emitTuffFromTypedImpl(typed: I32, source: *Str, triviaPayload: *Str) : *Str => {
    let _typed_guard = typed;
    let _trivia_guard = triviaPayload.strLength();
    let _source_guard = source.strLength();
    ensureTrailingNewline(source)
}
out fn selfhostTuffPrinterImplMarker() : I32 => 0;
