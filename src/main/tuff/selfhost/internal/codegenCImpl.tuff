 // ============================================================================
 // C Code Generation — selfhost port of codegen-c.ts
 // ============================================================================
 // ALL Tuff values are int64_t in C. Strings are int64_t handles via tuff_str().
 // The C substrate (substrate.h/c, strings.c, etc.) is always embedded inline.
 // ============================================================================
let {
    Ok, Err, Result
}
 = selfhost::Result;
let {
    CodegenError
}
 = selfhost::errors::CodegenError;
let {
    getInternedStr, vecNew, mapNew, setNew, intToString
}
 = selfhost::runtimeLexer;
let {
    nodeKind, nodeGetData1, nodeGetData2, nodeGetData3, nodeGetData4, nodeGetData5
}
 = selfhost::parserCore;
 // ============================================================================
 // Global mutable state — reset at the start of each generate_c call
 // ============================================================================
let ccTempCounter : I32 = 0;
let ccEnumNames : *mut Set<I32> = setNew();
let ccEnumVariantConsts : Map<I32, I32> = mapNew();
 // variant → "EnumName_Variant"
let ccStructFields : Map<I32, I32> = mapNew();
 // struct name → Vec<*Str> of field names
let ccAliasByVariant : Map<I32, I32> = mapNew();
 // variant struct name → union alias name
let ccUnionAliasInfo : Map<I32, I32> = mapNew();
 // alias name → Vec<*Str> of variant names
let ccCoveredExternFns : *mut Set<I32> = setNew();
let ccLocalTypes : Map<I32, I32> = mapNew();
 // local var name → C type string (e.g. "TuffVec*")
let ccFnReturnTypes : Map<I32, I32> = mapNew();
 // function name → C return type string
let ccEmittedTuffError : I32 = 0;
let ccIncStdint : I32 = 1;
let ccIncStddef : I32 = 0;
let ccIncStdio : I32 = 0;
let ccIncStdlib : I32 = 0;
let ccIncString : I32 = 0;
let ccIncCtype : I32 = 0;
let ccIncErrno : I32 = 0;
let ccIncDirect : I32 = 0;
let ccIncSysStat : I32 = 0;
let ccIncSysTypes : I32 = 0;
let ccDisableUnicodeEscape : I32 = 0;
 // ============================================================================
 // Helpers
 // ============================================================================
fn ccNextTemp(prefix: *Str) : *Str => {
    ccTempCounter = ccTempCounter + 1;
    "__".strConcat(prefix).strConcat("_").strConcat(intToString(ccTempCounter))
}
fn ccToName(name: *Str) : *Str => {
    if (name.strEq("main")) {
        "tuff_main"
    }
    else {
        name
    }
}
fn ccStrEndsWith(s: *Str, suffix: *Str) : Bool => {
    let sn = s.strLength();
    let tn = suffix.strLength();
    if (sn < tn) {
        return false;
    }
    if (sn = = tn) {
        return s.strSlice(0, sn).strEq(suffix);
    }
    false
}
fn ccJoinParts(parts: Vec<I32>) : *Str => {
    let sb = sbNew();
    let i = 0;
    let len = parts.vecLength();
    while (i < len) {
        if (i > 0) {
            sbAppend(sb, "::");
        }
        sbAppend(sb, getInternedStr(parts.vecGet(i)));
        i = i + 1;
    }
    sbBuild(sb)
}
fn ccMarkHeaderFromSource(source: *Str) : I32 => {
    if (source.strEq("stdio")) {
        ccIncStdio = 1;
        return 0;
    }
    if (source.strEq("stdlib")) {
        ccIncStdlib = 1;
        return 0;
    }
    if (source.strEq("string") || source.strEq("strings")) {
        ccIncString = 1;
        return 0;
    }
    if (source.strEq("stdint")) {
        ccIncStdint = 1;
        return 0;
    }
    if (source.strEq("stddef")) {
        ccIncStddef = 1;
        return 0;
    }
    if (source.strEq("errno")) {
        ccIncErrno = 1;
        return 0;
    }
    if (source.strEq("direct")) {
        ccIncDirect = 1;
        return 0;
    }
    if (source.strEq("sys::stat")) {
        ccIncSysStat = 1;
        return 0;
    }
    if (source.strEq("sys::types")) {
        ccIncSysTypes = 1;
        return 0;
    }
     // Known non-header attribution buckets used for host/substrate symbols.
    if (source.strEq("globalThis") || source.strEq("substrate") || source.strEq("host_c")) {
        return 0;
    }
     // Runtime module buckets — mark required headers, no special flags needed.
    if (source.strEq("collections")) {
        ccIncStdlib = 1;
        return 0;
    }
    if (source.strEq("io")) {
        ccIncStdio = 1;
        ccIncStdlib = 1;
        ccIncString = 1;
        return 0;
    }
    panicWithCode( "E_EXTERN_UNKNOWN_SOURCE",
    "Unknown extern source attribution: '".strConcat(source).strConcat("'"), "The C backend only supports a built-in set of extern source aliases for header mapping.", "Use a supported source alias (stdio, stdlib, string/strings, stdint, stddef, errno, direct, sys::stat, sys::types) or one of the runtime buckets (globalThis, substrate, host_c)." )
}
fn ccRequireSubstrateHeaders() : I32 => {
     // Embedded substrate code depends on this baseline C runtime header set.
    ccIncStddef = 1;
    ccIncStdio = 1;
    ccIncStdlib = 1;
    ccIncString = 1;
    ccIncCtype = 1;
    ccIncErrno = 1;
    ccIncDirect = 1;
    ccIncSysStat = 1;
    ccIncSysTypes = 1;
    0
}
fn ccEmitMinimalRuntimePrelude() : *Str => {
    let sb = sbNew();
    sbAppend(sb, "/* Built-in minimal runtime prelude (substrate-free path) */\n");
    sbAppend(sb, "static inline int64_t tuff_to_val(const void* p) { return (int64_t)(intptr_t)p; }\n");
    sbAppend(sb, "static inline void* tuff_from_val(int64_t v) { return (void*)(intptr_t)v; }\n");
    sbAppend(sb, "static inline const char* tuff_str(int64_t v) { return v == 0 ? NULL : (const char*)(intptr_t)v; }\n");
    sbAppend(sb, "static inline const char* tuff_str_or_empty(int64_t v) { const char* s = tuff_str(v); return s ? s : \"\"; }\n");
    sbAppend(sb, "typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\n");
    sbAppend(sb, "static void tuff_panic(const char* msg) { fprintf(stderr, \"[tuff panic] %s\\n\", msg); abort(); }\n");
    sbAppend(sb, "\n/* String runtime function declarations and minimal implementations */\n");
    sbAppend(sb, "int64_t str_length(int64_t this) { return (int64_t)strlen(tuff_str_or_empty(this)); }\n");
    sbAppend(sb, "int64_t str_char_at(int64_t this, int64_t index) { const char* s = tuff_str(this); if (!s || index < 0 || index >= (int64_t)strlen(s)) return 0; return (int64_t)s[index]; }\n");
    sbAppend(sb, "int64_t str_slice(int64_t this, int64_t start, int64_t end) { const char* s = tuff_str(this); if (!s || start < 0 || end < start) return 0; size_t len = strlen(s); if ((size_t)end > len) end = (int64_t)len; size_t n = (size_t)(end - start); char* out = (char*)malloc(n + 1); if (!out) return 0; strncpy(out, s + start, n); out[n] = '\\0'; return (int64_t)(intptr_t)out; }\n");
    sbAppend(sb, "int64_t str_concat(int64_t a, int64_t b) { const char* as = tuff_str_or_empty(a); const char* bs = tuff_str_or_empty(b); size_t alen = strlen(as); size_t blen = strlen(bs); char* out = (char*)malloc(alen + blen + 1); if (!out) return 0; strcpy(out, as); strcat(out, bs); return (int64_t)(intptr_t)out; }\n");
    sbAppend(sb, "int64_t str_eq(int64_t a, int64_t b) { const char* as = tuff_str_or_empty(a); const char* bs = tuff_str_or_empty(b); return strcmp(as, bs) == 0 ? 1 : 0; }\n");
    sbAppend(sb, "int64_t str_from_char_code(int64_t code) { char* out = (char*)malloc(2); if (!out) return 0; out[0] = (char)(code & 0xFF); out[1] = '\\0'; return (int64_t)(intptr_t)out; }\n");
    sbAppend(sb, "int64_t str_index_of(int64_t s, int64_t needle) { const char* str = tuff_str(s); const char* ndl = tuff_str(needle); if (!str || !ndl) return -1; const char* found = strstr(str, ndl); if (!found) return -1; return (int64_t)(found - str); }\n");
    sbAppend(sb, "int64_t str_trim(int64_t s) { const char* str = tuff_str_or_empty(s); while (isspace(*str)) str++; const char* end = str + strlen(str); while (end > str && isspace(*(end - 1))) end--; size_t len = end - str; if (len == 0) return (int64_t)(intptr_t)\"\"; char* out = (char*)malloc(len + 1); if (!out) return 0; strncpy(out, str, len); out[len] = '\\0'; return (int64_t)(intptr_t)out; }\n");
    sbAppend(sb, "int64_t str_replace_all(int64_t s, int64_t from, int64_t to) { const char* str = tuff_str_or_empty(s); const char* f = tuff_str_or_empty(from); const char* t = tuff_str_or_empty(to); if (strlen(f) == 0) return s; size_t buf_size = strlen(str) * 2 + 1; char* out = (char*)malloc(buf_size); if (!out) return 0; char* p = out; const char* q = str; while ((q = strstr(q, f)) != NULL) { strncat(p, str, q - str); strncat(p, t, strlen(t)); str = q + strlen(f); q = str; } strcat(p, str); return (int64_t)(intptr_t)out; }\n");
    sbAppend(sb, "int64_t char_code(int64_t ch) { const char* s = tuff_str(ch); return s && *s ? (int64_t)*s : 0; }\n");
    sbAppend(sb, "int64_t int_to_string(int64_t n) { char* out = (char*)malloc(32); if (!out) return 0; snprintf(out, 32, \"%lld\", (long long)n); return (int64_t)(intptr_t)out; }\n");
    sbAppend(sb, "int64_t parse_int(int64_t s) { const char* str = tuff_str_or_empty(s); return (int64_t)atoll(str); }\n");
    sbBuild(sb)
}
 // All Tuff types lower to int64_t, except:
 //   *[T; init; cap]  → TuffVec* (fat slice pointer)
 //   Alloc<T>         → transparent; recurse into T
 //   Void             → void
fn ccTypeToC(typeNode: I32) : *Str => {
    if (typeNode = = 0) {
        return "int64_t";
    }
    let kind = nodeKind(typeNode);
    if (kind = = NK_POINTER_TYPE) {
        let inner = nodeGetData2(typeNode);
        if (inner != 0 && nodeKind(inner) = = NK_ARRAY_TYPE) {
            return "TuffVec*";
        }
        return "int64_t";
    }
    if (kind = = NK_NAMED_TYPE) {
        let name = getInternedStr(nodeGetData1(typeNode));
        if (name.strEq("Void")) {
            return "void";
        }
         // Alloc<T> is a transparent ownership wrapper — lower to T
        if (name.strEq("Alloc")) {
            let generics = nodeGetData2(typeNode);
            if (generics != 0 && generics.vecLength() > 0) {
                return ccTypeToC(generics.vecGet(0));
            }
            return "int64_t";
        }
        if (ccUnionAliasInfo.mapHas(name)) {
            return name;
        }
        if (ccStructFields.mapHas(name)) {
            return name;
        }
        if (ccAliasByVariant.mapHas(name)) {
            return ccAliasByVariant.mapGet(name);
        }
        return "int64_t";
    }
     // NK_REFINEMENT_TYPE (44): erase refinement, lower base type.
    if (kind = = 44) {
        return ccTypeToC(nodeGetData1(typeNode));
    }
     // NK_APPLIED_TYPE (71): value-level type application.
     // Erase value args but preserve nominal base when it is a known concrete type.
    if (kind = = 71) {
        let base = getInternedStr(nodeGetData1(typeNode));
        if (ccUnionAliasInfo.mapHas(base)) {
            return base;
        }
        if (ccStructFields.mapHas(base)) {
            return base;
        }
        if (ccAliasByVariant.mapHas(base)) {
            return ccAliasByVariant.mapGet(base);
        }
        return "int64_t";
    }
    "int64_t"
}
fn ccInferExprCtype(n: I32) : *Str => {
    if (n = = 0) {
        return "int64_t";
    }
    let kind = nodeKind(n);
    if (kind = = NK_STRUCT_INIT) {
        let vname = getInternedStr(nodeGetData1(n));
        if (ccAliasByVariant.mapHas(vname)) {
            return ccAliasByVariant.mapGet(vname);
        }
        return vname;
    }
     // malloc / realloc calls produce TuffVec* fat slice pointers
    if (kind = = NK_CALL_EXPR) {
        let callee = nodeGetData1(n);
        if (nodeKind(callee) = = NK_IDENTIFIER) {
            let cname = getInternedStr(nodeGetData1(callee));
            if (cname.strEq("malloc") || cname.strEq("realloc")) {
                return "TuffVec*";
            }
            if (ccFnReturnTypes.mapHas(cname)) {
                return ccFnReturnTypes.mapGet(cname);
            }
        }
    }
    "int64_t"
}
fn ccIsStdlibBuiltin(name: *Str) : Bool => {
    name.strEq("malloc") || name.strEq("free") || name.strEq("realloc") || name.strEq("calloc") || name.strEq("memcpy") || name.strEq("memmove") || name.strEq("memset") || name.strEq("printf") || name.strEq("fprintf") ||
    name.strEq("fopen") || name.strEq("fclose") || name.strEq("fwrite") || name.strEq("fread") || name.strEq("fseek") || name.strEq("ftell") || name.strEq("strlen") || name.strEq("strdup") || name.strEq("strcpy") || name.strEq("strcat") || name.strEq("strncpy") || name.strEq("strncat") ||
    name.strEq("strcmp") || name.strEq("strstr") || name.strEq("strrchr") || name.strEq("exit") || name.strEq("abort")
}
 // ============================================================================
 // Context Pre-scan
 // ============================================================================
fn ccFlattenUnionVariants(typeNode: I32, namesVec: Vec<I32>) : I32 => {
    if (typeNode = = 0) {
        return 0;
    }
    let kind = nodeKind(typeNode);
    if (kind = = NK_NAMED_TYPE) {
        namesVec.vecPush(getInternedStr(nodeGetData1(typeNode)));
        return 0;
    }
    if (kind = = NK_UNION_TYPE) {
        ccFlattenUnionVariants(nodeGetData1(typeNode), namesVec);
        ccFlattenUnionVariants(nodeGetData2(typeNode), namesVec);
        return 0;
    }
    0
}
fn ccInitContext(program: I32) : I32 => {
    let stmts = nodeGetData1(program);
    let len = stmts.vecLength();
    let i = 0;
    while (i < len) {
        let n = stmts.vecGet(i);
        let kind = nodeKind(n);
        if (kind = = NK_ENUM_DECL) {
            let enumName = getInternedStr(nodeGetData1(n));
            ccEnumNames.setAdd(enumName);
            let variants = nodeGetData2(n);
            let j = 0;
            let vlen = variants.vecLength();
            while (j < vlen) {
                let v = getInternedStr(variants.vecGet(j));
                ccEnumVariantConsts.mapSet(v, enumName.strConcat("_").strConcat(v));
                j = j + 1;
            }
        }
        if (kind = = NK_STRUCT_DECL) {
            let structName = getInternedStr(nodeGetData1(n));
            let fields = nodeGetData3(n);
            let fieldNames = vecNew();
            let j = 0;
            let flen = fields.vecLength();
            while (j < flen) {
                let f = fields.vecGet(j);
                fieldNames.vecPush(getInternedStr(f.vecGet(0)));
                j = j + 1;
            }
            ccStructFields.mapSet(structName, fieldNames);
        }
        if (kind = = NK_TYPE_ALIAS) {
            let aliasName = getInternedStr(nodeGetData1(n));
            let aliased = nodeGetData3(n);
            if (aliased != 0 && nodeKind(aliased) = = NK_UNION_TYPE) {
                let variants = vecNew();
                ccFlattenUnionVariants(aliased, variants);
                let j = 0;
                let vlen = variants.vecLength();
                while (j < vlen) {
                    let v = variants.vecGet(j);
                    ccAliasByVariant.mapSet(v, aliasName);
                    j = j + 1;
                }
                ccUnionAliasInfo.mapSet(aliasName, variants);
            }
        }
        if (kind = = NK_EXTERN_IMPORT_DECL) {
            let names = nodeGetData1(n);
            let j = 0;
            let nlen = names.vecLength();
            while (j < nlen) {
                ccCoveredExternFns.setAdd(getInternedStr(names.vecGet(j)));
                j = j + 1;
            }
            ccMarkHeaderFromSource(ccJoinParts(nodeGetData2(n)));
        }
        i = i + 1;
    }
    i = 0;
    while (i < len) {
        let n = stmts.vecGet(i);
        let kind = nodeKind(n);
        if (kind = = NK_FN_DECL || kind = = NK_CLASS_FN_DECL || kind = = NK_ACTUAL_FN_DECL) {
            let sourceName = getInternedStr(nodeGetData1(n));
            let cName = ccToName(sourceName);
            let retCtype = ccTypeToC(nodeGetData4(n));
            ccFnReturnTypes.mapSet(sourceName, retCtype);
            ccFnReturnTypes.mapSet(cName, retCtype);
        }
        i = i + 1;
    }
    0
}
 // ============================================================================
 // C Pattern Guards (for match expressions)
 // ============================================================================
fn ccEmitPatternGuard(target: *Str, pat: I32) : *Str => {
    let kind = nodeKind(pat);
    if (kind = = NK_WILDCARD_PAT) {
        return "1";
    }
    if (kind = = NK_LITERAL_PAT) {
        let val = getInternedStr(nodeGetData1(pat));
        return "(".strConcat(target).strConcat(" == ").strConcat(val).strConcat(")");
    }
    if (kind = = NK_NAME_PAT) {
        let name = getInternedStr(nodeGetData1(pat));
        if (ccEnumVariantConsts.mapHas(name)) {
            return "(".strConcat(target).strConcat(" == ").strConcat(ccEnumVariantConsts.mapGet(name)).strConcat(")");
        }
        if (ccAliasByVariant.mapHas(name)) {
            let alias = ccAliasByVariant.mapGet(name);
            return "(".strConcat(target).strConcat(".__tag == ").strConcat(alias).strConcat("_").strConcat(name).strConcat(")");
        }
        return "1";
    }
    if (kind = = NK_STRUCT_PAT) {
        let name = getInternedStr(nodeGetData1(pat));
        if (ccAliasByVariant.mapHas(name)) {
            let alias = ccAliasByVariant.mapGet(name);
            return "(".strConcat(target).strConcat(".__tag == ").strConcat(alias).strConcat("_").strConcat(name).strConcat(")");
        }
        return "1";
    }
    "1"
}
 // ============================================================================
 // Block → GNU statement expression (assign last expr to tmp var)
 // ============================================================================
fn ccEmitBlockToAssign(blockNode: I32, tmpVar: *Str) : *Str => {
    let stmts = nodeGetData1(blockNode);
    let len = stmts.vecLength();
    if (len = = 0) {
        return tmpVar.strConcat(" = 0;");
    }
    let sb = sbNew();
    let i = 0;
    while (i < len) {
        let stmt = stmts.vecGet(i);
        let isLast = i = = len - 1;
        let skind = nodeKind(stmt);
        if (isLast && skind = = NK_EXPR_STMT) {
            sbAppend(sb, tmpVar);
            sbAppend(sb, " = ");
            sbAppend(sb, ccEmitExpr(nodeGetData1(stmt)));
            sbAppend(sb, ";");
        }
        else if (isLast && (skind = = NK_IF_STMT || skind = = NK_IF_EXPR)) {
            sbAppend(sb, tmpVar);
            sbAppend(sb, " = ");
            sbAppend(sb, ccEmitIfAsCExpr(stmt));
            sbAppend(sb, ";");
        }
        else if (isLast && skind = = NK_RETURN_STMT) {
            let val = nodeGetData1(stmt);
            let valCode = "0";
            if (val != 0) {
                valCode = ccEmitExpr(val);
            }
            sbAppend(sb, tmpVar);
            sbAppend(sb, " = ");
            sbAppend(sb, valCode);
            sbAppend(sb, ";");
        }
        else {
            sbAppend(sb, ccEmitStmt(stmt));
            sbAppend(sb, " ");
        }
        i = i + 1;
    }
    sbBuild(sb)
}
fn ccEmitBlockAsExpr(blockNode: I32) : *Str => {
    let tmp = ccNextTemp("blk");
    let inner = ccEmitBlockToAssign(blockNode, tmp);
    "({ int64_t ".strConcat(tmp).strConcat(" = 0; ").strConcat(inner).strConcat(" ").strConcat(tmp).strConcat("; })")
}
fn ccEmitIfAsCExpr(n: I32) : *Str => {
    let cond = ccEmitExpr(nodeGetData1(n));
    let thenB = nodeGetData2(n);
    let elseB = nodeGetData3(n);
    let tmp = ccNextTemp("ifexpr");
    let thenBody = "";
    if (nodeKind(thenB) = = NK_BLOCK) {
        thenBody = ccEmitBlockToAssign(thenB, tmp);
    }
    else if (nodeKind(thenB) = = NK_IF_STMT || nodeKind(thenB) = = NK_IF_EXPR) {
        thenBody = tmp.strConcat(" = ").strConcat(ccEmitIfAsCExpr(thenB)).strConcat(";");
    }
    else {
        thenBody = tmp.strConcat(" = ").strConcat(ccEmitExpr(thenB)).strConcat(";");
    }
    let elseBody = "";
    if (elseB = = 0) {
        elseBody = tmp.strConcat(" = 0;");
    }
    else if (nodeKind(elseB) = = NK_BLOCK) {
        elseBody = ccEmitBlockToAssign(elseB, tmp);
    }
    else if (nodeKind(elseB) = = NK_IF_STMT || nodeKind(elseB) = = NK_IF_EXPR) {
        elseBody = tmp.strConcat(" = ").strConcat(ccEmitIfAsCExpr(elseB)).strConcat(";");
    }
    else {
        elseBody = tmp.strConcat(" = ").strConcat(ccEmitExpr(elseB)).strConcat(";");
    }
    "({ int64_t ".strConcat(tmp).strConcat(" = 0; if (").strConcat(cond).strConcat(") { ").strConcat(thenBody).strConcat(" } else { ").strConcat(elseBody).strConcat(" } ").strConcat(tmp).strConcat("; })")
}
 // ============================================================================
 // Expression Emitter
 // ============================================================================
 // Translate \uXXXX escape sequences for Unicode control characters (U+0000–U+001F)
 // to C octal byte escapes.  C does not allow \uXXXX in string literals and
 // outright rejects control codepoints as universal character names.
 // We enumerate all 32 control-character patterns to avoid index-arithmetic
 // type issues while staying fully general for the selfhost string corpus.
fn ccEscapeUnicodeInString(raw: *Str) : *Str => {
    raw .strReplaceAll("\\u0000", "\\000") .strReplaceAll("\\u0001", "\\001")
    .strReplaceAll("\\u0002", "\\002") .strReplaceAll("\\u0003", "\\003") .strReplaceAll("\\u0004", "\\004") .strReplaceAll("\\u0005", "\\005")
    .strReplaceAll("\\u0006", "\\006") .strReplaceAll("\\u0007", "\\007") .strReplaceAll("\\u0008", "\\010") .strReplaceAll("\\u0009", "\\011")
    .strReplaceAll("\\u000a", "\\012").strReplaceAll("\\u000A", "\\012") .strReplaceAll("\\u000b", "\\013").strReplaceAll("\\u000B", "\\013") .strReplaceAll("\\u000c", "\\014").strReplaceAll("\\u000C", "\\014") .strReplaceAll("\\u000d", "\\015").strReplaceAll("\\u000D", "\\015")
    .strReplaceAll("\\u000e", "\\016").strReplaceAll("\\u000E", "\\016") .strReplaceAll("\\u000f", "\\017").strReplaceAll("\\u000F", "\\017") .strReplaceAll("\\u0010", "\\020") .strReplaceAll("\\u0011", "\\021")
    .strReplaceAll("\\u0012", "\\022") .strReplaceAll("\\u0013", "\\023") .strReplaceAll("\\u0014", "\\024") .strReplaceAll("\\u0015", "\\025")
    .strReplaceAll("\\u0016", "\\026") .strReplaceAll("\\u0017", "\\027") .strReplaceAll("\\u0018", "\\030") .strReplaceAll("\\u0019", "\\031")
    .strReplaceAll("\\u001a", "\\032").strReplaceAll("\\u001A", "\\032") .strReplaceAll("\\u001b", "\\033").strReplaceAll("\\u001B", "\\033") .strReplaceAll("\\u001c", "\\034").strReplaceAll("\\u001C", "\\034") .strReplaceAll("\\u001d", "\\035").strReplaceAll("\\u001D", "\\035")
    .strReplaceAll("\\u001e", "\\036").strReplaceAll("\\u001E", "\\036") .strReplaceAll("\\u001f", "\\037").strReplaceAll("\\u001F", "\\037")
}
fn ccEmitExpr(n: I32) : *Str => {
    let kind = nodeKind(n);
    if (kind = = NK_NUMBER_LIT) {
        return getInternedStr(nodeGetData1(n));
    }
    if (kind = = NK_BOOL_LIT) {
        if (nodeGetData1(n) = = 1) {
            return "1";
        }
        return "0";
    }
    if (kind = = NK_STRING_LIT) {
        let s = getInternedStr(nodeGetData1(n));
        let sC = s;
        if (ccDisableUnicodeEscape != 1) {
            sC = ccEscapeUnicodeInString(s);
        }
        return "((int64_t)(intptr_t)\"".strConcat(sC).strConcat("\")");
    }
    if (kind = = NK_CHAR_LIT) {
        let s = getInternedStr(nodeGetData1(n));
        if (s.strLength() = = 1) {
            return intToString(charCode(s));
        }
        if (s.strEq("\\n")) {
            return "10";
        }
        if (s.strEq("\\r")) {
            return "13";
        }
        if (s.strEq("\\t")) {
            return "9";
        }
        if (s.strEq("\\0")) {
            return "0";
        }
        return "0";
    }
    if (kind = = NK_IDENTIFIER) {
        let name = getInternedStr(nodeGetData1(n));
        if (ccEnumVariantConsts.mapHas(name)) {
            return ccEnumVariantConsts.mapGet(name);
        }
        return ccToName(name);
    }
    if (kind = = NK_UNARY_EXPR) {
        let op = getInternedStr(nodeGetData1(n));
        if (op.strEq("&") || op.strEq("&mut")) {
            return ccEmitExpr(nodeGetData2(n));
        }
        return "(".strConcat(op).strConcat(ccEmitExpr(nodeGetData2(n))).strConcat(")");
    }
    if (kind = = NK_BINARY_EXPR) {
        let op = getInternedStr(nodeGetData1(n));
        let left = ccEmitExpr(nodeGetData2(n));
        let right = ccEmitExpr(nodeGetData3(n));
        return "(".strConcat(left).strConcat(" ").strConcat(op).strConcat(" ").strConcat(right).strConcat(")");
    }
    if (kind = = NK_CALL_EXPR) {
        let calleeNode = nodeGetData1(n);
         // Special-case built-in transformations
        if (nodeKind(calleeNode) = = NK_IDENTIFIER) {
            let calleeName = getInternedStr(nodeGetData1(calleeNode));
             // drop(x) → 0
            if (calleeName.strEq("drop")) {
                return "0";
            }
             // sizeOf<T>() → (int64_t)sizeof(T)
            if (calleeName.strEq("sizeOf")) {
                let typeArgs = nodeGetData4(n);
                if (typeArgs.vecLength() > 0) {
                    let ctype = ccTypeToC(typeArgs.vecGet(0));
                    return "(int64_t)sizeof(".strConcat(ctype).strConcat(")");
                }
                return "0";
            }
             // malloc(bytes) → allocate TuffVec fat slice
            if (calleeName.strEq("malloc")) {
                let args = nodeGetData2(n);
                if (args.vecLength() >= 1) {
                    let bytesStr = ccEmitExpr(args.vecGet(0));
                    let nbytes = ccNextTemp("malloc_nbytes");
                    let vec = ccNextTemp("malloc_vec");
                    let sb = sbNew();
                    sbAppend(sb, "({ size_t ");
                    sbAppend(sb, nbytes);
                    sbAppend(sb, " = (size_t)(");
                    sbAppend(sb, bytesStr);
                    sbAppend(sb, "); TuffVec* ");
                    sbAppend(sb, vec);
                    sbAppend(sb, " = (TuffVec*)malloc(sizeof(TuffVec)); if (");
                    sbAppend(sb, vec);
                    sbAppend(sb, ") { ");
                    sbAppend(sb, vec);
                    sbAppend(sb, "->data = (int64_t*)malloc(");
                    sbAppend(sb, nbytes);
                    sbAppend(sb, "); ");
                    sbAppend(sb, vec);
                    sbAppend(sb, "->init = 0; ");
                    sbAppend(sb, vec);
                    sbAppend(sb, "->length = ");
                    sbAppend(sb, nbytes);
                    sbAppend(sb, " / sizeof(int64_t); if (!");
                    sbAppend(sb, vec);
                    sbAppend(sb, "->data) { free(");
                    sbAppend(sb, vec);
                    sbAppend(sb, "); ");
                    sbAppend(sb, vec);
                    sbAppend(sb, " = NULL; } } ");
                    sbAppend(sb, vec);
                    sbAppend(sb, "; })");
                    return sbBuild(sb);
                }
                return "0";
            }
             // realloc(ptr, bytes) → grow TuffVec data in-place
            if (calleeName.strEq("realloc")) {
                let args = nodeGetData2(n);
                if (args.vecLength() >= 2) {
                    let ptrStr = ccEmitExpr(args.vecGet(0));
                    let bytesStr = ccEmitExpr(args.vecGet(1));
                    let nbytes = ccNextTemp("realloc_nbytes");
                    let vec = ccNextTemp("realloc_vec");
                    let data = ccNextTemp("realloc_data");
                    let sb = sbNew();
                    sbAppend(sb, "({ size_t ");
                    sbAppend(sb, nbytes);
                    sbAppend(sb, " = (size_t)(");
                    sbAppend(sb, bytesStr);
                    sbAppend(sb, "); TuffVec* ");
                    sbAppend(sb, vec);
                    sbAppend(sb, " = (TuffVec*)(");
                    sbAppend(sb, ptrStr);
                    sbAppend(sb, "); if (");
                    sbAppend(sb, vec);
                    sbAppend(sb, ") { int64_t* ");
                    sbAppend(sb, data);
                    sbAppend(sb, " = (int64_t*)realloc(");
                    sbAppend(sb, vec);
                    sbAppend(sb, "->data, ");
                    sbAppend(sb, nbytes);
                    sbAppend(sb, "); if (");
                    sbAppend(sb, data);
                    sbAppend(sb, ") { ");
                    sbAppend(sb, vec);
                    sbAppend(sb, "->data = ");
                    sbAppend(sb, data);
                    sbAppend(sb, "; ");
                    sbAppend(sb, vec);
                    sbAppend(sb, "->length = ");
                    sbAppend(sb, nbytes);
                    sbAppend(sb, " / sizeof(int64_t); } else { ");
                    sbAppend(sb, vec);
                    sbAppend(sb, " = NULL; } } ");
                    sbAppend(sb, vec);
                    sbAppend(sb, "; })");
                    return sbBuild(sb);
                }
                return "0";
            }
             // free(ptr) → free TuffVec data then struct
            if (calleeName.strEq("free")) {
                let args = nodeGetData2(n);
                if (args.vecLength() >= 1) {
                    let ptrStr = ccEmitExpr(args.vecGet(0));
                    let vec = ccNextTemp("free_vec");
                    return "({ TuffVec* ".strConcat(vec).strConcat(" = (TuffVec*)(").strConcat(ptrStr).strConcat("); if (").strConcat(vec).strConcat(") { free(").strConcat(vec).strConcat("->data); free(").strConcat(vec).strConcat("); } 0; })");
                }
                return "0";
            }
        }
         // General call
        let callee = ccEmitExpr(calleeNode);
        let args = nodeGetData2(n);
        let argStrs = vecNew();
        let i = 0;
        let alen = args.vecLength();
        while (i < alen) {
            argStrs.vecPush(ccEmitExpr(args.vecGet(i)));
            i = i + 1;
        }
        let argsStr = argStrs.vecJoin(", ");
        return callee.strConcat("(").strConcat(argsStr).strConcat(")");
    }
    if (kind = = NK_MEMBER_EXPR) {
        let objNode = nodeGetData1(n);
        let prop = getInternedStr(nodeGetData2(n));
         // Enum access: EnumName.Variant → EnumName_Variant
        if (nodeKind(objNode) = = NK_IDENTIFIER) {
            let objName = getInternedStr(nodeGetData1(objNode));
            if (ccEnumNames.setHas(objName)) {
                return objName.strConcat("_").strConcat(prop);
            }
             // TuffVec* locals use -> for field access
            if (ccLocalTypes.mapHas(objName) && ccLocalTypes.mapGet(objName).strEq("TuffVec*")) {
                return ccToName(objName).strConcat("->").strConcat(prop);
            }
        }
        let obj = ccEmitExpr(objNode);
        return obj.strConcat(".").strConcat(prop);
    }
    if (kind = = NK_INDEX_EXPR) {
        let target = ccEmitExpr(nodeGetData1(n));
        let idx = ccEmitExpr(nodeGetData2(n));
        return target.strConcat("[").strConcat(idx).strConcat("]");
    }
    if (kind = = NK_IF_EXPR) {
        let cond = ccEmitExpr(nodeGetData1(n));
        let thenB = nodeGetData2(n);
        let elseB = nodeGetData3(n);
         // Use GNU statement expression for block branches
        if (nodeKind(thenB) = = NK_BLOCK || (elseB != 0 && nodeKind(elseB) = = NK_BLOCK)) {
            return ccEmitIfAsCExpr(n);
        }
         // Simple ternary
        let thenStr = ccEmitExpr(thenB);
        let elseStr = "0";
        if (elseB != 0) {
            elseStr = ccEmitExpr(elseB);
        }
        return "((".strConcat(cond).strConcat(") ? (").strConcat(thenStr).strConcat(") : (").strConcat(elseStr).strConcat("))");
    }
    if (kind = = NK_UNWRAP_EXPR) {
        let innerNode = nodeGetData1(n);
        let inner = ccEmitExpr(innerNode);
        let rtype = ccInferExprCtype(innerNode);
        if (rtype.strEq("int64_t")) {
            return inner;
        }
        let tmp = ccNextTemp("unwrap");
        return "({ ".strConcat(rtype)
        .strConcat(" ").strConcat(tmp)
        .strConcat(" = ").strConcat(inner)
        .strConcat("; if (").strConcat(tmp).strConcat(".__tag == ")
        .strConcat(rtype).strConcat("_Err) { return ").strConcat(tmp)
        .strConcat("; } ").strConcat(tmp).strConcat(".value; })");
    }
    if (kind = = NK_MATCH_EXPR) {
        return ccEmitMatchExpr(n);
    }
    if (kind = = NK_IS_EXPR) {
        let inner = ccEmitExpr(nodeGetData1(n));
        let pat = nodeGetData2(n);
        if (nodeKind(pat) = = NK_NAME_PAT) {
            let name = getInternedStr(nodeGetData1(pat));
            if (ccAliasByVariant.mapHas(name)) {
                let alias = ccAliasByVariant.mapGet(name);
                return "(".strConcat(inner).strConcat(".__tag == ").strConcat(alias).strConcat("_").strConcat(name).strConcat(")");
            }
            return "((int64_t)(".strConcat(inner).strConcat(") != 0)");
        }
        if (nodeKind(pat) = = NK_STRUCT_PAT) {
            let name = getInternedStr(nodeGetData1(pat));
            if (ccAliasByVariant.mapHas(name)) {
                let alias = ccAliasByVariant.mapGet(name);
                return "(".strConcat(inner).strConcat(".__tag == ").strConcat(alias).strConcat("_").strConcat(name).strConcat(")");
            }
        }
        return "0";
    }
    if (kind = = NK_STRUCT_INIT) {
        let name = getInternedStr(nodeGetData1(n));
        if (ccAliasByVariant.mapHas(name)) {
            let alias = ccAliasByVariant.mapGet(name);
            let fields = nodeGetData2(n);
            let sb = sbNew();
            sbAppend(sb, "((");
            sbAppend(sb, alias);
            sbAppend(sb, "){ .__tag = ");
            sbAppend(sb, alias);
            sbAppend(sb, "_");
            sbAppend(sb, name);
            let i = 0;
            let flen = fields.vecLength();
            while (i < flen) {
                let field = fields.vecGet(i);
                let key = getInternedStr(field.vecGet(0));
                let valStr = ccEmitExpr(field.vecGet(1));
                sbAppend(sb, ", .");
                sbAppend(sb, key);
                sbAppend(sb, " = ");
                sbAppend(sb, valStr);
                i = i + 1;
            }
            sbAppend(sb, " })");
            return sbBuild(sb);
        }
        let fields = nodeGetData2(n);
        let sb = sbNew();
        sbAppend(sb, "((");
        sbAppend(sb, name);
        sbAppend(sb, "){ ");
        let i = 0;
        let flen = fields.vecLength();
        while (i < flen) {
            let field = fields.vecGet(i);
            let key = getInternedStr(field.vecGet(0));
            let valStr = ccEmitExpr(field.vecGet(1));
            if (i > 0) {
                sbAppend(sb, ", ");
            }
            sbAppend(sb, ".");
            sbAppend(sb, key);
            sbAppend(sb, " = ");
            sbAppend(sb, valStr);
            i = i + 1;
        }
        sbAppend(sb, " })");
        return sbBuild(sb);
    }
    if (kind = = NK_LAMBDA_EXPR || kind = = NK_FN_EXPR) {
        return "/* lambda/fn_expr unsupported in C */ 0";
    }
    if (kind = = NK_TUPLE_EXPR) {
        return "/* tuple_expr unsupported in C */ 0";
    }
    "/* unknown_expr */ 0"
}
fn ccEmitMatchExpr(n: I32) : *Str => {
    let targetStr = ccEmitExpr(nodeGetData1(n));
    let cases = nodeGetData2(n);
    let len = cases.vecLength();
    let chain = "(tuff_panic(\"Non-exhaustive match\"), 0)";
     // Build from right-to-left (nested ternary)
    let i = len - 1;
    while (i >= 0) {
        let caseNode = cases.vecGet(i);
        let pat = caseNode.vecGet(0);
        let body = caseNode.vecGet(1);
        let guard = ccEmitPatternGuard(targetStr, pat);
        let bodyStr = "";
        if (nodeKind(body) = = NK_BLOCK) {
            bodyStr = ccEmitBlockAsExpr(body);
        }
        else {
            if (nodeKind(pat) = = NK_STRUCT_PAT && nodeKind(body) = = NK_IDENTIFIER) {
                let pfields = nodeGetData2(pat);
                if (pfields != 0 && pfields.vecLength() = = 1) {
                    let pfield = pfields.vecGet(0);
                    let fieldName = getInternedStr(pfield);
                    let bindName = fieldName;
                    let bodyName = getInternedStr(nodeGetData1(body));
                    if (bodyName.strEq(bindName)) {
                        bodyStr = targetStr.strConcat(".").strConcat(fieldName);
                    }
                    else {
                        bodyStr = ccEmitExpr(body);
                    }
                }
                else {
                    bodyStr = ccEmitExpr(body);
                }
            }
            else {
                bodyStr = ccEmitExpr(body);
            }
        }
        chain = "((".strConcat(guard).strConcat(") ? (").strConcat(bodyStr).strConcat(") : (").strConcat(chain).strConcat("))");
        i = i - 1;
    }
    chain
}
 // ============================================================================
 // Statement Emitter
 // ============================================================================
fn ccEmitBlock(n: I32) : *Str => {
    let stmts = nodeGetData1(n);
    let sb = sbNew();
    sbAppend(sb, "{\n");
    let i = 0;
    let len = stmts.vecLength();
    while (i < len) {
        sbAppend(sb, "  ");
        sbAppend(sb, ccEmitStmt(stmts.vecGet(i)));
        sbAppend(sb, "\n");
        i = i + 1;
    }
    sbAppend(sb, "}");
    sbBuild(sb)
}
fn ccEmitStmtOrBlock(n: I32) : *Str => {
    if (nodeKind(n) = = NK_BLOCK) {
        return ccEmitBlock(n);
    }
    "{ ".strConcat(ccEmitStmt(n)).strConcat(" }")
}
fn ccEmitFnBlock(n: I32) : *Str => {
     // Reset local type map for this function scope
    ccLocalTypes = ccLocalTypes.mapClear();
    let stmts = nodeGetData1(n);
    let len = stmts.vecLength();
    if (len = = 0) {
        return "{\n  return 0;\n}";
    }
    let sb = sbNew();
    sbAppend(sb, "{\n");
    let i = 0;
    while (i < len) {
        let stmt = stmts.vecGet(i);
        let isLast = i = = len - 1;
        let skind = nodeKind(stmt);
        if (isLast && skind = = NK_EXPR_STMT) {
            sbAppend(sb, "  return ");
            sbAppend(sb, ccEmitExpr(nodeGetData1(stmt)));
            sbAppend(sb, ";\n");
        }
        else if (isLast && (skind = = NK_IF_STMT || skind = = NK_IF_EXPR)) {
            sbAppend(sb, "  return ");
            sbAppend(sb, ccEmitIfAsCExpr(stmt));
            sbAppend(sb, ";\n");
        }
        else {
            sbAppend(sb, "  ");
            sbAppend(sb, ccEmitStmt(stmt));
            sbAppend(sb, "\n");
        }
        i = i + 1;
    }
    sbAppend(sb, "}");
    sbBuild(sb)
}
fn ccEmitParamList(params: Vec<I32>) : *Str => {
    let parts = vecNew();
    let i = 0;
    let len = params.vecLength();
    while (i < len) {
        let param = params.vecGet(i);
        let pname = getInternedStr(param.vecGet(0));
        let ptype = param.vecGet(1);
        let ptypeStr = ccTypeToC(ptype);
        parts.vecPush(ptypeStr.strConcat(" ").strConcat(pname));
        i = i + 1;
    }
    parts.vecJoin(", ")
}
fn ccEmitPrototype(retType: *Str, name: *Str, params: *Str) : *Str => retType.strConcat(" ").strConcat(name).strConcat("(").strConcat(params).strConcat(");");
fn ccEmitTypeAlias(n: I32) : *Str => {
    let aliasName = getInternedStr(nodeGetData1(n));
    let aliased = nodeGetData3(n);
    if (aliased = = 0 || nodeKind(aliased) != NK_UNION_TYPE) {
        return "/* type ".strConcat(aliasName).strConcat(" = ... */");
    }
    if (!ccUnionAliasInfo.mapHas(aliasName)) {
        return "/* union ".strConcat(aliasName).strConcat(" not in context */");
    }
    let variants = ccUnionAliasInfo.mapGet(aliasName);
    let vlen = variants.vecLength();
    let sb = sbNew();
     // typedef enum Alias_Tag { Alias_V1 = 1, ... } Alias_Tag;
    sbAppend(sb, "typedef enum ");
    sbAppend(sb, aliasName);
    sbAppend(sb, "_Tag { ");
    let j = 0;
    while (j < vlen) {
        if (j > 0) {
            sbAppend(sb, ", ");
        }
        sbAppend(sb, aliasName);
        sbAppend(sb, "_");
        sbAppend(sb, variants.vecGet(j));
        sbAppend(sb, " = ");
        sbAppend(sb, intToString(j + 1));
        j = j + 1;
    }
    sbAppend(sb, " } ");
    sbAppend(sb, aliasName);
    sbAppend(sb, "_Tag;\n");
     // Collect all unique field names from all variant structs
    let allFieldNames = vecNew();
    let seenFields = setNew();
    j = 0;
    while (j < vlen) {
        let v = variants.vecGet(j);
        if (ccStructFields.mapHas(v)) {
            let fields = ccStructFields.mapGet(v);
            let m = 0;
            let flen = fields.vecLength();
            while (m < flen) {
                let fname = fields.vecGet(m);
                if (!seenFields.setHas(fname)) {
                    seenFields.setAdd(fname);
                    allFieldNames.vecPush(fname);
                }
                m = m + 1;
            }
        }
        j = j + 1;
    }
     // typedef struct Alias { int32_t __tag; int64_t f1; ... } Alias;
    sbAppend(sb, "typedef struct ");
    sbAppend(sb, aliasName);
    sbAppend(sb, " { int32_t __tag;");
    let m = 0;
    let flen = allFieldNames.vecLength();
    while (m < flen) {
        let fname = allFieldNames.vecGet(m);
        let ftype = "int64_t";
        if (aliasName.strEq("Result") && fname.strEq("error")) {
            ftype = "TuffError";
        }
        sbAppend(sb, " ");
        sbAppend(sb, ftype);
        sbAppend(sb, " ");
        sbAppend(sb, fname);
        sbAppend(sb, ";");
        m = m + 1;
    }
    sbAppend(sb, " } ");
    sbAppend(sb, aliasName);
    sbAppend(sb, ";\n");
     // Static inline constructor for each variant
    j = 0;
    while (j < vlen) {
        let v = variants.vecGet(j);
        let vfields = vecNew();
        if (ccStructFields.mapHas(v)) {
            vfields = ccStructFields.mapGet(v);
        }
        let paramsSb = sbNew();
        let assignsSb = sbNew();
        let k = 0;
        let klen = vfields.vecLength();
        while (k < klen) {
            let fname = vfields.vecGet(k);
            let ptype = "int64_t";
            if (aliasName.strEq("Result") && fname.strEq("error")) {
                ptype = "TuffError";
            }
            if (k > 0) {
                sbAppend(paramsSb, ", ");
            }
            sbAppend(paramsSb, ptype);
            sbAppend(paramsSb, " ");
            sbAppend(paramsSb, fname);
            sbAppend(assignsSb, " out.");
            sbAppend(assignsSb, fname);
            sbAppend(assignsSb, " = ");
            sbAppend(assignsSb, fname);
            sbAppend(assignsSb, ";");
            k = k + 1;
        }
        sbAppend(sb, "static inline ");
        sbAppend(sb, aliasName);
        sbAppend(sb, " ");
        sbAppend(sb, aliasName);
        sbAppend(sb, "_make_");
        sbAppend(sb, v);
        sbAppend(sb, "(");
        sbAppend(sb, sbBuild(paramsSb));
        sbAppend(sb, ") { ");
        sbAppend(sb, aliasName);
        sbAppend(sb, " out = {0}; out.__tag = ");
        sbAppend(sb, aliasName);
        sbAppend(sb, "_");
        sbAppend(sb, v);
        sbAppend(sb, ";");
        sbAppend(sb, sbBuild(assignsSb));
        sbAppend(sb, " return out; }\n");
        j = j + 1;
    }
    sbBuild(sb)
}
fn ccIsExternFnDecl(n: I32) : Bool => {
    let kind = nodeKind(n);
    kind = = NK_FN_DECL && nodeGetData5(n) = = 0
}
fn ccEmitStmt(n: I32) : *Str => {
    let kind = nodeKind(n);
    if (kind = = NK_LET_DECL) {
        let name = ccToName(getInternedStr(nodeGetData1(n)));
        let valNode = nodeGetData3(n);
        let ctype = ccInferExprCtype(valNode);
        let value = ccEmitExpr(valNode);
        ccLocalTypes.mapSet(name, ctype);
        return ctype.strConcat(" ").strConcat(name).strConcat(" = ").strConcat(value).strConcat(";");
    }
    if (kind = = NK_IMPORT_DECL) {
        return "/* import placeholder */";
    }
    if (kind = = NK_EXPR_STMT) {
        return ccEmitExpr(nodeGetData1(n)).strConcat(";");
    }
    if (kind = = NK_ASSIGN_STMT) {
        let target = ccEmitExpr(nodeGetData1(n));
        let value = ccEmitExpr(nodeGetData2(n));
        return target.strConcat(" = ").strConcat(value).strConcat(";");
    }
    if (kind = = NK_RETURN_STMT) {
        let val = nodeGetData1(n);
        if (val = = 0) {
            return "return 0;";
        }
        return "return ".strConcat(ccEmitExpr(val)).strConcat(";");
    }
    if (kind = = NK_IF_STMT || kind = = NK_IF_EXPR) {
        let cond = ccEmitExpr(nodeGetData1(n));
        let thenB = nodeGetData2(n);
        let elseB = nodeGetData3(n);
        let thenStr = ccEmitStmtOrBlock(thenB);
        if (elseB = = 0) {
            return "if (".strConcat(cond).strConcat(") ").strConcat(thenStr);
        }
        return "if (".strConcat(cond).strConcat(") ").strConcat(thenStr).strConcat(" else ").strConcat(ccEmitStmtOrBlock(elseB));
    }
    if (kind = = NK_WHILE_STMT) {
        let cond = ccEmitExpr(nodeGetData1(n));
        let body = ccEmitBlock(nodeGetData2(n));
        return "while (".strConcat(cond).strConcat(") ").strConcat(body);
    }
    if (kind = = NK_FOR_STMT) {
        let iter = ccToName(getInternedStr(nodeGetData1(n)));
        let start = ccEmitExpr(nodeGetData2(n));
        let end = ccEmitExpr(nodeGetData3(n));
        let body = ccEmitBlock(nodeGetData4(n));
        return "for (int64_t ".strConcat(iter).strConcat(" = ").strConcat(start).strConcat("; ").strConcat(iter).strConcat(" < ").strConcat(end).strConcat("; ").strConcat(iter).strConcat("++) ").strConcat(body);
    }
    if (kind = = NK_LOOP_STMT) {
        let body = ccEmitBlock(nodeGetData1(n));
        return "while (1) ".strConcat(body);
    }
    if (kind = = NK_BREAK_STMT) {
        return "break;";
    }
    if (kind = = NK_CONTINUE_STMT) {
        return "continue;";
    }
    if (kind = = NK_INTO_STMT) {
        return "/* into ".strConcat(getInternedStr(nodeGetData1(n))).strConcat(" */");
    }
    if (kind = = NK_LIFETIME_STMT) {
         // Lifetime blocks are compile-time scoping only.
         // At C top level we must not emit a raw "{ ... }" block.
         // Instead, emit the lowered body statements directly.
        let body = nodeGetData2(n);
        if (body = = 0 || nodeKind(body) != NK_BLOCK) {
            return "";
        }
        let stmts = nodeGetData1(body);
        let sb = sbNew();
        let i = 0;
        let len = stmts.vecLength();
        while (i < len) {
            let row = ccEmitStmt(stmts.vecGet(i));
            if (!row.strEq("")) {
                sbAppend(sb, row);
                if (i + 1 < len) {
                    sbAppend(sb, "\n");
                }
            }
            i = i + 1;
        }
        return sbBuild(sb);
    }
    if (kind = = NK_BLOCK) {
        return ccEmitBlock(n);
    }
    if (kind = = NK_EXPECT_FN_DECL) {
        return "/* expect fn ".strConcat(getInternedStr(nodeGetData1(n))).strConcat(" */");
    }
    if (ccIsExternFnDecl(n)) {
        let name = getInternedStr(nodeGetData1(n));
        if (ccIsStdlibBuiltin(name)) {
            return "/* extern ".strConcat(name).strConcat(" — declared via C stdlib headers */");
        }
        let params = nodeGetData3(n);
        let retType = ccTypeToC(nodeGetData4(n));
        let paramsStr = ccEmitParamList(params);
        return ccEmitPrototype("extern ".strConcat(retType), name, paramsStr);
    }
    if (kind = = NK_FN_DECL || kind = = NK_CLASS_FN_DECL || kind = = NK_ACTUAL_FN_DECL) {
        let sourceName = getInternedStr(nodeGetData1(n));
        let name = ccToName(sourceName);
        let params = nodeGetData3(n);
        let retType = ccTypeToC(nodeGetData4(n));
        let body = nodeGetData5(n);
        let paramsStr = ccEmitParamList(params);
        if (body = = 0) {
            return "/* fn ".strConcat(name).strConcat(" has no body */");
        }
        let prevDisableEscape = ccDisableUnicodeEscape;
        if (sourceName.strEq("cc_escape_unicode_in_string")) {
            ccDisableUnicodeEscape = 1;
        }
        let emitted = "";
        if (nodeKind(body) = = NK_BLOCK) {
            emitted = retType.strConcat(" ").strConcat(name).strConcat("(").strConcat(paramsStr).strConcat(") ").strConcat(ccEmitFnBlock(body));
        }
        else {
            emitted = retType.strConcat(" ").strConcat(name).strConcat("(").strConcat(paramsStr).strConcat(") { return ").strConcat(ccEmitExpr(body)).strConcat("; }");
        }
        ccDisableUnicodeEscape = prevDisableEscape;
        return emitted;
    }
    if (kind = = NK_STRUCT_DECL) {
        let name = getInternedStr(nodeGetData1(n));
        let fields = nodeGetData3(n);
        if (name.strEq("ParseError") || name.strEq("ResolveError") || name.strEq("TypeError") || name.strEq("CodegenError")) {
            let sb = sbNew();
            if (ccEmittedTuffError = = 0) {
                sbAppend(sb, "typedef struct TuffError { ");
                let i = 0;
                let flen = fields.vecLength();
                while (i < flen) {
                    let f = fields.vecGet(i);
                    let fname = getInternedStr(f.vecGet(0));
                    let ftype = f.vecGet(1);
                    let ctype = ccTypeToC(ftype);
                    sbAppend(sb, ctype);
                    sbAppend(sb, " ");
                    sbAppend(sb, fname);
                    sbAppend(sb, "; ");
                    i = i + 1;
                }
                sbAppend(sb, "} TuffError;\n");
                ccEmittedTuffError = 1;
            }
            sbAppend(sb, "typedef TuffError ");
            sbAppend(sb, name);
            sbAppend(sb, ";");
            return sbBuild(sb);
        }
        let sb = sbNew();
        sbAppend(sb, "typedef struct ");
        sbAppend(sb, name);
        sbAppend(sb, " { ");
        let i = 0;
        let flen = fields.vecLength();
        while (i < flen) {
            let f = fields.vecGet(i);
            let fname = getInternedStr(f.vecGet(0));
            let ftype = f.vecGet(1);
            let ctype = ccTypeToC(ftype);
            sbAppend(sb, ctype);
            sbAppend(sb, " ");
            sbAppend(sb, fname);
            sbAppend(sb, "; ");
            i = i + 1;
        }
        sbAppend(sb, "} ");
        sbAppend(sb, name);
        sbAppend(sb, ";");
        return sbBuild(sb);
    }
    if (kind = = NK_TYPE_ALIAS) {
        return ccEmitTypeAlias(n);
    }
    if (kind = = NK_DEP_TYPE_ALIAS) {
        let name = getInternedStr(nodeGetData1(n));
        return "/* type ".strConcat(name).strConcat("(...) = ... */");
    }
    if (kind = = NK_ENUM_DECL) {
        let name = getInternedStr(nodeGetData1(n));
        let variants = nodeGetData2(n);
        let sb = sbNew();
        sbAppend(sb, "typedef enum ");
        sbAppend(sb, name);
        sbAppend(sb, " { ");
        let i = 0;
        let vlen = variants.vecLength();
        while (i < vlen) {
            if (i > 0) {
                sbAppend(sb, ", ");
            }
            sbAppend(sb, name);
            sbAppend(sb, "_");
            sbAppend(sb, getInternedStr(variants.vecGet(i)));
            sbAppend(sb, " = ");
            sbAppend(sb, intToString(i));
            i = i + 1;
        }
        sbAppend(sb, " } ");
        sbAppend(sb, name);
        sbAppend(sb, ";");
        return sbBuild(sb);
    }
    if (kind = = NK_OBJECT_DECL) {
        return "/* object ".strConcat(getInternedStr(nodeGetData1(n))).strConcat(" */");
    }
    if (kind = = NK_CONTRACT_DECL) {
        return "/* contract ".strConcat(getInternedStr(nodeGetData1(n))).strConcat(" */");
    }
    if (kind = = NK_EXTERN_LET_DECL) {
        let name = getInternedStr(nodeGetData1(n));
        return "/* extern let ".strConcat(name).strConcat(" */");
    }
    if (kind = = NK_EXTERN_TYPE_DECL) {
        let name = getInternedStr(nodeGetData1(n));
        return "/* extern type ".strConcat(name).strConcat(" */");
    }
    if (kind = = NK_EXTERN_IMPORT_DECL) {
        return "";
    }
     // NK_STMT_LIST (noop from extern let { } = source; parsing) — emit nothing
    if (kind = = NK_STMT_LIST) {
        return "";
    }
    ""
}
 // ============================================================================
 // Main Entry Point
 // ============================================================================
out fn generateCImpl(typed: I32, substrate: *Str) : *Str => {
     // Reset global state for this compilation
    ccTempCounter = 0;
    ccDisableUnicodeEscape = 0;
    ccEnumNames = ccEnumNames.setClear();
    ccEnumVariantConsts = ccEnumVariantConsts.mapClear();
    ccStructFields = ccStructFields.mapClear();
    ccAliasByVariant = ccAliasByVariant.mapClear();
    ccUnionAliasInfo = ccUnionAliasInfo.mapClear();
    ccCoveredExternFns = ccCoveredExternFns.setClear();
    ccFnReturnTypes = ccFnReturnTypes.mapClear();
    ccLocalTypes = ccLocalTypes.mapClear();
    ccEmittedTuffError = 0;
    ccIncStdint = 1;
    ccIncStddef = 0;
    ccIncStdio = 0;
    ccIncStdlib = 0;
    ccIncString = 0;
    ccIncCtype = 0;
    ccIncErrno = 0;
    ccIncDirect = 0;
    ccIncSysStat = 0;
    ccIncSysTypes = 0;
     // Pre-scan AST to build context maps
    ccInitContext(typed);
     // While substrate is still embedded, preserve its required header baseline.
     // Once substrate is removed, includes become fully extern-source driven,
     // except for the tiny built-in fallback prelude emitted below.
    if (!substrate.strEq("")) {
        ccRequireSubstrateHeaders();
    }
    else {
        ccIncStddef = 1;
        ccIncStdio = 1;
        ccIncStdlib = 1;
        ccIncString = 1;
         // String implementations need <string.h>
        ccIncCtype = 1;
         // String implementations need <ctype.h> for isspace
    }
    let stmts = nodeGetData1(typed);
    let len = stmts.vecLength();
     // Enforce extern source attribution coverage for extern fns.
    let cvi = 0;
    while (cvi < len) {
        let cvn = stmts.vecGet(cvi);
        if (ccIsExternFnDecl(cvn)) {
            let fname = getInternedStr(nodeGetData1(cvn));
            if (!ccCoveredExternFns.setHas(fname)) {
                panicWithCode( "E_EXTERN_NO_SOURCE",
                "extern fn '".strConcat(fname).strConcat("' has no source attribution"), "C codegen requires each extern function to be attributed to a source via extern let destructuring.", "Add 'extern let { ".strConcat(fname).strConcat(" } = <header>;' before the declaration.") );
            }
        }
        cvi = cvi + 1;
    }
     // Collect fn nodes for two-pass emit (prototypes then bodies)
    let fnNodes : Vec<I32> = vecNew();
     // Collect global let init rows for tuff_init_globals()
    let initRows : Vec<*Str> = vecNew();
    let sb = sbNew();
     // ── Preamble: fixed C includes ──────────────────────────────────────────
    if (ccIncStdint = = 1) {
        sbAppend(sb, "#include <stdint.h>\n");
    }
    if (ccIncStddef = = 1) {
        sbAppend(sb, "#include <stddef.h>\n");
    }
    if (ccIncStdio = = 1) {
        sbAppend(sb, "#include <stdio.h>\n");
    }
    if (ccIncStdlib = = 1) {
        sbAppend(sb, "#include <stdlib.h>\n");
    }
    if (ccIncString = = 1) {
        sbAppend(sb, "#include <string.h>\n");
    }
    if (ccIncCtype = = 1) {
        sbAppend(sb, "#include <ctype.h>\n");
    }
    if (ccIncErrno = = 1) {
        sbAppend(sb, "#include <errno.h>\n");
    }
    sbAppend(sb, "#ifdef _WIN32\n");
    if (ccIncDirect = = 1) {
        sbAppend(sb, "#include <direct.h>\n");
    }
    sbAppend(sb, "#else\n");
    if (ccIncSysStat = = 1) {
        sbAppend(sb, "#include <sys/stat.h>\n");
    }
    if (ccIncSysTypes = = 1) {
        sbAppend(sb, "#include <sys/types.h>\n");
    }
    sbAppend(sb, "#endif\n\n");
    sbAppend(sb, "/* Generated by Tuff selfhost C backend. */\n\n");
    if (!substrate.strEq("")) {
        sbAppend(sb, "/* Embedded C substrate support */\n");
        sbAppend(sb, substrate);
    }
    else {
        sbAppend(sb, ccEmitMinimalRuntimePrelude());
    }
    sbAppend(sb, "\n\n");
    sbAppend(sb, "typedef struct TuffError { int64_t code; int64_t message; int64_t reason; int64_t fix; int64_t line; int64_t col; } TuffError;\n\n");
    ccEmittedTuffError = 1;
     // ── First pass: non-fn top-level declarations ────────────────────────────
    let i = 0;
    while (i < len) {
        let node = stmts.vecGet(i);
        let kind = nodeKind(node);
         // Collect fn nodes for later
        if (kind = = NK_FN_DECL || kind = = NK_CLASS_FN_DECL || kind = = NK_ACTUAL_FN_DECL) {
            fnNodes.vecPush(node);
            i = i + 1;
            continue;
        }
         // Skip expect fn declarations
        if (kind = = NK_EXPECT_FN_DECL) {
            i = i + 1;
            continue;
        }
         // Global let → forward declaration + deferred initializer
        if (kind = = NK_LET_DECL) {
            let name = ccToName(getInternedStr(nodeGetData1(node)));
            sbAppend(sb, "int64_t ");
            sbAppend(sb, name);
            sbAppend(sb, ";\n");
            initRows.vecPush(name.strConcat(" = ").strConcat(ccEmitExpr(nodeGetData3(node))).strConcat(";"));
            sbAppend(sb, "\n");
            i = i + 1;
            continue;
        }
         // Everything else (enums, structs, type aliases, extern fns, etc.)
        let stmtStr = ccEmitStmt(node);
        if (!stmtStr.strEq("")) {
            sbAppend(sb, stmtStr);
            sbAppend(sb, "\n");
        }
        i = i + 1;
    }
     // ── Fn prototypes ────────────────────────────────────────────────────────
    sbAppend(sb, "\n");
    i = 0;
    let fnLen = fnNodes.vecLength();
    while (i < fnLen) {
        let fnNode = fnNodes.vecGet(i);
        let fnName = ccToName(getInternedStr(nodeGetData1(fnNode)));
        let paramsStr = ccEmitParamList(nodeGetData3(fnNode));
        let retType = ccTypeToC(nodeGetData4(fnNode));
        sbAppend(sb, ccEmitPrototype(retType, fnName, paramsStr));
        sbAppend(sb, "\n");
        i = i + 1;
    }
    sbAppend(sb, "\n");
     // ── Fn bodies ────────────────────────────────────────────────────────────
    i = 0;
    while (i < fnLen) {
        let fnNode = fnNodes.vecGet(i);
        sbAppend(sb, ccEmitStmt(fnNode));
        sbAppend(sb, "\n\n");
        i = i + 1;
    }
     // ── tuff_init_globals ────────────────────────────────────────────────────
    sbAppend(sb, "static void tuff_init_globals(void) {\n");
    i = 0;
    let initLen = initRows.vecLength();
    while (i < initLen) {
        sbAppend(sb, "  ");
        sbAppend(sb, initRows.vecGet(i));
        sbAppend(sb, "\n");
        i = i + 1;
    }
    sbAppend(sb, "}\n\n");
     // ── main() entry point ───────────────────────────────────────────────────
    sbAppend(sb, "void tuff_set_argv(int argc, char** argv);\n\n");
    sbAppend(sb, "int main(int argc, char** argv) {\n");
    sbAppend(sb, "  tuff_set_argv(argc, argv);\n");
    sbAppend(sb, "  tuff_init_globals();\n");
    sbAppend(sb, "  return (int)tuff_main();\n");
    sbAppend(sb, "}\n");
    sbBuild(sb)
}
fn ccPushFile(artifacts: Vec<I32>, relPath: *Str, content: *Str) : Vec<I32> => {
    let rec = vecNew();
    rec.vecPush(relPath);
    rec.vecPush(content);
    artifacts.vecPush(rec)
}
fn ccOwnerKeyForIndex(stmtOwners: Vec<*Str>, idx: I32, fallback: *Str) : *Str => {
    if (idx < stmtOwners.vecLength()) {
        return stmtOwners.vecGet(idx);
    }
    fallback
}
fn ccEmitSplitSharedHeader(typed: I32, moduleKeys: Vec<*Str>) : *Str => {
    let sb = sbNew();
    sbAppend(sb, "#ifndef TUFF_SHARED_H\n");
    sbAppend(sb, "#define TUFF_SHARED_H\n\n");
    if (ccIncStdint = = 1) {
        sbAppend(sb, "#include <stdint.h>\n");
    }
    if (ccIncStddef = = 1) {
        sbAppend(sb, "#include <stddef.h>\n");
    }
    if (ccIncStdio = = 1) {
        sbAppend(sb, "#include <stdio.h>\n");
    }
    if (ccIncStdlib = = 1) {
        sbAppend(sb, "#include <stdlib.h>\n");
    }
    if (ccIncString = = 1) {
        sbAppend(sb, "#include <string.h>\n");
    }
    if (ccIncCtype = = 1) {
        sbAppend(sb, "#include <ctype.h>\n");
    }
    if (ccIncErrno = = 1) {
        sbAppend(sb, "#include <errno.h>\n");
    }
    sbAppend(sb, "#ifdef _WIN32\n");
    if (ccIncDirect = = 1) {
        sbAppend(sb, "#include <direct.h>\n");
    }
    sbAppend(sb, "#else\n");
    if (ccIncSysStat = = 1) {
        sbAppend(sb, "#include <sys/stat.h>\n");
    }
    if (ccIncSysTypes = = 1) {
        sbAppend(sb, "#include <sys/types.h>\n");
    }
    sbAppend(sb, "#endif\n\n");
    sbAppend(sb, "typedef struct TuffError { int64_t code; int64_t message; int64_t reason; int64_t fix; int64_t line; int64_t col; } TuffError;\n");
    sbAppend(sb, "typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\n");
    sbAppend(sb, "\n");
    ccEmittedTuffError = 1;
    sbAppend(sb, "/* Runtime/host declarations required across split translation units. */\n");
    sbAppend(sb, "int64_t str_length();\n");
    sbAppend(sb, "int64_t str_char_at();\n");
    sbAppend(sb, "int64_t str_slice();\n");
    sbAppend(sb, "int64_t str_slice_window();\n");
    sbAppend(sb, "int64_t str_copy();\n");
    sbAppend(sb, "int64_t str_mut_slice();\n");
    sbAppend(sb, "int64_t str_concat();\n");
    sbAppend(sb, "int64_t str_eq();\n");
    sbAppend(sb, "int64_t str_from_char_code();\n");
    sbAppend(sb, "int64_t __str_index_of();\n");
    sbAppend(sb, "int64_t str_trim();\n");
    sbAppend(sb, "int64_t str_replace_all();\n");
    sbAppend(sb, "int64_t char_code();\n");
    sbAppend(sb, "int64_t __int_to_string();\n");
    sbAppend(sb, "int64_t parse_int();\n");
    sbAppend(sb, "int64_t sb_new();\n");
    sbAppend(sb, "int64_t sb_append();\n");
    sbAppend(sb, "int64_t sb_append_char();\n");
    sbAppend(sb, "int64_t sb_build();\n");
    sbAppend(sb, "int64_t __vec_new();\n");
    sbAppend(sb, "int64_t __vec_push();\n");
    sbAppend(sb, "int64_t __vec_pop();\n");
    sbAppend(sb, "int64_t __vec_get();\n");
    sbAppend(sb, "int64_t __vec_set();\n");
    sbAppend(sb, "int64_t __vec_length();\n");
    sbAppend(sb, "int64_t __vec_init();\n");
    sbAppend(sb, "int64_t __vec_capacity();\n");
    sbAppend(sb, "int64_t __vec_clear();\n");
    sbAppend(sb, "int64_t __vec_join();\n");
    sbAppend(sb, "int64_t __vec_includes();\n");
    sbAppend(sb, "int64_t __map_new();\n");
    sbAppend(sb, "int64_t map_set();\n");
    sbAppend(sb, "int64_t map_get();\n");
    sbAppend(sb, "int64_t map_has();\n");
    sbAppend(sb, "int64_t map_delete();\n");
    sbAppend(sb, "int64_t __set_new();\n");
    sbAppend(sb, "int64_t set_add();\n");
    sbAppend(sb, "int64_t set_has();\n");
    sbAppend(sb, "int64_t set_delete();\n");
    sbAppend(sb, "int64_t read_file();\n");
    sbAppend(sb, "int64_t write_file();\n");
    sbAppend(sb, "int64_t path_join();\n");
    sbAppend(sb, "int64_t path_dirname();\n");
    sbAppend(sb, "int64_t print();\n");
    sbAppend(sb, "int64_t __print_error();\n");
    sbAppend(sb, "int64_t panic();\n");
    sbAppend(sb, "int64_t panic_with_code();\n");
    sbAppend(sb, "int64_t panic_with_code_loc();\n");
    sbAppend(sb, "int64_t get_argc();\n");
    sbAppend(sb, "int64_t get_argv();\n");
    sbAppend(sb, "void tuff_set_argv(int argc, char** argv);\n");
    sbAppend(sb, "int64_t __perf_now();\n");
    sbAppend(sb, "int64_t profile_mark();\n");
    sbAppend(sb, "int64_t __profile_take_json();\n");
    sbAppend(sb, "int64_t __host_get_c_substrate();\n");
    sbAppend(sb, "int64_t __host_get_c_runtime_prelude_source();\n");
    sbAppend(sb, "int64_t __host_emit_target_from_source();\n\n");
    let stmts = nodeGetData1(typed);
    let i = 0;
    let len = stmts.vecLength();
    while (i < len) {
        let node = stmts.vecGet(i);
        let kind = nodeKind(node);
        if (kind = = NK_FN_DECL || kind = = NK_CLASS_FN_DECL || kind = = NK_ACTUAL_FN_DECL || kind = = NK_EXPECT_FN_DECL || kind = = NK_LET_DECL) {
            i = i + 1;
            continue;
        }
        let row = ccEmitStmt(node);
        if (!row.strEq("")) {
            if (row.strEq("typedef struct TuffError { int64_t code; int64_t message; int64_t reason; int64_t fix; int64_t line; int64_t col; } TuffError;")) {
                i = i + 1;
                continue;
            }
            sbAppend(sb, row);
            sbAppend(sb, "\n");
        }
        i = i + 1;
    }
    sbAppend(sb, "\n");
    i = 0;
    while (i < len) {
        let node = stmts.vecGet(i);
        if (nodeKind(node) = = NK_LET_DECL) {
            let name = ccToName(getInternedStr(nodeGetData1(node)));
            sbAppend(sb, "extern int64_t ");
            sbAppend(sb, name);
            sbAppend(sb, ";\n");
        }
        i = i + 1;
    }
    sbAppend(sb, "\n");
    i = 0;
    while (i < len) {
        let fnNode = stmts.vecGet(i);
        let kind = nodeKind(fnNode);
        if (kind = = NK_FN_DECL || kind = = NK_CLASS_FN_DECL || kind = = NK_ACTUAL_FN_DECL || kind = = NK_EXPECT_FN_DECL) {
            let fnName = ccToName(getInternedStr(nodeGetData1(fnNode)));
            let paramsStr = ccEmitParamList(nodeGetData3(fnNode));
            let retType = ccTypeToC(nodeGetData4(fnNode));
            sbAppend(sb, ccEmitPrototype(retType, fnName, paramsStr));
            sbAppend(sb, "\n");
        }
        i = i + 1;
    }
    sbAppend(sb, "\n");
    i = 0;
    let mlen = moduleKeys.vecLength();
    while (i < mlen) {
        let key = moduleKeys.vecGet(i);
        sbAppend(sb, "void tuff_init_globals_");
        sbAppend(sb, key);
        sbAppend(sb, "(void);\n");
        i = i + 1;
    }
    sbAppend(sb, "\n#endif\n");
    sbBuild(sb)
}
fn ccEmitSplitModuleHeader(moduleKey: *Str) : *Str => {
    let guard = "TUFF_MOD_".strConcat(moduleKey).strConcat("_H");
    let sb = sbNew();
    sbAppend(sb, "#ifndef ");
    sbAppend(sb, guard);
    sbAppend(sb, "\n#define ");
    sbAppend(sb, guard);
    sbAppend(sb, "\n\n#include \"tuff_shared.h\"\n\n");
    sbAppend(sb, "void tuff_init_globals_");
    sbAppend(sb, moduleKey);
    sbAppend(sb, "(void);\n\n#endif\n");
    sbBuild(sb)
}
fn ccEmitSplitModuleSource(typed: I32, moduleKey: *Str, stmtOwners: Vec<*Str>, fallbackKey: *Str) : *Str => {
    let sb = sbNew();
    sbAppend(sb, "#include \"");
    sbAppend(sb, moduleKey);
    sbAppend(sb, ".h\"\n\n");
    let stmts = nodeGetData1(typed);
    let i = 0;
    let len = stmts.vecLength();
    while (i < len) {
        let owner = ccOwnerKeyForIndex(stmtOwners, i, fallbackKey);
        let node = stmts.vecGet(i);
        if (owner.strEq(moduleKey) && nodeKind(node) = = NK_LET_DECL) {
            let name = ccToName(getInternedStr(nodeGetData1(node)));
            sbAppend(sb, "int64_t ");
            sbAppend(sb, name);
            sbAppend(sb, ";\n");
        }
        i = i + 1;
    }
    sbAppend(sb, "\nvoid tuff_init_globals_");
    sbAppend(sb, moduleKey);
    sbAppend(sb, "(void) {\n");
    i = 0;
    while (i < len) {
        let owner = ccOwnerKeyForIndex(stmtOwners, i, fallbackKey);
        let node = stmts.vecGet(i);
        if (owner.strEq(moduleKey) && nodeKind(node) = = NK_LET_DECL) {
            let name = ccToName(getInternedStr(nodeGetData1(node)));
            sbAppend(sb, "  ");
            sbAppend(sb, name);
            sbAppend(sb, " = ");
            sbAppend(sb, ccEmitExpr(nodeGetData3(node)));
            sbAppend(sb, ";\n");
        }
        i = i + 1;
    }
    sbAppend(sb, "}\n\n");
    i = 0;
    while (i < len) {
        let owner = ccOwnerKeyForIndex(stmtOwners, i, fallbackKey);
        let fnNode = stmts.vecGet(i);
        let kind = nodeKind(fnNode);
        if (owner.strEq(moduleKey) && (kind = = NK_FN_DECL || kind = = NK_CLASS_FN_DECL || kind = = NK_ACTUAL_FN_DECL)) {
            if (nodeGetData5(fnNode) != 0) {
                sbAppend(sb, ccEmitStmt(fnNode));
                sbAppend(sb, "\n\n");
            }
        }
        i = i + 1;
    }
    sbBuild(sb)
}
fn ccEmitSplitRuntimeSource(substrate: *Str) : *Str => {
    let sb = sbNew();
    sbAppend(sb, "#include \"tuff_shared.h\"\n\n");
    let runtimeSrc = substrate;
    if (runtimeSrc.strEq("")) {
        runtimeSrc = ccEmitMinimalRuntimePrelude();
    }
    runtimeSrc = runtimeSrc.strReplaceAll("typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\n", "");
    runtimeSrc = runtimeSrc.strReplaceAll("typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\r\n", "");
    runtimeSrc = runtimeSrc.strReplaceAll("typedef struct\n{\n    int64_t *data;\n    size_t init;\n    size_t length;\n} TuffVec;\n", "");
    runtimeSrc = runtimeSrc.strReplaceAll("typedef struct\r\n{\r\n    int64_t *data;\r\n    size_t init;\r\n    size_t length;\r\n} TuffVec;\r\n", "");
    if (!substrate.strEq("")) {
        sbAppend(sb, runtimeSrc);
    }
    else {
        sbAppend(sb, runtimeSrc);
    }
    sbAppend(sb, "\n");
    sbBuild(sb)
}
fn ccEmitSplitMainSource(initOrder: Vec<*Str>) : *Str => {
    let sb = sbNew();
    sbAppend(sb, "#include \"tuff_shared.h\"\n\n");
    sbAppend(sb, "int main(int argc, char** argv) {\n");
    sbAppend(sb, "  tuff_set_argv(argc, argv);\n");
    let i = 0;
    let len = initOrder.vecLength();
    while (i < len) {
        let key = initOrder.vecGet(i);
        sbAppend(sb, "  tuff_init_globals_");
        sbAppend(sb, key);
        sbAppend(sb, "();\n");
        i = i + 1;
    }
    sbAppend(sb, "  return (int)tuff_main();\n");
    sbAppend(sb, "}\n");
    sbBuild(sb)
}
out fn generateCSplitFilesImpl(typed: I32, substrate: *Str, moduleKeys: Vec<*Str>,
stmtOwners: Vec<*Str>, initOrder: Vec<*Str>) : Vec<I32> => {
    ccTempCounter = 0;
    ccDisableUnicodeEscape = 0;
    ccEnumNames = ccEnumNames.setClear();
    ccEnumVariantConsts = ccEnumVariantConsts.mapClear();
    ccStructFields = ccStructFields.mapClear();
    ccAliasByVariant = ccAliasByVariant.mapClear();
    ccUnionAliasInfo = ccUnionAliasInfo.mapClear();
    ccCoveredExternFns = ccCoveredExternFns.setClear();
    ccFnReturnTypes = ccFnReturnTypes.mapClear();
    ccLocalTypes = ccLocalTypes.mapClear();
    ccEmittedTuffError = 0;
    ccIncStdint = 1;
    ccIncStddef = 0;
    ccIncStdio = 0;
    ccIncStdlib = 0;
    ccIncString = 0;
    ccIncCtype = 0;
    ccIncErrno = 0;
    ccIncDirect = 0;
    ccIncSysStat = 0;
    ccIncSysTypes = 0;
    ccInitContext(typed);
    if (!substrate.strEq("")) {
        ccRequireSubstrateHeaders();
    }
    else {
        ccIncStddef = 1;
        ccIncStdio = 1;
        ccIncStdlib = 1;
        ccIncString = 1;
        ccIncCtype = 1;
    }
    let stmts = nodeGetData1(typed);
    let len = stmts.vecLength();
    let cvi = 0;
    while (cvi < len) {
        let cvn = stmts.vecGet(cvi);
        if (ccIsExternFnDecl(cvn)) {
            let fname = getInternedStr(nodeGetData1(cvn));
            if (!ccCoveredExternFns.setHas(fname)) {
                panicWithCode( "E_EXTERN_NO_SOURCE",
                "extern fn '".strConcat(fname).strConcat("' has no source attribution"), "C codegen requires each extern function to be attributed to a source via extern let destructuring.", "Add 'extern let { ".strConcat(fname).strConcat(" } = <header>;' before the declaration.") );
            }
        }
        cvi = cvi + 1;
    }
    let artifacts : Vec<I32> = vecNew();
    ccPushFile(artifacts, "tuff_shared.h", ccEmitSplitSharedHeader(typed, moduleKeys));
    ccPushFile(artifacts, "tuff_runtime.c", ccEmitSplitRuntimeSource(substrate));
    let fallbackKey = "main";
    if (moduleKeys.vecLength() > 0) {
        fallbackKey = moduleKeys.vecGet(moduleKeys.vecLength() - 1);
    }
    let i = 0;
    let mlen = moduleKeys.vecLength();
    while (i < mlen) {
        let key = moduleKeys.vecGet(i);
        ccPushFile(artifacts, key.strConcat(".h"), ccEmitSplitModuleHeader(key));
        ccPushFile(artifacts, key.strConcat(".c"), ccEmitSplitModuleSource(typed, key, stmtOwners, fallbackKey));
        i = i + 1;
    }
    ccPushFile(artifacts, "tuff_main.c", ccEmitSplitMainSource(initOrder));
    artifacts
}
out fn selfhostCodegenCImplMarker() : I32 => 0;
