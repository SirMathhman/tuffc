 // ============================================================================
 // Typecheck - skip for now, minimal implementation
 // ============================================================================
let {
    get_interned_str, map_new, set_new, vec_new, str_includes, str_starts_with
}
 = selfhost::runtime_lexer;
let {
    node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5,
    node_get_line, node_get_col
}
 = selfhost::parser_core;
 // Current AST node being type-checked — set at each typecheck_expr/typecheck_stmt entry
 // so that tc_panic_loc can report the source location of the error.
let tc_current_node : I32 = 0;
let tc_type_name_cache : Map = map_new();
fn tc_panic_loc(code: *Str, msg: *Str, reason: *Str, fix: *Str) : I32 => panic_with_code_loc(code,
msg, reason, fix, node_get_line(tc_current_node), node_get_col(tc_current_node));
fn union_type_contains(union_name: *Str, candidate: *Str) : Bool => {
    let start = 0;
    let i = 0;
    while (i < union_name.str_length()) {
        if (union_name.str_char_at(i) = = 124) {
            if (union_name.str_slice(start, i).str_eq(candidate)) {
                return true;
            }
            start = i + 1;
        }
        i = i + 1;
    }
     // Check the last segment (after the final '|' delimiter or the entire string).
    union_name.str_slice(start, union_name.str_length()).str_eq(candidate)
}
fn is_this_return_type_for (actual: *Str, declared: *Str) : Bool => {
    if (!actual.str_starts_with("__this_")) {
        return false;
    }
    let n = actual.str_length();
    actual.str_slice(7, n).str_eq(declared)
}
fn type_name_from_type_node(t: I32) : *Str => {
    if (tc_type_name_cache.map_has(t)) {
        return tc_type_name_cache.map_get(t);
    }
    if (t = = 0) {
        tc_type_name_cache.map_set(t, "Unknown");
        return "Unknown";
    }
    let result = "Unknown";
    let k = node_kind(t);
    if (k = = 40) {
        result = get_interned_str(node_get_data1(t));
        tc_type_name_cache.map_set(t, result);
        return result;
    }
    if (k = = 41) {
        let mutable = node_get_data1(t);
        let inner = type_name_from_type_node(node_get_data2(t));
        let move_ptr = node_get_data3(t);
        let life_idx = node_get_data4(t);
        let life_prefix = "";
        if (life_idx != 0) {
            life_prefix = get_interned_str(life_idx).str_concat(" ");
        }
        if (move_ptr = = 1) {
            result = "*".str_concat(life_prefix).str_concat("move ").str_concat(inner);
            tc_type_name_cache.map_set(t, result);
            return result;
        }
        if (mutable = = 1) {
            result = "*".str_concat(life_prefix).str_concat("mut ").str_concat(inner);
            tc_type_name_cache.map_set(t, result);
            return result;
        }
        result = "*".str_concat(life_prefix).str_concat(inner);
        tc_type_name_cache.map_set(t, result);
        return result;
    }
    if (k = = 44) {
        result = type_name_from_type_node(node_get_data1(t));
        tc_type_name_cache.map_set(t, result);
        return result;
    }
     // NK_APPLIED_TYPE (71) — erase to alias name; also check arity if alias is registered.
    if (k = = 71) {
        let alias_name = get_interned_str(node_get_data1(t));
        let args = node_get_data2(t);
        let actual_arity = args.vec_length();
        if (tc_dep_type_alias_params.map_has(alias_name)) {
            let expected_arity = tc_dep_type_alias_params.map_get(alias_name);
            if (actual_arity != expected_arity) {
                tc_panic_loc(
                "E_TYPE_APPLIED_ARITY", "'".str_concat(alias_name).str_concat("' applied with ").str_concat(int_to_string(actual_arity)).str_concat(" argument(s), expected ").str_concat(int_to_string(expected_arity)), "Dependent type aliases must be applied with exactly the number of arguments declared in the type parameter list.", "Provide exactly ".str_concat(int_to_string(expected_arity)).str_concat(" argument(s) to '").str_concat(alias_name).str_concat("'.")
                );
            }
        }
        result = alias_name;
        tc_type_name_cache.map_set(t, result);
        return result;
    }
    if (k = = 45) {
        let left = type_name_from_type_node(node_get_data1(t));
        let right = type_name_from_type_node(node_get_data2(t));
        result = left.str_concat("|").str_concat(right);
        tc_type_name_cache.map_set(t, result);
        return result;
    }
    tc_type_name_cache.map_set(t, result);
    result
}
fn pointer_types_compatible(expected: *Str, actual: *Str) : Bool => {
    if (expected.str_eq(actual)) {
        return true;
    }
    if (expected.str_includes("|")) {
        if (union_type_contains(expected, actual)) {
            return true;
        }
    }
     // Allow *mut T where *T is expected (including lifetime-prefixed forms like *a T / *a mut T).
    if (expected.str_starts_with("*") && actual.str_starts_with("*")) {
        let expected_body = expected.str_slice(1, expected.str_length());
        let actual_body = actual.str_slice(1, actual.str_length());
        let expected_has_life = !expected_body.str_starts_with("mut ") && !expected_body.str_starts_with("move ") && expected_body.str_includes(" ");
        let actual_has_life = !actual_body.str_starts_with("mut ") && !actual_body.str_starts_with("move ") && actual_body.str_includes(" ");
        if (expected_has_life) {
            let i = 0;
            while (i < expected_body.str_length()) {
                if (expected_body.str_char_at(i) = = 32) {
                    break;
                }
                i = i + 1;
            }
            if (i < expected_body.str_length()) {
                expected_body = expected_body.str_slice(i + 1, expected_body.str_length());
            }
        }
        if (actual_has_life) {
            let j = 0;
            while (j < actual_body.str_length()) {
                if (actual_body.str_char_at(j) = = 32) {
                    break;
                }
                j = j + 1;
            }
            if (j < actual_body.str_length()) {
                actual_body = actual_body.str_slice(j + 1, actual_body.str_length());
            }
        }
        if (!expected_body.str_starts_with("mut ") && actual_body.str_starts_with("mut ")) {
            let expected_inner = expected_body;
            let actual_inner = actual_body.str_slice(4, actual_body.str_length());
            return expected_inner.str_eq(actual_inner);
        }
        if (expected_body.str_starts_with("mut ") && !actual_body.str_starts_with("mut ")) {
            return false;
        }
        return expected_body.str_eq(actual_body);
    }
    false
}
fn str_ends_with_local(s: *Str, suffix: *Str) : Bool => {
    let ns = s.str_length();
    let nf = suffix.str_length();
    if (nf > ns) {
        return false;
    }
    s.str_slice(ns - nf, ns).str_eq(suffix)
}
fn is_number_literal_with_suffix(n: I32, suffix: *Str) : Bool => {
    if (n = = 0 || node_kind(n) != NK_NUMBER_LIT) {
        return false;
    }
    let text = get_interned_str(node_get_data1(n));
    str_ends_with_local(text, suffix)
}
fn is_usize_zero_literal_node(n: I32) : Bool => {
    if (!is_number_literal_with_suffix(n, "USize")) {
        return false;
    }
    get_interned_str(node_get_data1(n)).str_eq("0USize")
}
fn is_nullable_pointer_type_name(name: *Str) : Bool => {
    if (!name.str_includes("|")) {
        return false;
    }
    if (name.str_starts_with("*") && str_ends_with_local(name, "|USize")) {
        return true;
    }
    if (name.str_starts_with("USize|*") && name.str_includes("*")) {
        return true;
    }
    false
}
fn numeric_types_compatible(expected: *Str, actual: *Str, rhs: I32) : Bool => {
    if (expected.str_eq(actual)) {
        return true;
    }
     // Allow unsigned targets from non-negative numeric literals.
    if (expected.str_eq("USize") && actual.str_eq("I32") && rhs != 0 && node_kind(rhs) = = NK_NUMBER_LIT) {
        let lit = get_interned_str(node_get_data1(rhs));
        return !lit.str_starts_with("-");
    }
     // Allow I32 as USize for signed-index variables proven bounded by the call-bound
     // constraint check (Phase 4+). The bounds check compensates for the type looseness.
    if (expected.str_eq("USize") && actual.str_eq("I32")) {
        return true;
    }
     // Unsigned integer widening: smaller types are safely assignable to larger types.
    if (expected.str_eq("U16") && actual.str_eq("U8")) {
        return true;
    }
    if (expected.str_eq("U32") && (actual.str_eq("U8") || actual.str_eq("U16"))) {
        return true;
    }
    if (expected.str_eq("U64") && (actual.str_eq("U8") || actual.str_eq("U16") || actual.str_eq("U32"))) {
        return true;
    }
    if (expected.str_eq("U128") && (actual.str_eq("U8") || actual.str_eq("U16") || actual.str_eq("U32") || actual.str_eq("U64"))) {
        return true;
    }
    if (expected.str_eq("USize") && (actual.str_eq("U8") || actual.str_eq("U16") || actual.str_eq("U32") || actual.str_eq("U64"))) {
        return true;
    }
    false
}
fn is_type_variable_name(name: *Str) : Bool => {
    if (name.str_length() != 1) {
        return false;
    }
    let ch = char_code(name);
    (ch >= 65 && ch <= 90)
}
fn runtime_opaque_handle_compatible(expected: *Str, actual: *Str) : Bool => {
    if (actual.str_eq("I32") && (expected.str_eq("Vec") || expected.str_eq("Map") || expected.str_eq("Set"))) {
        return true;
    }
    if (expected.str_eq("I32") && (actual.str_eq("Vec") || actual.str_eq("Map") || actual.str_eq("Set"))) {
        return true;
    }
    false
}
fn type_names_compatible(expected: *Str, actual: *Str, rhs: I32) : Bool => {
    if (expected.str_eq("Unknown") || actual.str_eq("Unknown")) {
        return true;
    }
    if (expected.str_eq(actual)) {
        return true;
    }
    if (is_type_variable_name(expected) || is_type_variable_name(actual)) {
        return true;
    }
    if (runtime_opaque_handle_compatible(expected, actual)) {
        return true;
    }
    if (pointer_types_compatible(expected, actual)) {
        return true;
    }
    if (numeric_types_compatible(expected, actual, rhs)) {
        return true;
    }
    false
}
fn infer_expr_type_name(n: I32, fn_return_types: Map, local_types: Map) : *Str => {
    if (n = = 0) {
        return "Unknown";
    }
    let kind = node_kind(n);
    if (kind = = 20) {
        let text = get_interned_str(node_get_data1(n));
        if (str_ends_with_local(text, "USize")) {
            return "USize";
        }
        if (str_ends_with_local(text, "ISize")) {
            return "ISize";
        }
        if (str_ends_with_local(text, "U128")) {
            return "U128";
        }
        if (str_ends_with_local(text, "I128")) {
            return "I128";
        }
        if (str_ends_with_local(text, "U64")) {
            return "U64";
        }
        if (str_ends_with_local(text, "I64")) {
            return "I64";
        }
        if (str_ends_with_local(text, "U32")) {
            return "U32";
        }
        if (str_ends_with_local(text, "I32")) {
            return "I32";
        }
        if (str_ends_with_local(text, "U16")) {
            return "U16";
        }
        if (str_ends_with_local(text, "I16")) {
            return "I16";
        }
        if (str_ends_with_local(text, "U8")) {
            return "U8";
        }
        if (str_ends_with_local(text, "I8")) {
            return "I8";
        }
        return "I32";
    }
    if (kind = = 21) {
        return "Bool";
    }
    if (kind = = 22) {
        return "*Str";
    }
    if (kind = = 23) {
        return "Char";
    }
    if (kind = = 24) {
        let name = get_interned_str(node_get_data1(n));
        if (local_types.map_has(name)) {
            return local_types.map_get(name);
        }
        if (tc_global_value_types.map_has(name)) {
            return tc_global_value_types.map_get(name);
        }
        return "Unknown";
    }
    if (kind = = 26) {
        let op = get_interned_str(node_get_data1(n));
        let inner = infer_expr_type_name(node_get_data2(n), fn_return_types, local_types);
        if (op.str_eq("&")) {
            return "*".str_concat(inner);
        }
        if (op.str_eq("&mut")) {
            return "*mut ".str_concat(inner);
        }
        if (op.str_eq("!")) {
            return "Bool";
        }
        return inner;
    }
    if (kind = = 25) {
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("==") || op.str_eq("!=") || op.str_eq("<") || op.str_eq("<=") || op.str_eq(">") || op.str_eq(">=") || op.str_eq("&&") || op.str_eq("||")) {
            return "Bool";
        }
        if (op.str_eq("..")) {
            return "Iter";
        }
        return infer_expr_type_name(node_get_data2(n), fn_return_types, local_types);
    }
    if (kind = = 27) {
        let callee = node_get_data1(n);
        if (node_kind(callee) = = 24) {
            let fname = get_interned_str(node_get_data1(callee));
            if (fname.str_eq("into") && node_get_data3(n) = = 1) {
                let type_args = node_get_data4(n);
                if (type_args.vec_length() = = 1 && node_kind(type_args.vec_get(0)) = = NK_NAMED_TYPE)
                {
                    let cname = get_interned_str(node_get_data1(type_args.vec_get(0)));
                    return "__dyn_".str_concat(cname);
                }
                return "Unknown";
            }
            if (fn_return_types.map_has(fname)) {
                return fn_return_types.map_get(fname);
            }
        }
         // Handle method calls: obj.method() → look up method's return type
        if (node_kind(callee) = = NK_MEMBER_EXPR) {
            let method_name = get_interned_str(node_get_data2(callee));
            if (fn_return_types.map_has(method_name)) {
                return fn_return_types.map_get(method_name);
            }
        }
    }
    if (kind = = NK_TUPLE_EXPR) {
        return "Unknown";
    }
    "Unknown"
}
fn expr_is_number_literal_nonzero(n: I32) : Bool => {
    if (n = = 0 || node_kind(n) != NK_NUMBER_LIT) {
        return false;
    }
    !get_interned_str(node_get_data1(n)).str_eq("0")
}
fn is_decimal_digits(s: *Str) : Bool => {
    let i = 0;
    if (s.str_length() = = 0) {
        return false;
    }
    while (i < s.str_length()) {
        let ch = s.str_char_at(i);
        if (ch < 48 || ch > 57) {
            return false;
        }
        i = i + 1;
    }
    true
}
fn try_get_decimal_literal_value(n: I32) : I32 => {
    if (n = = 0 || node_kind(n) != NK_NUMBER_LIT) {
        return 0;
    }
    let text = get_interned_str(node_get_data1(n));
    if (!is_decimal_digits(text)) {
        return 0;
    }
    parse_int(text)
}
 // Returns the known I32 value for a node: either a decimal literal or a variable with a tracked
 // literal assignment. Returns a sentinel value of -2147483649 (impossible I32) when unknown.
fn try_get_known_int_value(n: I32) : I32 => {
    if (n = = 0) {
        return - 2147483649;
    }
    let k = node_kind(n);
    if (k = = NK_NUMBER_LIT) {
        let text = get_interned_str(node_get_data1(n));
        if (is_decimal_digits(text)) {
            return parse_int(text);
        }
        return - 2147483649;
    }
    if (k = = NK_IDENTIFIER) {
        let vname = get_interned_str(node_get_data1(n));
        if (tc_var_literal_values.map_has(vname)) {
            return tc_var_literal_values.map_get(vname);
        }
    }
    -2147483649
}
fn known_int_value_is_valid(v: I32) : Bool => {
     // The sentinel -2147483649 cannot be represented as I32 in JS (it's a float), but
     // we use it as a distinct out-of-band marker. In JS, parseInt returns it fine.
     // A simpler check: any value in [-2147483648, 2147483647] is a valid I32.
    v >= -2147483648 && v <= 2147483647
}
fn is_decimal_zero_literal(n: I32) : Bool => {
    if (n = = 0 || node_kind(n) != NK_NUMBER_LIT) {
        return false;
    }
    get_interned_str(node_get_data1(n)).str_eq("0")
}
 // Temporary typecheck context maps used for strict array bounds proofs.
let tc_array_init_bounds : Map = map_new();
let tc_index_upper_bounds : Map = map_new();
 // Path-sensitive call-bound facts: varName -> "fnName:argK" (e.g. "p" -> "str_length:s").
 // Populated by if-condition narrowing for patterns like `if (i < str_length(s))`.
let tc_call_bounds : Map = map_new();
 // Maps function name -> Vec<*Str> of per-param call-bound constraints ("fnName:refParamIdx" or "").
let fn_param_call_bounds : Map = map_new();
 // Maps variable names to their known literal I32 values for richer overflow diagnostics.
let tc_var_literal_values : Map = map_new();
let tc_global_value_types : Map = map_new();
let tc_alias_union_tags : Map = map_new();
let tc_type_alias_names : *mut Set = set_new();
let tc_dep_type_alias_params : Map = map_new();
 // alias_name -> expected arg count (I32)
let tc_contract_names : *mut Set = set_new();
let tc_destructor_alias_by_alias : Map = map_new();
let tc_destructor_alias_names : Vec = vec_new();
let tc_alias_base_type : Map = map_new();
 // Maps function name → Set of field names present in that function's `this` struct.
 // Only populated for functions that implicitly return `this` (no explicit return type).
let tc_fn_this_fields : Map = map_new();
fn type_node_is_destructor_receiver(t: I32, alias_name: *Str) : Bool => {
    if (t = = 0) {
        return false;
    }
     // Preferred form: alias receiver value (e.g. Alloc<...>)
    if (node_kind(t) = = NK_NAMED_TYPE && get_interned_str(node_get_data1(t)).str_eq(alias_name)) {
        return true;
    }
     // Back-compat: *move Alias
    if (node_kind(t) = = NK_POINTER_TYPE && node_get_data3(t) = = 1) {
        return type_name_from_type_node(node_get_data2(t)).str_eq(alias_name);
    }
    false
}
fn collect_union_named_tags(type_node: I32, tags: Vec) : I32 => {
    if (type_node = = 0) {
        return 0;
    }
    let kind = node_kind(type_node);
    if (kind = = NK_UNION_TYPE) {
        collect_union_named_tags(node_get_data1(type_node), tags);
        collect_union_named_tags(node_get_data2(type_node), tags);
        return 0;
    }
    if (kind = = NK_NAMED_TYPE) {
        tags.vec_push(get_interned_str(node_get_data1(type_node)));
        return 0;
    }
    if (kind = = NK_REFINEMENT_TYPE) {
        collect_union_named_tags(node_get_data1(type_node), tags);
    }
    0
}
fn try_get_nonnegative_integer_literal(n: I32) : I32 => {
    if (n = = 0 || node_kind(n) != NK_NUMBER_LIT) {
        return - 1;
    }
    let text = get_interned_str(node_get_data1(n));
    if (str_ends_with_local(text, "USize")) {
        let len = text.str_length();
        let raw = text.str_slice(0, len - 5);
        if (!is_decimal_digits(raw)) {
            return - 1;
        }
        return parse_int(raw);
    }
    if (!is_decimal_digits(text)) {
        return - 1;
    }
    parse_int(text)
}
fn try_get_array_init_bound_from_type_node(t: I32) : I32 => {
    if (t = = 0) {
        return - 1;
    }
    let k = node_kind(t);
    if (k = = NK_REFINEMENT_TYPE) {
        return try_get_array_init_bound_from_type_node(node_get_data1(t));
    }
    if (k = = NK_POINTER_TYPE) {
        return try_get_array_init_bound_from_type_node(node_get_data2(t));
    }
    if (k = = NK_ARRAY_TYPE) {
        return try_get_nonnegative_integer_literal(node_get_data2(t));
    }
    -1
}
fn try_get_index_upper_bound_from_type_node(t: I32) : I32 => {
    if (t = = 0 || node_kind(t) != NK_REFINEMENT_TYPE) {
        return - 1;
    }
    let base = node_get_data1(t);
    if (base = = 0 || node_kind(base) != NK_NAMED_TYPE) {
        return - 1;
    }
    let base_name = get_interned_str(node_get_data1(base));
    if (!base_name.str_eq("USize")) {
        return - 1;
    }
    let lit = try_get_nonnegative_integer_literal(node_get_data3(t));
    if (lit < 0) {
        return - 1;
    }
    let op = get_interned_str(node_get_data2(t));
    if (op.str_eq("<")) {
        return lit - 1;
    }
    if (op.str_eq("<=")) {
        return lit;
    }
    -1
}
fn is_zero_numeric_literal_node(n: I32) : Bool => {
    if (n = = 0 || node_kind(n) != NK_NUMBER_LIT) {
        return false;
    }
    let text = get_interned_str(node_get_data1(n));
    text.str_eq("0") || text.str_eq("0USize")
}
 // If `t` is a refinement type of the form `USize < fnName(paramName)`,
 // returns "fnName:paramName"; otherwise returns "".
fn try_extract_fn_call_constraint(t: I32) : *Str => {
    if (t = = 0 || node_kind(t) != NK_REFINEMENT_TYPE) {
        return "";
    }
    let base = node_get_data1(t);
    if (base = = 0 || node_kind(base) != NK_NAMED_TYPE) {
        return "";
    }
    let base_name = get_interned_str(node_get_data1(base));
    if (!base_name.str_eq("USize") && !base_name.str_eq("I32") && !base_name.str_eq("ISize")) {
        return "";
    }
    let op = get_interned_str(node_get_data2(t));
    if (!op.str_eq("<") && !op.str_eq("<=")) {
        return "";
    }
    let constraint_expr = node_get_data3(t);
    if (constraint_expr = = 0 || node_kind(constraint_expr) != NK_CALL_EXPR) {
        return "";
    }
    let callee = node_get_data1(constraint_expr);
    let args = node_get_data2(constraint_expr);
    if (callee = = 0 || node_kind(callee) != NK_IDENTIFIER) {
        return "";
    }
    if (args.vec_length() != 1) {
        return "";
    }
    let arg0 = args.vec_get(0);
    if (arg0 = = 0 || node_kind(arg0) != NK_IDENTIFIER) {
        return "";
    }
    let fn_name = get_interned_str(node_get_data1(callee));
    let ref_param_name = get_interned_str(node_get_data1(arg0));
    fn_name.str_concat(":").str_concat(ref_param_name)
}
fn expr_is_proven_nonzero(n: I32, nonnull_ptrs: Map) : Bool => {
    if (expr_is_number_literal_nonzero(n)) {
        return true;
    }
    if (n != 0 && node_kind(n) = = NK_IDENTIFIER) {
        let name = get_interned_str(node_get_data1(n));
        return nonnull_ptrs.map_has(name);
    }
    false
}
fn type_node_proves_nonzero(t: I32) : Bool => {
    if (t = = 0 || node_kind(t) != NK_REFINEMENT_TYPE) {
        return false;
    }
    let op = get_interned_str(node_get_data2(t));
    if (!op.str_eq("!=")) {
        return false;
    }
    is_zero_numeric_literal_node(node_get_data3(t))
}
fn typecheck_if_expr_branch(n: I32, fn_arities: Map, fn_param_types: Map, fn_return_types: Map,
local_types: Map, nonnull_ptrs: Map) : I32 => {
    let cond = node_get_data1(n);
    typecheck_expr(cond, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
    let cond_name = infer_expr_type_name(cond, fn_return_types, local_types);
    if (!cond_name.str_eq("Bool") && !cond_name.str_eq("Unknown")) {
        tc_panic_loc( "E_TYPE_IF_CONDITION", "if condition must be Bool, got ".str_concat(cond_name), "Conditional branches require a boolean predicate, but the given expression has a non-Bool type.", "Return or compute a Bool expression in the if condition." );
    }
    let ie_then_key = "";
    let ie_else_key = "";
    let ie_cb_key = "";
    let ie_cb_value = "";
    if (node_kind(cond) = = NK_BINARY_EXPR) {
        let bop = get_interned_str(node_get_data1(cond));
        let bleft = node_get_data2(cond);
        let bright = node_get_data3(cond);
        if (bop.str_eq("!=")) {
            if (ie_then_key.str_eq("") && node_kind(bleft) = = NK_IDENTIFIER && (is_usize_zero_literal_node(bright) || is_zero_numeric_literal_node(bright))) {
                ie_then_key = get_interned_str(node_get_data1(bleft));
            }
            if (ie_then_key.str_eq("") && node_kind(bright) = = NK_IDENTIFIER && (is_usize_zero_literal_node(bleft) || is_zero_numeric_literal_node(bleft))) {
                ie_then_key = get_interned_str(node_get_data1(bright));
            }
        }
        if (bop.str_eq("==")) {
            if (ie_else_key.str_eq("") && node_kind(bleft) = = NK_IDENTIFIER && is_zero_numeric_literal_node(bright)) {
                ie_else_key = get_interned_str(node_get_data1(bleft));
            }
            if (ie_else_key.str_eq("") && node_kind(bright) = = NK_IDENTIFIER && is_zero_numeric_literal_node(bleft)) {
                ie_else_key = get_interned_str(node_get_data1(bright));
            }
        }
        if ((bop.str_eq("<") || bop.str_eq("<=")) && node_kind(bleft) = = NK_IDENTIFIER && node_kind(bright) = = NK_CALL_EXPR) {
            let ie_cb_callee = node_get_data1(bright);
            let ie_cb_args = node_get_data2(bright);
            if (node_kind(ie_cb_callee) = = NK_IDENTIFIER && ie_cb_args.vec_length() = = 1 &&
            node_kind(ie_cb_args.vec_get(0)) = = NK_IDENTIFIER) {
                ie_cb_key = get_interned_str(node_get_data1(bleft));
                ie_cb_value = get_interned_str(node_get_data1(ie_cb_callee)).str_concat(":").str_concat(get_interned_str(node_get_data1(ie_cb_args.vec_get(0))));
            }
        }
    }
    let ie_then_present = false;
    if (!ie_then_key.str_eq("")) {
        ie_then_present = nonnull_ptrs.map_has(ie_then_key);
        nonnull_ptrs.map_set(ie_then_key, 1);
    }
    let ie_cb_was_present = false;
    if (!ie_cb_key.str_eq("")) {
        ie_cb_was_present = tc_call_bounds.map_has(ie_cb_key);
        tc_call_bounds.map_set(ie_cb_key, ie_cb_value);
    }
    typecheck_stmt(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, "Unknown");
    if (!ie_then_key.str_eq("") && !ie_then_present) {
        nonnull_ptrs.map_delete(ie_then_key);
    }
    if (!ie_cb_key.str_eq("") && !ie_cb_was_present) {
        tc_call_bounds.map_delete(ie_cb_key);
    }
    if (node_get_data3(n) != 0) {
        let ie_else_present = false;
        if (!ie_else_key.str_eq("")) {
            ie_else_present = nonnull_ptrs.map_has(ie_else_key);
            nonnull_ptrs.map_set(ie_else_key, 1);
        }
        typecheck_stmt(node_get_data3(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, "Unknown");
        if (!ie_else_key.str_eq("") && !ie_else_present) {
            nonnull_ptrs.map_delete(ie_else_key);
        }
    }
    0
}
fn typecheck_match_expr_branch(n: I32, fn_arities: Map, fn_param_types: Map, fn_return_types: Map,
local_types: Map, nonnull_ptrs: Map) : I32 => {
    let target = node_get_data1(n);
    typecheck_expr(target, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
    let target_name = infer_expr_type_name(target, fn_return_types, local_types);
    let expected_tags = vec_new();
    if (tc_alias_union_tags.map_has(target_name)) {
        expected_tags = tc_alias_union_tags.map_get(target_name);
    }
    let cases = node_get_data2(n);
    let i = 0;
    let len = cases.vec_length();
    let seen_tags = set_new();
    let has_wildcard = false;
    while (i < len) {
        let case_node = cases.vec_get(i);
        let pat = case_node.vec_get(0);
        if (node_kind(pat) = = NK_WILDCARD_PAT) {
            has_wildcard = true;
        }
        if (node_kind(pat) = = NK_NAME_PAT || node_kind(pat) = = NK_STRUCT_PAT) {
            seen_tags.set_add(get_interned_str(node_get_data1(pat)));
        }
        typecheck_stmt(case_node.vec_get(1), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, "Unknown");
        i = i + 1;
    }
    if (expected_tags.vec_length() > 0 && !has_wildcard) {
        let j = 0;
        let jlen = expected_tags.vec_length();
        while (j < jlen) {
            let tag = expected_tags.vec_get(j);
            if (!seen_tags.set_has(tag)) {
                tc_panic_loc( "E_TYPE_MATCH_NON_EXHAUSTIVE",
                "Non-exhaustive match: missing case for ".str_concat(tag), "A match expression over a known union type does not handle all variants.", "Add missing case arms or include a wildcard case '_'." );
            }
            j = j + 1;
        }
    }
    0
}
fn typecheck_if_stmt_branch(n: I32, fn_arities: Map, fn_param_types: Map, fn_return_types: Map,
local_types: Map, nonnull_ptrs: Map, expected_return_type: *Str) : I32 => {
    let cond = node_get_data1(n);
    typecheck_expr(cond, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
    let cond_name = infer_expr_type_name(cond, fn_return_types, local_types);
    if (!cond_name.str_eq("Bool") && !cond_name.str_eq("Unknown")) {
        tc_panic_loc( "E_TYPE_IF_CONDITION", "if condition must be Bool, got ".str_concat(cond_name),
        "Conditional branches require a boolean predicate, but the given expression has a non-Bool type.", "Return or compute a Bool expression in the if condition." );
    }
    let then_inject_key = "";
    let else_inject_key = "";
    let cb_then_key = "";
    let cb_then_value = "";
    if (node_kind(cond) = = NK_BINARY_EXPR) {
        let bop = get_interned_str(node_get_data1(cond));
        let bleft = node_get_data2(cond);
        let bright = node_get_data3(cond);
        if (bop.str_eq("!=")) {
            if (then_inject_key.str_eq("") && node_kind(bleft) = = NK_IDENTIFIER && (is_usize_zero_literal_node(bright) || is_zero_numeric_literal_node(bright))) {
                then_inject_key = get_interned_str(node_get_data1(bleft));
            }
            if (then_inject_key.str_eq("") && node_kind(bright) = = NK_IDENTIFIER && (is_usize_zero_literal_node(bleft) || is_zero_numeric_literal_node(bleft))) {
                then_inject_key = get_interned_str(node_get_data1(bright));
            }
        }
        if (bop.str_eq("==")) {
            if (else_inject_key.str_eq("") && node_kind(bleft) = = NK_IDENTIFIER && is_zero_numeric_literal_node(bright)) {
                else_inject_key = get_interned_str(node_get_data1(bleft));
            }
            if (else_inject_key.str_eq("") && node_kind(bright) = = NK_IDENTIFIER && is_zero_numeric_literal_node(bleft)) {
                else_inject_key = get_interned_str(node_get_data1(bright));
            }
        }
        if ((bop.str_eq("<") || bop.str_eq("<=")) && node_kind(bleft) = = NK_IDENTIFIER && node_kind(bright) = = NK_CALL_EXPR) {
            let cb_callee = node_get_data1(bright);
            let cb_args = node_get_data2(bright);
            if (node_kind(cb_callee) = = NK_IDENTIFIER && cb_args.vec_length() = = 1 &&
            node_kind(cb_args.vec_get(0)) = = NK_IDENTIFIER) {
                cb_then_key = get_interned_str(node_get_data1(bleft));
                cb_then_value = get_interned_str(node_get_data1(cb_callee)).str_concat(":").str_concat(get_interned_str(node_get_data1(cb_args.vec_get(0))));
            }
        }
    }
    let narrowed_ident = "";
    let had_prev_narrowed = 0;
    let prev_narrowed_type = "";
    if (node_kind(cond) = = NK_IS_EXPR) {
        let subject = node_get_data1(cond);
        let pat = node_get_data2(cond);
        if (node_kind(subject) = = NK_IDENTIFIER && (node_kind(pat) = = NK_NAME_PAT || node_kind(pat)
        = = NK_STRUCT_PAT)) {
            narrowed_ident = get_interned_str(node_get_data1(subject));
            let narrowed_type = get_interned_str(node_get_data1(pat));
            if (local_types.map_has(narrowed_ident)) {
                had_prev_narrowed = 1;
                prev_narrowed_type = local_types.map_get(narrowed_ident);
            }
            local_types.map_set(narrowed_ident, narrowed_type);
        }
    }
    let then_was_present = false;
    if (!then_inject_key.str_eq("")) {
        then_was_present = nonnull_ptrs.map_has(then_inject_key);
        nonnull_ptrs.map_set(then_inject_key, 1);
    }
    let cb_then_was_present = false;
    if (!cb_then_key.str_eq("")) {
        cb_then_was_present = tc_call_bounds.map_has(cb_then_key);
        tc_call_bounds.map_set(cb_then_key, cb_then_value);
    }
    typecheck_stmt(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types,
    nonnull_ptrs, expected_return_type);
    if (!then_inject_key.str_eq("") && !then_was_present) {
        nonnull_ptrs.map_delete(then_inject_key);
    }
    if (!cb_then_key.str_eq("") && !cb_then_was_present) {
        tc_call_bounds.map_delete(cb_then_key);
    }
    if (!narrowed_ident.str_eq("")) {
        if (had_prev_narrowed = = 1) {
            local_types.map_set(narrowed_ident, prev_narrowed_type);
        }
        else {
            local_types.map_set(narrowed_ident, "Unknown");
        }
    }
    if (node_get_data3(n) != 0) {
        let else_was_present = false;
        if (!else_inject_key.str_eq("")) {
            else_was_present = nonnull_ptrs.map_has(else_inject_key);
            nonnull_ptrs.map_set(else_inject_key, 1);
        }
        typecheck_stmt(node_get_data3(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs, expected_return_type);
        if (!else_inject_key.str_eq("") && !else_was_present) {
            nonnull_ptrs.map_delete(else_inject_key);
        }
    }
    0
}
fn typecheck_member_or_index_expr(n: I32, fn_arities: Map, fn_param_types: Map, fn_return_types:
Map, local_types: Map, nonnull_ptrs: Map) : I32 => {
    let kind = node_kind(n);
    if (kind = = NK_MEMBER_EXPR) {
        let obj = node_get_data1(n);
        let obj_name = infer_expr_type_name(obj, fn_return_types, local_types);
        if (is_nullable_pointer_type_name(obj_name)) {
            let guarded = false;
            if (node_kind(obj) = = NK_IDENTIFIER) {
                let oname = get_interned_str(node_get_data1(obj));
                guarded = nonnull_ptrs.map_has(oname);
            }
            if (!guarded) {
                tc_panic_loc( "E_SAFETY_NULLABLE_POINTER_GUARD", "Nullable pointer access requires guard", "A nullable pointer must be proven non-null before pointer-consuming operations.", "Guard with if (p != 0USize) or if (0USize != p) before member access." );
            }
        }
        if (obj_name.str_starts_with("__this_")) {
            let fn_name = obj_name.str_slice(7, obj_name.str_length());
            if (tc_fn_this_fields.map_has(fn_name)) {
                let field_names = tc_fn_this_fields.map_get(fn_name);
                let field = get_interned_str(node_get_data2(n));
                if (!field_names.set_has(field)) {
                    tc_panic_loc( "E_TYPE_MEMBER_NOT_FOUND", "Field '".str_concat(field).str_concat("' does not exist on '").str_concat(fn_name).str_concat("' scope"), "The function's 'this' struct does not declare the accessed field.", "Check that the field is declared in the function body or use a different access path." );
                }
            }
        }
        typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        return 1;
    }
    if (kind = = NK_INDEX_EXPR) {
        let target_node = node_get_data1(n);
        let target_name = infer_expr_type_name(target_node, fn_return_types, local_types);
        if (is_nullable_pointer_type_name(target_name)) {
            let guarded = false;
            if (node_kind(target_node) = = NK_IDENTIFIER) {
                let tname = get_interned_str(node_get_data1(target_node));
                guarded = nonnull_ptrs.map_has(tname);
            }
            if (!guarded) {
                tc_panic_loc( "E_SAFETY_NULLABLE_POINTER_GUARD", "Nullable pointer indexing requires guard", "A nullable pointer must be proven non-null before pointer-consuming operations.", "Guard with if (p != 0USize) or if (0USize != p) before indexing." );
            }
        }
        if (node_kind(target_node) = = NK_IDENTIFIER) {
            let tname = get_interned_str(node_get_data1(target_node));
            if (tc_array_init_bounds.map_has(tname)) {
                let bound = tc_array_init_bounds.map_get(tname);
                if (bound >= 0) {
                    let index_node = node_get_data2(n);
                    let index_max = -1;
                    if (node_kind(index_node) = = NK_IDENTIFIER) {
                        let iname = get_interned_str(node_get_data1(index_node));
                        if (tc_index_upper_bounds.map_has(iname)) {
                            index_max = tc_index_upper_bounds.map_get(iname);
                        }
                    }
                    if (index_max < 0) {
                        index_max = try_get_nonnegative_integer_literal(index_node);
                    }
                    if (index_max < 0) {
                        tc_panic_loc( "E_SAFETY_ARRAY_BOUNDS_UNPROVEN", "Cannot prove array index bound safety", "The array index does not have a proven upper bound under strict safety checks.", "Guard index with 'if (i < arr.length)' before indexing." );
                    }
                    if (index_max >= bound) {
                        tc_panic_loc( "E_SAFETY_ARRAY_BOUNDS", "Array index may be out of bounds", "The proven index upper bound can exceed initialized array length.", "Ensure 0 <= index < initialized length." );
                    }
                }
            }
        }
        typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        typecheck_expr(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        return 1;
    }
    0
}
fn typecheck_expr(n: I32, fn_arities: Map, fn_param_types: Map, fn_return_types: Map, local_types:
Map, nonnull_ptrs: Map) : I32 => {
    if (n = = 0) {
        return 0;
    }
    tc_current_node = n;
    let kind = node_kind(n);
    if (kind = = NK_BINARY_EXPR) {
        typecheck_expr(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        typecheck_expr(node_get_data3(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("/") && !expr_is_proven_nonzero(node_get_data3(n), nonnull_ptrs)) {
            let denom_node = node_get_data3(n);
            let denom_desc = "denominator";
            if (node_kind(denom_node) = = NK_IDENTIFIER) {
                denom_desc = "denominator `".str_concat(get_interned_str(node_get_data1(denom_node))).str_concat("`");
            }
            tc_panic_loc( "E_SAFETY_DIV_BY_ZERO",
            "Division by zero cannot be ruled out at compile time", "The ".str_concat(denom_desc).str_concat(" is not proven non-zero; any value including 0 is possible."), "Prove denominator != 0 via refinement type or control-flow guard." );
        }
        if (op.str_eq("%") && !expr_is_proven_nonzero(node_get_data3(n), nonnull_ptrs)) {
            let mod_node = node_get_data3(n);
            let mod_desc = "modulo denominator";
            if (node_kind(mod_node) = = NK_IDENTIFIER) {
                mod_desc = "modulo denominator `".str_concat(get_interned_str(node_get_data1(mod_node))).str_concat("`");
            }
            tc_panic_loc(
            "E_SAFETY_MOD_BY_ZERO", "Modulo by zero cannot be ruled out at compile time", "The ".str_concat(mod_desc).str_concat(" is not proven non-zero; any value including 0 is possible."), "Prove denominator != 0 via refinement type or control-flow guard."
            );
        }
        if (op.str_eq("+") || op.str_eq("-") || op.str_eq("*")) {
            let lnode = node_get_data2(n);
            let rnode = node_get_data3(n);
            let left = try_get_known_int_value(lnode);
            let right = try_get_known_int_value(rnode);
            if (known_int_value_is_valid(left) && known_int_value_is_valid(right)) {
                let result = 0;
                if (op.str_eq("+")) {
                    result = left + right;
                }
                else if (op.str_eq("-")) {
                    result = left - right;
                }
                else {
                    result = left * right;
                }
                if (result < -2147483648 || result > 2147483647) {
                    let left_desc = int_to_string(left);
                    let right_desc = int_to_string(right);
                    if (node_kind(lnode) = = NK_IDENTIFIER) {
                        left_desc = get_interned_str(node_get_data1(lnode)).str_concat("=").str_concat(int_to_string(left));
                    }
                    if (node_kind(rnode) = = NK_IDENTIFIER) {
                        right_desc = get_interned_str(node_get_data1(rnode)).str_concat("=").str_concat(int_to_string(right));
                    }
                    let witness = left_desc.str_concat(" ").str_concat(op).str_concat(" ").str_concat(right_desc).str_concat(" = ").str_concat(int_to_string(result)).str_concat(", which is outside I32 range [-2147483648, 2147483647]");
                    tc_panic_loc( "E_SAFETY_INTEGER_OVERFLOW",
                    "Integer overflow/underflow proven possible for '".str_concat(op).str_concat("'"), witness, "Constrain operands or use a wider intermediate type before narrowing." );
                }
            }
        }
        return 0;
    }
    if (kind = = NK_UNARY_EXPR || kind = = NK_UNWRAP_EXPR) {
        if (kind = = NK_UNARY_EXPR) {
            typecheck_expr(node_get_data2(n), fn_arities, fn_param_types, fn_return_types,
            local_types, nonnull_ptrs);
        }
        else {
            typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types,
            local_types, nonnull_ptrs);
        }
        return 0;
    }
    if (kind = = NK_CALL_EXPR) {
        let callee = node_get_data1(n);
        let args = node_get_data2(n);
        let arg_count = args.vec_length();
        let fname = "";
        if (node_kind(callee) = = NK_IDENTIFIER) {
            fname = get_interned_str(node_get_data1(callee));
            if (fname.str_eq("drop")) {
                if (arg_count != 1) {
                    tc_panic_loc( "E_TYPE_ARG_COUNT",
                    "drop expects exactly one argument", "The drop builtin requires one argument representing the value to drop.", "Call drop(value) with exactly one argument." );
                }
                let target = args.vec_get(0);
                let target_name = infer_expr_type_name(target, fn_return_types, local_types);
                if (!tc_destructor_alias_by_alias.map_has(target_name)) {
                    tc_panic_loc( "E_TYPE_DESTRUCTOR_NOT_FOUND", "Type '".str_concat(target_name).str_concat("' does not have an associated destructor"), "drop can only be called for values whose alias type declares a destructor.",
                    "Define `type Alias = Base then destructorName;` and use that alias for dropped values." );
                }
                return 0;
            }
            if (fname.str_eq("into") && node_get_data3(n) = = 1) {
                if (arg_count < 1) {
                    tc_panic_loc( "E_TYPE_ARG_COUNT",
                    "into conversion requires a receiver", "Method-sugar into conversion requires a source value as receiver.", "Use value.into<Contract>(...) with a receiver value." );
                }
                let type_args = node_get_data4(n);
                let cname = "";
                if (type_args.vec_length() = = 1 && node_kind(type_args.vec_get(0)) = = NK_NAMED_TYPE)
                {
                    cname = get_interned_str(node_get_data1(type_args.vec_get(0)));
                }
                let cname_label = cname;
                if (cname_label.str_eq("")) {
                    cname_label = "<missing>";
                }
                if (cname.str_eq("") || !tc_contract_names.set_has(cname)) {
                    tc_panic_loc( "E_TYPE_INTO_UNKNOWN_CONTRACT",
                    "Unknown contract '".str_concat(cname_label).str_concat("' in into conversion"), "An into conversion referenced a contract that is not declared.", "Declare the contract before converting with into." );
                }
                typecheck_expr(args.vec_get(0), fn_arities, fn_param_types, fn_return_types,
                local_types, nonnull_ptrs);
                let j = 1;
                while (j < arg_count) {
                    typecheck_expr(args.vec_get(j), fn_arities, fn_param_types, fn_return_types,
                    local_types, nonnull_ptrs);
                    j = j + 1;
                }
                return 0;
            }
            if (fn_arities.map_has(fname)) {
                let expected = fn_arities.map_get(fname);
                if (expected != arg_count) {
                    let msg = "Function ".str_concat(fname).str_concat(" expects ".str_concat(int_to_string(expected))).str_concat(" args, got ".str_concat(int_to_string(arg_count)));
                    tc_panic_loc( "E_TYPE_ARG_COUNT", msg, "A function call provided a different number of arguments than the function signature requires.",
                    "Pass exactly the number of parameters declared by the function." );
                }
            }
             // Dep-alias type application in expression position: arity check.
             // e.g. str_char_at(s, Index())  — Index is a dep alias, not a function.
            if (!fn_arities.map_has(fname) && tc_dep_type_alias_params.map_has(fname)) {
                let expected_arity = tc_dep_type_alias_params.map_get(fname);
                if (arg_count != expected_arity) {
                    tc_panic_loc(
                    "E_TYPE_APPLIED_ARITY", "'".str_concat(fname).str_concat("' applied with ").str_concat(int_to_string(arg_count)).str_concat(" argument(s), expected ").str_concat(int_to_string(expected_arity)), "Dependent type aliases must be applied with exactly the number of arguments declared in the type parameter list.", "Provide exactly ".str_concat(int_to_string(expected_arity)).str_concat(" argument(s) to '").str_concat(fname).str_concat("'.")
                    );
                }
            }
            if (fn_param_types.map_has(fname)) {
                let expected_types = fn_param_types.map_get(fname);
                let j = 0;
                while (j < arg_count) {
                    let arg_node = args.vec_get(j);
                    let arg_name = infer_expr_type_name(arg_node, fn_return_types, local_types);
                    let expected_name = expected_types.vec_get(j);
                    if ( expected_name.str_starts_with("*") && is_nullable_pointer_type_name(arg_name) ) {
                        tc_panic_loc( "E_SAFETY_NULLABLE_POINTER_GUARD", "Call requires nullable pointer guard", "A nullable pointer argument must be proven non-null before pointer-consuming calls.",
                        "Guard pointer use with if (p != 0USize) or if (0USize != p) before the call." );
                    }
                    if (!type_names_compatible(expected_name, arg_name, arg_node) &&
                    !tc_type_alias_names.set_has(expected_name)) {
                        let msg = "Type mismatch in call to ".str_concat(fname) .str_concat(" arg ").str_concat(int_to_string(j + 1)) .str_concat(": expected ").str_concat(expected_name)
                        .str_concat(", got ").str_concat(arg_name);
                        tc_panic_loc( "E_TYPE_ARG_MISMATCH", msg,
                        "A function argument type does not match the corresponding parameter type.", "Update the call argument or function parameter type so both sides are compatible." );
                    }
                    j = j + 1;
                }
            }
             // Call-bound constraint verification.
             // For each parameter with a call-bound constraint (e.g. index: USize < str_length(this)),
             // verify the corresponding argument has a proven bound matching the constraint via tc_call_bounds.
            if (fn_param_call_bounds.map_has(fname)) {
                let call_bounds_vec = fn_param_call_bounds.map_get(fname);
                let cj = 0;
                while (cj < call_bounds_vec.vec_length() && cj < arg_count) {
                    let cb = call_bounds_vec.vec_get(cj);
                    if (!cb.str_eq("")) {
                         // cb = "fnName:refParamIdx"
                        let cb_sep = cb.str_index_of(":");
                        let cb_fn = cb.str_slice(0, cb_sep);
                        let cb_ref_idx = parse_int(cb.str_slice(cb_sep + 1, cb.str_length()));
                        let constrained_arg = args.vec_get(cj);
                        if (node_kind(constrained_arg) = = NK_IDENTIFIER && cb_ref_idx >= 0 &&
                        cb_ref_idx < arg_count) {
                            let constrained_name =
                            get_interned_str(node_get_data1(constrained_arg));
                            let ref_arg = args.vec_get(cb_ref_idx);
                            if (node_kind(ref_arg) = = NK_IDENTIFIER) {
                                let ref_arg_name = get_interned_str(node_get_data1(ref_arg));
                                let expected_bound = cb_fn.str_concat(":").str_concat(ref_arg_name);
                                let proven = tc_call_bounds.map_has(constrained_name) &&
                                tc_call_bounds.map_get(constrained_name).str_eq(expected_bound);
                                if (!proven) {
                                    let msg = "Call to '".str_concat(fname) .str_concat("' argument ").str_concat(int_to_string(cj + 1)) .str_concat(" ('").str_concat(constrained_name).str_concat("')") .str_concat(" must be proven < ").str_concat(cb_fn)
                                    .str_concat("(").str_concat(ref_arg_name).str_concat(")");
                                    tc_panic_loc( "E_SAFETY_STR_BOUNDS_UNPROVEN", msg,
                                    "The argument does not have a proven upper bound matching the parameter constraint.", "Guard the call with 'if (".str_concat(constrained_name).str_concat(" < ").str_concat(cb_fn).str_concat("(").str_concat(ref_arg_name).str_concat("))' before calling ").str_concat(fname).str_concat(".") );
                                }
                            }
                        }
                    }
                    cj = cj + 1;
                }
            }
        }
        typecheck_expr(callee, fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        let i = 0;
        while (i < arg_count) {
            typecheck_expr(args.vec_get(i), fn_arities, fn_param_types, fn_return_types,
            local_types, nonnull_ptrs);
            i = i + 1;
        }
        return 0;
    }
    if (typecheck_member_or_index_expr(n, fn_arities, fn_param_types, fn_return_types, local_types,
    nonnull_ptrs) = = 1) {
        return 0;
    }
    if (kind = = NK_STRUCT_INIT) {
        let fields = node_get_data2(n);
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            typecheck_expr(field.vec_get(1), fn_arities, fn_param_types, fn_return_types,
            local_types, nonnull_ptrs);
            i = i + 1;
        }
        return 0;
    }
    if (kind = = NK_TUPLE_EXPR) {
        let items = node_get_data1(n);
        let i = 0;
        let len = items.vec_length();
        while (i < len) {
            typecheck_expr(items.vec_get(i), fn_arities, fn_param_types, fn_return_types,
            local_types, nonnull_ptrs);
            i = i + 1;
        }
        return 0;
    }
    if (kind = = NK_IF_EXPR) {
        typecheck_if_expr_branch(n, fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        return 0;
    }
    if (kind = = NK_MATCH_EXPR) {
        typecheck_match_expr_branch(n, fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        return 0;
    }
    if (kind = = NK_IS_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        return 0;
    }
    0
}
fn typecheck_stmt(n: I32, fn_arities: Map, fn_param_types: Map, fn_return_types: Map, local_types:
Map, nonnull_ptrs: Map, expected_return_type: *Str) : I32 => {
    if (n = = 0) {
        return 0;
    }
    tc_current_node = n;
    let kind = node_kind(n);
    if (kind = = NK_BLOCK) {
        let stmts = node_get_data1(n);
        let i = 0;
        let len = stmts.vec_length();
        while (i < len) {
            typecheck_stmt(stmts.vec_get(i), fn_arities, fn_param_types, fn_return_types,
            local_types, nonnull_ptrs, expected_return_type);
            i = i + 1;
        }
        return 0;
    }
    if (kind = = NK_EXPECT_FN_DECL) {
        return 0;
    }
    if (kind = = NK_CONTRACT_DECL) {
        return 0;
    }
    if (kind = = NK_FN_DECL || kind = = NK_CLASS_FN_DECL || kind = = NK_ACTUAL_FN_DECL) {
        let prev_array_bounds = tc_array_init_bounds;
        let prev_index_bounds = tc_index_upper_bounds;
        let prev_var_literals = tc_var_literal_values;
        tc_array_init_bounds = map_new();
        tc_index_upper_bounds = map_new();
        tc_var_literal_values = map_new();
        let fn_local_types = map_new();
        let fn_nonnull_ptrs = map_new();
        let params = node_get_data3(n);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let p = params.vec_get(i);
            let pname = get_interned_str(p.vec_get(0));
            let ptype = p.vec_get(1);
            if (ptype != 0) {
                fn_local_types.map_set(pname, type_name_from_type_node(ptype));
                let arr_init_bound = try_get_array_init_bound_from_type_node(ptype);
                if (arr_init_bound >= 0) {
                    tc_array_init_bounds.map_set(pname, arr_init_bound);
                }
                let index_upper_bound = try_get_index_upper_bound_from_type_node(ptype);
                if (index_upper_bound >= 0) {
                    tc_index_upper_bounds.map_set(pname, index_upper_bound);
                }
                if (type_node_proves_nonzero(ptype)) {
                    fn_nonnull_ptrs.map_set(pname, 1);
                }
            }
            i = i + 1;
        }
        let expected_name = type_name_from_type_node(node_get_data4(n));
         // If function has no explicit return type, check if it terminates with `this`.
         // If so, model its return type as "__this_<name>" and track its this-struct fields.
        let fn_body = node_get_data5(n);
        let fname_str = get_interned_str(node_get_data1(n));
        let has_this_param = false;
        let pi = 0;
        while (pi < params.vec_length()) {
            if (get_interned_str(params.vec_get(pi).vec_get(0)).str_eq("this")) {
                has_this_param = true;
            }
            pi = pi + 1;
        }
        if (!has_this_param && node_get_data4(n) = = 0) {
            let terminates_with_this = false;
            if (node_kind(fn_body) = = NK_BLOCK) {
                let body_stmts = node_get_data1(fn_body);
                let blen = body_stmts.vec_length();
                if (blen > 0) {
                    let last_stmt = body_stmts.vec_get(blen - 1);
                    if (node_kind(last_stmt) = = NK_EXPR_STMT) {
                        let last_expr = node_get_data1(last_stmt);
                        if (node_kind(last_expr) = = NK_IDENTIFIER && get_interned_str(node_get_data1(last_expr)).str_eq("this")) {
                            terminates_with_this = true;
                        }
                    }
                }
            }
            else if (node_kind(fn_body) = = NK_IDENTIFIER) {
                if (get_interned_str(node_get_data1(fn_body)).str_eq("this")) {
                    terminates_with_this = true;
                }
            }
            if (terminates_with_this) {
                let this_fields = set_new();
                this_fields.set_add("this");
                 // Add params (excluding 'this') to this-struct fields
                let qi = 0;
                while (qi < params.vec_length()) {
                    let pn = get_interned_str(params.vec_get(qi).vec_get(0));
                    if (!pn.str_eq("this")) {
                        this_fields.set_add(pn);
                    }
                    qi = qi + 1;
                }
                 // Add declared names from function body
                if (node_kind(fn_body) = = NK_BLOCK) {
                    let body_stmts = node_get_data1(fn_body);
                    let bi = 0;
                    let blen2 = body_stmts.vec_length();
                    while (bi < blen2) {
                        let bstmt = body_stmts.vec_get(bi);
                        let bkind = node_kind(bstmt);
                        if (bkind = = NK_LET_DECL) {
                            this_fields.set_add(get_interned_str(node_get_data1(bstmt)));
                        }
                        if (bkind = = NK_FN_DECL || bkind = = NK_CLASS_FN_DECL) {
                            this_fields.set_add(get_interned_str(node_get_data1(bstmt)));
                        }
                        bi = bi + 1;
                    }
                }
                tc_fn_this_fields.map_set(fname_str, this_fields);
                fn_return_types.map_set(fname_str, "__this_".str_concat(fname_str));
            }
        }
        typecheck_stmt(node_get_data5(n), fn_arities, fn_param_types, fn_return_types,
        fn_local_types, fn_nonnull_ptrs, expected_name);
        let body = node_get_data5(n);
        if (node_kind(body) != NK_BLOCK) {
            let body_name = infer_expr_type_name(body, fn_return_types, fn_local_types);
            if (!type_names_compatible(expected_name, body_name, body)) {
                let fname = get_interned_str(node_get_data1(n));
                tc_panic_loc( "E_TYPE_RETURN_MISMATCH", "Function ".str_concat(fname).str_concat(" return type mismatch: expected ").str_concat(expected_name).str_concat(", got ").str_concat(body_name),
                "The function body expression type does not match the declared return type.", "Update the function return type annotation or adjust the returned expression." );
            }
        }
        tc_array_init_bounds = prev_array_bounds;
        tc_index_upper_bounds = prev_index_bounds;
        tc_var_literal_values = prev_var_literals;
        return 0;
    }
    if (kind = = NK_LET_DECL) {
        let declared_type = node_get_data2(n);
        let rhs = node_get_data3(n);
        typecheck_expr(rhs, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
        let rhs_name = infer_expr_type_name(rhs, fn_return_types, local_types);
        if (declared_type != 0) {
            let declared_name = type_name_from_type_node(declared_type);
            if (!declared_name.str_eq("Unknown") && !rhs_name.str_eq("Unknown") && !pointer_types_compatible(declared_name, rhs_name) && !numeric_types_compatible(declared_name, rhs_name, rhs) && !tc_type_alias_names.set_has(declared_name) && !is_this_return_type_for (rhs_name, declared_name)) {
                let vname = get_interned_str(node_get_data1(n));
                let msg = "Type mismatch for let ".str_concat(vname).str_concat(": expected ").str_concat(declared_name).str_concat(", got ").str_concat(rhs_name);
                tc_panic_loc( "E_TYPE_LET_MISMATCH",
                msg, "An explicit let type annotation does not match the assigned RHS expression type.", "Update the explicit type annotation or change the RHS expression to match." );
            }
            let lname = get_interned_str(node_get_data1(n));
            local_types.map_set(lname, declared_name);
            let arr_init_bound = try_get_array_init_bound_from_type_node(declared_type);
            if (arr_init_bound >= 0) {
                tc_array_init_bounds.map_set(lname, arr_init_bound);
            }
            let index_upper_bound = try_get_index_upper_bound_from_type_node(declared_type);
            if (index_upper_bound >= 0) {
                tc_index_upper_bounds.map_set(lname, index_upper_bound);
            }
        }
        else if (!rhs_name.str_eq("Unknown")) {
            local_types.map_set(get_interned_str(node_get_data1(n)), rhs_name);
        }
         // Track literal assignments for richer overflow witness messages.
        let lit_val = try_get_known_int_value(rhs);
        if (known_int_value_is_valid(lit_val)) {
            tc_var_literal_values.map_set(get_interned_str(node_get_data1(n)), lit_val);
        }
        return 0;
    }
    if (kind = = NK_EXTERN_IMPORT_DECL) {
        return 0;
    }
    if (kind = = NK_EXPR_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        return 0;
    }
    if (kind = = NK_ASSIGN_STMT) {
        let target = node_get_data1(n);
        let value = node_get_data2(n);
        typecheck_expr(target, fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        typecheck_expr(value, fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        if (node_kind(target) = = NK_IDENTIFIER) {
            let tname = get_interned_str(node_get_data1(target));
            if (local_types.map_has(tname)) {
                let expected_name = local_types.map_get(tname);
                let value_name = infer_expr_type_name(value, fn_return_types, local_types);
                if (!type_names_compatible(expected_name, value_name, value) &&
                !tc_type_alias_names.set_has(expected_name)) {
                    tc_panic_loc( "E_TYPE_ASSIGN_MISMATCH",
                    "Assignment mismatch for ".str_concat(tname).str_concat(": expected ").str_concat(expected_name).str_concat(", got ").str_concat(value_name), "The assigned value type is incompatible with the declared variable type.", "Assign a compatible value or change the variable type declaration." );
                }
            }
        }
        return 0;
    }
    if (kind = = NK_RETURN_STMT) {
        let value = node_get_data1(n);
        typecheck_expr(value, fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        if (!expected_return_type.str_eq("Unknown")) {
            let value_name = infer_expr_type_name(value, fn_return_types, local_types);
            if (!type_names_compatible(expected_return_type, value_name, value)) {
                tc_panic_loc( "E_TYPE_RETURN_MISMATCH",
                "Return type mismatch: expected ".str_concat(expected_return_type).str_concat(", got ").str_concat(value_name), "A return statement produced a value incompatible with the function's declared return type.", "Return a value of the declared type or adjust the function return annotation." );
            }
        }
        return 0;
    }
    if (kind = = NK_IF_STMT) {
        typecheck_if_stmt_branch(n, fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs, expected_return_type);
        return 0;
    }
    if (kind = = NK_FOR_STMT) {
        typecheck_expr(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        typecheck_expr(node_get_data3(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        typecheck_stmt(node_get_data4(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs, expected_return_type);
        return 0;
    }
    if (kind = = NK_WHILE_STMT) {
        let cond = node_get_data1(n);
        typecheck_expr(cond, fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs);
        let cond_name = infer_expr_type_name(cond, fn_return_types, local_types);
        if (!cond_name.str_eq("Bool") && !cond_name.str_eq("Unknown")) {
            tc_panic_loc( "E_TYPE_IF_CONDITION", "if condition must be Bool, got ".str_concat(cond_name),
            "Conditional branches require a boolean predicate, but the given expression has a non-Bool type.", "Return or compute a Bool expression in the condition." );
        }
         // Call-bound narrowing: inject `i < fnName(s)` fact into while body.
        let wh_cb_key = "";
        let wh_cb_value = "";
        if (node_kind(cond) = = NK_BINARY_EXPR) {
            let wh_bop = get_interned_str(node_get_data1(cond));
            let wh_bleft = node_get_data2(cond);
            let wh_bright = node_get_data3(cond);
            if ((wh_bop.str_eq("<") || wh_bop.str_eq("<=")) && node_kind(wh_bleft) = = NK_IDENTIFIER && node_kind(wh_bright) = = NK_CALL_EXPR) {
                let wh_callee = node_get_data1(wh_bright);
                let wh_args = node_get_data2(wh_bright);
                if (node_kind(wh_callee) = = NK_IDENTIFIER && wh_args.vec_length() = = 1 &&
                node_kind(wh_args.vec_get(0)) = = NK_IDENTIFIER) {
                    wh_cb_key = get_interned_str(node_get_data1(wh_bleft));
                    wh_cb_value = get_interned_str(node_get_data1(wh_callee)).str_concat(":").str_concat(get_interned_str(node_get_data1(wh_args.vec_get(0))));
                }
            }
        }
        let wh_cb_was_present = false;
        if (!wh_cb_key.str_eq("")) {
            wh_cb_was_present = tc_call_bounds.map_has(wh_cb_key);
            tc_call_bounds.map_set(wh_cb_key, wh_cb_value);
        }
        typecheck_stmt(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs, expected_return_type);
        if (!wh_cb_key.str_eq("") && !wh_cb_was_present) {
            tc_call_bounds.map_delete(wh_cb_key);
        }
        return 0;
    }
    if (kind = = NK_LOOP_STMT) {
        typecheck_stmt(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs, expected_return_type);
        return 0;
    }
    if (kind = = NK_LIFETIME_STMT) {
        typecheck_stmt(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types,
        nonnull_ptrs, expected_return_type);
        return 0;
    }
    if (kind = = NK_INTO_STMT) {
        let cname = get_interned_str(node_get_data1(n));
        if (!tc_contract_names.set_has(cname)) {
            tc_panic_loc(
            "E_TYPE_UNKNOWN_CONTRACT", "Unknown contract '".str_concat(cname).str_concat("' in into statement"), "An into statement referenced a contract that is not declared.", "Declare the contract before using 'into'."
            );
        }
        return 0;
    }
     // Register nested type aliases (e.g. inside fn body) so let-mismatch check recognises them.
    if (kind = = NK_TYPE_ALIAS) {
        let alias_name = get_interned_str(node_get_data1(n));
        tc_type_alias_names.set_add(alias_name);
        let destructor_name_idx = node_get_data5(n);
        if (destructor_name_idx != 0) {
            let destructor_name = get_interned_str(destructor_name_idx);
            tc_destructor_alias_by_alias.map_set(alias_name, destructor_name);
            tc_destructor_alias_names.vec_push(alias_name);
        }
        return 0;
    }
    if (kind = = NK_DEP_TYPE_ALIAS) {
        let alias_name = get_interned_str(node_get_data1(n));
        tc_type_alias_names.set_add(alias_name);
        let value_params = node_get_data2(n);
        tc_dep_type_alias_params.map_set(alias_name, value_params.vec_length());
        return 0;
    }
    if (kind = = NK_EXTERN_TYPE_DECL) {
        let alias_name = get_interned_str(node_get_data1(n));
        tc_type_alias_names.set_add(alias_name);
        let destructor_name_idx = node_get_data5(n);
        if (destructor_name_idx != 0) {
            let destructor_name = get_interned_str(destructor_name_idx);
            tc_destructor_alias_by_alias.map_set(alias_name, destructor_name);
            tc_destructor_alias_names.vec_push(alias_name);
        }
        return 0;
    }
     // Fallback: treat unmatched nodes as expressions.
    typecheck_expr(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
    0
}
out fn typecheck_program_with_options_impl(program: I32) : I32 => {
    let fn_arities = map_new();
    let fn_param_types = map_new();
    let fn_return_types = map_new();
    let fn_nodes = map_new();
    let local_types = map_new();
    tc_global_value_types = map_new();
    tc_alias_union_tags = map_new();
    tc_type_alias_names = set_new();
    tc_dep_type_alias_params = map_new();
    tc_contract_names = set_new();
    tc_destructor_alias_by_alias = map_new();
    tc_destructor_alias_names = vec_new();
    tc_fn_this_fields = map_new();
    tc_alias_base_type = map_new();
    tc_type_name_cache = map_new();
    tc_call_bounds = map_new();
    fn_param_call_bounds = map_new();
    let body = node_get_data1(program);
     // Collect function signatures (including extern fns).
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        let stmt = body.vec_get(i);
        let kind = node_kind(stmt);
        if (kind = = NK_FN_DECL || kind = = NK_CLASS_FN_DECL || kind = = NK_EXTERN_FN_DECL || kind = =
        NK_ACTUAL_FN_DECL) {
            let name = get_interned_str(node_get_data1(stmt));
            fn_nodes.map_set(name, stmt);
            let params = node_get_data3(stmt);
            fn_arities.map_set(name, params.vec_length());
            let param_types = vec_new();
            let param_call_bounds_vec = vec_new();
            let p = 0;
            while (p < params.vec_length()) {
                let param = params.vec_get(p);
                let param_type_node = param.vec_get(1);
                param_types.vec_push(type_name_from_type_node(param_type_node));
                let raw_constraint = try_extract_fn_call_constraint(param_type_node);
                if (!raw_constraint.str_eq("")) {
                     // Resolve ref param name to its index within this function's params.
                    let sep = raw_constraint.str_index_of(":");
                    let fn_part = raw_constraint.str_slice(0, sep);
                    let ref_name = raw_constraint.str_slice(sep + 1, raw_constraint.str_length());
                    let ref_idx = -1;
                    let pi = 0;
                    while (pi < params.vec_length()) {
                        let pi_name = get_interned_str(params.vec_get(pi).vec_get(0));
                        if (pi_name.str_eq(ref_name)) {
                            ref_idx = pi;
                        }
                        pi = pi + 1;
                    }
                    if (ref_idx >= 0) {
                        param_call_bounds_vec.vec_push(fn_part.str_concat(":").str_concat(int_to_string(ref_idx)));
                    }
                    else {
                        param_call_bounds_vec.vec_push("");
                    }
                }
                else {
                    param_call_bounds_vec.vec_push("");
                }
                p = p + 1;
            }
            fn_param_types.map_set(name, param_types);
            fn_param_call_bounds.map_set(name, param_call_bounds_vec);
            let ret_type = node_get_data4(stmt);
            fn_return_types.map_set(name, type_name_from_type_node(ret_type));
        }
        if (kind = = NK_EXTERN_LET_DECL) {
            let vname = get_interned_str(node_get_data1(stmt));
            let vtype = node_get_data2(stmt);
            let tname = type_name_from_type_node(vtype);
            local_types.map_set(vname, tname);
            tc_global_value_types.map_set(vname, tname);
        }
        if (kind = = NK_TYPE_ALIAS) {
            let alias_name = get_interned_str(node_get_data1(stmt));
            tc_type_alias_names.set_add(alias_name);
            let alias_type = node_get_data3(stmt);
            let tags = vec_new();
            collect_union_named_tags(alias_type, tags);
            if (tags.vec_length() > 0) {
                tc_alias_union_tags.map_set(alias_name, tags);
            }
            let destructor_name_idx = node_get_data5(stmt);
            if (destructor_name_idx != 0) {
                let destructor_name = get_interned_str(destructor_name_idx);
                tc_destructor_alias_by_alias.map_set(alias_name, destructor_name);
                tc_destructor_alias_names.vec_push(alias_name);
            }
            let alias_base_type = node_get_data3(stmt);
            let alias_base_type_name = type_name_from_type_node(alias_base_type);
            if (!alias_base_type_name.str_eq("Unknown")) {
                tc_alias_base_type.map_set(alias_name, alias_base_type_name);
            }
        }
        if (kind = = NK_DEP_TYPE_ALIAS) {
            let alias_name = get_interned_str(node_get_data1(stmt));
            tc_type_alias_names.set_add(alias_name);
            let value_params = node_get_data2(stmt);
            tc_dep_type_alias_params.map_set(alias_name, value_params.vec_length());
        }
        if (kind = = NK_EXTERN_TYPE_DECL) {
            let alias_name = get_interned_str(node_get_data1(stmt));
            tc_type_alias_names.set_add(alias_name);
            let destructor_name_idx = node_get_data5(stmt);
            if (destructor_name_idx != 0) {
                let destructor_name = get_interned_str(destructor_name_idx);
                tc_destructor_alias_by_alias.map_set(alias_name, destructor_name);
                tc_destructor_alias_names.vec_push(alias_name);
            }
        }
        if (kind = = NK_CONTRACT_DECL) {
            tc_contract_names.set_add(get_interned_str(node_get_data1(stmt)));
        }
        if (kind = = NK_LET_DECL) {
            let vname = get_interned_str(node_get_data1(stmt));
            let vtype = node_get_data2(stmt);
            if (vtype != 0) {
                tc_global_value_types.map_set(vname, type_name_from_type_node(vtype));
            }
        }
        i = i + 1;
    }
     // Validate destructor declarations/signatures irrespective of strict mode.
    i = 0;
    let destructor_alias_count = tc_destructor_alias_names.vec_length();
    while (i < destructor_alias_count) {
        let alias_name = tc_destructor_alias_names.vec_get(i);
        let destructor_name = tc_destructor_alias_by_alias.map_get(alias_name);
        if (!fn_nodes.map_has(destructor_name)) {
            tc_panic_loc( "E_TYPE_DESTRUCTOR_NOT_FOUND",
            "Destructor '".str_concat(destructor_name).str_concat("' for alias '").str_concat(alias_name).str_concat("' was not found"), "A type alias referenced a destructor function that does not exist.", "Declare the destructor function before using it in 'type Alias = ... then destructor'." );
        }
        let fn_node = fn_nodes.map_get(destructor_name);
        let params = node_get_data3(fn_node);
        let valid = true;
        if (params.vec_length() != 1) {
            valid = false;
        }
        else {
            let p0 = params.vec_get(0);
            let pname = get_interned_str(p0.vec_get(0));
            let ptype = p0.vec_get(1);
            if (!pname.str_eq("this")) {
                valid = false;
            }
            if (!type_node_is_destructor_receiver(ptype, alias_name)) {
                let ptype_name = type_name_from_type_node(ptype);
                let base_type_ok = tc_alias_base_type.map_has(alias_name) &&
                ptype_name.str_eq(tc_alias_base_type.map_get(alias_name));
                if (!base_type_ok) {
                    valid = false;
                }
            }
        }
        let ret_name = type_name_from_type_node(node_get_data4(fn_node));
        if (!ret_name.str_eq("Void") && !ret_name.str_eq("Unknown")) {
            valid = false;
        }
        if (!valid) {
            tc_panic_loc( "E_TYPE_DESTRUCTOR_SIGNATURE", "Destructor '".str_concat(destructor_name).str_concat("' must have signature fn ").str_concat(destructor_name).str_concat("(this : ").str_concat(alias_name).str_concat("<...>) : Void"),
            "Destructor signatures must follow the required receiver and return type contract.", "Use exactly one receiver parameter named 'this' with the alias type (or legacy '*move AliasType') and return Void." );
        }
        i = i + 1;
    }
     // Check calls across whole program.
    i = 0;
    while (i < len) {
        typecheck_stmt(body.vec_get(i), fn_arities, fn_param_types, fn_return_types, local_types, map_new(), "Unknown");
        i = i + 1;
    }
    program
}
out fn typecheck_program_impl(program: I32) : I32 => {
    typecheck_program_with_options_impl(program)
}
out fn selfhost_typecheck_impl_marker() : I32 => 0;
