 // ============================================================================
 // C Code Generation — selfhost port of codegen-c.ts
 // ============================================================================
 // ALL Tuff values are int64_t in C. Strings are int64_t handles via tuff_str().
 // The C substrate (substrate.h/c, strings.c, etc.) is always embedded inline.
 // ============================================================================
let {
    Ok, Err, Result
}
 = selfhost::Result;
let {
    CodegenError
}
 = selfhost::errors::CodegenError;
let {
    get_interned_str, vec_new, map_new, set_new, int_to_string
}
 = selfhost::runtime_lexer;
let {
    node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5
}
 = selfhost::parser_core;
 // ============================================================================
 // Global mutable state — reset at the start of each generate_c call
 // ============================================================================
let cc_temp_counter : I32 = 0;
let cc_enum_names : *mut Set<I32> = set_new();
let cc_enum_variant_consts : Map<I32, I32> = map_new();
 // variant → "EnumName_Variant"
let cc_struct_fields : Map<I32, I32> = map_new();
 // struct name → Vec<*Str> of field names
let cc_alias_by_variant : Map<I32, I32> = map_new();
 // variant struct name → union alias name
let cc_union_alias_info : Map<I32, I32> = map_new();
 // alias name → Vec<*Str> of variant names
let cc_covered_extern_fns : *mut Set<I32> = set_new();
let cc_local_types : Map<I32, I32> = map_new();
 // local var name → C type string (e.g. "TuffVec*")
let cc_fn_return_types : Map<I32, I32> = map_new();
 // function name → C return type string
let cc_emitted_tuff_error : I32 = 0;
let cc_inc_stdint : I32 = 1;
let cc_inc_stddef : I32 = 0;
let cc_inc_stdio : I32 = 0;
let cc_inc_stdlib : I32 = 0;
let cc_inc_string : I32 = 0;
let cc_inc_ctype : I32 = 0;
let cc_inc_errno : I32 = 0;
let cc_inc_direct : I32 = 0;
let cc_inc_sys_stat : I32 = 0;
let cc_inc_sys_types : I32 = 0;
let cc_disable_unicode_escape : I32 = 0;
 // ============================================================================
 // Helpers
 // ============================================================================
fn cc_next_temp(prefix: *Str) : *Str => {
    cc_temp_counter = cc_temp_counter + 1;
    "__".str_concat(prefix).str_concat("_").str_concat(int_to_string(cc_temp_counter))
}
fn cc_to_name(name: *Str) : *Str => {
    if (name.str_eq("main")) {
        "tuff_main"
    }
    else {
        name
    }
}
fn cc_str_ends_with(s: *Str, suffix: *Str) : Bool => {
    let sn = s.str_length();
    let tn = suffix.str_length();
    if (sn < tn) {
        return false;
    }
    if (sn == tn) {
        return s.str_slice(0, sn).str_eq(suffix);
    }
    false
}
fn cc_join_parts(parts: Vec<I32>) : *Str => {
    let sb = sb_new();
    let i = 0;
    let len = parts.vec_length();
    while (i < len) {
        if (i > 0) {
            sb_append(sb, "::");
        }
        sb_append(sb, get_interned_str(parts.vec_get(i)));
        i = i + 1;
    }
    sb_build(sb)
}
fn cc_mark_header_from_source(source: *Str) : I32 => {
    if (source.str_eq("stdio")) {
        cc_inc_stdio = 1;
        return 0;
    }
    if (source.str_eq("stdlib")) {
        cc_inc_stdlib = 1;
        return 0;
    }
    if (source.str_eq("string") || source.str_eq("strings")) {
        cc_inc_string = 1;
        return 0;
    }
    if (source.str_eq("stdint")) {
        cc_inc_stdint = 1;
        return 0;
    }
    if (source.str_eq("stddef")) {
        cc_inc_stddef = 1;
        return 0;
    }
    if (source.str_eq("errno")) {
        cc_inc_errno = 1;
        return 0;
    }
    if (source.str_eq("direct")) {
        cc_inc_direct = 1;
        return 0;
    }
    if (source.str_eq("sys::stat")) {
        cc_inc_sys_stat = 1;
        return 0;
    }
    if (source.str_eq("sys::types")) {
        cc_inc_sys_types = 1;
        return 0;
    }
     // Known non-header attribution buckets used for host/substrate symbols.
    if (source.str_eq("globalThis") || source.str_eq("substrate") || source.str_eq("host_c")) {
        return 0;
    }
     // Runtime module buckets — mark required headers, no special flags needed.
    if (source.str_eq("collections")) {
        cc_inc_stdlib = 1;
        return 0;
    }
    if (source.str_eq("io")) {
        cc_inc_stdio = 1;
        cc_inc_stdlib = 1;
        cc_inc_string = 1;
        return 0;
    }
    panic_with_code( "E_EXTERN_UNKNOWN_SOURCE",
    "Unknown extern source attribution: '".str_concat(source).str_concat("'"), "The C backend only supports a built-in set of extern source aliases for header mapping.", "Use a supported source alias (stdio, stdlib, string/strings, stdint, stddef, errno, direct, sys::stat, sys::types) or one of the runtime buckets (globalThis, substrate, host_c)." )
}
fn cc_require_substrate_headers() : I32 => {
     // Embedded substrate code depends on this baseline C runtime header set.
    cc_inc_stddef = 1;
    cc_inc_stdio = 1;
    cc_inc_stdlib = 1;
    cc_inc_string = 1;
    cc_inc_ctype = 1;
    cc_inc_errno = 1;
    cc_inc_direct = 1;
    cc_inc_sys_stat = 1;
    cc_inc_sys_types = 1;
    0
}
fn cc_emit_minimal_runtime_prelude() : *Str => {
    let sb = sb_new();
    sb_append(sb, "/* Built-in minimal runtime prelude (substrate-free path) */\n");
    sb_append(sb, "static inline int64_t tuff_to_val(const void* p) { return (int64_t)(intptr_t)p; }\n");
    sb_append(sb, "static inline void* tuff_from_val(int64_t v) { return (void*)(intptr_t)v; }\n");
    sb_append(sb, "static inline const char* tuff_str(int64_t v) { return v == 0 ? NULL : (const char*)(intptr_t)v; }\n");
    sb_append(sb, "static inline const char* tuff_str_or_empty(int64_t v) { const char* s = tuff_str(v); return s ? s : \"\"; }\n");
    sb_append(sb, "typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\n");
    sb_append(sb, "static void tuff_panic(const char* msg) { fprintf(stderr, \"[tuff panic] %s\\n\", msg); abort(); }\n");
    sb_append(sb, "\n/* String runtime function declarations and minimal implementations */\n");
    sb_append(sb, "int64_t str_length(int64_t this) { return (int64_t)strlen(tuff_str_or_empty(this)); }\n");
    sb_append(sb, "int64_t str_char_at(int64_t this, int64_t index) { const char* s = tuff_str(this); if (!s || index < 0 || index >= (int64_t)strlen(s)) return 0; return (int64_t)s[index]; }\n");
    sb_append(sb, "int64_t str_slice(int64_t this, int64_t start, int64_t end) { const char* s = tuff_str(this); if (!s || start < 0 || end < start) return 0; size_t len = strlen(s); if ((size_t)end > len) end = (int64_t)len; size_t n = (size_t)(end - start); char* out = (char*)malloc(n + 1); if (!out) return 0; strncpy(out, s + start, n); out[n] = '\\0'; return (int64_t)(intptr_t)out; }\n");
    sb_append(sb, "int64_t str_concat(int64_t a, int64_t b) { const char* as = tuff_str_or_empty(a); const char* bs = tuff_str_or_empty(b); size_t alen = strlen(as); size_t blen = strlen(bs); char* out = (char*)malloc(alen + blen + 1); if (!out) return 0; strcpy(out, as); strcat(out, bs); return (int64_t)(intptr_t)out; }\n");
    sb_append(sb, "int64_t str_eq(int64_t a, int64_t b) { const char* as = tuff_str_or_empty(a); const char* bs = tuff_str_or_empty(b); return strcmp(as, bs) == 0 ? 1 : 0; }\n");
    sb_append(sb, "int64_t str_from_char_code(int64_t code) { char* out = (char*)malloc(2); if (!out) return 0; out[0] = (char)(code & 0xFF); out[1] = '\\0'; return (int64_t)(intptr_t)out; }\n");
    sb_append(sb, "int64_t str_index_of(int64_t s, int64_t needle) { const char* str = tuff_str(s); const char* ndl = tuff_str(needle); if (!str || !ndl) return -1; const char* found = strstr(str, ndl); if (!found) return -1; return (int64_t)(found - str); }\n");
    sb_append(sb, "int64_t str_trim(int64_t s) { const char* str = tuff_str_or_empty(s); while (isspace(*str)) str++; const char* end = str + strlen(str); while (end > str && isspace(*(end - 1))) end--; size_t len = end - str; if (len == 0) return (int64_t)(intptr_t)\"\"; char* out = (char*)malloc(len + 1); if (!out) return 0; strncpy(out, str, len); out[len] = '\\0'; return (int64_t)(intptr_t)out; }\n");
    sb_append(sb, "int64_t str_replace_all(int64_t s, int64_t from, int64_t to) { const char* str = tuff_str_or_empty(s); const char* f = tuff_str_or_empty(from); const char* t = tuff_str_or_empty(to); if (strlen(f) == 0) return s; size_t buf_size = strlen(str) * 2 + 1; char* out = (char*)malloc(buf_size); if (!out) return 0; char* p = out; const char* q = str; while ((q = strstr(q, f)) != NULL) { strncat(p, str, q - str); strncat(p, t, strlen(t)); str = q + strlen(f); q = str; } strcat(p, str); return (int64_t)(intptr_t)out; }\n");
    sb_append(sb, "int64_t char_code(int64_t ch) { const char* s = tuff_str(ch); return s && *s ? (int64_t)*s : 0; }\n");
    sb_append(sb, "int64_t int_to_string(int64_t n) { char* out = (char*)malloc(32); if (!out) return 0; snprintf(out, 32, \"%lld\", (long long)n); return (int64_t)(intptr_t)out; }\n");
    sb_append(sb, "int64_t parse_int(int64_t s) { const char* str = tuff_str_or_empty(s); return (int64_t)atoll(str); }\n");
    sb_build(sb)
}
 // All Tuff types lower to int64_t, except:
 //   *[T; init; cap]  → TuffVec* (fat slice pointer)
 //   Alloc<T>         → transparent; recurse into T
 //   Void             → void
fn cc_type_to_c(type_node: I32) : *Str => {
    if (type_node == 0) {
        return "int64_t";
    }
    let kind = node_kind(type_node);
    if (kind == NK_POINTER_TYPE) {
        let inner = node_get_data2(type_node);
        if (inner != 0 && node_kind(inner) == NK_ARRAY_TYPE) {
            return "TuffVec*";
        }
        return "int64_t";
    }
    if (kind == NK_NAMED_TYPE) {
        let name = get_interned_str(node_get_data1(type_node));
        if (name.str_eq("Void")) {
            return "void";
        }
         // Alloc<T> is a transparent ownership wrapper — lower to T
        if (name.str_eq("Alloc")) {
            let generics = node_get_data2(type_node);
            if (generics != 0 && generics.vec_length() > 0) {
                return cc_type_to_c(generics.vec_get(0));
            }
            return "int64_t";
        }
        if (cc_union_alias_info.map_has(name)) {
            return name;
        }
        if (cc_struct_fields.map_has(name)) {
            return name;
        }
        if (cc_alias_by_variant.map_has(name)) {
            return cc_alias_by_variant.map_get(name);
        }
        return "int64_t";
    }
     // NK_REFINEMENT_TYPE (44): erase refinement, lower base type.
    if (kind == 44) {
        return cc_type_to_c(node_get_data1(type_node));
    }
    // NK_APPLIED_TYPE (71): value-level type application.
    // Erase value args but preserve nominal base when it is a known concrete type.
    if (kind == 71) {
        let base = get_interned_str(node_get_data1(type_node));
        if (cc_union_alias_info.map_has(base)) {
            return base;
        }
        if (cc_struct_fields.map_has(base)) {
            return base;
        }
        if (cc_alias_by_variant.map_has(base)) {
            return cc_alias_by_variant.map_get(base);
        }
        return "int64_t";
    }
    "int64_t"
}
fn cc_infer_expr_ctype(n: I32) : *Str => {
    if (n == 0) {
        return "int64_t";
    }
    let kind = node_kind(n);
    if (kind == NK_STRUCT_INIT) {
        let vname = get_interned_str(node_get_data1(n));
        if (cc_alias_by_variant.map_has(vname)) {
            return cc_alias_by_variant.map_get(vname);
        }
        return vname;
    }
     // malloc / realloc calls produce TuffVec* fat slice pointers
    if (kind == NK_CALL_EXPR) {
        let callee = node_get_data1(n);
        if (node_kind(callee) == NK_IDENTIFIER) {
            let cname = get_interned_str(node_get_data1(callee));
            if (cname.str_eq("malloc") || cname.str_eq("realloc")) {
                return "TuffVec*";
            }
            if (cc_fn_return_types.map_has(cname)) {
                return cc_fn_return_types.map_get(cname);
            }
        }
    }
    "int64_t"
}
fn cc_is_stdlib_builtin(name: *Str) : Bool => {
    name.str_eq("malloc") || name.str_eq("free") || name.str_eq("realloc") || name.str_eq("calloc") || name.str_eq("memcpy") || name.str_eq("memmove") || name.str_eq("memset") || name.str_eq("printf") || name.str_eq("fprintf") ||
    name.str_eq("fopen") || name.str_eq("fclose") || name.str_eq("fwrite") || name.str_eq("fread") || name.str_eq("fseek") || name.str_eq("ftell") || name.str_eq("strlen") || name.str_eq("strdup") || name.str_eq("strcpy") || name.str_eq("strcat") || name.str_eq("strncpy") || name.str_eq("strncat") ||
    name.str_eq("strcmp") || name.str_eq("strstr") || name.str_eq("strrchr") || name.str_eq("exit") || name.str_eq("abort")
}
 // ============================================================================
 // Context Pre-scan
 // ============================================================================
fn cc_flatten_union_variants(type_node: I32, names_vec: Vec<I32>) : I32 => {
    if (type_node == 0) {
        return 0;
    }
    let kind = node_kind(type_node);
    if (kind == NK_NAMED_TYPE) {
        names_vec.vec_push(get_interned_str(node_get_data1(type_node)));
        return 0;
    }
    if (kind == NK_UNION_TYPE) {
        cc_flatten_union_variants(node_get_data1(type_node), names_vec);
        cc_flatten_union_variants(node_get_data2(type_node), names_vec);
        return 0;
    }
    0
}
fn cc_init_context(program: I32) : I32 => {
    let stmts = node_get_data1(program);
    let len = stmts.vec_length();
    let i = 0;
    while (i < len) {
        let n = stmts.vec_get(i);
        let kind = node_kind(n);
        if (kind == NK_ENUM_DECL) {
            let enum_name = get_interned_str(node_get_data1(n));
            cc_enum_names.set_add(enum_name);
            let variants = node_get_data2(n);
            let j = 0;
            let vlen = variants.vec_length();
            while (j < vlen) {
                let v = get_interned_str(variants.vec_get(j));
                cc_enum_variant_consts.map_set(v, enum_name.str_concat("_").str_concat(v));
                j = j + 1;
            }
        }
        if (kind == NK_STRUCT_DECL) {
            let struct_name = get_interned_str(node_get_data1(n));
            let fields = node_get_data3(n);
            let field_names = vec_new();
            let j = 0;
            let flen = fields.vec_length();
            while (j < flen) {
                let f = fields.vec_get(j);
                field_names.vec_push(get_interned_str(f.vec_get(0)));
                j = j + 1;
            }
            cc_struct_fields.map_set(struct_name, field_names);
        }
        if (kind == NK_TYPE_ALIAS) {
            let alias_name = get_interned_str(node_get_data1(n));
            let aliased = node_get_data3(n);
            if (aliased != 0 && node_kind(aliased) == NK_UNION_TYPE) {
                let variants = vec_new();
                cc_flatten_union_variants(aliased, variants);
                let j = 0;
                let vlen = variants.vec_length();
                while (j < vlen) {
                    let v = variants.vec_get(j);
                    cc_alias_by_variant.map_set(v, alias_name);
                    j = j + 1;
                }
                cc_union_alias_info.map_set(alias_name, variants);
            }
        }
        if (kind == NK_EXTERN_IMPORT_DECL) {
            let names = node_get_data1(n);
            let j = 0;
            let nlen = names.vec_length();
            while (j < nlen) {
                cc_covered_extern_fns.set_add(get_interned_str(names.vec_get(j)));
                j = j + 1;
            }
            cc_mark_header_from_source(cc_join_parts(node_get_data2(n)));
        }
        i = i + 1;
    }
    i = 0;
    while (i < len) {
        let n = stmts.vec_get(i);
        let kind = node_kind(n);
        if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
            let source_name = get_interned_str(node_get_data1(n));
            let c_name = cc_to_name(source_name);
            let ret_ctype = cc_type_to_c(node_get_data4(n));
            cc_fn_return_types.map_set(source_name, ret_ctype);
            cc_fn_return_types.map_set(c_name, ret_ctype);
        }
        i = i + 1;
    }
    0
}
 // ============================================================================
 // C Pattern Guards (for match expressions)
 // ============================================================================
fn cc_emit_pattern_guard(target: *Str, pat: I32) : *Str => {
    let kind = node_kind(pat);
    if (kind == NK_WILDCARD_PAT) {
        return "1";
    }
    if (kind == NK_LITERAL_PAT) {
        let val = get_interned_str(node_get_data1(pat));
        return "(".str_concat(target).str_concat(" == ").str_concat(val).str_concat(")");
    }
    if (kind == NK_NAME_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        if (cc_enum_variant_consts.map_has(name)) {
            return "(".str_concat(target).str_concat(" == ").str_concat(cc_enum_variant_consts.map_get(name)).str_concat(")");
        }
        if (cc_alias_by_variant.map_has(name)) {
            let alias = cc_alias_by_variant.map_get(name);
            return "(".str_concat(target).str_concat(".__tag == ").str_concat(alias).str_concat("_").str_concat(name).str_concat(")");
        }
        return "1";
    }
    if (kind == NK_STRUCT_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        if (cc_alias_by_variant.map_has(name)) {
            let alias = cc_alias_by_variant.map_get(name);
            return "(".str_concat(target).str_concat(".__tag == ").str_concat(alias).str_concat("_").str_concat(name).str_concat(")");
        }
        return "1";
    }
    "1"
}
 // ============================================================================
 // Block → GNU statement expression (assign last expr to tmp var)
 // ============================================================================
fn cc_emit_block_to_assign(block_node: I32, tmp_var: *Str) : *Str => {
    let stmts = node_get_data1(block_node);
    let len = stmts.vec_length();
    if (len == 0) {
        return tmp_var.str_concat(" = 0;");
    }
    let sb = sb_new();
    let i = 0;
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let is_last = i == len - 1;
        let skind = node_kind(stmt);
        if (is_last && skind == NK_EXPR_STMT) {
            sb_append(sb, tmp_var);
            sb_append(sb, " = ");
            sb_append(sb, cc_emit_expr(node_get_data1(stmt)));
            sb_append(sb, ";");
        }
        else if (is_last && (skind == NK_IF_STMT || skind == NK_IF_EXPR)) {
            sb_append(sb, tmp_var);
            sb_append(sb, " = ");
            sb_append(sb, cc_emit_if_as_c_expr(stmt));
            sb_append(sb, ";");
        }
        else if (is_last && skind == NK_RETURN_STMT) {
            let val = node_get_data1(stmt);
            let val_code = "0";
            if (val != 0) {
                val_code = cc_emit_expr(val);
            }
            sb_append(sb, tmp_var);
            sb_append(sb, " = ");
            sb_append(sb, val_code);
            sb_append(sb, ";");
        }
        else {
            sb_append(sb, cc_emit_stmt(stmt));
            sb_append(sb, " ");
        }
        i = i + 1;
    }
    sb_build(sb)
}
fn cc_emit_block_as_expr(block_node: I32) : *Str => {
    let tmp = cc_next_temp("blk");
    let inner = cc_emit_block_to_assign(block_node, tmp);
    "({ int64_t ".str_concat(tmp).str_concat(" = 0; ").str_concat(inner).str_concat(" ").str_concat(tmp).str_concat("; })")
}
fn cc_emit_if_as_c_expr(n: I32) : *Str => {
    let cond = cc_emit_expr(node_get_data1(n));
    let then_b = node_get_data2(n);
    let else_b = node_get_data3(n);
    let tmp = cc_next_temp("ifexpr");
    let then_body = "";
    if (node_kind(then_b) == NK_BLOCK) {
        then_body = cc_emit_block_to_assign(then_b, tmp);
    }
    else if (node_kind(then_b) == NK_IF_STMT || node_kind(then_b) == NK_IF_EXPR) {
        then_body = tmp.str_concat(" = ").str_concat(cc_emit_if_as_c_expr(then_b)).str_concat(";");
    }
    else {
        then_body = tmp.str_concat(" = ").str_concat(cc_emit_expr(then_b)).str_concat(";");
    }
    let else_body = "";
    if (else_b == 0) {
        else_body = tmp.str_concat(" = 0;");
    }
    else if (node_kind(else_b) == NK_BLOCK) {
        else_body = cc_emit_block_to_assign(else_b, tmp);
    }
    else if (node_kind(else_b) == NK_IF_STMT || node_kind(else_b) == NK_IF_EXPR) {
        else_body = tmp.str_concat(" = ").str_concat(cc_emit_if_as_c_expr(else_b)).str_concat(";");
    }
    else {
        else_body = tmp.str_concat(" = ").str_concat(cc_emit_expr(else_b)).str_concat(";");
    }
    "({ int64_t ".str_concat(tmp).str_concat(" = 0; if (").str_concat(cond).str_concat(") { ").str_concat(then_body).str_concat(" } else { ").str_concat(else_body).str_concat(" } ").str_concat(tmp).str_concat("; })")
}
 // ============================================================================
 // Expression Emitter
 // ============================================================================
 // Translate \uXXXX escape sequences for Unicode control characters (U+0000–U+001F)
 // to C octal byte escapes.  C does not allow \uXXXX in string literals and
 // outright rejects control codepoints as universal character names.
 // We enumerate all 32 control-character patterns to avoid index-arithmetic
 // type issues while staying fully general for the selfhost string corpus.
fn cc_escape_unicode_in_string(raw: *Str) : *Str => {
    raw .str_replace_all("\\u0000", "\\000") .str_replace_all("\\u0001", "\\001")
    .str_replace_all("\\u0002", "\\002") .str_replace_all("\\u0003", "\\003") .str_replace_all("\\u0004", "\\004") .str_replace_all("\\u0005", "\\005")
    .str_replace_all("\\u0006", "\\006") .str_replace_all("\\u0007", "\\007") .str_replace_all("\\u0008", "\\010") .str_replace_all("\\u0009", "\\011")
    .str_replace_all("\\u000a", "\\012").str_replace_all("\\u000A", "\\012") .str_replace_all("\\u000b", "\\013").str_replace_all("\\u000B", "\\013") .str_replace_all("\\u000c", "\\014").str_replace_all("\\u000C", "\\014") .str_replace_all("\\u000d", "\\015").str_replace_all("\\u000D", "\\015")
    .str_replace_all("\\u000e", "\\016").str_replace_all("\\u000E", "\\016") .str_replace_all("\\u000f", "\\017").str_replace_all("\\u000F", "\\017") .str_replace_all("\\u0010", "\\020") .str_replace_all("\\u0011", "\\021")
    .str_replace_all("\\u0012", "\\022") .str_replace_all("\\u0013", "\\023") .str_replace_all("\\u0014", "\\024") .str_replace_all("\\u0015", "\\025")
    .str_replace_all("\\u0016", "\\026") .str_replace_all("\\u0017", "\\027") .str_replace_all("\\u0018", "\\030") .str_replace_all("\\u0019", "\\031")
    .str_replace_all("\\u001a", "\\032").str_replace_all("\\u001A", "\\032") .str_replace_all("\\u001b", "\\033").str_replace_all("\\u001B", "\\033") .str_replace_all("\\u001c", "\\034").str_replace_all("\\u001C", "\\034") .str_replace_all("\\u001d", "\\035").str_replace_all("\\u001D", "\\035")
    .str_replace_all("\\u001e", "\\036").str_replace_all("\\u001E", "\\036") .str_replace_all("\\u001f", "\\037").str_replace_all("\\u001F", "\\037")
}
fn cc_emit_expr(n: I32) : *Str => {
    let kind = node_kind(n);
    if (kind == NK_NUMBER_LIT) {
        return get_interned_str(node_get_data1(n));
    }
    if (kind == NK_BOOL_LIT) {
        if (node_get_data1(n) == 1) {
            return "1";
        }
        return "0";
    }
    if (kind == NK_STRING_LIT) {
        let s = get_interned_str(node_get_data1(n));
        let s_c = s;
        if (cc_disable_unicode_escape != 1) {
            s_c = cc_escape_unicode_in_string(s);
        }
        return "((int64_t)(intptr_t)\"".str_concat(s_c).str_concat("\")");
    }
    if (kind == NK_CHAR_LIT) {
        let s = get_interned_str(node_get_data1(n));
        if (s.str_length() == 1) {
            return int_to_string(char_code(s));
        }
        if (s.str_eq("\\n")) {
            return "10";
        }
        if (s.str_eq("\\r")) {
            return "13";
        }
        if (s.str_eq("\\t")) {
            return "9";
        }
        if (s.str_eq("\\0")) {
            return "0";
        }
        return "0";
    }
    if (kind == NK_IDENTIFIER) {
        let name = get_interned_str(node_get_data1(n));
        if (cc_enum_variant_consts.map_has(name)) {
            return cc_enum_variant_consts.map_get(name);
        }
        return cc_to_name(name);
    }
    if (kind == NK_UNARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("&") || op.str_eq("&mut")) {
            return cc_emit_expr(node_get_data2(n));
        }
        return "(".str_concat(op).str_concat(cc_emit_expr(node_get_data2(n))).str_concat(")");
    }
    if (kind == NK_BINARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        let left = cc_emit_expr(node_get_data2(n));
        let right = cc_emit_expr(node_get_data3(n));
        return "(".str_concat(left).str_concat(" ").str_concat(op).str_concat(" ").str_concat(right).str_concat(")");
    }
    if (kind == NK_CALL_EXPR) {
        let callee_node = node_get_data1(n);
         // Special-case built-in transformations
        if (node_kind(callee_node) == NK_IDENTIFIER) {
            let callee_name = get_interned_str(node_get_data1(callee_node));
             // drop(x) → 0
            if (callee_name.str_eq("drop")) {
                return "0";
            }
             // sizeOf<T>() → (int64_t)sizeof(T)
            if (callee_name.str_eq("sizeOf")) {
                let type_args = node_get_data4(n);
                if (type_args.vec_length() > 0) {
                    let ctype = cc_type_to_c(type_args.vec_get(0));
                    return "(int64_t)sizeof(".str_concat(ctype).str_concat(")");
                }
                return "0";
            }
             // malloc(bytes) → allocate TuffVec fat slice
            if (callee_name.str_eq("malloc")) {
                let args = node_get_data2(n);
                if (args.vec_length() >= 1) {
                    let bytes_str = cc_emit_expr(args.vec_get(0));
                    let nbytes = cc_next_temp("malloc_nbytes");
                    let vec = cc_next_temp("malloc_vec");
                    let sb = sb_new();
                    sb_append(sb, "({ size_t ");
                    sb_append(sb, nbytes);
                    sb_append(sb, " = (size_t)(");
                    sb_append(sb, bytes_str);
                    sb_append(sb, "); TuffVec* ");
                    sb_append(sb, vec);
                    sb_append(sb, " = (TuffVec*)malloc(sizeof(TuffVec)); if (");
                    sb_append(sb, vec);
                    sb_append(sb, ") { ");
                    sb_append(sb, vec);
                    sb_append(sb, "->data = (int64_t*)malloc(");
                    sb_append(sb, nbytes);
                    sb_append(sb, "); ");
                    sb_append(sb, vec);
                    sb_append(sb, "->init = 0; ");
                    sb_append(sb, vec);
                    sb_append(sb, "->length = ");
                    sb_append(sb, nbytes);
                    sb_append(sb, " / sizeof(int64_t); if (!");
                    sb_append(sb, vec);
                    sb_append(sb, "->data) { free(");
                    sb_append(sb, vec);
                    sb_append(sb, "); ");
                    sb_append(sb, vec);
                    sb_append(sb, " = NULL; } } ");
                    sb_append(sb, vec);
                    sb_append(sb, "; })");
                    return sb_build(sb);
                }
                return "0";
            }
             // realloc(ptr, bytes) → grow TuffVec data in-place
            if (callee_name.str_eq("realloc")) {
                let args = node_get_data2(n);
                if (args.vec_length() >= 2) {
                    let ptr_str = cc_emit_expr(args.vec_get(0));
                    let bytes_str = cc_emit_expr(args.vec_get(1));
                    let nbytes = cc_next_temp("realloc_nbytes");
                    let vec = cc_next_temp("realloc_vec");
                    let data = cc_next_temp("realloc_data");
                    let sb = sb_new();
                    sb_append(sb, "({ size_t ");
                    sb_append(sb, nbytes);
                    sb_append(sb, " = (size_t)(");
                    sb_append(sb, bytes_str);
                    sb_append(sb, "); TuffVec* ");
                    sb_append(sb, vec);
                    sb_append(sb, " = (TuffVec*)(");
                    sb_append(sb, ptr_str);
                    sb_append(sb, "); if (");
                    sb_append(sb, vec);
                    sb_append(sb, ") { int64_t* ");
                    sb_append(sb, data);
                    sb_append(sb, " = (int64_t*)realloc(");
                    sb_append(sb, vec);
                    sb_append(sb, "->data, ");
                    sb_append(sb, nbytes);
                    sb_append(sb, "); if (");
                    sb_append(sb, data);
                    sb_append(sb, ") { ");
                    sb_append(sb, vec);
                    sb_append(sb, "->data = ");
                    sb_append(sb, data);
                    sb_append(sb, "; ");
                    sb_append(sb, vec);
                    sb_append(sb, "->length = ");
                    sb_append(sb, nbytes);
                    sb_append(sb, " / sizeof(int64_t); } else { ");
                    sb_append(sb, vec);
                    sb_append(sb, " = NULL; } } ");
                    sb_append(sb, vec);
                    sb_append(sb, "; })");
                    return sb_build(sb);
                }
                return "0";
            }
             // free(ptr) → free TuffVec data then struct
            if (callee_name.str_eq("free")) {
                let args = node_get_data2(n);
                if (args.vec_length() >= 1) {
                    let ptr_str = cc_emit_expr(args.vec_get(0));
                    let vec = cc_next_temp("free_vec");
                    return "({ TuffVec* ".str_concat(vec).str_concat(" = (TuffVec*)(").str_concat(ptr_str).str_concat("); if (").str_concat(vec).str_concat(") { free(").str_concat(vec).str_concat("->data); free(").str_concat(vec).str_concat("); } 0; })");
                }
                return "0";
            }
        }
         // General call
        let callee = cc_emit_expr(callee_node);
        let args = node_get_data2(n);
        let arg_strs = vec_new();
        let i = 0;
        let alen = args.vec_length();
        while (i < alen) {
            arg_strs.vec_push(cc_emit_expr(args.vec_get(i)));
            i = i + 1;
        }
        let args_str = arg_strs.vec_join(", ");
        return callee.str_concat("(").str_concat(args_str).str_concat(")");
    }
    if (kind == NK_MEMBER_EXPR) {
        let obj_node = node_get_data1(n);
        let prop = get_interned_str(node_get_data2(n));
         // Enum access: EnumName.Variant → EnumName_Variant
        if (node_kind(obj_node) == NK_IDENTIFIER) {
            let obj_name = get_interned_str(node_get_data1(obj_node));
            if (cc_enum_names.set_has(obj_name)) {
                return obj_name.str_concat("_").str_concat(prop);
            }
             // TuffVec* locals use -> for field access
            if (cc_local_types.map_has(obj_name) && cc_local_types.map_get(obj_name).str_eq("TuffVec*")) {
                return cc_to_name(obj_name).str_concat("->").str_concat(prop);
            }
        }
        let obj = cc_emit_expr(obj_node);
        return obj.str_concat(".").str_concat(prop);
    }
    if (kind == NK_INDEX_EXPR) {
        let target = cc_emit_expr(node_get_data1(n));
        let idx = cc_emit_expr(node_get_data2(n));
        return target.str_concat("[").str_concat(idx).str_concat("]");
    }
    if (kind == NK_IF_EXPR) {
        let cond = cc_emit_expr(node_get_data1(n));
        let then_b = node_get_data2(n);
        let else_b = node_get_data3(n);
         // Use GNU statement expression for block branches
        if (node_kind(then_b) == NK_BLOCK || (else_b != 0 && node_kind(else_b) == NK_BLOCK)) {
            return cc_emit_if_as_c_expr(n);
        }
         // Simple ternary
        let then_str = cc_emit_expr(then_b);
        let else_str = "0";
        if (else_b != 0) {
            else_str = cc_emit_expr(else_b);
        }
        return "((".str_concat(cond).str_concat(") ? (").str_concat(then_str).str_concat(") : (").str_concat(else_str).str_concat("))");
    }
    if (kind == NK_UNWRAP_EXPR) {
        let inner_node = node_get_data1(n);
        let inner = cc_emit_expr(inner_node);
        let rtype = cc_infer_expr_ctype(inner_node);
        if (rtype.str_eq("int64_t")) {
            return inner;
        }
        let tmp = cc_next_temp("unwrap");
        return "({ ".str_concat(rtype)
            .str_concat(" ").str_concat(tmp)
            .str_concat(" = ").str_concat(inner)
            .str_concat("; if (").str_concat(tmp).str_concat(".__tag == ")
            .str_concat(rtype).str_concat("_Err) { return ").str_concat(tmp)
            .str_concat("; } ").str_concat(tmp).str_concat(".value; })");
    }
    if (kind == NK_MATCH_EXPR) {
        return cc_emit_match_expr(n);
    }
    if (kind == NK_IS_EXPR) {
        let inner = cc_emit_expr(node_get_data1(n));
        let pat = node_get_data2(n);
        if (node_kind(pat) == NK_NAME_PAT) {
            let name = get_interned_str(node_get_data1(pat));
            if (cc_alias_by_variant.map_has(name)) {
                let alias = cc_alias_by_variant.map_get(name);
                return "(".str_concat(inner).str_concat(".__tag == ").str_concat(alias).str_concat("_").str_concat(name).str_concat(")");
            }
            return "((int64_t)(".str_concat(inner).str_concat(") != 0)");
        }
        if (node_kind(pat) == NK_STRUCT_PAT) {
            let name = get_interned_str(node_get_data1(pat));
            if (cc_alias_by_variant.map_has(name)) {
                let alias = cc_alias_by_variant.map_get(name);
                return "(".str_concat(inner).str_concat(".__tag == ").str_concat(alias).str_concat("_").str_concat(name).str_concat(")");
            }
        }
        return "0";
    }
    if (kind == NK_STRUCT_INIT) {
        let name = get_interned_str(node_get_data1(n));
        if (cc_alias_by_variant.map_has(name)) {
            let alias = cc_alias_by_variant.map_get(name);
            let fields = node_get_data2(n);
            let sb = sb_new();
            sb_append(sb, "((");
            sb_append(sb, alias);
            sb_append(sb, "){ .__tag = ");
            sb_append(sb, alias);
            sb_append(sb, "_");
            sb_append(sb, name);
            let i = 0;
            let flen = fields.vec_length();
            while (i < flen) {
                let field = fields.vec_get(i);
                let key = get_interned_str(field.vec_get(0));
                let val_str = cc_emit_expr(field.vec_get(1));
                sb_append(sb, ", .");
                sb_append(sb, key);
                sb_append(sb, " = ");
                sb_append(sb, val_str);
                i = i + 1;
            }
            sb_append(sb, " })");
            return sb_build(sb);
        }
        let fields = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "((");
        sb_append(sb, name);
        sb_append(sb, "){ ");
        let i = 0;
        let flen = fields.vec_length();
        while (i < flen) {
            let field = fields.vec_get(i);
            let key = get_interned_str(field.vec_get(0));
            let val_str = cc_emit_expr(field.vec_get(1));
            if (i > 0) {
                sb_append(sb, ", ");
            }
            sb_append(sb, ".");
            sb_append(sb, key);
            sb_append(sb, " = ");
            sb_append(sb, val_str);
            i = i + 1;
        }
        sb_append(sb, " })");
        return sb_build(sb);
    }
    if (kind == NK_LAMBDA_EXPR || kind == NK_FN_EXPR) {
        return "/* lambda/fn_expr unsupported in C */ 0";
    }
    if (kind == NK_TUPLE_EXPR) {
        return "/* tuple_expr unsupported in C */ 0";
    }
    "/* unknown_expr */ 0"
}
fn cc_emit_match_expr(n: I32) : *Str => {
    let target_str = cc_emit_expr(node_get_data1(n));
    let cases = node_get_data2(n);
    let len = cases.vec_length();
    let chain = "(tuff_panic(\"Non-exhaustive match\"), 0)";
     // Build from right-to-left (nested ternary)
    let i = len - 1;
    while (i >= 0) {
        let case_node = cases.vec_get(i);
        let pat = case_node.vec_get(0);
        let body = case_node.vec_get(1);
        let guard = cc_emit_pattern_guard(target_str, pat);
        let body_str = "";
        if (node_kind(body) == NK_BLOCK) {
            body_str = cc_emit_block_as_expr(body);
        }
        else {
            if (node_kind(pat) == NK_STRUCT_PAT && node_kind(body) == NK_IDENTIFIER) {
                let pfields = node_get_data2(pat);
                if (pfields != 0 && pfields.vec_length() == 1) {
                    let pfield = pfields.vec_get(0);
                    let field_name = get_interned_str(pfield);
                    let bind_name = field_name;
                    let body_name = get_interned_str(node_get_data1(body));
                    if (body_name.str_eq(bind_name)) {
                        body_str = target_str.str_concat(".").str_concat(field_name);
                    }
                    else {
                        body_str = cc_emit_expr(body);
                    }
                }
                else {
                    body_str = cc_emit_expr(body);
                }
            }
            else {
                body_str = cc_emit_expr(body);
            }
        }
        chain = "((".str_concat(guard).str_concat(") ? (").str_concat(body_str).str_concat(") : (").str_concat(chain).str_concat("))");
        i = i - 1;
    }
    chain
}
 // ============================================================================
 // Statement Emitter
 // ============================================================================
fn cc_emit_block(n: I32) : *Str => {
    let stmts = node_get_data1(n);
    let sb = sb_new();
    sb_append(sb, "{\n");
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        sb_append(sb, "  ");
        sb_append(sb, cc_emit_stmt(stmts.vec_get(i)));
        sb_append(sb, "\n");
        i = i + 1;
    }
    sb_append(sb, "}");
    sb_build(sb)
}
fn cc_emit_stmt_or_block(n: I32) : *Str => {
    if (node_kind(n) == NK_BLOCK) {
        return cc_emit_block(n);
    }
    "{ ".str_concat(cc_emit_stmt(n)).str_concat(" }")
}
fn cc_emit_fn_block(n: I32) : *Str => {
     // Reset local type map for this function scope
    cc_local_types = map_new();
    let stmts = node_get_data1(n);
    let len = stmts.vec_length();
    if (len == 0) {
        return "{\n  return 0;\n}";
    }
    let sb = sb_new();
    sb_append(sb, "{\n");
    let i = 0;
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let is_last = i == len - 1;
        let skind = node_kind(stmt);
        if (is_last && skind == NK_EXPR_STMT) {
            sb_append(sb, "  return ");
            sb_append(sb, cc_emit_expr(node_get_data1(stmt)));
            sb_append(sb, ";\n");
        }
        else if (is_last && (skind == NK_IF_STMT || skind == NK_IF_EXPR)) {
            sb_append(sb, "  return ");
            sb_append(sb, cc_emit_if_as_c_expr(stmt));
            sb_append(sb, ";\n");
        }
        else {
            sb_append(sb, "  ");
            sb_append(sb, cc_emit_stmt(stmt));
            sb_append(sb, "\n");
        }
        i = i + 1;
    }
    sb_append(sb, "}");
    sb_build(sb)
}
fn cc_emit_param_list(params: Vec<I32>) : *Str => {
    let parts = vec_new();
    let i = 0;
    let len = params.vec_length();
    while (i < len) {
        let param = params.vec_get(i);
        let pname = get_interned_str(param.vec_get(0));
        let ptype = param.vec_get(1);
        let ptype_str = cc_type_to_c(ptype);
        parts.vec_push(ptype_str.str_concat(" ").str_concat(pname));
        i = i + 1;
    }
    parts.vec_join(", ")
}
fn cc_emit_prototype(ret_type: *Str, name: *Str, params: *Str) : *Str => ret_type.str_concat(" ").str_concat(name).str_concat("(").str_concat(params).str_concat(");");
fn cc_emit_type_alias(n: I32) : *Str => {
    let alias_name = get_interned_str(node_get_data1(n));
    let aliased = node_get_data3(n);
    if (aliased == 0 || node_kind(aliased) != NK_UNION_TYPE) {
        return "/* type ".str_concat(alias_name).str_concat(" = ... */");
    }
    if (!cc_union_alias_info.map_has(alias_name)) {
        return "/* union ".str_concat(alias_name).str_concat(" not in context */");
    }
    let variants = cc_union_alias_info.map_get(alias_name);
    let vlen = variants.vec_length();
    let sb = sb_new();
     // typedef enum Alias_Tag { Alias_V1 = 1, ... } Alias_Tag;
    sb_append(sb, "typedef enum ");
    sb_append(sb, alias_name);
    sb_append(sb, "_Tag { ");
    let j = 0;
    while (j < vlen) {
        if (j > 0) {
            sb_append(sb, ", ");
        }
        sb_append(sb, alias_name);
        sb_append(sb, "_");
        sb_append(sb, variants.vec_get(j));
        sb_append(sb, " = ");
        sb_append(sb, int_to_string(j + 1));
        j = j + 1;
    }
    sb_append(sb, " } ");
    sb_append(sb, alias_name);
    sb_append(sb, "_Tag;\n");
     // Collect all unique field names from all variant structs
    let all_field_names = vec_new();
    let seen_fields = set_new();
    j = 0;
    while (j < vlen) {
        let v = variants.vec_get(j);
        if (cc_struct_fields.map_has(v)) {
            let fields = cc_struct_fields.map_get(v);
            let m = 0;
            let flen = fields.vec_length();
            while (m < flen) {
                let fname = fields.vec_get(m);
                if (!seen_fields.set_has(fname)) {
                    seen_fields.set_add(fname);
                    all_field_names.vec_push(fname);
                }
                m = m + 1;
            }
        }
        j = j + 1;
    }
     // typedef struct Alias { int32_t __tag; int64_t f1; ... } Alias;
    sb_append(sb, "typedef struct ");
    sb_append(sb, alias_name);
    sb_append(sb, " { int32_t __tag;");
    let m = 0;
    let flen = all_field_names.vec_length();
    while (m < flen) {
        let fname = all_field_names.vec_get(m);
        let ftype = "int64_t";
        if (alias_name.str_eq("Result") && fname.str_eq("error")) {
            ftype = "TuffError";
        }
        sb_append(sb, " ");
        sb_append(sb, ftype);
        sb_append(sb, " ");
        sb_append(sb, fname);
        sb_append(sb, ";");
        m = m + 1;
    }
    sb_append(sb, " } ");
    sb_append(sb, alias_name);
    sb_append(sb, ";\n");
     // Static inline constructor for each variant
    j = 0;
    while (j < vlen) {
        let v = variants.vec_get(j);
        let vfields = vec_new();
        if (cc_struct_fields.map_has(v)) {
            vfields = cc_struct_fields.map_get(v);
        }
        let params_sb = sb_new();
        let assigns_sb = sb_new();
        let k = 0;
        let klen = vfields.vec_length();
        while (k < klen) {
            let fname = vfields.vec_get(k);
            let ptype = "int64_t";
            if (alias_name.str_eq("Result") && fname.str_eq("error")) {
                ptype = "TuffError";
            }
            if (k > 0) {
                sb_append(params_sb, ", ");
            }
            sb_append(params_sb, ptype);
            sb_append(params_sb, " ");
            sb_append(params_sb, fname);
            sb_append(assigns_sb, " out.");
            sb_append(assigns_sb, fname);
            sb_append(assigns_sb, " = ");
            sb_append(assigns_sb, fname);
            sb_append(assigns_sb, ";");
            k = k + 1;
        }
        sb_append(sb, "static inline ");
        sb_append(sb, alias_name);
        sb_append(sb, " ");
        sb_append(sb, alias_name);
        sb_append(sb, "_make_");
        sb_append(sb, v);
        sb_append(sb, "(");
        sb_append(sb, sb_build(params_sb));
        sb_append(sb, ") { ");
        sb_append(sb, alias_name);
        sb_append(sb, " out = {0}; out.__tag = ");
        sb_append(sb, alias_name);
        sb_append(sb, "_");
        sb_append(sb, v);
        sb_append(sb, ";");
        sb_append(sb, sb_build(assigns_sb));
        sb_append(sb, " return out; }\n");
        j = j + 1;
    }
    sb_build(sb)
}
fn cc_is_extern_fn_decl(n: I32) : Bool => {
    let kind = node_kind(n);
    kind == NK_FN_DECL && node_get_data5(n) == 0
}
fn cc_emit_stmt(n: I32) : *Str => {
    let kind = node_kind(n);
    if (kind == NK_LET_DECL) {
        let name = cc_to_name(get_interned_str(node_get_data1(n)));
        let val_node = node_get_data3(n);
        let ctype = cc_infer_expr_ctype(val_node);
        let value = cc_emit_expr(val_node);
        cc_local_types.map_set(name, ctype);
        return ctype.str_concat(" ").str_concat(name).str_concat(" = ").str_concat(value).str_concat(";");
    }
    if (kind == NK_IMPORT_DECL) {
        return "/* import placeholder */";
    }
    if (kind == NK_EXPR_STMT) {
        return cc_emit_expr(node_get_data1(n)).str_concat(";");
    }
    if (kind == NK_ASSIGN_STMT) {
        let target = cc_emit_expr(node_get_data1(n));
        let value = cc_emit_expr(node_get_data2(n));
        return target.str_concat(" = ").str_concat(value).str_concat(";");
    }
    if (kind == NK_RETURN_STMT) {
        let val = node_get_data1(n);
        if (val == 0) {
            return "return 0;";
        }
        return "return ".str_concat(cc_emit_expr(val)).str_concat(";");
    }
    if (kind == NK_IF_STMT || kind == NK_IF_EXPR) {
        let cond = cc_emit_expr(node_get_data1(n));
        let then_b = node_get_data2(n);
        let else_b = node_get_data3(n);
        let then_str = cc_emit_stmt_or_block(then_b);
        if (else_b == 0) {
            return "if (".str_concat(cond).str_concat(") ").str_concat(then_str);
        }
        return "if (".str_concat(cond).str_concat(") ").str_concat(then_str).str_concat(" else ").str_concat(cc_emit_stmt_or_block(else_b));
    }
    if (kind == NK_WHILE_STMT) {
        let cond = cc_emit_expr(node_get_data1(n));
        let body = cc_emit_block(node_get_data2(n));
        return "while (".str_concat(cond).str_concat(") ").str_concat(body);
    }
    if (kind == NK_FOR_STMT) {
        let iter = cc_to_name(get_interned_str(node_get_data1(n)));
        let start = cc_emit_expr(node_get_data2(n));
        let end = cc_emit_expr(node_get_data3(n));
        let body = cc_emit_block(node_get_data4(n));
        return "for (int64_t ".str_concat(iter).str_concat(" = ").str_concat(start).str_concat("; ").str_concat(iter).str_concat(" < ").str_concat(end).str_concat("; ").str_concat(iter).str_concat("++) ").str_concat(body);
    }
    if (kind == NK_LOOP_STMT) {
        let body = cc_emit_block(node_get_data1(n));
        return "while (1) ".str_concat(body);
    }
    if (kind == NK_BREAK_STMT) {
        return "break;";
    }
    if (kind == NK_CONTINUE_STMT) {
        return "continue;";
    }
    if (kind == NK_INTO_STMT) {
        return "/* into ".str_concat(get_interned_str(node_get_data1(n))).str_concat(" */");
    }
    if (kind == NK_LIFETIME_STMT) {
         // Lifetime blocks are compile-time scoping only.
         // At C top level we must not emit a raw "{ ... }" block.
         // Instead, emit the lowered body statements directly.
        let body = node_get_data2(n);
        if (body == 0 || node_kind(body) != NK_BLOCK) {
            return "";
        }
        let stmts = node_get_data1(body);
        let sb = sb_new();
        let i = 0;
        let len = stmts.vec_length();
        while (i < len) {
            let row = cc_emit_stmt(stmts.vec_get(i));
            if (!row.str_eq("")) {
                sb_append(sb, row);
                if (i + 1 < len) {
                    sb_append(sb, "\n");
                }
            }
            i = i + 1;
        }
        return sb_build(sb);
    }
    if (kind == NK_BLOCK) {
        return cc_emit_block(n);
    }
    if (kind == NK_EXPECT_FN_DECL) {
        return "/* expect fn ".str_concat(get_interned_str(node_get_data1(n))).str_concat(" */");
    }
    if (cc_is_extern_fn_decl(n)) {
        let name = get_interned_str(node_get_data1(n));
        if (cc_is_stdlib_builtin(name)) {
            return "/* extern ".str_concat(name).str_concat(" — declared via C stdlib headers */");
        }
        let params = node_get_data3(n);
        let ret_type = cc_type_to_c(node_get_data4(n));
        let params_str = cc_emit_param_list(params);
        return cc_emit_prototype("extern ".str_concat(ret_type), name, params_str);
    }
    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
        let source_name = get_interned_str(node_get_data1(n));
        let name = cc_to_name(source_name);
        let params = node_get_data3(n);
        let ret_type = cc_type_to_c(node_get_data4(n));
        let body = node_get_data5(n);
        let params_str = cc_emit_param_list(params);
        if (body == 0) {
            return "/* fn ".str_concat(name).str_concat(" has no body */");
        }
        let prev_disable_escape = cc_disable_unicode_escape;
        if (source_name.str_eq("cc_escape_unicode_in_string")) {
            cc_disable_unicode_escape = 1;
        }
        let emitted = "";
        if (node_kind(body) == NK_BLOCK) {
            emitted = ret_type.str_concat(" ").str_concat(name).str_concat("(").str_concat(params_str).str_concat(") ").str_concat(cc_emit_fn_block(body));
        }
        else {
            emitted = ret_type.str_concat(" ").str_concat(name).str_concat("(").str_concat(params_str).str_concat(") { return ").str_concat(cc_emit_expr(body)).str_concat("; }");
        }
        cc_disable_unicode_escape = prev_disable_escape;
        return emitted;
    }
    if (kind == NK_STRUCT_DECL) {
        let name = get_interned_str(node_get_data1(n));
        let fields = node_get_data3(n);
        if (name.str_eq("ParseError") || name.str_eq("ResolveError") || name.str_eq("TypeError") || name.str_eq("CodegenError")) {
            let sb = sb_new();
            if (cc_emitted_tuff_error == 0) {
                sb_append(sb, "typedef struct TuffError { ");
                let i = 0;
                let flen = fields.vec_length();
                while (i < flen) {
                    let f = fields.vec_get(i);
                    let fname = get_interned_str(f.vec_get(0));
                    let ftype = f.vec_get(1);
                    let ctype = cc_type_to_c(ftype);
                    sb_append(sb, ctype);
                    sb_append(sb, " ");
                    sb_append(sb, fname);
                    sb_append(sb, "; ");
                    i = i + 1;
                }
                sb_append(sb, "} TuffError;\n");
                cc_emitted_tuff_error = 1;
            }
            sb_append(sb, "typedef TuffError ");
            sb_append(sb, name);
            sb_append(sb, ";");
            return sb_build(sb);
        }
        let sb = sb_new();
        sb_append(sb, "typedef struct ");
        sb_append(sb, name);
        sb_append(sb, " { ");
        let i = 0;
        let flen = fields.vec_length();
        while (i < flen) {
            let f = fields.vec_get(i);
            let fname = get_interned_str(f.vec_get(0));
            let ftype = f.vec_get(1);
            let ctype = cc_type_to_c(ftype);
            sb_append(sb, ctype);
            sb_append(sb, " ");
            sb_append(sb, fname);
            sb_append(sb, "; ");
            i = i + 1;
        }
        sb_append(sb, "} ");
        sb_append(sb, name);
        sb_append(sb, ";");
        return sb_build(sb);
    }
    if (kind == NK_TYPE_ALIAS) {
        return cc_emit_type_alias(n);
    }
    if (kind == NK_DEP_TYPE_ALIAS) {
        let name = get_interned_str(node_get_data1(n));
        return "/* type ".str_concat(name).str_concat("(...) = ... */");
    }
    if (kind == NK_ENUM_DECL) {
        let name = get_interned_str(node_get_data1(n));
        let variants = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "typedef enum ");
        sb_append(sb, name);
        sb_append(sb, " { ");
        let i = 0;
        let vlen = variants.vec_length();
        while (i < vlen) {
            if (i > 0) {
                sb_append(sb, ", ");
            }
            sb_append(sb, name);
            sb_append(sb, "_");
            sb_append(sb, get_interned_str(variants.vec_get(i)));
            sb_append(sb, " = ");
            sb_append(sb, int_to_string(i));
            i = i + 1;
        }
        sb_append(sb, " } ");
        sb_append(sb, name);
        sb_append(sb, ";");
        return sb_build(sb);
    }
    if (kind == NK_OBJECT_DECL) {
        return "/* object ".str_concat(get_interned_str(node_get_data1(n))).str_concat(" */");
    }
    if (kind == NK_CONTRACT_DECL) {
        return "/* contract ".str_concat(get_interned_str(node_get_data1(n))).str_concat(" */");
    }
    if (kind == NK_EXTERN_LET_DECL) {
        let name = get_interned_str(node_get_data1(n));
        return "/* extern let ".str_concat(name).str_concat(" */");
    }
    if (kind == NK_EXTERN_TYPE_DECL) {
        let name = get_interned_str(node_get_data1(n));
        return "/* extern type ".str_concat(name).str_concat(" */");
    }
    if (kind == NK_EXTERN_IMPORT_DECL) {
        return "";
    }
     // NK_STMT_LIST (noop from extern let { } = source; parsing) — emit nothing
    if (kind == NK_STMT_LIST) {
        return "";
    }
    ""
}
 // ============================================================================
 // Main Entry Point
 // ============================================================================
out fn generate_c_impl(typed: I32, substrate: *Str) : *Str => {
     // Reset global state for this compilation
    cc_temp_counter = 0;
    cc_disable_unicode_escape = 0;
    cc_enum_names = set_new();
    cc_enum_variant_consts = map_new();
    cc_struct_fields = map_new();
    cc_alias_by_variant = map_new();
    cc_union_alias_info = map_new();
    cc_covered_extern_fns = set_new();
    cc_fn_return_types = map_new();
    cc_local_types = map_new();
    cc_emitted_tuff_error = 0;
    cc_inc_stdint = 1;
    cc_inc_stddef = 0;
    cc_inc_stdio = 0;
    cc_inc_stdlib = 0;
    cc_inc_string = 0;
    cc_inc_ctype = 0;
    cc_inc_errno = 0;
    cc_inc_direct = 0;
    cc_inc_sys_stat = 0;
    cc_inc_sys_types = 0;
     // Pre-scan AST to build context maps
    cc_init_context(typed);
     // While substrate is still embedded, preserve its required header baseline.
     // Once substrate is removed, includes become fully extern-source driven,
     // except for the tiny built-in fallback prelude emitted below.
    if (!substrate.str_eq("")) {
        cc_require_substrate_headers();
    }
    else {
        cc_inc_stddef = 1;
        cc_inc_stdio = 1;
        cc_inc_stdlib = 1;
        cc_inc_string = 1;
         // String implementations need <string.h>
        cc_inc_ctype = 1;
         // String implementations need <ctype.h> for isspace
    }
    let stmts = node_get_data1(typed);
    let len = stmts.vec_length();
     // Enforce extern source attribution coverage for extern fns.
    let cvi = 0;
    while (cvi < len) {
        let cvn = stmts.vec_get(cvi);
        if (cc_is_extern_fn_decl(cvn)) {
            let fname = get_interned_str(node_get_data1(cvn));
            if (!cc_covered_extern_fns.set_has(fname)) {
                panic_with_code( "E_EXTERN_NO_SOURCE",
                "extern fn '".str_concat(fname).str_concat("' has no source attribution"), "C codegen requires each extern function to be attributed to a source via extern let destructuring.", "Add 'extern let { ".str_concat(fname).str_concat(" } = <header>;' before the declaration.") );
            }
        }
        cvi = cvi + 1;
    }
     // Collect fn nodes for two-pass emit (prototypes then bodies)
    let fn_nodes : Vec<I32> = vec_new();
     // Collect global let init rows for tuff_init_globals()
    let init_rows : Vec<*Str> = vec_new();
    let sb = sb_new();
     // ── Preamble: fixed C includes ──────────────────────────────────────────
    if (cc_inc_stdint == 1) {
        sb_append(sb, "#include <stdint.h>\n");
    }
    if (cc_inc_stddef == 1) {
        sb_append(sb, "#include <stddef.h>\n");
    }
    if (cc_inc_stdio == 1) {
        sb_append(sb, "#include <stdio.h>\n");
    }
    if (cc_inc_stdlib == 1) {
        sb_append(sb, "#include <stdlib.h>\n");
    }
    if (cc_inc_string == 1) {
        sb_append(sb, "#include <string.h>\n");
    }
    if (cc_inc_ctype == 1) {
        sb_append(sb, "#include <ctype.h>\n");
    }
    if (cc_inc_errno == 1) {
        sb_append(sb, "#include <errno.h>\n");
    }
    sb_append(sb, "#ifdef _WIN32\n");
    if (cc_inc_direct == 1) {
        sb_append(sb, "#include <direct.h>\n");
    }
    sb_append(sb, "#else\n");
    if (cc_inc_sys_stat == 1) {
        sb_append(sb, "#include <sys/stat.h>\n");
    }
    if (cc_inc_sys_types == 1) {
        sb_append(sb, "#include <sys/types.h>\n");
    }
    sb_append(sb, "#endif\n\n");
    sb_append(sb, "/* Generated by Tuff selfhost C backend. */\n\n");
    if (!substrate.str_eq("")) {
        sb_append(sb, "/* Embedded C substrate support */\n");
        sb_append(sb, substrate);
    }
    else {
        sb_append(sb, cc_emit_minimal_runtime_prelude());
    }
    sb_append(sb, "\n\n");
    sb_append(sb, "typedef struct TuffError { int64_t code; int64_t message; int64_t reason; int64_t fix; int64_t line; int64_t col; } TuffError;\n\n");
    cc_emitted_tuff_error = 1;
     // ── First pass: non-fn top-level declarations ────────────────────────────
    let i = 0;
    while (i < len) {
        let node = stmts.vec_get(i);
        let kind = node_kind(node);
         // Collect fn nodes for later
        if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
            fn_nodes.vec_push(node);
            i = i + 1;
            continue;
        }
         // Skip expect fn declarations
        if (kind == NK_EXPECT_FN_DECL) {
            i = i + 1;
            continue;
        }
         // Global let → forward declaration + deferred initializer
        if (kind == NK_LET_DECL) {
            let name = cc_to_name(get_interned_str(node_get_data1(node)));
            sb_append(sb, "int64_t ");
            sb_append(sb, name);
            sb_append(sb, ";\n");
            init_rows.vec_push(name.str_concat(" = ").str_concat(cc_emit_expr(node_get_data3(node))).str_concat(";"));
            sb_append(sb, "\n");
            i = i + 1;
            continue;
        }
         // Everything else (enums, structs, type aliases, extern fns, etc.)
        let stmt_str = cc_emit_stmt(node);
        if (!stmt_str.str_eq("")) {
            sb_append(sb, stmt_str);
            sb_append(sb, "\n");
        }
        i = i + 1;
    }
     // ── Fn prototypes ────────────────────────────────────────────────────────
    sb_append(sb, "\n");
    i = 0;
    let fn_len = fn_nodes.vec_length();
    while (i < fn_len) {
        let fn_node = fn_nodes.vec_get(i);
        let fn_name = cc_to_name(get_interned_str(node_get_data1(fn_node)));
        let params_str = cc_emit_param_list(node_get_data3(fn_node));
        let ret_type = cc_type_to_c(node_get_data4(fn_node));
        sb_append(sb, cc_emit_prototype(ret_type, fn_name, params_str));
        sb_append(sb, "\n");
        i = i + 1;
    }
    sb_append(sb, "\n");
     // ── Fn bodies ────────────────────────────────────────────────────────────
    i = 0;
    while (i < fn_len) {
        let fn_node = fn_nodes.vec_get(i);
        sb_append(sb, cc_emit_stmt(fn_node));
        sb_append(sb, "\n\n");
        i = i + 1;
    }
     // ── tuff_init_globals ────────────────────────────────────────────────────
    sb_append(sb, "static void tuff_init_globals(void) {\n");
    i = 0;
    let init_len = init_rows.vec_length();
    while (i < init_len) {
        sb_append(sb, "  ");
        sb_append(sb, init_rows.vec_get(i));
        sb_append(sb, "\n");
        i = i + 1;
    }
    sb_append(sb, "}\n\n");
     // ── main() entry point ───────────────────────────────────────────────────
    sb_append(sb, "int main(void) {\n");
    sb_append(sb, "  tuff_init_globals();\n");
    sb_append(sb, "  return (int)tuff_main();\n");
    sb_append(sb, "}\n");
    sb_build(sb)
}
out fn selfhost_codegen_c_impl_marker() : I32 => 0;
