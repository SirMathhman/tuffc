 // ============================================================================
 // Typecheck - skip for now, minimal implementation
 // ============================================================================
let {
    getInternedStr, mapNew, setNew, vecNew, strIncludes, strStartsWith, strIndexOf, intToString
}
 = selfhost::runtimeLexer;
let {
    Ok, Err, Result
}
 = selfhost::Result;
let {
    TypeError
}
 = selfhost::errors::TypeError;
let {
    nodeKind, nodeGetData1, nodeGetData2, nodeGetData3, nodeGetData4, nodeGetData5,
    nodeGetLine, nodeGetCol
}
 = selfhost::parserCore;
 // Current AST node being type-checked — set at each typecheck_expr/typecheck_stmt entry
 // so that tc_panic_loc can report the source location of the error.
let tcCurrentNode : I32 = 0;
let tcTypeNameCache : Map<I32, I32> = mapNew();
fn tcPanicLoc(code: *Str, msg: *Str, reason: *Str, fix: *Str) : I32 => {
    panicWithCodeLoc(code, msg, reason, fix, nodeGetLine(tcCurrentNode), nodeGetCol(tcCurrentNode))
}
fn tcResultError(code: *Str, msg: *Str, reason: *Str, fix: *Str) : Result<I32, TypeError> => {
    Err<TypeError> {
        error: TypeError {
            code: code,
            message: msg,
            reason: reason,
            fix: fix,
            line: nodeGetLine(tcCurrentNode),
            col: nodeGetCol(tcCurrentNode)
        }
    }
}
fn unionTypeContains(unionName: *Str, candidate: *Str) : Bool => {
    if (unionName.strEq(candidate)) {
        return true;
    }
    let prefix = candidate.strConcat("|");
    if (unionName.strStartsWith(prefix)) {
        return true;
    }
    let middle = "|".strConcat(candidate).strConcat("|");
    if (unionName.strIncludes(middle)) {
        return true;
    }
    let tail = "|".strConcat(candidate);
    if (!unionName.strIncludes(tail.strConcat("|")) && unionName.strIncludes(tail)) {
        return true;
    }
    false
}
fn unionTypeSplitTags(unionName: *Str) : Vec<I32> => {
    let tags = vecNew();
    tags
}
fn isThisReturnTypeFor (actual: *Str, declared: *Str) : Bool => {
    if (!actual.strStartsWith("__this_")) {
        return false;
    }
    let n = actual.strLength();
    if (n < 7) {
        return false;
    }
    actual.strSlice(7, n).strEq(declared)
}
fn typeNameFromTypeNode(t: I32) : *Str => {
    if (tcTypeNameCache.mapHas(t)) {
        return tcTypeNameCache.mapGet(t);
    }
    if (t == 0) {
        tcTypeNameCache.mapSet(t, "Unknown");
        return "Unknown";
    }
    let result = "Unknown";
    let k = nodeKind(t);
    if (k == 40) {
        result = getInternedStr(nodeGetData1(t));
        let genericArgs = nodeGetData2(t);
        let namedActualArity = genericArgs.vecLength();
        if (tcExternTypeParams.mapHas(result)) {
            let externExpectedArity = tcExternTypeParams.mapGet(result);
            if (namedActualArity != externExpectedArity) {
                tcPanicLoc(
                "E_TYPE_APPLIED_ARITY", "'".strConcat(result).strConcat("' applied with ").strConcat(intToString(namedActualArity)).strConcat(" argument(s), expected ").strConcat(intToString(externExpectedArity)), "Extern types must be applied with exactly the number of generic parameters declared by their extern type declaration.", "Provide exactly ".strConcat(intToString(externExpectedArity)).strConcat(" argument(s) to '").strConcat(result).strConcat("'.")
                );
            }
        }
        tcTypeNameCache.mapSet(t, result);
        return result;
    }
    if (k == 41) {
        let mutable = nodeGetData1(t);
        let inner = typeNameFromTypeNode(nodeGetData2(t));
        let movePtr = nodeGetData3(t);
        let lifeIdx = nodeGetData4(t);
        let lifePrefix = "";
        if (lifeIdx != 0) {
            lifePrefix = getInternedStr(lifeIdx).strConcat(" ");
        }
        if (movePtr == 1) {
            result = "*".strConcat(lifePrefix).strConcat("move ").strConcat(inner);
            tcTypeNameCache.mapSet(t, result);
            return result;
        }
        if (mutable == 1) {
            result = "*".strConcat(lifePrefix).strConcat("mut ").strConcat(inner);
            tcTypeNameCache.mapSet(t, result);
            return result;
        }
        result = "*".strConcat(lifePrefix).strConcat(inner);
        tcTypeNameCache.mapSet(t, result);
        return result;
    }
    if (k == 44) {
        result = typeNameFromTypeNode(nodeGetData1(t));
        tcTypeNameCache.mapSet(t, result);
        return result;
    }
     // NK_APPLIED_TYPE (71) — erase to alias name; also check arity if alias is registered.
    if (k == 71) {
        let aliasName = getInternedStr(nodeGetData1(t));
        let args = nodeGetData2(t);
        let actualArity = args.vecLength();
        if (tcExternTypeParams.mapHas(aliasName)) {
            let externExpectedArity = tcExternTypeParams.mapGet(aliasName);
            if (actualArity != externExpectedArity) {
                tcPanicLoc(
                "E_TYPE_APPLIED_ARITY", "'".strConcat(aliasName).strConcat("' applied with ").strConcat(intToString(actualArity)).strConcat(" argument(s), expected ").strConcat(intToString(externExpectedArity)), "Extern types must be applied with exactly the number of generic parameters declared by their extern type declaration.", "Provide exactly ".strConcat(intToString(externExpectedArity)).strConcat(" argument(s) to '").strConcat(aliasName).strConcat("'.")
                );
            }
        }
        if (tcDepTypeAliasParams.mapHas(aliasName)) {
            let expectedArity = tcDepTypeAliasParams.mapGet(aliasName);
            if (actualArity != expectedArity) {
                tcPanicLoc(
                "E_TYPE_APPLIED_ARITY", "'".strConcat(aliasName).strConcat("' applied with ").strConcat(intToString(actualArity)).strConcat(" argument(s), expected ").strConcat(intToString(expectedArity)), "Dependent type aliases must be applied with exactly the number of arguments declared in the type parameter list.", "Provide exactly ".strConcat(intToString(expectedArity)).strConcat(" argument(s) to '").strConcat(aliasName).strConcat("'.")
                );
            }
        }
        result = aliasName;
        tcTypeNameCache.mapSet(t, result);
        return result;
    }
    if (k == 45) {
        let left = typeNameFromTypeNode(nodeGetData1(t));
        let right = typeNameFromTypeNode(nodeGetData2(t));
        result = left.strConcat("|").strConcat(right);
        tcTypeNameCache.mapSet(t, result);
        return result;
    }
    tcTypeNameCache.mapSet(t, result);
    result
}
fn pointerTypesCompatible(expected: *Str, actual: *Str) : Bool => {
    if (expected.strEq(actual)) {
        return true;
    }
    if (expected.strIncludes("|")) {
        if (unionTypeContains(expected, actual)) {
            return true;
        }
    }
     // Allow *mut T where *T is expected (including lifetime-prefixed forms like *a T / *a mut T).
    if (expected.strStartsWith("*") && actual.strStartsWith("*")) {
        let expectedBody = expected.strSlice(1, expected.strLength());
        let actualBody = actual.strSlice(1, actual.strLength());
        let expectedHasLife = !expectedBody.strStartsWith("mut ") && !expectedBody.strStartsWith("move ") && expectedBody.strIncludes(" ");
        let actualHasLife = !actualBody.strStartsWith("mut ") && !actualBody.strStartsWith("move ") && actualBody.strIncludes(" ");
        if (expectedHasLife) {
            let i = 0;
            while (i < expectedBody.strLength()) {
                if (expectedBody.strCharAt(i) == 32) {
                    break;
                }
                i = i + 1;
            }
            if (i < expectedBody.strLength()) {
                let expectedStart = i + 1;
                if (expectedStart <= expectedBody.strLength()) {
                    expectedBody = expectedBody.strSlice(expectedStart, expectedBody.strLength());
                }
            }
        }
        if (actualHasLife) {
            let j = 0;
            while (j < actualBody.strLength()) {
                if (actualBody.strCharAt(j) == 32) {
                    break;
                }
                j = j + 1;
            }
            if (j < actualBody.strLength()) {
                let actualStart = j + 1;
                if (actualStart <= actualBody.strLength()) {
                    actualBody = actualBody.strSlice(actualStart, actualBody.strLength());
                }
            }
        }
        if (!expectedBody.strStartsWith("mut ") && actualBody.strStartsWith("mut ")) {
            let expectedInner = expectedBody;
            let actualInner = "";
            if (actualBody.strLength() >= 4) {
                actualInner = actualBody.strSlice(4, actualBody.strLength());
            }
            else {
                actualInner = actualBody;
            }
            return expectedInner.strEq(actualInner);
        }
        if (expectedBody.strStartsWith("mut ") && !actualBody.strStartsWith("mut ")) {
            return false;
        }
        return expectedBody.strEq(actualBody);
    }
    false
}
fn strEndsWithLocal(s: *Str, suffix: *Str) : Bool => {
    let ns = s.strLength();
    let nf = suffix.strLength();
    if (nf > ns) {
        return false;
    }
    if (nf == 0) {
        return true;
    }
    if (nf == ns) {
        return s.strSlice(0, ns).strEq(suffix);
    }
    let i = 0;
    while (i < nf) {
        if (s.strCharAt((ns - nf) + i) != suffix.strCharAt(i)) {
            return false;
        }
        i = i + 1;
    }
    true
}
fn isNumberLiteralWithSuffix(n: I32, suffix: *Str) : Bool => {
    if (n == 0 || nodeKind(n) != NK_NUMBER_LIT) {
        return false;
    }
    let text = getInternedStr(nodeGetData1(n));
    strEndsWithLocal(text, suffix)
}
fn isUsizeZeroLiteralNode(n: I32) : Bool => {
    if (!isNumberLiteralWithSuffix(n, "USize")) {
        return false;
    }
    getInternedStr(nodeGetData1(n)).strEq("0USize")
}
fn isNullablePointerTypeName(name: *Str) : Bool => {
    if (!name.strIncludes("|")) {
        return false;
    }
    if (name.strStartsWith("*") && strEndsWithLocal(name, "|USize")) {
        return true;
    }
    if (name.strStartsWith("USize|*") && name.strIncludes("*")) {
        return true;
    }
    false
}
fn numericTypesCompatible(expected: *Str, actual: *Str, rhs: I32) : Bool => {
    if (expected.strEq(actual)) {
        return true;
    }
     // Allow unsigned targets from non-negative numeric literals.
    if (expected.strEq("USize") && actual.strEq("I32") && rhs != 0 && nodeKind(rhs) == NK_NUMBER_LIT) {
        let lit = getInternedStr(nodeGetData1(rhs));
        return !lit.strStartsWith("-");
    }
     // Allow I32 as USize for signed-index variables proven bounded by the call-bound
     // constraint check (Phase 4+). The bounds check compensates for the type looseness.
    if (expected.strEq("USize") && actual.strEq("I32")) {
        return true;
    }
    if (expected.strEq("I32") && actual.strEq("USize")) {
        return true;
    }
     // Unsigned integer widening: smaller types are safely assignable to larger types.
    if (expected.strEq("U16") && actual.strEq("U8")) {
        return true;
    }
    if (expected.strEq("U32") && (actual.strEq("U8") || actual.strEq("U16"))) {
        return true;
    }
    if (expected.strEq("U64") && (actual.strEq("U8") || actual.strEq("U16") || actual.strEq("U32"))) {
        return true;
    }
    if (expected.strEq("U128") && (actual.strEq("U8") || actual.strEq("U16") || actual.strEq("U32") || actual.strEq("U64"))) {
        return true;
    }
    if (expected.strEq("USize") && (actual.strEq("U8") || actual.strEq("U16") || actual.strEq("U32") || actual.strEq("U64"))) {
        return true;
    }
    false
}
fn isTypeVariableName(name: *Str) : Bool => {
    if (name.strLength() != 1) {
        return false;
    }
    let ch = charCode(name);
    (ch >= 65 && ch <= 90)
}
fn isBuiltinPrimitiveTypeName(name: *Str) : Bool => {
    name.strEq("I8") || name.strEq("I16") || name.strEq("I32") || name.strEq("I64") || name.strEq("I128") ||
    name.strEq("U8") || name.strEq("U16") || name.strEq("U32") || name.strEq("U64") || name.strEq("U128") ||
    name.strEq("USize") || name.strEq("ISize") || name.strEq("F32") || name.strEq("F64") ||
    name.strEq("Bool") || name.strEq("Char") || name.strEq("Void")
}
fn runtimeOpaqueHandleCompatible(expected: *Str, actual: *Str) : Bool => {
    if (actual.strEq("I32") && (expected.strEq("Vec") || expected.strEq("Map") || expected.strEq("Set"))) {
        return true;
    }
    if (expected.strEq("I32") && (actual.strEq("Vec") || actual.strEq("Map") || actual.strEq("Set"))) {
        return true;
    }
    false
}
fn typeNameWithAliasBase(name: *Str) : *Str => {
    if (tcAliasBaseType.mapHas(name)) {
        return tcAliasBaseType.mapGet(name);
    }
    name
}
fn typeNamesCompatible(expected: *Str, actual: *Str, rhs: I32) : Bool => {
    if (expected.strEq("Unknown") || actual.strEq("Unknown")) {
        return true;
    }
    if (expected.strEq(actual)) {
        return true;
    }
    if (isTypeVariableName(expected) || isTypeVariableName(actual)) {
        return true;
    }
    let expectedBase = typeNameWithAliasBase(expected);
    let actualBase = typeNameWithAliasBase(actual);
    if (expectedBase.strEq(actualBase)) {
        return true;
    }
    if (runtimeOpaqueHandleCompatible(expectedBase, actualBase)) {
        return true;
    }
    if (pointerTypesCompatible(expectedBase, actualBase)) {
        return true;
    }
    if (numericTypesCompatible(expectedBase, actualBase, rhs)) {
        return true;
    }
    if (runtimeOpaqueHandleCompatible(expected, actual)) {
        return true;
    }
    if (pointerTypesCompatible(expected, actual)) {
        return true;
    }
    if (numericTypesCompatible(expected, actual, rhs)) {
        return true;
    }
    false
}
fn inferExprTypeName(n: I32, fnReturnTypes: Map<I32, I32>, localTypes: Map<I32, I32>) : *Str => {
    if (n == 0) {
        return "Unknown";
    }
    let kind = nodeKind(n);
    if (kind == 20) {
        let text = getInternedStr(nodeGetData1(n));
        if (strEndsWithLocal(text, "USize")) {
            return "USize";
        }
        if (strEndsWithLocal(text, "ISize")) {
            return "ISize";
        }
        if (strEndsWithLocal(text, "U128")) {
            return "U128";
        }
        if (strEndsWithLocal(text, "I128")) {
            return "I128";
        }
        if (strEndsWithLocal(text, "U64")) {
            return "U64";
        }
        if (strEndsWithLocal(text, "I64")) {
            return "I64";
        }
        if (strEndsWithLocal(text, "U32")) {
            return "U32";
        }
        if (strEndsWithLocal(text, "I32")) {
            return "I32";
        }
        if (strEndsWithLocal(text, "U16")) {
            return "U16";
        }
        if (strEndsWithLocal(text, "I16")) {
            return "I16";
        }
        if (strEndsWithLocal(text, "U8")) {
            return "U8";
        }
        if (strEndsWithLocal(text, "I8")) {
            return "I8";
        }
        return "I32";
    }
    if (kind == 21) {
        return "Bool";
    }
    if (kind == 22) {
        return "*Str";
    }
    if (kind == 23) {
        return "Char";
    }
    if (kind == 24) {
        let name = getInternedStr(nodeGetData1(n));
        if (localTypes.mapHas(name)) {
            return localTypes.mapGet(name);
        }
        if (tcGlobalValueTypes.mapHas(name)) {
            return tcGlobalValueTypes.mapGet(name);
        }
        return "Unknown";
    }
    if (kind == 26) {
        let op = getInternedStr(nodeGetData1(n));
        let inner = inferExprTypeName(nodeGetData2(n), fnReturnTypes, localTypes);
        if (op.strEq("&")) {
            return "*".strConcat(inner);
        }
        if (op.strEq("&mut")) {
            return "*mut ".strConcat(inner);
        }
        if (op.strEq("!")) {
            return "Bool";
        }
        return inner;
    }
    if (kind == 25) {
        let op = getInternedStr(nodeGetData1(n));
        if (op.strEq("==") || op.strEq("!=") || op.strEq("<") || op.strEq("<=") || op.strEq(">") || op.strEq(">=") || op.strEq("&&") || op.strEq("||")) {
            return "Bool";
        }
        if (op.strEq("..")) {
            return "Iter";
        }
        return inferExprTypeName(nodeGetData2(n), fnReturnTypes, localTypes);
    }
    if (kind == 27) {
        let callee = nodeGetData1(n);
        if (nodeKind(callee) == 24) {
            let fname = getInternedStr(nodeGetData1(callee));
            if (fname.strEq("into") && nodeGetData3(n) == 1) {
                let typeArgs = nodeGetData4(n);
                if (typeArgs.vecLength() == 1 && nodeKind(typeArgs.vecGet(0)) == NK_NAMED_TYPE)
                {
                    let cname = getInternedStr(nodeGetData1(typeArgs.vecGet(0)));
                    return "__dyn_".strConcat(cname);
                }
                return "Unknown";
            }
            if (fnReturnTypes.mapHas(fname)) {
                return fnReturnTypes.mapGet(fname);
            }
        }
         // Handle method calls: obj.method() → look up method's return type
        if (nodeKind(callee) == NK_MEMBER_EXPR) {
            let methodName = getInternedStr(nodeGetData2(callee));
            if (fnReturnTypes.mapHas(methodName)) {
                return fnReturnTypes.mapGet(methodName);
            }
        }
    }
    if (kind == NK_TUPLE_EXPR) {
        return "Unknown";
    }
    "Unknown"
}
fn exprIsNumberLiteralNonzero(n: I32) : Bool => {
    if (n == 0 || nodeKind(n) != NK_NUMBER_LIT) {
        return false;
    }
    !getInternedStr(nodeGetData1(n)).strEq("0")
}
fn isDecimalDigits(s: *Str) : Bool => {
    let i = 0;
    if (s.strLength() == 0) {
        return false;
    }
    while (i < s.strLength()) {
        let ch = s.strCharAt(i);
        if (ch < 48 || ch > 57) {
            return false;
        }
        i = i + 1;
    }
    true
}
fn tryGetDecimalLiteralValue(n: I32) : I32 => {
    if (n == 0 || nodeKind(n) != NK_NUMBER_LIT) {
        return 0;
    }
    let text = getInternedStr(nodeGetData1(n));
    if (!isDecimalDigits(text)) {
        return 0;
    }
    parseInt(text)
}
 // Returns the known I32 value for a node: either a decimal literal or a variable with a tracked
 // literal assignment. Returns a sentinel value of -2147483649 (impossible I32) when unknown.
fn tryGetKnownIntValue(n: I32) : I32 => {
    if (n == 0) {
        return - 2147483649;
    }
    let k = nodeKind(n);
    if (k == NK_NUMBER_LIT) {
        let text = getInternedStr(nodeGetData1(n));
        if (isDecimalDigits(text)) {
            return parseInt(text);
        }
        return - 2147483649;
    }
    if (k == NK_IDENTIFIER) {
        let vname = getInternedStr(nodeGetData1(n));
        if (tcVarLiteralValues.mapHas(vname)) {
            return tcVarLiteralValues.mapGet(vname);
        }
    }
    -2147483649
}
fn knownIntValueIsValid(v: I32) : Bool => {
     // The sentinel -2147483649 cannot be represented as I32 in JS (it's a float), but
     // we use it as a distinct out-of-band marker. In JS, parseInt returns it fine.
     // A simpler check: any value in [-2147483648, 2147483647] is a valid I32.
    v >= -2147483648 && v <= 2147483647
}
fn isDecimalZeroLiteral(n: I32) : Bool => {
    if (n == 0 || nodeKind(n) != NK_NUMBER_LIT) {
        return false;
    }
    getInternedStr(nodeGetData1(n)).strEq("0")
}
 // Temporary typecheck context maps used for strict array bounds proofs.
let tcArrayInitBounds : Map<I32, I32> = mapNew();
let tcIndexUpperBounds : Map<I32, I32> = mapNew();
 // Path-sensitive call-bound facts: varName -> "fnName:argK" (e.g. "p" -> "str_length:s").
 // Populated by if-condition narrowing for patterns like `if (i < str_length(s))`.
let tcCallBounds : Map<I32, I32> = mapNew();
 // Maps function name -> Vec<*Str> of per-param call-bound constraints ("fnName:refParamIdx" or "").
let fnParamCallBounds : Map<I32, I32> = mapNew();
 // Maps variable names to their known literal I32 values for richer overflow diagnostics.
let tcVarLiteralValues : Map<I32, I32> = mapNew();
let tcGlobalValueTypes : Map<I32, I32> = mapNew();
let tcAliasUnionTags : Map<I32, I32> = mapNew();
let tcTypeAliasNames : *mut Set<I32> = setNew();
let tcDepTypeAliasParams : Map<I32, I32> = mapNew();
 // alias_name -> expected arg count (I32)
let tcExternTypeParams : Map<I32, I32> = mapNew();
 // extern_type_name -> expected arg count (I32)
let tcContractNames : *mut Set<I32> = setNew();
let tcDestructorAliasByAlias : Map<I32, I32> = mapNew();
let tcDestructorAliasNames : Vec<I32> = vecNew();
let tcAliasBaseType : Map<I32, I32> = mapNew();
 // Maps function name → Set of field names present in that function's `this` struct.
 // Only populated for functions that implicitly return `this` (no explicit return type).
let tcFnThisFields : Map<I32, I32> = mapNew();
fn typeNodeIsDestructorReceiver(t: I32, aliasName: *Str) : Bool => {
    if (t == 0) {
        return false;
    }
     // Preferred form: alias receiver value (e.g. Alloc<...>)
    if (nodeKind(t) == NK_NAMED_TYPE && getInternedStr(nodeGetData1(t)).strEq(aliasName)) {
        return true;
    }
     // Back-compat: *move Alias
    if (nodeKind(t) == NK_POINTER_TYPE && nodeGetData3(t) == 1) {
        return typeNameFromTypeNode(nodeGetData2(t)).strEq(aliasName);
    }
    false
}
fn collectUnionNamedTags(typeNode: I32, tags: Vec<I32>) : I32 => {
    if (typeNode == 0) {
        return 0;
    }
    let kind = nodeKind(typeNode);
    if (kind == NK_UNION_TYPE) {
        collectUnionNamedTags(nodeGetData1(typeNode), tags);
        collectUnionNamedTags(nodeGetData2(typeNode), tags);
        return 0;
    }
    if (kind == NK_NAMED_TYPE) {
        tags.vecPush(getInternedStr(nodeGetData1(typeNode)));
        return 0;
    }
    if (kind == NK_REFINEMENT_TYPE) {
        collectUnionNamedTags(nodeGetData1(typeNode), tags);
    }
    0
}
fn tryGetNonnegativeIntegerLiteral(n: I32) : I32 => {
    if (n == 0 || nodeKind(n) != NK_NUMBER_LIT) {
        return - 1;
    }
    let text = getInternedStr(nodeGetData1(n));
    if (strEndsWithLocal(text, "USize")) {
        let len = text.strLength();
        if (len < 5) {
            return - 1;
        }
        let raw = text.strSlice(0, len - 5);
        if (!isDecimalDigits(raw)) {
            return - 1;
        }
        return parseInt(raw);
    }
    if (!isDecimalDigits(text)) {
        return - 1;
    }
    parseInt(text)
}
fn tryGetArrayInitBoundFromTypeNode(t: I32) : I32 => {
    if (t == 0) {
        return - 1;
    }
    let k = nodeKind(t);
    if (k == NK_REFINEMENT_TYPE) {
        return tryGetArrayInitBoundFromTypeNode(nodeGetData1(t));
    }
    if (k == NK_POINTER_TYPE) {
        return tryGetArrayInitBoundFromTypeNode(nodeGetData2(t));
    }
    if (k == NK_ARRAY_TYPE) {
        return tryGetNonnegativeIntegerLiteral(nodeGetData2(t));
    }
    -1
}
fn tryGetIndexUpperBoundFromTypeNode(t: I32) : I32 => {
    if (t == 0 || nodeKind(t) != NK_REFINEMENT_TYPE) {
        return - 1;
    }
    let base = nodeGetData1(t);
    if (base == 0 || nodeKind(base) != NK_NAMED_TYPE) {
        return - 1;
    }
    let baseName = getInternedStr(nodeGetData1(base));
    if (!baseName.strEq("USize")) {
        return - 1;
    }
    let lit = tryGetNonnegativeIntegerLiteral(nodeGetData3(t));
    if (lit < 0) {
        return - 1;
    }
    let op = getInternedStr(nodeGetData2(t));
    if (op.strEq("<")) {
        return lit - 1;
    }
    if (op.strEq("<=")) {
        return lit;
    }
    -1
}
fn isZeroNumericLiteralNode(n: I32) : Bool => {
    if (n == 0 || nodeKind(n) != NK_NUMBER_LIT) {
        return false;
    }
    let text = getInternedStr(nodeGetData1(n));
    text.strEq("0") || text.strEq("0USize")
}
 // If `t` is a refinement type of the form `USize < fnName(paramName)`,
 // returns "fnName:paramName"; otherwise returns "".
fn tryExtractFnCallConstraint(t: I32) : *Str => {
    if (t == 0 || nodeKind(t) != NK_REFINEMENT_TYPE) {
        return "";
    }
    let base = nodeGetData1(t);
    if (base == 0 || nodeKind(base) != NK_NAMED_TYPE) {
        return "";
    }
    let baseName = getInternedStr(nodeGetData1(base));
    if (!baseName.strEq("USize") && !baseName.strEq("I32") && !baseName.strEq("ISize")) {
        return "";
    }
    let op = getInternedStr(nodeGetData2(t));
    if (!op.strEq("<") && !op.strEq("<=")) {
        return "";
    }
    let constraintExpr = nodeGetData3(t);
    if (constraintExpr == 0 || nodeKind(constraintExpr) != NK_CALL_EXPR) {
        return "";
    }
    let callee = nodeGetData1(constraintExpr);
    let args = nodeGetData2(constraintExpr);
    if (callee == 0 || nodeKind(callee) != NK_IDENTIFIER) {
        return "";
    }
    if (args.vecLength() != 1) {
        return "";
    }
    let arg0 = args.vecGet(0);
    if (arg0 == 0 || nodeKind(arg0) != NK_IDENTIFIER) {
        return "";
    }
    let fnName = getInternedStr(nodeGetData1(callee));
    let refParamName = getInternedStr(nodeGetData1(arg0));
    fnName.strConcat(":").strConcat(refParamName)
}
fn isExternTypeLikeDecl(stmt: I32) : Bool => {
    if (stmt == 0) {
        return false;
    }
    let kind = nodeKind(stmt);
    if (kind == NK_EXTERN_TYPE_DECL) {
        return true;
    }
     // Some transforms may keep extern-type declarations in alias-shaped nodes.
    if (kind == NK_TYPE_ALIAS && nodeGetData3(stmt) == 0) {
        return true;
    }
    false
}
fn exprIsProvenNonzero(n: I32, nonnullPtrs: Map<I32, I32>) : Bool => {
    if (exprIsNumberLiteralNonzero(n)) {
        return true;
    }
    if (n != 0 && nodeKind(n) == NK_IDENTIFIER) {
        let name = getInternedStr(nodeGetData1(n));
        return nonnullPtrs.mapHas(name);
    }
    false
}
fn typeNodeProvesNonzero(t: I32) : Bool => {
    if (t == 0 || nodeKind(t) != NK_REFINEMENT_TYPE) {
        return false;
    }
    let op = getInternedStr(nodeGetData2(t));
    if (!op.strEq("!=")) {
        return false;
    }
    isZeroNumericLiteralNode(nodeGetData3(t))
}
fn typecheckIfExprBranch(n: I32, fnArities: Map<I32, I32>, fnParamTypes: Map<I32, I32>, fnReturnTypes: Map<I32, I32>,
localTypes: Map<I32, I32>, nonnullPtrs: Map<I32, I32>) : Result<I32, TypeError> => {
    let cond = nodeGetData1(n);
    typecheckExpr(cond, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs)?;
    let condName = inferExprTypeName(cond, fnReturnTypes, localTypes);
    if (!condName.strEq("Bool") && !condName.strEq("Unknown")) {
        return tcResultError( "E_TYPE_IF_CONDITION", "if condition must be Bool, got ".strConcat(condName), "Conditional branches require a boolean predicate, but the given expression has a non-Bool type.", "Return or compute a Bool expression in the if condition." );
    }
    let ieThenKey = "";
    let ieElseKey = "";
    let ieCbKey = "";
    let ieCbValue = "";
    if (nodeKind(cond) == NK_BINARY_EXPR) {
        let bop = getInternedStr(nodeGetData1(cond));
        let bleft = nodeGetData2(cond);
        let bright = nodeGetData3(cond);
        if (bop.strEq("!=")) {
            if (ieThenKey.strEq("") && nodeKind(bleft) == NK_IDENTIFIER && (isUsizeZeroLiteralNode(bright) || isZeroNumericLiteralNode(bright))) {
                ieThenKey = getInternedStr(nodeGetData1(bleft));
            }
            if (ieThenKey.strEq("") && nodeKind(bright) == NK_IDENTIFIER && (isUsizeZeroLiteralNode(bleft) || isZeroNumericLiteralNode(bleft))) {
                ieThenKey = getInternedStr(nodeGetData1(bright));
            }
        }
        if (bop.strEq("==")) {
            if (ieElseKey.strEq("") && nodeKind(bleft) == NK_IDENTIFIER && isZeroNumericLiteralNode(bright)) {
                ieElseKey = getInternedStr(nodeGetData1(bleft));
            }
            if (ieElseKey.strEq("") && nodeKind(bright) == NK_IDENTIFIER && isZeroNumericLiteralNode(bleft)) {
                ieElseKey = getInternedStr(nodeGetData1(bright));
            }
        }
        if ((bop.strEq("<") || bop.strEq("<=")) && nodeKind(bleft) == NK_IDENTIFIER && nodeKind(bright) == NK_CALL_EXPR) {
            let ieCbCallee = nodeGetData1(bright);
            let ieCbArgs = nodeGetData2(bright);
            if (nodeKind(ieCbCallee) == NK_IDENTIFIER && ieCbArgs.vecLength() == 1 &&
            nodeKind(ieCbArgs.vecGet(0)) == NK_IDENTIFIER) {
                ieCbKey = getInternedStr(nodeGetData1(bleft));
                ieCbValue = getInternedStr(nodeGetData1(ieCbCallee)).strConcat(":").strConcat(getInternedStr(nodeGetData1(ieCbArgs.vecGet(0))));
            }
        }
    }
    let ieThenPresent = false;
    if (!ieThenKey.strEq("")) {
        ieThenPresent = nonnullPtrs.mapHas(ieThenKey);
        nonnullPtrs.mapSet(ieThenKey, 1);
    }
    let ieCbWasPresent = false;
    if (!ieCbKey.strEq("")) {
        ieCbWasPresent = tcCallBounds.mapHas(ieCbKey);
        tcCallBounds.mapSet(ieCbKey, ieCbValue);
    }
    typecheckStmt(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, "Unknown");
    if (!ieThenKey.strEq("") && !ieThenPresent) {
        nonnullPtrs.mapDelete(ieThenKey);
    }
    if (!ieCbKey.strEq("") && !ieCbWasPresent) {
        tcCallBounds.mapDelete(ieCbKey);
    }
    if (nodeGetData3(n) != 0) {
        let ieElsePresent = false;
        if (!ieElseKey.strEq("")) {
            ieElsePresent = nonnullPtrs.mapHas(ieElseKey);
            nonnullPtrs.mapSet(ieElseKey, 1);
        }
        typecheckStmt(nodeGetData3(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, "Unknown");
        if (!ieElseKey.strEq("") && !ieElsePresent) {
            nonnullPtrs.mapDelete(ieElseKey);
        }
    }
    Ok<I32> {
        value: 0
    }
}
fn typecheckMatchExprBranch(n: I32, fnArities: Map<I32, I32>, fnParamTypes: Map<I32, I32>, fnReturnTypes: Map<I32, I32>,
localTypes: Map<I32, I32>, nonnullPtrs: Map<I32, I32>) : Result<I32, TypeError> => {
    let target = nodeGetData1(n);
    typecheckExpr(target, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs)?;
    let targetName = inferExprTypeName(target, fnReturnTypes, localTypes);
    let expectedTags = vecNew();
    if (tcAliasUnionTags.mapHas(targetName)) {
        expectedTags = tcAliasUnionTags.mapGet(targetName);
    }
    let cases = nodeGetData2(n);
    let i = 0;
    let len = cases.vecLength();
    let seenTags = setNew();
    let hasWildcard = false;
    while (i < len) {
        let caseNode = cases.vecGet(i);
        let pat = caseNode.vecGet(0);
        if (nodeKind(pat) == NK_WILDCARD_PAT) {
            hasWildcard = true;
        }
        if (nodeKind(pat) == NK_NAME_PAT || nodeKind(pat) == NK_STRUCT_PAT) {
            seenTags.setAdd(getInternedStr(nodeGetData1(pat)));
        }
        typecheckStmt(caseNode.vecGet(1), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, "Unknown");
        i = i + 1;
    }
    if (expectedTags.vecLength() > 0 && !hasWildcard) {
        let j = 0;
        let jlen = expectedTags.vecLength();
        while (j < jlen) {
            let tag = expectedTags.vecGet(j);
            if (!seenTags.setHas(tag)) {
                return tcResultError( "E_TYPE_MATCH_NON_EXHAUSTIVE",
                "Non-exhaustive match: missing case for ".strConcat(tag), "A match expression over a known union type does not handle all variants.", "Add missing case arms or include a wildcard case '_'." );
            }
            j = j + 1;
        }
    }
    Ok<I32> {
        value: 0
    }
}
fn typecheckIfStmtBranch(n: I32, fnArities: Map<I32, I32>, fnParamTypes: Map<I32, I32>, fnReturnTypes: Map<I32, I32>,
localTypes: Map<I32, I32>, nonnullPtrs: Map<I32, I32>, expectedReturnType: *Str) : Result<I32, TypeError> => {
    let cond = nodeGetData1(n);
    typecheckExpr(cond, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs)?;
    let condName = inferExprTypeName(cond, fnReturnTypes, localTypes);
    if (!condName.strEq("Bool") && !condName.strEq("Unknown")) {
        return tcResultError( "E_TYPE_IF_CONDITION", "if condition must be Bool, got ".strConcat(condName),
        "Conditional branches require a boolean predicate, but the given expression has a non-Bool type.", "Return or compute a Bool expression in the if condition." );
    }
    let thenInjectKey = "";
    let elseInjectKey = "";
    let cbThenKey = "";
    let cbThenValue = "";
    if (nodeKind(cond) == NK_BINARY_EXPR) {
        let bop = getInternedStr(nodeGetData1(cond));
        let bleft = nodeGetData2(cond);
        let bright = nodeGetData3(cond);
        if (bop.strEq("!=")) {
            if (thenInjectKey.strEq("") && nodeKind(bleft) == NK_IDENTIFIER && (isUsizeZeroLiteralNode(bright) || isZeroNumericLiteralNode(bright))) {
                thenInjectKey = getInternedStr(nodeGetData1(bleft));
            }
            if (thenInjectKey.strEq("") && nodeKind(bright) == NK_IDENTIFIER && (isUsizeZeroLiteralNode(bleft) || isZeroNumericLiteralNode(bleft))) {
                thenInjectKey = getInternedStr(nodeGetData1(bright));
            }
        }
        if (bop.strEq("==")) {
            if (elseInjectKey.strEq("") && nodeKind(bleft) == NK_IDENTIFIER && isZeroNumericLiteralNode(bright)) {
                elseInjectKey = getInternedStr(nodeGetData1(bleft));
            }
            if (elseInjectKey.strEq("") && nodeKind(bright) == NK_IDENTIFIER && isZeroNumericLiteralNode(bleft)) {
                elseInjectKey = getInternedStr(nodeGetData1(bright));
            }
        }
        if ((bop.strEq("<") || bop.strEq("<=")) && nodeKind(bleft) == NK_IDENTIFIER && nodeKind(bright) == NK_CALL_EXPR) {
            let cbCallee = nodeGetData1(bright);
            let cbArgs = nodeGetData2(bright);
            if (nodeKind(cbCallee) == NK_IDENTIFIER && cbArgs.vecLength() == 1 &&
            nodeKind(cbArgs.vecGet(0)) == NK_IDENTIFIER) {
                cbThenKey = getInternedStr(nodeGetData1(bleft));
                cbThenValue = getInternedStr(nodeGetData1(cbCallee)).strConcat(":").strConcat(getInternedStr(nodeGetData1(cbArgs.vecGet(0))));
            }
        }
    }
    let narrowedIdent = "";
    let hadPrevNarrowed = 0;
    let prevNarrowedType = "";
    if (nodeKind(cond) == NK_IS_EXPR) {
        let subject = nodeGetData1(cond);
        let pat = nodeGetData2(cond);
        if (nodeKind(subject) == NK_IDENTIFIER && (nodeKind(pat) == NK_NAME_PAT || nodeKind(pat)
        == NK_STRUCT_PAT)) {
            narrowedIdent = getInternedStr(nodeGetData1(subject));
            let narrowedType = getInternedStr(nodeGetData1(pat));
            if (localTypes.mapHas(narrowedIdent)) {
                hadPrevNarrowed = 1;
                prevNarrowedType = localTypes.mapGet(narrowedIdent);
            }
            localTypes.mapSet(narrowedIdent, narrowedType);
        }
    }
    let thenWasPresent = false;
    if (!thenInjectKey.strEq("")) {
        thenWasPresent = nonnullPtrs.mapHas(thenInjectKey);
        nonnullPtrs.mapSet(thenInjectKey, 1);
    }
    let cbThenWasPresent = false;
    if (!cbThenKey.strEq("")) {
        cbThenWasPresent = tcCallBounds.mapHas(cbThenKey);
        tcCallBounds.mapSet(cbThenKey, cbThenValue);
    }
    typecheckStmt(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
    nonnullPtrs, expectedReturnType);
    if (!thenInjectKey.strEq("") && !thenWasPresent) {
        nonnullPtrs.mapDelete(thenInjectKey);
    }
    if (!cbThenKey.strEq("") && !cbThenWasPresent) {
        tcCallBounds.mapDelete(cbThenKey);
    }
    if (!narrowedIdent.strEq("")) {
        if (hadPrevNarrowed == 1) {
            localTypes.mapSet(narrowedIdent, prevNarrowedType);
        }
        else {
            localTypes.mapSet(narrowedIdent, "Unknown");
        }
    }
    if (nodeGetData3(n) != 0) {
        let elseWasPresent = false;
        if (!elseInjectKey.strEq("")) {
            elseWasPresent = nonnullPtrs.mapHas(elseInjectKey);
            nonnullPtrs.mapSet(elseInjectKey, 1);
        }
        typecheckStmt(nodeGetData3(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs, expectedReturnType);
        if (!elseInjectKey.strEq("") && !elseWasPresent) {
            nonnullPtrs.mapDelete(elseInjectKey);
        }
    }
    Ok<I32> {
        value: 0
    }
}
fn typecheckMemberOrIndexExpr(n: I32, fnArities: Map<I32, I32>, fnParamTypes: Map<I32, I32>, fnReturnTypes:
Map<I32, I32>, localTypes: Map<I32, I32>, nonnullPtrs: Map<I32, I32>) : Result<I32, TypeError> => {
    let kind = nodeKind(n);
    if (kind == NK_MEMBER_EXPR) {
        let obj = nodeGetData1(n);
        let objName = inferExprTypeName(obj, fnReturnTypes, localTypes);
        if (isNullablePointerTypeName(objName)) {
            let guarded = false;
            if (nodeKind(obj) == NK_IDENTIFIER) {
                let oname = getInternedStr(nodeGetData1(obj));
                guarded = nonnullPtrs.mapHas(oname);
            }
            if (!guarded) {
                return tcResultError( "E_SAFETY_NULLABLE_POINTER_GUARD", "Nullable pointer access requires guard", "A nullable pointer must be proven non-null before pointer-consuming operations.", "Guard with if (p != 0USize) or if (0USize != p) before member access." );
            }
        }
        if (objName.strStartsWith("__this_")) {
            let fnName = objName.strSlice(7, objName.strLength());
            if (tcFnThisFields.mapHas(fnName)) {
                let fieldNames = tcFnThisFields.mapGet(fnName);
                let field = getInternedStr(nodeGetData2(n));
                if (!fieldNames.setHas(field)) {
                    return tcResultError( "E_TYPE_MEMBER_NOT_FOUND", "Field '".strConcat(field).strConcat("' does not exist on '").strConcat(fnName).strConcat("' scope"), "The function's 'this' struct does not declare the accessed field.", "Check that the field is declared in the function body or use a different access path." );
                }
            }
        }
        typecheckExpr(nodeGetData1(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs);
        return Ok<I32> {
            value: 1
        }
        ;
    }
    if (kind == NK_INDEX_EXPR) {
        let targetNode = nodeGetData1(n);
        let targetName = inferExprTypeName(targetNode, fnReturnTypes, localTypes);
        if (isNullablePointerTypeName(targetName)) {
            let guarded = false;
            if (nodeKind(targetNode) == NK_IDENTIFIER) {
                let tname = getInternedStr(nodeGetData1(targetNode));
                guarded = nonnullPtrs.mapHas(tname);
            }
            if (!guarded) {
                return tcResultError( "E_SAFETY_NULLABLE_POINTER_GUARD", "Nullable pointer indexing requires guard", "A nullable pointer must be proven non-null before pointer-consuming operations.", "Guard with if (p != 0USize) or if (0USize != p) before indexing." );
            }
        }
        if (nodeKind(targetNode) == NK_IDENTIFIER) {
            let tname = getInternedStr(nodeGetData1(targetNode));
            if (tcArrayInitBounds.mapHas(tname)) {
                let bound = tcArrayInitBounds.mapGet(tname);
                if (bound >= 0) {
                    let indexNode = nodeGetData2(n);
                    let indexMax = -1;
                    if (nodeKind(indexNode) == NK_IDENTIFIER) {
                        let iname = getInternedStr(nodeGetData1(indexNode));
                        if (tcIndexUpperBounds.mapHas(iname)) {
                            indexMax = tcIndexUpperBounds.mapGet(iname);
                        }
                    }
                    if (indexMax < 0) {
                        indexMax = tryGetNonnegativeIntegerLiteral(indexNode);
                    }
                    if (indexMax < 0) {
                        tcPanicLoc("E_SAFETY_ARRAY_BOUNDS_UNPROVEN", "Cannot prove array index bound safety", "The array index does not have a proven upper bound under strict safety checks.", "Guard index with 'if (i < arr.length)' before indexing.");
                    }
                    if (indexMax >= bound) {
                        tcPanicLoc("E_SAFETY_ARRAY_BOUNDS", "Array index may be out of bounds", "The proven index upper bound can exceed initialized array length.", "Ensure 0 <= index < initialized length.");
                    }
                }
            }
        }
        typecheckExpr(nodeGetData1(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs);
        typecheckExpr(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs);
        return Ok<I32> {
            value: 1
        }
        ;
    }
    Ok<I32> {
        value: 0
    }
}
fn typecheckExpr(n: I32, fnArities: Map<I32, I32>, fnParamTypes: Map<I32, I32>, fnReturnTypes: Map<I32, I32>, localTypes:
Map<I32, I32>, nonnullPtrs: Map<I32, I32>) : Result<I32, TypeError> => {
    if (n == 0) {
        return Ok<I32> {
            value: 0
        }
        ;
    }
    tcCurrentNode = n;
    let kind = nodeKind(n);
    if (kind == NK_BINARY_EXPR) {
        typecheckExpr(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs)?;
        typecheckExpr(nodeGetData3(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs)?;
        let op = getInternedStr(nodeGetData1(n));
        if (op.strEq("/") && !exprIsProvenNonzero(nodeGetData3(n), nonnullPtrs)) {
            let denomNode = nodeGetData3(n);
            let denomDesc = "denominator";
            if (nodeKind(denomNode) == NK_IDENTIFIER) {
                denomDesc = "denominator `".strConcat(getInternedStr(nodeGetData1(denomNode))).strConcat("`");
            }
            tcPanicLoc("E_SAFETY_DIV_BY_ZERO", "Division by zero cannot be ruled out at compile time", "The ".strConcat(denomDesc).strConcat(" is not proven non-zero; any value including 0 is possible."), "Prove denominator != 0 via refinement type or control-flow guard.");
        }
        if (op.strEq("%") && !exprIsProvenNonzero(nodeGetData3(n), nonnullPtrs)) {
            let modNode = nodeGetData3(n);
            let modDesc = "modulo denominator";
            if (nodeKind(modNode) == NK_IDENTIFIER) {
                modDesc = "modulo denominator `".strConcat(getInternedStr(nodeGetData1(modNode))).strConcat("`");
            }
            return tcResultError(
            "E_SAFETY_MOD_BY_ZERO", "Modulo by zero cannot be ruled out at compile time", "The ".strConcat(modDesc).strConcat(" is not proven non-zero; any value including 0 is possible."), "Prove denominator != 0 via refinement type or control-flow guard."
            );
        }
        if (op.strEq("+") || op.strEq("-") || op.strEq("*")) {
            let lnode = nodeGetData2(n);
            let rnode = nodeGetData3(n);
            let left = tryGetKnownIntValue(lnode);
            let right = tryGetKnownIntValue(rnode);
            if (knownIntValueIsValid(left) && knownIntValueIsValid(right)) {
                let result = 0;
                if (op.strEq("+")) {
                    result = left + right;
                }
                else if (op.strEq("-")) {
                    result = left - right;
                }
                else {
                    result = left * right;
                }
                if (result < -2147483648 || result > 2147483647) {
                    let leftDesc = intToString(left);
                    let rightDesc = intToString(right);
                    if (nodeKind(lnode) == NK_IDENTIFIER) {
                        leftDesc = getInternedStr(nodeGetData1(lnode)).strConcat("=").strConcat(intToString(left));
                    }
                    if (nodeKind(rnode) == NK_IDENTIFIER) {
                        rightDesc = getInternedStr(nodeGetData1(rnode)).strConcat("=").strConcat(intToString(right));
                    }
                    let witness = leftDesc.strConcat(" ").strConcat(op).strConcat(" ").strConcat(rightDesc).strConcat(" = ").strConcat(intToString(result)).strConcat(", which is outside I32 range [-2147483648, 2147483647]");
                    tcPanicLoc("E_SAFETY_INTEGER_OVERFLOW", "Integer overflow/underflow proven possible for '".strConcat(op).strConcat("'"), witness, "Constrain operands or use a wider intermediate type before narrowing.");
                }
            }
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
        if (kind == NK_UNARY_EXPR) {
            typecheckExpr(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes,
            localTypes, nonnullPtrs)?;
        }
        else {
            typecheckExpr(nodeGetData1(n), fnArities, fnParamTypes, fnReturnTypes,
            localTypes, nonnullPtrs)?;
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_CALL_EXPR) {
        let callee = nodeGetData1(n);
        let args = nodeGetData2(n);
        let argCount = args.vecLength();
        let fname = "";
        if (nodeKind(callee) == NK_IDENTIFIER) {
            fname = getInternedStr(nodeGetData1(callee));
            if (fname.strEq("drop")) {
                if (argCount != 1) {
                    return tcResultError( "E_TYPE_ARG_COUNT",
                    "drop expects exactly one argument", "The drop builtin requires one argument representing the value to drop.", "Call drop(value) with exactly one argument." );
                }
                let target = args.vecGet(0);
                let targetName = inferExprTypeName(target, fnReturnTypes, localTypes);
                if (!tcDestructorAliasByAlias.mapHas(targetName)) {
                    return tcResultError( "E_TYPE_DESTRUCTOR_NOT_FOUND", "Type '".strConcat(targetName).strConcat("' does not have an associated destructor"), "drop can only be called for values whose alias type declares a destructor.",
                    "Define `type Alias = Base then destructorName;` and use that alias for dropped values." );
                }
                return Ok<I32> {
                    value: 0
                }
                ;
            }
            if (fname.strEq("into") && nodeGetData3(n) == 1) {
                if (argCount < 1) {
                    return tcResultError( "E_TYPE_ARG_COUNT",
                    "into conversion requires a receiver", "Method-sugar into conversion requires a source value as receiver.", "Use value.into<Contract>(...) with a receiver value." );
                }
                let typeArgs = nodeGetData4(n);
                let cname = "";
                if (typeArgs.vecLength() == 1 && nodeKind(typeArgs.vecGet(0)) == NK_NAMED_TYPE)
                {
                    cname = getInternedStr(nodeGetData1(typeArgs.vecGet(0)));
                }
                let cnameDeclared = false;
                if (!cname.strEq("")) {
                    cnameDeclared = tcContractNames.setHas(cname);
                }
                if (cname.strEq("") || !cnameDeclared) {
                    let cnameLabel = cname;
                    if (cnameLabel.strEq("")) {
                        cnameLabel = "<missing>";
                    }
                    return tcResultError( "E_TYPE_INTO_UNKNOWN_CONTRACT",
                    "Unknown contract '".strConcat(cnameLabel).strConcat("' in into conversion"), "An into conversion referenced a contract that is not declared.", "Declare the contract before converting with into." );
                }
                typecheckExpr(args.vecGet(0), fnArities, fnParamTypes, fnReturnTypes,
                localTypes, nonnullPtrs);
                let j = 1;
                while (j < argCount) {
                    typecheckExpr(args.vecGet(j), fnArities, fnParamTypes, fnReturnTypes,
                    localTypes, nonnullPtrs);
                    j = j + 1;
                }
                return Ok<I32> {
                    value: 0
                }
                ;
            }
            if (fnArities.mapHas(fname)) {
                let expected = fnArities.mapGet(fname);
                if (expected != argCount) {
                    let msg = "Function ".strConcat(fname).strConcat(" expects ".strConcat(intToString(expected))).strConcat(" args, got ".strConcat(intToString(argCount)));
                    return tcResultError( "E_TYPE_ARG_COUNT", msg, "A function call provided a different number of arguments than the function signature requires.",
                    "Pass exactly the number of parameters declared by the function." );
                }
            }
             // Dep-alias type application in expression position: arity check.
             // e.g. str_char_at(s, Index())  — Index is a dep alias, not a function.
            if (!fnArities.mapHas(fname) && tcDepTypeAliasParams.mapHas(fname)) {
                let expectedArity = tcDepTypeAliasParams.mapGet(fname);
                if (argCount != expectedArity) {
                    tcPanicLoc("E_TYPE_APPLIED_ARITY", "'".strConcat(fname).strConcat("' applied with ").strConcat(intToString(argCount)).strConcat(" argument(s), expected ").strConcat(intToString(expectedArity)), "Dependent type aliases must be applied with exactly the number of arguments declared in the type parameter list.", "Provide exactly ".strConcat(intToString(expectedArity)).strConcat(" argument(s) to '").strConcat(fname).strConcat("'."));
                }
            }
            if (fnParamTypes.mapHas(fname)) {
                let expectedTypes = fnParamTypes.mapGet(fname);
                let j = 0;
                while (j < argCount) {
                    let argNode = args.vecGet(j);
                    let argName = inferExprTypeName(argNode, fnReturnTypes, localTypes);
                    let expectedName = expectedTypes.vecGet(j);
                    if ( expectedName.strStartsWith("*") && isNullablePointerTypeName(argName) ) {
                        return tcResultError( "E_SAFETY_NULLABLE_POINTER_GUARD", "Call requires nullable pointer guard", "A nullable pointer argument must be proven non-null before pointer-consuming calls.",
                        "Guard pointer use with if (p != 0USize) or if (0USize != p) before the call." );
                    }
                    if (!typeNamesCompatible(expectedName, argName, argNode) &&
                    !(tcTypeAliasNames.setHas(expectedName) && !isBuiltinPrimitiveTypeName(expectedName))) {
                        let msg = "Type mismatch in call to ".strConcat(fname) .strConcat(" arg ").strConcat(intToString(j + 1)) .strConcat(": expected ").strConcat(expectedName)
                        .strConcat(", got ").strConcat(argName);
                        tcPanicLoc("E_TYPE_ARG_MISMATCH", msg, "A function argument type does not match the corresponding parameter type.", "Update the call argument or function parameter type so both sides are compatible.");
                    }
                    j = j + 1;
                }
            }
             // Call-bound constraint verification.
             // For each parameter with a call-bound constraint (e.g. index: USize < str_length(this)),
             // verify the corresponding argument has a proven bound matching the constraint via tc_call_bounds.
            if (fnParamCallBounds.mapHas(fname)) {
                let callBoundsVec = fnParamCallBounds.mapGet(fname);
                let cj = 0;
                while (cj < callBoundsVec.vecLength() && cj < argCount) {
                    let cb = callBoundsVec.vecGet(cj);
                    if (!cb.strEq("")) {
                        if (cb.strEq("__REFINE__")) {
                            let constrainedArg = args.vecGet(cj);
                            let refinedOk = false;
                            if (fname.strEq("str_slice") && cj == 0 && argCount >= 2 && nodeKind(args.vecGet(0)) == NK_NUMBER_LIT && getInternedStr(nodeGetData1(args.vecGet(0))).strEq("0")) {
                                refinedOk = true;
                            }
                            if (tryGetNonnegativeIntegerLiteral(constrainedArg) >= 0) {
                                refinedOk = true;
                            }
                            else if (nodeKind(constrainedArg) == NK_IDENTIFIER) {
                                let constrainedName = getInternedStr(nodeGetData1(constrainedArg));
                                if (tcIndexUpperBounds.mapHas(constrainedName) || tcCallBounds.mapHas(constrainedName)) {
                                    refinedOk = true;
                                }
                            }
                            if (!refinedOk) {
                                let msg = "Call to '".strConcat(fname).strConcat("' argument ").strConcat(intToString(cj + 1)).strConcat(" must satisfy its refinement constraint");
                                tcPanicLoc("E_SAFETY_STR_BOUNDS_UNPROVEN", msg, "The argument does not have a compile-time proof for the parameter refinement constraint.", "Provide a guard that proves the refinement before the call.");
                            }
                            cj = cj + 1;
                            continue;
                        }
                         // cb = "fnName:refParamIdx"
                        let cbSep = cb.strIndexOf(":");
                        if (cbSep < 0) {
                            tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", "Malformed internal call-bound metadata for '".strConcat(fname).strConcat("'"), "The typechecker expected call-bound metadata in the form 'fnName:paramIndex' but the separator ':' was missing.", "Regenerate the program AST and ensure call-bound metadata is emitted as 'fnName:paramIndex'.");
                        }
                        let cbLen = cb.strLength();
                        if (cbSep > cbLen) {
                            tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", "Malformed internal call-bound metadata for '".strConcat(fname).strConcat("'"), "The separator ':' index is outside the metadata string bounds.", "Regenerate the program AST and ensure call-bound metadata indexes are valid.");
                        }
                        let cbFn = cb.strSlice(0, cbSep);
                        let cbRefIdx = 0;
                        let cbIdxPos = cbSep + 1;
                        let cbIdxHasDigit = false;
                        while (cbIdxPos < cb.strLength()) {
                            let cbCh = cb.strCharAt(cbIdxPos);
                            if (cbCh < 48 || cbCh > 57) {
                                tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", "Malformed internal call-bound metadata for '".strConcat(fname).strConcat("'"), "The parameter index suffix in call-bound metadata must contain only decimal digits.", "Regenerate the program AST and ensure call-bound metadata suffixes are numeric.");
                            }
                            cbRefIdx = (cbRefIdx * 10) + (cbCh - 48);
                            cbIdxHasDigit = true;
                            cbIdxPos = cbIdxPos + 1;
                        }
                        if (!cbIdxHasDigit) {
                            tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", "Malformed internal call-bound metadata for '".strConcat(fname).strConcat("'"), "The call-bound metadata separator ':' was present, but no parameter index followed it.", "Regenerate the program AST and ensure metadata includes a numeric parameter index after ':'.");
                        }
                        let constrainedArg = args.vecGet(cj);
                        if (nodeKind(constrainedArg) == NK_IDENTIFIER && cbRefIdx >= 0 &&
                        cbRefIdx < argCount) {
                            let constrainedName =
                            getInternedStr(nodeGetData1(constrainedArg));
                            let refArg = args.vecGet(cbRefIdx);
                            if (nodeKind(refArg) == NK_IDENTIFIER) {
                                let refArgName = getInternedStr(nodeGetData1(refArg));
                                let expectedBound = cbFn.strConcat(":").strConcat(refArgName);
                                let proven = tcCallBounds.mapHas(constrainedName) &&
                                tcCallBounds.mapGet(constrainedName).strEq(expectedBound);
                                if (!proven) {
                                    let msg = "Call to '".strConcat(fname) .strConcat("' argument ").strConcat(intToString(cj + 1)) .strConcat(" ('").strConcat(constrainedName).strConcat("')") .strConcat(" must be proven < ").strConcat(cbFn)
                                    .strConcat("(").strConcat(refArgName).strConcat(")");
                                    tcPanicLoc("E_SAFETY_STR_BOUNDS_UNPROVEN", msg, "The argument does not have a proven upper bound matching the parameter constraint.", "Guard the call with 'if (".strConcat(constrainedName).strConcat(" < ").strConcat(cbFn).strConcat("(").strConcat(refArgName).strConcat("))' before calling ").strConcat(fname).strConcat("."));
                                }
                            }
                        }
                    }
                    cj = cj + 1;
                }
            }
        }
        typecheckExpr(callee, fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs)?;
        let i = 0;
        while (i < argCount) {
            typecheckExpr(args.vecGet(i), fnArities, fnParamTypes, fnReturnTypes,
            localTypes, nonnullPtrs)?;
            i = i + 1;
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (typecheckMemberOrIndexExpr(n, fnArities, fnParamTypes, fnReturnTypes, localTypes,
    nonnullPtrs)? == 1) {
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_STRUCT_INIT) {
        let fields = nodeGetData2(n);
        let i = 0;
        let len = fields.vecLength();
        while (i < len) {
            let field = fields.vecGet(i);
            typecheckExpr(field.vecGet(1), fnArities, fnParamTypes, fnReturnTypes,
            localTypes, nonnullPtrs);
            i = i + 1;
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_TUPLE_EXPR) {
        let items = nodeGetData1(n);
        let i = 0;
        let len = items.vecLength();
        while (i < len) {
            typecheckExpr(items.vecGet(i), fnArities, fnParamTypes, fnReturnTypes,
            localTypes, nonnullPtrs);
            i = i + 1;
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_IF_EXPR) {
        typecheckIfExprBranch(n, fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs)?;
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_MATCH_EXPR) {
        typecheckMatchExprBranch(n, fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs)?;
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_IS_EXPR) {
        typecheckExpr(nodeGetData1(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs);
        return Ok<I32> {
            value: 0
        }
        ;
    }
    Ok<I32> {
        value: 0
    }
}
fn typecheckStmt(n: I32, fnArities: Map<I32, I32>, fnParamTypes: Map<I32, I32>, fnReturnTypes: Map<I32, I32>, localTypes:
Map<I32, I32>, nonnullPtrs: Map<I32, I32>, expectedReturnType: *Str) : Result<I32, TypeError> => {
    if (n == 0) {
        return Ok<I32> {
            value: 0
        }
        ;
    }
    tcCurrentNode = n;
    let kind = nodeKind(n);
    if (kind == NK_BLOCK) {
        let stmts = nodeGetData1(n);
        let i = 0;
        let len = stmts.vecLength();
        while (i < len) {
            typecheckStmt(stmts.vecGet(i), fnArities, fnParamTypes, fnReturnTypes,
            localTypes, nonnullPtrs, expectedReturnType)?;
            i = i + 1;
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_EXPECT_FN_DECL) {
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_CONTRACT_DECL) {
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
        let prevArrayBounds = tcArrayInitBounds;
        let prevIndexBounds = tcIndexUpperBounds;
        let prevVarLiterals = tcVarLiteralValues;
        tcArrayInitBounds = mapNew();
        tcIndexUpperBounds = mapNew();
        tcVarLiteralValues = mapNew();
        let fnLocalTypes = mapNew();
        let fnNonnullPtrs = mapNew();
        let params = nodeGetData3(n);
        let i = 0;
        let len = params.vecLength();
        while (i < len) {
            let p = params.vecGet(i);
            let pname = getInternedStr(p.vecGet(0));
            let ptype = p.vecGet(1);
            if (ptype != 0) {
                fnLocalTypes.mapSet(pname, typeNameFromTypeNode(ptype));
                let arrInitBound = tryGetArrayInitBoundFromTypeNode(ptype);
                if (arrInitBound >= 0) {
                    tcArrayInitBounds.mapSet(pname, arrInitBound);
                }
                let indexUpperBound = tryGetIndexUpperBoundFromTypeNode(ptype);
                if (indexUpperBound >= 0) {
                    tcIndexUpperBounds.mapSet(pname, indexUpperBound);
                }
                if (typeNodeProvesNonzero(ptype)) {
                    fnNonnullPtrs.mapSet(pname, 1);
                }
            }
            i = i + 1;
        }
        let expectedName = typeNameFromTypeNode(nodeGetData4(n));
         // If function has no explicit return type, check if it terminates with `this`.
         // If so, model its return type as "__this_<name>" and track its this-struct fields.
        let fnBody = nodeGetData5(n);
        let fnameStr = getInternedStr(nodeGetData1(n));
        let hasThisParam = false;
        let pi = 0;
        let __len3 = params.vecLength();
        while (pi < __len3) {
            if (getInternedStr(params.vecGet(pi).vecGet(0)).strEq("this")) {
                hasThisParam = true;
            }
            pi = pi + 1;
        }
        if (!hasThisParam && nodeGetData4(n) == 0) {
            let terminatesWithThis = false;
            if (nodeKind(fnBody) == NK_BLOCK) {
                let bodyStmts = nodeGetData1(fnBody);
                let blen = bodyStmts.vecLength();
                if (blen > 0) {
                    let lastStmt = bodyStmts.vecGet(blen - 1);
                    if (nodeKind(lastStmt) == NK_EXPR_STMT) {
                        let lastExpr = nodeGetData1(lastStmt);
                        if (nodeKind(lastExpr) == NK_IDENTIFIER && getInternedStr(nodeGetData1(lastExpr)).strEq("this")) {
                            terminatesWithThis = true;
                        }
                    }
                    if (nodeKind(lastStmt) == NK_IDENTIFIER && getInternedStr(nodeGetData1(lastStmt)).strEq("this")) {
                        terminatesWithThis = true;
                    }
                }
            }
            else if (nodeKind(fnBody) == NK_IDENTIFIER) {
                if (getInternedStr(nodeGetData1(fnBody)).strEq("this")) {
                    terminatesWithThis = true;
                }
            }
            if (terminatesWithThis) {
                let thisFields = setNew();
                thisFields.setAdd("this");
                 // Add params (excluding 'this') to this-struct fields
                let qi = 0;
                let __len2 = params.vecLength();
                while (qi < __len2) {
                    let pn = getInternedStr(params.vecGet(qi).vecGet(0));
                    if (!pn.strEq("this")) {
                        thisFields.setAdd(pn);
                    }
                    qi = qi + 1;
                }
                 // Add declared names from function body
                if (nodeKind(fnBody) == NK_BLOCK) {
                    let bodyStmts = nodeGetData1(fnBody);
                    let bi = 0;
                    let blen2 = bodyStmts.vecLength();
                    while (bi < blen2) {
                        let bstmt = bodyStmts.vecGet(bi);
                        let bkind = nodeKind(bstmt);
                        if (bkind == NK_LET_DECL) {
                            thisFields.setAdd(getInternedStr(nodeGetData1(bstmt)));
                        }
                        if (bkind == NK_FN_DECL || bkind == NK_CLASS_FN_DECL) {
                            thisFields.setAdd(getInternedStr(nodeGetData1(bstmt)));
                        }
                        bi = bi + 1;
                    }
                }
                tcFnThisFields.mapSet(fnameStr, thisFields);
                fnReturnTypes.mapSet(fnameStr, "__this_".strConcat(fnameStr));
            }
        }
        typecheckStmt(nodeGetData5(n), fnArities, fnParamTypes, fnReturnTypes,
        fnLocalTypes, fnNonnullPtrs, expectedName)?;
        let body = nodeGetData5(n);
        if (nodeKind(body) != NK_BLOCK) {
            let bodyName = inferExprTypeName(body, fnReturnTypes, fnLocalTypes);
            if (!typeNamesCompatible(expectedName, bodyName, body)) {
                let fname = getInternedStr(nodeGetData1(n));
                return tcResultError( "E_TYPE_RETURN_MISMATCH", "Function ".strConcat(fname).strConcat(" return type mismatch: expected ").strConcat(expectedName).strConcat(", got ").strConcat(bodyName),
                "The function body expression type does not match the declared return type.", "Update the function return type annotation or adjust the returned expression." );
            }
        }
        tcArrayInitBounds = prevArrayBounds;
        tcIndexUpperBounds = prevIndexBounds;
        tcVarLiteralValues = prevVarLiterals;
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_LET_DECL) {
        let declaredType = nodeGetData2(n);
        let rhs = nodeGetData3(n);
        typecheckExpr(rhs, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs)?;
        let rhsName = inferExprTypeName(rhs, fnReturnTypes, localTypes);
        if (declaredType != 0) {
            let declaredName = typeNameFromTypeNode(declaredType);
            if (!typeNamesCompatible(declaredName, rhsName, rhs) && !isThisReturnTypeFor (rhsName, declaredName) &&
            !(tcTypeAliasNames.setHas(declaredName) && !isBuiltinPrimitiveTypeName(declaredName))) {
                let vname = getInternedStr(nodeGetData1(n));
                let msg = "Type mismatch for let ".strConcat(vname).strConcat(": expected ").strConcat(declaredName).strConcat(", got ").strConcat(rhsName);
                tcPanicLoc("E_TYPE_LET_MISMATCH", msg, "An explicit let type annotation does not match the assigned RHS expression type.", "Update the explicit type annotation or change the RHS expression to match.");
            }
            let lname = getInternedStr(nodeGetData1(n));
            localTypes.mapSet(lname, declaredName);
            let arrInitBound = tryGetArrayInitBoundFromTypeNode(declaredType);
            if (arrInitBound >= 0) {
                tcArrayInitBounds.mapSet(lname, arrInitBound);
            }
            let indexUpperBound = tryGetIndexUpperBoundFromTypeNode(declaredType);
            if (indexUpperBound >= 0) {
                tcIndexUpperBounds.mapSet(lname, indexUpperBound);
            }
        }
        else if (!rhsName.strEq("Unknown")) {
            localTypes.mapSet(getInternedStr(nodeGetData1(n)), rhsName);
        }
         // Track literal assignments for richer overflow witness messages.
        let litVal = tryGetKnownIntValue(rhs);
        if (knownIntValueIsValid(litVal)) {
            tcVarLiteralValues.mapSet(getInternedStr(nodeGetData1(n)), litVal);
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_EXTERN_IMPORT_DECL) {
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_EXPR_STMT) {
        typecheckExpr(nodeGetData1(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs)?;
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_ASSIGN_STMT) {
        let target = nodeGetData1(n);
        let value = nodeGetData2(n);
        typecheckExpr(target, fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs);
        typecheckExpr(value, fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs);
        if (nodeKind(target) == NK_IDENTIFIER) {
            let tname = getInternedStr(nodeGetData1(target));
            if (localTypes.mapHas(tname)) {
                let expectedName = localTypes.mapGet(tname);
                let valueName = inferExprTypeName(value, fnReturnTypes, localTypes);
                if (!typeNamesCompatible(expectedName, valueName, value) &&
                !(tcTypeAliasNames.setHas(expectedName) && !isBuiltinPrimitiveTypeName(expectedName))) {
                    tcPanicLoc("E_TYPE_ASSIGN_MISMATCH", "Assignment mismatch for ".strConcat(tname).strConcat(": expected ").strConcat(expectedName).strConcat(", got ").strConcat(valueName), "The assigned value type is incompatible with the declared variable type.", "Assign a compatible value or change the variable type declaration.");
                }
            }
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_RETURN_STMT) {
        let value = nodeGetData1(n);
        typecheckExpr(value, fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs);
        if (!expectedReturnType.strEq("Unknown")) {
            let valueName = inferExprTypeName(value, fnReturnTypes, localTypes);
            if (!typeNamesCompatible(expectedReturnType, valueName, value)) {
                return tcResultError( "E_TYPE_RETURN_MISMATCH",
                "Return type mismatch: expected ".strConcat(expectedReturnType).strConcat(", got ").strConcat(valueName), "A return statement produced a value incompatible with the function's declared return type.", "Return a value of the declared type or adjust the function return annotation." );
            }
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_IF_STMT) {
        typecheckIfStmtBranch(n, fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs, expectedReturnType)?;
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_FOR_STMT) {
        typecheckExpr(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs);
        typecheckExpr(nodeGetData3(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs);
        typecheckStmt(nodeGetData4(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs, expectedReturnType);
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_WHILE_STMT) {
        let cond = nodeGetData1(n);
        typecheckExpr(cond, fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs);
        let condName = inferExprTypeName(cond, fnReturnTypes, localTypes);
        if (!condName.strEq("Bool") && !condName.strEq("Unknown")) {
            return tcResultError( "E_TYPE_IF_CONDITION", "if condition must be Bool, got ".strConcat(condName),
            "Conditional branches require a boolean predicate, but the given expression has a non-Bool type.", "Return or compute a Bool expression in the condition." );
        }
         // Call-bound narrowing: inject `i < fnName(s)` fact into while body.
        let whCbKey = "";
        let whCbValue = "";
        if (nodeKind(cond) == NK_BINARY_EXPR) {
            let whBop = getInternedStr(nodeGetData1(cond));
            let whBleft = nodeGetData2(cond);
            let whBright = nodeGetData3(cond);
            if ((whBop.strEq("<") || whBop.strEq("<=")) && nodeKind(whBleft) == NK_IDENTIFIER && nodeKind(whBright) == NK_CALL_EXPR) {
                let whCallee = nodeGetData1(whBright);
                let whArgs = nodeGetData2(whBright);
                if (nodeKind(whCallee) == NK_IDENTIFIER && whArgs.vecLength() == 1 &&
                nodeKind(whArgs.vecGet(0)) == NK_IDENTIFIER) {
                    whCbKey = getInternedStr(nodeGetData1(whBleft));
                    whCbValue = getInternedStr(nodeGetData1(whCallee)).strConcat(":").strConcat(getInternedStr(nodeGetData1(whArgs.vecGet(0))));
                }
            }
        }
        let whCbWasPresent = false;
        if (!whCbKey.strEq("")) {
            whCbWasPresent = tcCallBounds.mapHas(whCbKey);
            tcCallBounds.mapSet(whCbKey, whCbValue);
        }
        typecheckStmt(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs, expectedReturnType);
        if (!whCbKey.strEq("") && !whCbWasPresent) {
            tcCallBounds.mapDelete(whCbKey);
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_LOOP_STMT) {
        typecheckStmt(nodeGetData1(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs, expectedReturnType);
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_LIFETIME_STMT) {
        typecheckStmt(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes,
        nonnullPtrs, expectedReturnType);
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_INTO_STMT) {
        let cname = getInternedStr(nodeGetData1(n));
        if (!tcContractNames.setHas(cname)) {
            return tcResultError(
            "E_TYPE_UNKNOWN_CONTRACT", "Unknown contract '".strConcat(cname).strConcat("' in into statement"), "An into statement referenced a contract that is not declared.", "Declare the contract before using 'into'."
            );
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
     // Register nested type aliases (e.g. inside fn body) so let-mismatch check recognises them.
    if (kind == NK_TYPE_ALIAS) {
        let aliasName = getInternedStr(nodeGetData1(n));
        tcTypeAliasNames.setAdd(aliasName);
        let destructorNameIdx = nodeGetData5(n);
        if (destructorNameIdx != 0) {
            let destructorName = getInternedStr(destructorNameIdx);
            tcDestructorAliasByAlias.mapSet(aliasName, destructorName);
            tcDestructorAliasNames.vecPush(aliasName);
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_DEP_TYPE_ALIAS) {
        let aliasName = getInternedStr(nodeGetData1(n));
        tcTypeAliasNames.setAdd(aliasName);
        let valueParams = nodeGetData2(n);
        tcDepTypeAliasParams.mapSet(aliasName, valueParams.vecLength());
        let aliasBaseType = nodeGetData3(n);
        let aliasBaseTypeName = typeNameFromTypeNode(aliasBaseType);
        if (!aliasBaseTypeName.strEq("Unknown")) {
            tcAliasBaseType.mapSet(aliasName, aliasBaseTypeName);
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
    if (kind == NK_EXTERN_TYPE_DECL) {
        let aliasName = getInternedStr(nodeGetData1(n));
        tcTypeAliasNames.setAdd(aliasName);
        let valueParams = nodeGetData2(n);
        tcExternTypeParams.mapSet(aliasName, valueParams.vecLength());
        let destructorNameIdx = nodeGetData5(n);
        if (destructorNameIdx != 0) {
            let destructorName = getInternedStr(destructorNameIdx);
            tcDestructorAliasByAlias.mapSet(aliasName, destructorName);
            tcDestructorAliasNames.vecPush(aliasName);
        }
        return Ok<I32> {
            value: 0
        }
        ;
    }
     // Fallback: treat unmatched nodes as expressions.
    typecheckExpr(n, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs)?;
    Ok<I32> {
        value: 0
    }
}
out fn typecheckProgramWithOptionsImpl(program: I32) : Result<I32, TypeError> => {
    let fnArities = mapNew();
    let fnParamTypes = mapNew();
    let fnReturnTypes = mapNew();
    let fnNodes = mapNew();
    let localTypes = mapNew();
    tcGlobalValueTypes = tcGlobalValueTypes.mapClear();
    tcAliasUnionTags = tcAliasUnionTags.mapClear();
    tcTypeAliasNames = tcTypeAliasNames.setClear();
    tcDepTypeAliasParams = tcDepTypeAliasParams.mapClear();
    tcExternTypeParams = tcExternTypeParams.mapClear();
    tcContractNames = tcContractNames.setClear();
    tcDestructorAliasByAlias = tcDestructorAliasByAlias.mapClear();
    tcDestructorAliasNames = vecNew();
    tcFnThisFields = tcFnThisFields.mapClear();
    tcAliasBaseType = tcAliasBaseType.mapClear();
    tcTypeNameCache = tcTypeNameCache.mapClear();
    tcCallBounds = tcCallBounds.mapClear();
    fnParamCallBounds = fnParamCallBounds.mapClear();
    let body = nodeGetData1(program);
     // Pre-collect generic arities so type-name checks are strict regardless of declaration order.
    let preI = 0;
    let preLen = body.vecLength();
    while (preI < preLen) {
        let preStmt = body.vecGet(preI);
        let preKind = nodeKind(preStmt);
        if (isExternTypeLikeDecl(preStmt)) {
            let aliasName = getInternedStr(nodeGetData1(preStmt));
            tcTypeAliasNames.setAdd(aliasName);
            let valueParams = nodeGetData2(preStmt);
            tcExternTypeParams.mapSet(aliasName, valueParams.vecLength());
        }
        if (preKind == NK_DEP_TYPE_ALIAS) {
            let aliasName = getInternedStr(nodeGetData1(preStmt));
            tcTypeAliasNames.setAdd(aliasName);
            let valueParams = nodeGetData2(preStmt);
            tcDepTypeAliasParams.mapSet(aliasName, valueParams.vecLength());
        }
        preI = preI + 1;
    }
     // Collect function signatures (including extern fns).
    let i = 0;
    let len = body.vecLength();
    while (i < len) {
        let stmt = body.vecGet(i);
        let kind = nodeKind(stmt);
        if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind = =
        NK_ACTUAL_FN_DECL) {
            let name = getInternedStr(nodeGetData1(stmt));
            fnNodes.mapSet(name, stmt);
            let params = nodeGetData3(stmt);
            fnArities.mapSet(name, params.vecLength());
            let paramTypes = vecNew();
            let paramCallBoundsVec = vecNew();
            let p = 0;
            let __len1 = params.vecLength();
            while (p < __len1) {
                let param = params.vecGet(p);
                let paramTypeNode = param.vecGet(1);
                paramTypes.vecPush(typeNameFromTypeNode(paramTypeNode));
                let rawConstraint = tryExtractFnCallConstraint(paramTypeNode);
                if (!rawConstraint.strEq("")) {
                     // Resolve ref param name to its index within this function's params.
                    let sep = rawConstraint.strIndexOf(":");
                    if (sep < 0) {
                        tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", "Malformed internal call-bound constraint metadata in function '".strConcat(name).strConcat("'"), "Expected call-bound metadata in the form 'fnName:paramName', but ':' was missing.", "Ensure refinement call-bound metadata is emitted as 'fnName:paramName'.");
                    }
                    let rawLen = rawConstraint.strLength();
                    if (sep > rawLen) {
                        tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", "Malformed internal call-bound constraint metadata in function '".strConcat(name).strConcat("'"), "The separator ':' index is outside the metadata string bounds.", "Ensure refinement call-bound metadata is emitted with valid separator positions.");
                    }
                    if (sep + 1 > rawLen) {
                        tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", "Malformed internal call-bound constraint metadata in function '".strConcat(name).strConcat("'"), "The metadata separator ':' is in an invalid position for extracting the parameter name.", "Ensure call-bound metadata includes a non-empty parameter name after ':'.");
                    }
                    let fnPart = rawConstraint.strSlice(0, sep);
                    let refIdx = -1;
                    let pi = 0;
                    let __len = params.vecLength();
                    while (pi < __len) {
                        let piName = getInternedStr(params.vecGet(pi).vecGet(0));
                        let expectedRaw = fnPart.strConcat(":").strConcat(piName);
                        if (expectedRaw.strEq(rawConstraint)) {
                            refIdx = pi;
                        }
                        pi = pi + 1;
                    }
                    if (refIdx >= 0) {
                        paramCallBoundsVec.vecPush(fnPart.strConcat(":").strConcat(intToString(refIdx)));
                    }
                    else {
                        paramCallBoundsVec.vecPush("");
                    }
                }
                else {
                    if (paramTypeNode != 0 && nodeKind(paramTypeNode) == NK_REFINEMENT_TYPE) {
                        paramCallBoundsVec.vecPush("__REFINE__");
                    }
                    else {
                        paramCallBoundsVec.vecPush("");
                    }
                }
                p = p + 1;
            }
            fnParamTypes.mapSet(name, paramTypes);
            fnParamCallBounds.mapSet(name, paramCallBoundsVec);
            let retType = nodeGetData4(stmt);
            fnReturnTypes.mapSet(name, typeNameFromTypeNode(retType));
        }
        if (kind == NK_EXTERN_LET_DECL) {
            let vname = getInternedStr(nodeGetData1(stmt));
            let vtype = nodeGetData2(stmt);
            let tname = typeNameFromTypeNode(vtype);
            localTypes.mapSet(vname, tname);
            tcGlobalValueTypes.mapSet(vname, tname);
        }
        if (kind == NK_TYPE_ALIAS) {
            let aliasName = getInternedStr(nodeGetData1(stmt));
            tcTypeAliasNames.setAdd(aliasName);
            let aliasType = nodeGetData3(stmt);
            let tags = vecNew();
            collectUnionNamedTags(aliasType, tags);
            if (tags.vecLength() > 0) {
                tcAliasUnionTags.mapSet(aliasName, tags);
            }
            let destructorNameIdx = nodeGetData5(stmt);
            if (destructorNameIdx != 0) {
                let destructorName = getInternedStr(destructorNameIdx);
                tcDestructorAliasByAlias.mapSet(aliasName, destructorName);
                tcDestructorAliasNames.vecPush(aliasName);
            }
            let aliasBaseType = nodeGetData3(stmt);
            let aliasBaseTypeName = typeNameFromTypeNode(aliasBaseType);
            if (!aliasBaseTypeName.strEq("Unknown")) {
                tcAliasBaseType.mapSet(aliasName, aliasBaseTypeName);
            }
        }
        if (kind == NK_DEP_TYPE_ALIAS) {
            let aliasName = getInternedStr(nodeGetData1(stmt));
            tcTypeAliasNames.setAdd(aliasName);
            let valueParams = nodeGetData2(stmt);
            tcDepTypeAliasParams.mapSet(aliasName, valueParams.vecLength());
            let aliasBaseType = nodeGetData3(stmt);
            let aliasBaseTypeName = typeNameFromTypeNode(aliasBaseType);
            if (!aliasBaseTypeName.strEq("Unknown")) {
                tcAliasBaseType.mapSet(aliasName, aliasBaseTypeName);
            }
        }
        if (isExternTypeLikeDecl(stmt)) {
            let aliasName = getInternedStr(nodeGetData1(stmt));
            tcTypeAliasNames.setAdd(aliasName);
            let valueParams = nodeGetData2(stmt);
            tcExternTypeParams.mapSet(aliasName, valueParams.vecLength());
            let destructorNameIdx = nodeGetData5(stmt);
            if (destructorNameIdx != 0) {
                let destructorName = getInternedStr(destructorNameIdx);
                tcDestructorAliasByAlias.mapSet(aliasName, destructorName);
                tcDestructorAliasNames.vecPush(aliasName);
            }
        }
        if (kind == NK_CONTRACT_DECL) {
            tcContractNames.setAdd(getInternedStr(nodeGetData1(stmt)));
        }
        if (kind == NK_LET_DECL) {
            let vname = getInternedStr(nodeGetData1(stmt));
            let vtype = nodeGetData2(stmt);
            if (vtype != 0) {
                tcGlobalValueTypes.mapSet(vname, typeNameFromTypeNode(vtype));
            }
        }
        i = i + 1;
    }
     // Validate destructor declarations/signatures irrespective of strict mode.
    i = 0;
    let destructorAliasCount = tcDestructorAliasNames.vecLength();
    while (i < destructorAliasCount) {
        let aliasName = tcDestructorAliasNames.vecGet(i);
        let destructorName = tcDestructorAliasByAlias.mapGet(aliasName);
        if (!fnNodes.mapHas(destructorName)) {
            tcPanicLoc("E_TYPE_DESTRUCTOR_NOT_FOUND", "Destructor '".strConcat(destructorName).strConcat("' for alias '").strConcat(aliasName).strConcat("' was not found"), "A type alias referenced a destructor function that does not exist.", "Declare the destructor function before using it in 'type Alias = ... then destructor'.");
        }
        let fnNode = fnNodes.mapGet(destructorName);
        let params = nodeGetData3(fnNode);
        let valid = true;
        if (params.vecLength() != 1) {
            valid = false;
        }
        else {
            let p0 = params.vecGet(0);
            let pname = getInternedStr(p0.vecGet(0));
            let ptype = p0.vecGet(1);
            if (!pname.strEq("this")) {
                valid = false;
            }
            if (!typeNodeIsDestructorReceiver(ptype, aliasName)) {
                let ptypeName = typeNameFromTypeNode(ptype);
                let baseTypeOk = tcAliasBaseType.mapHas(aliasName) &&
                ptypeName.strEq(tcAliasBaseType.mapGet(aliasName));
                if (!baseTypeOk) {
                    valid = false;
                }
            }
        }
        let retName = typeNameFromTypeNode(nodeGetData4(fnNode));
        if (!retName.strEq("Void") && !retName.strEq("Unknown")) {
            valid = false;
        }
        if (!valid) {
            tcPanicLoc("E_TYPE_DESTRUCTOR_SIGNATURE", "Destructor '".strConcat(destructorName).strConcat("' must have signature fn ").strConcat(destructorName).strConcat("(this : ").strConcat(aliasName).strConcat("<...>) : Void"), "Destructor signatures must follow the required receiver and return type contract.", "Use exactly one receiver parameter named 'this' with the alias type (or legacy '*move AliasType') and return Void.");
        }
        i = i + 1;
    }
     // Check calls across whole program.
    i = 0;
    while (i < len) {
        typecheckStmt(body.vecGet(i), fnArities, fnParamTypes, fnReturnTypes, localTypes, mapNew(), "Unknown")?;
        i = i + 1;
    }
    Ok<I32> {
        value: program
    }
}
out fn typecheckProgramImpl(program: I32) : Result<I32, TypeError> => {
    typecheckProgramWithOptionsImpl(program)
}
out fn selfhostTypecheckImplMarker() : I32 => 0;
