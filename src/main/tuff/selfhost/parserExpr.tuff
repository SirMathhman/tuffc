let {
    pAt, pEat, pExpect, pParseIdentifier, pAtKind, pPeek, pMark, pParsePattern,
    pErrorWithTokenContext, nodeKind, nodeNew, nodeSetData1, nodeSetData2, nodeSetData3, nodeSetData4, nodeGetData1
}
 = selfhost::parserCore;
let {
    tokKind, tokValue, tokLine, tokCol, getInternedStr, vecNew, mapNew
}
 = selfhost::runtimeLexer;
let {
    pParsePrimary
}
 = selfhost::parserExprPrimary;
fn pParseUnary() : I32 => {
    if (pAt(TK_SYMBOL, "!") || pAt(TK_SYMBOL, "-") || pAt(TK_SYMBOL, "&")) {
        let t = pEat();
        let op = tokValue(t);
        if (getInternedStr(op).strEq("&") && pAt(TK_KEYWORD, "mut")) {
            pEat();
            op = intern("&mut");
        }
        let inner = pParseUnary();
        let node = nodeNew(NK_UNARY_EXPR);
        nodeSetData1(node, op);
        nodeSetData2(node, inner);
        return node;
    }
    pParsePrimary()
}
let precedenceMap : Map<I32, I32> = mapNew();
let precedenceMapInit : Bool = false;
fn initPrecedenceMap() => {
    if (precedenceMapInit) {
        return 0;
    }
    precedenceMapInit = true;
    precedenceMap.mapSet(intern("||"), 1);
    precedenceMap.mapSet(intern("&&"), 2);
    precedenceMap.mapSet(intern("=="), 3);
    precedenceMap.mapSet(intern("!="), 3);
    precedenceMap.mapSet(intern("<"), 4);
    precedenceMap.mapSet(intern("<="), 4);
    precedenceMap.mapSet(intern(">"), 4);
    precedenceMap.mapSet(intern(">="), 4);
    precedenceMap.mapSet(intern(".."), 4);
    precedenceMap.mapSet(intern("+"), 5);
    precedenceMap.mapSet(intern("-"), 5);
    precedenceMap.mapSet(intern("*"), 6);
    precedenceMap.mapSet(intern("/"), 6);
    precedenceMap.mapSet(intern("%"), 6);
    0
}
fn pGetPrecedence(op: I32) : I32 => {
    initPrecedenceMap();
    if (precedenceMap.mapHas(op)) {
        return precedenceMap.mapGet(op);
    }
    0
}
fn pIsBinaryOp() : Bool => {
    if (pAt(TK_SYMBOL, "+")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "-")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "*")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "/")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "%")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "==")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "!=")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "<")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "<=")) {
        return true;
    }
    if (pAt(TK_SYMBOL, ">")) {
        return true;
    }
    if (pAt(TK_SYMBOL, ">=")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "..")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "&&")) {
        return true;
    }
    if (pAt(TK_SYMBOL, "||")) {
        return true;
    }
    if (pAt(TK_KEYWORD, "is")) {
        return true;
    }
    if (pAt(TK_KEYWORD, "into")) {
        return true;
    }
    false
}
fn pParseExpression(minPrec: I32) : I32 => {
    let left = pParseUnary();
    let watchdog = 0;
    while (pIsBinaryOp()) {
        watchdog = watchdog + 1;
        if (watchdog > 200000) {
            pErrorWithTokenContext("Parser watchdog: binary-expression loop exceeded 200000 iterations");
        }
        if (minPrec <= 0 && pAt(TK_KEYWORD, "into")) {
            pEat();
            let contractName = pParseIdentifier();
            let typeArgs = vecNew();
            let contractType = nodeNew(NK_NAMED_TYPE);
            nodeSetData1(contractType, contractName);
            nodeSetData2(contractType, vecNew());
            typeArgs.vecPush(contractType);
            let args = vecNew();
            args.vecPush(left);
            if (pAt(TK_SYMBOL, "(")) {
                pEat();
                if (!pAt(TK_SYMBOL, ")")) {
                    args.vecPush(pParseExpression(0));
                    while (pAt(TK_SYMBOL, ",")) {
                        pEat();
                        args.vecPush(pParseExpression(0));
                    }
                }
                pExpect(TK_SYMBOL, ")", "Expected ')' after into arguments");
            }
            let call = nodeNew(NK_CALL_EXPR);
            let callee = nodeNew(NK_IDENTIFIER);
            nodeSetData1(callee, intern("into"));
            nodeSetData1(call, callee);
            nodeSetData2(call, args);
            nodeSetData3(call, 1);
            nodeSetData4(call, typeArgs);
            left = call;
            continue;
        }
        let op = tokValue(pPeek(0));
        let prec = pGetPrecedence(op);
         // Handle 'is' keyword specially
        if (pAt(TK_KEYWORD, "is")) {
            pEat();
            let pat = pParsePattern();
            let isNode = nodeNew(NK_IS_EXPR);
            nodeSetData1(isNode, left);
            nodeSetData2(isNode, pat);
            left = isNode;
            continue;
        }
        if (prec < minPrec) {
            break;
        }
         // Don't consume op= sequences (+=, -=, etc.) as binary operators;
         // statement parser handles them as compound assignments.
        if (
        (internMap.mapHas("+") && op = = internMap.mapGet("+")) ||
        (internMap.mapHas("-") && op = = internMap.mapGet("-")) ||
        (internMap.mapHas("*") && op = = internMap.mapGet("*")) ||
        (internMap.mapHas("/") && op = = internMap.mapGet("/")) ||
        (internMap.mapHas("%") && op = = internMap.mapGet("%")) ||
        (internMap.mapHas("&") && op = = internMap.mapGet("&")) ||
        (internMap.mapHas("|") && op = = internMap.mapGet("|")) ||
        (internMap.mapHas("^") && op = = internMap.mapGet("^"))
        ) {
            let next = pPeek(1);
            if (tokKind(next) = = TK_SYMBOL && getInternedStr(tokValue(next)).strEq("=")) {
                break;
            }
        }
        pEat();
        let right = pParseExpression(prec + 1);
        let bin = nodeNew(NK_BINARY_EXPR);
        nodeSetData1(bin, op);
        nodeSetData2(bin, left);
        nodeSetData3(bin, right);
        left = bin;
    }
    left
}
fn pParseBlock() : I32 => {
    pExpect(TK_SYMBOL, "{", "Expected '{'");
    let stmts = vecNew();
    while (!pAt(TK_SYMBOL, "}") && !pAtKind(TK_EOF)) {
        let before = pMark();
        let stmt = pParseStatement();
        let after = pMark();
        if (after = = before) {
            pErrorWithTokenContext("Parser made no progress while parsing block statement");
        }
        if (nodeKind(stmt) = = NK_STMT_LIST) {
            let inner = nodeGetData1(stmt);
            let i = 0;
            let __len = inner.vecLength();
            while (i < __len) {
                stmts.vecPush(inner.vecGet(i));
                i = i + 1;
            }
        }
        else {
            stmts.vecPush(stmt);
        }
    }
    pExpect(TK_SYMBOL, "}", "Expected '}'");
    let node = nodeNew(NK_BLOCK);
    nodeSetData1(node, stmts);
    node
}
out fn selfhostParserExprMarker() : I32 => 0;
