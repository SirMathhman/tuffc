// ============================================================================
// C Code Generation — selfhost port of codegen-c.ts
// ============================================================================
// ALL Tuff values are int64_t in C. Strings are int64_t handles via tuff_str().
// The C substrate (substrate.h/c, strings.c, etc.) is always embedded inline.
// ============================================================================

let { get_interned_str, vec_new, map_new, set_new } = selfhost::runtime_lexer;
let { node_kind, node_get_data1, node_get_data2, node_get_data3, node_get_data4, node_get_data5 } = selfhost::parser_core;

// ============================================================================
// Global mutable state — reset at the start of each generate_c call
// ============================================================================

let cc_temp_counter : I32 = 0;
let cc_enum_names : *mut Set = set_new();
let cc_enum_variant_consts : Map = map_new();  // variant → "EnumName_Variant"
let cc_struct_fields : Map = map_new();        // struct name → Vec<*Str> of field names
let cc_alias_by_variant : Map = map_new();     // variant struct name → union alias name
let cc_union_alias_info : Map = map_new();     // alias name → Vec<*Str> of variant names

// ============================================================================
// Helpers
// ============================================================================

fn cc_next_temp(prefix: *Str) : *Str => {
    cc_temp_counter = cc_temp_counter + 1;
    "__".str_concat(prefix).str_concat("_").str_concat(int_to_string(cc_temp_counter))
}

fn cc_to_name(name: *Str) : *Str => {
    if (name.str_eq("main")) { "tuff_main" } else { name }
}

// All Tuff types lower to int64_t, except Void → void.
fn cc_type_to_c(type_node: I32) : *Str => {
    if (type_node == 0) { return "int64_t"; }
    let kind = node_kind(type_node);
    if (kind == NK_NAMED_TYPE) {
        let name = get_interned_str(node_get_data1(type_node));
        if (name.str_eq("Void")) { return "void"; }
        return "int64_t";
    }
    "int64_t"
}

fn cc_is_stdlib_builtin(name: *Str) : Bool => {
    name.str_eq("malloc") || name.str_eq("free") || name.str_eq("realloc") ||
    name.str_eq("memcpy") || name.str_eq("memmove") || name.str_eq("printf") ||
    name.str_eq("fprintf") || name.str_eq("strlen") || name.str_eq("strdup") ||
    name.str_eq("strcmp") || name.str_eq("exit") || name.str_eq("abort")
}

// ============================================================================
// Context Pre-scan
// ============================================================================

fn cc_flatten_union_variants(type_node: I32, names_vec: Vec) : I32 => {
    if (type_node == 0) { return 0; }
    let kind = node_kind(type_node);
    if (kind == NK_NAMED_TYPE) {
        names_vec.vec_push(get_interned_str(node_get_data1(type_node)));
        return 0;
    }
    if (kind == NK_UNION_TYPE) {
        cc_flatten_union_variants(node_get_data1(type_node), names_vec);
        cc_flatten_union_variants(node_get_data2(type_node), names_vec);
        return 0;
    }
    0
}

fn cc_init_context(program: I32) : I32 => {
    let stmts = node_get_data1(program);
    let len = stmts.vec_length();
    let i = 0;
    while (i < len) {
        let n = stmts.vec_get(i);
        let kind = node_kind(n);

        if (kind == NK_ENUM_DECL) {
            let enum_name = get_interned_str(node_get_data1(n));
            cc_enum_names.set_add(enum_name);
            let variants = node_get_data2(n);
            let j = 0;
            let vlen = variants.vec_length();
            while (j < vlen) {
                let v = get_interned_str(variants.vec_get(j));
                cc_enum_variant_consts.map_set(v, enum_name.str_concat("_").str_concat(v));
                j = j + 1;
            }
        }

        if (kind == NK_STRUCT_DECL) {
            let struct_name = get_interned_str(node_get_data1(n));
            let fields = node_get_data3(n);
            let field_names = vec_new();
            let j = 0;
            let flen = fields.vec_length();
            while (j < flen) {
                let f = fields.vec_get(j);
                field_names.vec_push(get_interned_str(f.vec_get(0)));
                j = j + 1;
            }
            cc_struct_fields.map_set(struct_name, field_names);
        }

        if (kind == NK_TYPE_ALIAS) {
            let alias_name = get_interned_str(node_get_data1(n));
            let aliased = node_get_data3(n);
            if (aliased != 0 && node_kind(aliased) == NK_UNION_TYPE) {
                let variants = vec_new();
                cc_flatten_union_variants(aliased, variants);
                let j = 0;
                let vlen = variants.vec_length();
                while (j < vlen) {
                    let v = variants.vec_get(j);
                    cc_alias_by_variant.map_set(v, alias_name);
                    j = j + 1;
                }
                cc_union_alias_info.map_set(alias_name, variants);
            }
        }

        i = i + 1;
    }
    0
}

// ============================================================================
// C Pattern Guards (for match expressions)
// ============================================================================

fn cc_emit_pattern_guard(target: *Str, pat: I32) : *Str => {
    let kind = node_kind(pat);
    if (kind == NK_WILDCARD_PAT) { return "1"; }
    if (kind == NK_LITERAL_PAT) {
        let val = get_interned_str(node_get_data1(pat));
        return "(".str_concat(target).str_concat(" == ").str_concat(val).str_concat(")");
    }
    if (kind == NK_NAME_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        if (cc_enum_variant_consts.map_has(name)) {
            return "(".str_concat(target).str_concat(" == ").str_concat(cc_enum_variant_consts.map_get(name)).str_concat(")");
        }
        if (cc_alias_by_variant.map_has(name)) {
            let alias = cc_alias_by_variant.map_get(name);
            return "(".str_concat(target).str_concat(".__tag == ").str_concat(alias).str_concat("_").str_concat(name).str_concat(")");
        }
        return "1";
    }
    if (kind == NK_STRUCT_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        if (cc_alias_by_variant.map_has(name)) {
            let alias = cc_alias_by_variant.map_get(name);
            return "(".str_concat(target).str_concat(".__tag == ").str_concat(alias).str_concat("_").str_concat(name).str_concat(")");
        }
        return "1";
    }
    "1"
}

// ============================================================================
// Block → GNU statement expression (assign last expr to tmp var)
// ============================================================================

fn cc_emit_block_to_assign(block_node: I32, tmp_var: *Str) : *Str => {
    let stmts = node_get_data1(block_node);
    let len = stmts.vec_length();
    if (len == 0) {
        return tmp_var.str_concat(" = 0;");
    }
    let sb = sb_new();
    let i = 0;
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let is_last = i == len - 1;
        let skind = node_kind(stmt);
        if (is_last && skind == NK_EXPR_STMT) {
            sb_append(sb, tmp_var);
            sb_append(sb, " = ");
            sb_append(sb, cc_emit_expr(node_get_data1(stmt)));
            sb_append(sb, ";");
        } else if (is_last && skind == NK_RETURN_STMT) {
            let val = node_get_data1(stmt);
            sb_append(sb, tmp_var);
            sb_append(sb, " = ");
            sb_append(sb, if (val == 0) { "0" } else { cc_emit_expr(val) });
            sb_append(sb, ";");
        } else {
            sb_append(sb, cc_emit_stmt(stmt));
            sb_append(sb, " ");
        }
        i = i + 1;
    }
    sb_build(sb)
}

fn cc_emit_block_as_expr(block_node: I32) : *Str => {
    let tmp = cc_next_temp("blk");
    let inner = cc_emit_block_to_assign(block_node, tmp);
    "({ int64_t ".str_concat(tmp).str_concat(" = 0; ").str_concat(inner).str_concat(" ").str_concat(tmp).str_concat("; })")
}

fn cc_emit_if_as_c_expr(n: I32) : *Str => {
    let cond = cc_emit_expr(node_get_data1(n));
    let then_b = node_get_data2(n);
    let else_b = node_get_data3(n);
    let tmp = cc_next_temp("ifexpr");
    let then_body = if (node_kind(then_b) == NK_BLOCK) {
        cc_emit_block_to_assign(then_b, tmp)
    } else {
        tmp.str_concat(" = ").str_concat(cc_emit_expr(then_b)).str_concat(";")
    };
    let else_body = if (else_b == 0) {
        tmp.str_concat(" = 0;")
    } else if (node_kind(else_b) == NK_BLOCK) {
        cc_emit_block_to_assign(else_b, tmp)
    } else {
        tmp.str_concat(" = ").str_concat(cc_emit_expr(else_b)).str_concat(";")
    };
    "({ int64_t ".str_concat(tmp).str_concat(" = 0; if (").str_concat(cond).str_concat(") { ").str_concat(then_body).str_concat(" } else { ").str_concat(else_body).str_concat(" } ").str_concat(tmp).str_concat("; })")
}

// ============================================================================
// Expression Emitter
// ============================================================================

fn cc_emit_expr(n: I32) : *Str => {
    let kind = node_kind(n);

    if (kind == NK_NUMBER_LIT) {
        return get_interned_str(node_get_data1(n));
    }

    if (kind == NK_BOOL_LIT) {
        if (node_get_data1(n) == 1) { return "1"; }
        return "0";
    }

    if (kind == NK_STRING_LIT) {
        let s = get_interned_str(node_get_data1(n));
        return "((int64_t)(intptr_t)\"".str_concat(s).str_concat("\")");
    }

    if (kind == NK_CHAR_LIT) {
        let s = get_interned_str(node_get_data1(n));
        if (s.str_length() == 1) {
            return int_to_string(char_code(s));
        }
        if (s.str_eq("\\n")) { return "10"; }
        if (s.str_eq("\\r")) { return "13"; }
        if (s.str_eq("\\t")) { return "9"; }
        if (s.str_eq("\\0")) { return "0"; }
        return "0";
    }

    if (kind == NK_IDENTIFIER) {
        let name = get_interned_str(node_get_data1(n));
        if (cc_enum_variant_consts.map_has(name)) {
            return cc_enum_variant_consts.map_get(name);
        }
        return cc_to_name(name);
    }

    if (kind == NK_UNARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("&") || op.str_eq("&mut")) {
            return cc_emit_expr(node_get_data2(n));
        }
        return "(".str_concat(op).str_concat(cc_emit_expr(node_get_data2(n))).str_concat(")");
    }

    if (kind == NK_BINARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        let left = cc_emit_expr(node_get_data2(n));
        let right = cc_emit_expr(node_get_data3(n));
        return "(".str_concat(left).str_concat(" ").str_concat(op).str_concat(" ").str_concat(right).str_concat(")");
    }

    if (kind == NK_CALL_EXPR) {
        let callee_node = node_get_data1(n);
        // Special-case built-in transformations
        if (node_kind(callee_node) == NK_IDENTIFIER) {
            let callee_name = get_interned_str(node_get_data1(callee_node));

            // drop(x) → 0
            if (callee_name.str_eq("drop")) {
                return "0";
            }

            // sizeOf<T>() → (int64_t)sizeof(T)
            if (callee_name.str_eq("sizeOf")) {
                let type_args = node_get_data4(n);
                if (type_args.vec_length() > 0) {
                    let ctype = cc_type_to_c(type_args.vec_get(0));
                    return "(int64_t)sizeof(".str_concat(ctype).str_concat(")");
                }
                return "0";
            }

            // malloc(bytes) → allocate TuffVec fat slice
            if (callee_name.str_eq("malloc")) {
                let args = node_get_data2(n);
                if (args.vec_length() >= 1) {
                    let bytes_str = cc_emit_expr(args.vec_get(0));
                    let nbytes = cc_next_temp("malloc_nbytes");
                    let vec = cc_next_temp("malloc_vec");
                    let sb = sb_new();
                    sb_append(sb, "({ size_t ");
                    sb_append(sb, nbytes);
                    sb_append(sb, " = (size_t)(");
                    sb_append(sb, bytes_str);
                    sb_append(sb, "); TuffVec* ");
                    sb_append(sb, vec);
                    sb_append(sb, " = (TuffVec*)malloc(sizeof(TuffVec)); if (");
                    sb_append(sb, vec);
                    sb_append(sb, ") { ");
                    sb_append(sb, vec);
                    sb_append(sb, "->data = (int64_t*)malloc(");
                    sb_append(sb, nbytes);
                    sb_append(sb, "); ");
                    sb_append(sb, vec);
                    sb_append(sb, "->init = 0; ");
                    sb_append(sb, vec);
                    sb_append(sb, "->length = ");
                    sb_append(sb, nbytes);
                    sb_append(sb, " / sizeof(int64_t); if (!");
                    sb_append(sb, vec);
                    sb_append(sb, "->data) { free(");
                    sb_append(sb, vec);
                    sb_append(sb, "); ");
                    sb_append(sb, vec);
                    sb_append(sb, " = NULL; } } ");
                    sb_append(sb, vec);
                    sb_append(sb, "; })");
                    return sb_build(sb);
                }
                return "0";
            }

            // realloc(ptr, bytes) → grow TuffVec data in-place
            if (callee_name.str_eq("realloc")) {
                let args = node_get_data2(n);
                if (args.vec_length() >= 2) {
                    let ptr_str = cc_emit_expr(args.vec_get(0));
                    let bytes_str = cc_emit_expr(args.vec_get(1));
                    let nbytes = cc_next_temp("realloc_nbytes");
                    let vec = cc_next_temp("realloc_vec");
                    let data = cc_next_temp("realloc_data");
                    let sb = sb_new();
                    sb_append(sb, "({ size_t ");
                    sb_append(sb, nbytes);
                    sb_append(sb, " = (size_t)(");
                    sb_append(sb, bytes_str);
                    sb_append(sb, "); TuffVec* ");
                    sb_append(sb, vec);
                    sb_append(sb, " = (TuffVec*)(");
                    sb_append(sb, ptr_str);
                    sb_append(sb, "); if (");
                    sb_append(sb, vec);
                    sb_append(sb, ") { int64_t* ");
                    sb_append(sb, data);
                    sb_append(sb, " = (int64_t*)realloc(");
                    sb_append(sb, vec);
                    sb_append(sb, "->data, ");
                    sb_append(sb, nbytes);
                    sb_append(sb, "); if (");
                    sb_append(sb, data);
                    sb_append(sb, ") { ");
                    sb_append(sb, vec);
                    sb_append(sb, "->data = ");
                    sb_append(sb, data);
                    sb_append(sb, "; ");
                    sb_append(sb, vec);
                    sb_append(sb, "->length = ");
                    sb_append(sb, nbytes);
                    sb_append(sb, " / sizeof(int64_t); } else { ");
                    sb_append(sb, vec);
                    sb_append(sb, " = NULL; } } ");
                    sb_append(sb, vec);
                    sb_append(sb, "; })");
                    return sb_build(sb);
                }
                return "0";
            }

            // free(ptr) → free TuffVec data then struct
            if (callee_name.str_eq("free")) {
                let args = node_get_data2(n);
                if (args.vec_length() >= 1) {
                    let ptr_str = cc_emit_expr(args.vec_get(0));
                    let vec = cc_next_temp("free_vec");
                    return "({ TuffVec* ".str_concat(vec).str_concat(" = (TuffVec*)(").str_concat(ptr_str).str_concat("); if (").str_concat(vec).str_concat(") { free(").str_concat(vec).str_concat("->data); free(").str_concat(vec).str_concat("); } 0; })");
                }
                return "0";
            }
        }

        // General call
        let callee = cc_emit_expr(callee_node);
        let args = node_get_data2(n);
        let arg_strs = vec_new();
        let i = 0;
        let alen = args.vec_length();
        while (i < alen) {
            arg_strs.vec_push(cc_emit_expr(args.vec_get(i)));
            i = i + 1;
        }
        let args_str = arg_strs.vec_join(", ");
        return callee.str_concat("(").str_concat(args_str).str_concat(")");
    }

    if (kind == NK_MEMBER_EXPR) {
        let obj_node = node_get_data1(n);
        let prop = get_interned_str(node_get_data2(n));
        // Enum access: EnumName.Variant → EnumName_Variant
        if (node_kind(obj_node) == NK_IDENTIFIER) {
            let obj_name = get_interned_str(node_get_data1(obj_node));
            if (cc_enum_names.set_has(obj_name)) {
                return obj_name.str_concat("_").str_concat(prop);
            }
        }
        let obj = cc_emit_expr(obj_node);
        return obj.str_concat(".").str_concat(prop);
    }

    if (kind == NK_INDEX_EXPR) {
        let target = cc_emit_expr(node_get_data1(n));
        let idx = cc_emit_expr(node_get_data2(n));
        return target.str_concat("[").str_concat(idx).str_concat("]");
    }

    if (kind == NK_IF_EXPR) {
        let cond = cc_emit_expr(node_get_data1(n));
        let then_b = node_get_data2(n);
        let else_b = node_get_data3(n);
        // Use GNU statement expression for block branches
        if (node_kind(then_b) == NK_BLOCK || (else_b != 0 && node_kind(else_b) == NK_BLOCK)) {
            return cc_emit_if_as_c_expr(n);
        }
        // Simple ternary
        let then_str = cc_emit_expr(then_b);
        let else_str = if (else_b == 0) { "0" } else { cc_emit_expr(else_b) };
        return "((".str_concat(cond).str_concat(") ? (").str_concat(then_str).str_concat(") : (").str_concat(else_str).str_concat("))");
    }

    if (kind == NK_UNWRAP_EXPR) {
        return cc_emit_expr(node_get_data1(n));
    }

    if (kind == NK_MATCH_EXPR) {
        return cc_emit_match_expr(n);
    }

    if (kind == NK_IS_EXPR) {
        let inner = cc_emit_expr(node_get_data1(n));
        let pat = node_get_data2(n);
        if (node_kind(pat) == NK_NAME_PAT) {
            let name = get_interned_str(node_get_data1(pat));
            if (cc_alias_by_variant.map_has(name)) {
                let alias = cc_alias_by_variant.map_get(name);
                return "(".str_concat(inner).str_concat(".__tag == ").str_concat(alias).str_concat("_").str_concat(name).str_concat(")");
            }
            return "((int64_t)(".str_concat(inner).str_concat(") != 0)");
        }
        return "0";
    }

    if (kind == NK_STRUCT_INIT) {
        let name = get_interned_str(node_get_data1(n));
        if (cc_alias_by_variant.map_has(name)) {
            let alias = cc_alias_by_variant.map_get(name);
            let fields = node_get_data2(n);
            let sb = sb_new();
            sb_append(sb, "((");
            sb_append(sb, alias);
            sb_append(sb, "){ .__tag = ");
            sb_append(sb, alias);
            sb_append(sb, "_");
            sb_append(sb, name);
            let i = 0;
            let flen = fields.vec_length();
            while (i < flen) {
                let field = fields.vec_get(i);
                let key = get_interned_str(field.vec_get(0));
                let val_str = cc_emit_expr(field.vec_get(1));
                sb_append(sb, ", .");
                sb_append(sb, key);
                sb_append(sb, " = ");
                sb_append(sb, val_str);
                i = i + 1;
            }
            sb_append(sb, " })");
            return sb_build(sb);
        }
        return "/* struct_init(".str_concat(name).str_concat(") unsupported in C MVP */ 0");
    }

    if (kind == NK_LAMBDA_EXPR || kind == NK_FN_EXPR) {
        return "/* lambda/fn_expr unsupported in C */ 0";
    }

    if (kind == NK_TUPLE_EXPR) {
        return "/* tuple_expr unsupported in C */ 0";
    }

    "/* unknown_expr */ 0"
}

fn cc_emit_match_expr(n: I32) : *Str => {
    let target_str = cc_emit_expr(node_get_data1(n));
    let cases = node_get_data2(n);
    let len = cases.vec_length();
    let chain = "(tuff_panic(\"Non-exhaustive match\"), 0)";
    // Build from right-to-left (nested ternary)
    let i = len - 1;
    while (i >= 0) {
        let case_node = cases.vec_get(i);
        let pat = case_node.vec_get(0);
        let body = case_node.vec_get(1);
        let guard = cc_emit_pattern_guard(target_str, pat);
        let body_str = if (node_kind(body) == NK_BLOCK) {
            cc_emit_block_as_expr(body)
        } else {
            cc_emit_expr(body)
        };
        chain = "((".str_concat(guard).str_concat(") ? (").str_concat(body_str).str_concat(") : (").str_concat(chain).str_concat("))");
        i = i - 1;
    }
    chain
}

// ============================================================================
// Statement Emitter
// ============================================================================

fn cc_emit_block(n: I32) : *Str => {
    let stmts = node_get_data1(n);
    let sb = sb_new();
    sb_append(sb, "{\n");
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        sb_append(sb, "  ");
        sb_append(sb, cc_emit_stmt(stmts.vec_get(i)));
        sb_append(sb, "\n");
        i = i + 1;
    }
    sb_append(sb, "}");
    sb_build(sb)
}

fn cc_emit_stmt_or_block(n: I32) : *Str => {
    if (node_kind(n) == NK_BLOCK) {
        return cc_emit_block(n);
    }
    "{ ".str_concat(cc_emit_stmt(n)).str_concat(" }")
}

fn cc_emit_fn_block(n: I32) : *Str => {
    let stmts = node_get_data1(n);
    let len = stmts.vec_length();
    if (len == 0) {
        return "{\n  return 0;\n}";
    }
    let sb = sb_new();
    sb_append(sb, "{\n");
    let i = 0;
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let is_last = i == len - 1;
        let skind = node_kind(stmt);
        if (is_last && skind == NK_EXPR_STMT) {
            sb_append(sb, "  return ");
            sb_append(sb, cc_emit_expr(node_get_data1(stmt)));
            sb_append(sb, ";\n");
        } else if (is_last && (skind == NK_IF_STMT || skind == NK_IF_EXPR)) {
            sb_append(sb, "  return ");
            sb_append(sb, cc_emit_if_as_c_expr(stmt));
            sb_append(sb, ";\n");
        } else {
            sb_append(sb, "  ");
            sb_append(sb, cc_emit_stmt(stmt));
            sb_append(sb, "\n");
        }
        i = i + 1;
    }
    sb_append(sb, "}");
    sb_build(sb)
}

fn cc_emit_param_list(params: Vec) : *Str => {
    let parts = vec_new();
    let i = 0;
    let len = params.vec_length();
    while (i < len) {
        let param = params.vec_get(i);
        let pname = get_interned_str(param.vec_get(0));
        let ptype = param.vec_get(1);
        let ptype_str = cc_type_to_c(ptype);
        parts.vec_push(ptype_str.str_concat(" ").str_concat(pname));
        i = i + 1;
    }
    parts.vec_join(", ")
}

fn cc_emit_prototype(ret_type: *Str, name: *Str, params: *Str) : *Str =>
    ret_type.str_concat(" ").str_concat(name).str_concat("(").str_concat(params).str_concat(");");

fn cc_emit_type_alias(n: I32) : *Str => {
    let alias_name = get_interned_str(node_get_data1(n));
    let aliased = node_get_data3(n);
    if (aliased == 0 || node_kind(aliased) != NK_UNION_TYPE) {
        return "/* type ".str_concat(alias_name).str_concat(" = ... */");
    }
    if (!cc_union_alias_info.map_has(alias_name)) {
        return "/* union ".str_concat(alias_name).str_concat(" not in context */");
    }
    let variants = cc_union_alias_info.map_get(alias_name);
    let vlen = variants.vec_length();
    let sb = sb_new();

    // typedef enum Alias_Tag { Alias_V1 = 1, ... } Alias_Tag;
    sb_append(sb, "typedef enum ");
    sb_append(sb, alias_name);
    sb_append(sb, "_Tag { ");
    let j = 0;
    while (j < vlen) {
        if (j > 0) { sb_append(sb, ", "); }
        sb_append(sb, alias_name);
        sb_append(sb, "_");
        sb_append(sb, variants.vec_get(j));
        sb_append(sb, " = ");
        sb_append(sb, int_to_string(j + 1));
        j = j + 1;
    }
    sb_append(sb, " } ");
    sb_append(sb, alias_name);
    sb_append(sb, "_Tag;\n");

    // Collect all unique field names from all variant structs
    let all_field_names = vec_new();
    let seen_fields = set_new();
    j = 0;
    while (j < vlen) {
        let v = variants.vec_get(j);
        if (cc_struct_fields.map_has(v)) {
            let fields = cc_struct_fields.map_get(v);
            let m = 0;
            let flen = fields.vec_length();
            while (m < flen) {
                let fname = fields.vec_get(m);
                if (!seen_fields.set_has(fname)) {
                    seen_fields.set_add(fname);
                    all_field_names.vec_push(fname);
                }
                m = m + 1;
            }
        }
        j = j + 1;
    }

    // typedef struct Alias { int32_t __tag; int64_t f1; ... } Alias;
    sb_append(sb, "typedef struct ");
    sb_append(sb, alias_name);
    sb_append(sb, " { int32_t __tag;");
    let m = 0;
    let flen = all_field_names.vec_length();
    while (m < flen) {
        sb_append(sb, " int64_t ");
        sb_append(sb, all_field_names.vec_get(m));
        sb_append(sb, ";");
        m = m + 1;
    }
    sb_append(sb, " } ");
    sb_append(sb, alias_name);
    sb_append(sb, ";\n");

    // Static inline constructor for each variant
    j = 0;
    while (j < vlen) {
        let v = variants.vec_get(j);
        let vfields = if (cc_struct_fields.map_has(v)) { cc_struct_fields.map_get(v) } else { vec_new() };
        let params_sb = sb_new();
        let assigns_sb = sb_new();
        let k = 0;
        let klen = vfields.vec_length();
        while (k < klen) {
            let fname = vfields.vec_get(k);
            if (k > 0) { sb_append(params_sb, ", "); }
            sb_append(params_sb, "int64_t ");
            sb_append(params_sb, fname);
            sb_append(assigns_sb, " out.");
            sb_append(assigns_sb, fname);
            sb_append(assigns_sb, " = ");
            sb_append(assigns_sb, fname);
            sb_append(assigns_sb, ";");
            k = k + 1;
        }
        sb_append(sb, "static inline ");
        sb_append(sb, alias_name);
        sb_append(sb, " ");
        sb_append(sb, alias_name);
        sb_append(sb, "_make_");
        sb_append(sb, v);
        sb_append(sb, "(");
        sb_append(sb, sb_build(params_sb));
        sb_append(sb, ") { ");
        sb_append(sb, alias_name);
        sb_append(sb, " out = {0}; out.__tag = ");
        sb_append(sb, alias_name);
        sb_append(sb, "_");
        sb_append(sb, v);
        sb_append(sb, ";");
        sb_append(sb, sb_build(assigns_sb));
        sb_append(sb, " return out; }\n");
        j = j + 1;
    }

    sb_build(sb)
}

fn cc_emit_stmt(n: I32) : *Str => {
    let kind = node_kind(n);

    if (kind == NK_LET_DECL) {
        let name = cc_to_name(get_interned_str(node_get_data1(n)));
        let value = cc_emit_expr(node_get_data3(n));
        return "int64_t ".str_concat(name).str_concat(" = ").str_concat(value).str_concat(";");
    }

    if (kind == NK_IMPORT_DECL) {
        return "/* import placeholder */";
    }

    if (kind == NK_EXPR_STMT) {
        return cc_emit_expr(node_get_data1(n)).str_concat(";");
    }

    if (kind == NK_ASSIGN_STMT) {
        let target = cc_emit_expr(node_get_data1(n));
        let value = cc_emit_expr(node_get_data2(n));
        return target.str_concat(" = ").str_concat(value).str_concat(";");
    }

    if (kind == NK_RETURN_STMT) {
        let val = node_get_data1(n);
        if (val == 0) { return "return 0;"; }
        return "return ".str_concat(cc_emit_expr(val)).str_concat(";");
    }

    if (kind == NK_IF_STMT || kind == NK_IF_EXPR) {
        let cond = cc_emit_expr(node_get_data1(n));
        let then_b = node_get_data2(n);
        let else_b = node_get_data3(n);
        let then_str = cc_emit_stmt_or_block(then_b);
        if (else_b == 0) {
            return "if (".str_concat(cond).str_concat(") ").str_concat(then_str);
        }
        return "if (".str_concat(cond).str_concat(") ").str_concat(then_str).str_concat(" else ").str_concat(cc_emit_stmt_or_block(else_b));
    }

    if (kind == NK_WHILE_STMT) {
        let cond = cc_emit_expr(node_get_data1(n));
        let body = cc_emit_block(node_get_data2(n));
        return "while (".str_concat(cond).str_concat(") ").str_concat(body);
    }

    if (kind == NK_FOR_STMT) {
        let iter = cc_to_name(get_interned_str(node_get_data1(n)));
        let start = cc_emit_expr(node_get_data2(n));
        let end = cc_emit_expr(node_get_data3(n));
        let body = cc_emit_block(node_get_data4(n));
        return "for (int64_t ".str_concat(iter).str_concat(" = ").str_concat(start).str_concat("; ").str_concat(iter).str_concat(" < ").str_concat(end).str_concat("; ").str_concat(iter).str_concat("++) ").str_concat(body);
    }

    if (kind == NK_LOOP_STMT) {
        let body = cc_emit_block(node_get_data1(n));
        return "while (1) ".str_concat(body);
    }

    if (kind == NK_BREAK_STMT) { return "break;"; }
    if (kind == NK_CONTINUE_STMT) { return "continue;"; }

    if (kind == NK_INTO_STMT) {
        return "/* into ".str_concat(get_interned_str(node_get_data1(n))).str_concat(" */");
    }

    if (kind == NK_LIFETIME_STMT) {
        return cc_emit_block(node_get_data2(n));
    }

    if (kind == NK_BLOCK) {
        return cc_emit_block(n);
    }

    if (kind == NK_EXPECT_FN_DECL) {
        return "/* expect fn ".str_concat(get_interned_str(node_get_data1(n))).str_concat(" */");
    }

    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
        let name = cc_to_name(get_interned_str(node_get_data1(n)));
        let params = node_get_data3(n);
        let ret_type = cc_type_to_c(node_get_data4(n));
        let body = node_get_data5(n);
        let params_str = cc_emit_param_list(params);
        if (body == 0) {
            return "/* fn ".str_concat(name).str_concat(" has no body */");
        }
        if (node_kind(body) == NK_BLOCK) {
            return ret_type.str_concat(" ").str_concat(name).str_concat("(").str_concat(params_str).str_concat(") ").str_concat(cc_emit_fn_block(body));
        }
        return ret_type.str_concat(" ").str_concat(name).str_concat("(").str_concat(params_str).str_concat(") { return ").str_concat(cc_emit_expr(body)).str_concat("; }");
    }

    if (kind == NK_STRUCT_DECL) {
        let name = get_interned_str(node_get_data1(n));
        return "/* struct ".str_concat(name).str_concat(" lowered via union aliases when applicable */");
    }

    if (kind == NK_TYPE_ALIAS) {
        return cc_emit_type_alias(n);
    }

    if (kind == NK_ENUM_DECL) {
        let name = get_interned_str(node_get_data1(n));
        let variants = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "typedef enum ");
        sb_append(sb, name);
        sb_append(sb, " { ");
        let i = 0;
        let vlen = variants.vec_length();
        while (i < vlen) {
            if (i > 0) { sb_append(sb, ", "); }
            sb_append(sb, name);
            sb_append(sb, "_");
            sb_append(sb, get_interned_str(variants.vec_get(i)));
            sb_append(sb, " = ");
            sb_append(sb, int_to_string(i));
            i = i + 1;
        }
        sb_append(sb, " } ");
        sb_append(sb, name);
        sb_append(sb, ";");
        return sb_build(sb);
    }

    if (kind == NK_OBJECT_DECL) {
        return "/* object ".str_concat(get_interned_str(node_get_data1(n))).str_concat(" */");
    }

    if (kind == NK_CONTRACT_DECL) {
        return "/* contract ".str_concat(get_interned_str(node_get_data1(n))).str_concat(" */");
    }

    if (kind == NK_EXTERN_FN_DECL) {
        let name = get_interned_str(node_get_data1(n));
        if (cc_is_stdlib_builtin(name)) {
            return "/* extern ".str_concat(name).str_concat(" — declared via C stdlib headers */");
        }
        let params = node_get_data3(n);
        let ret_type = cc_type_to_c(node_get_data4(n));
        let params_str = cc_emit_param_list(params);
        return cc_emit_prototype("extern ".str_concat(ret_type), name, params_str);
    }

    if (kind == NK_EXTERN_LET_DECL) {
        let name = get_interned_str(node_get_data1(n));
        return "/* extern let ".str_concat(name).str_concat(" */");
    }

    if (kind == NK_EXTERN_TYPE_DECL) {
        let name = get_interned_str(node_get_data1(n));
        return "/* extern type ".str_concat(name).str_concat(" */");
    }

    // NK_STMT_LIST (noop from extern let { } = source; parsing) — emit nothing
    if (kind == NK_STMT_LIST) {
        return "";
    }

    ""
}

// ============================================================================
// Main Entry Point
// ============================================================================

out fn generate_c(typed: I32, substrate: *Str) : *Str => {
    // Reset global state for this compilation
    cc_temp_counter = 0;
    cc_enum_names = set_new();
    cc_enum_variant_consts = map_new();
    cc_struct_fields = map_new();
    cc_alias_by_variant = map_new();
    cc_union_alias_info = map_new();

    // Pre-scan AST to build context maps
    cc_init_context(typed);

    let stmts = node_get_data1(typed);
    let len = stmts.vec_length();

    // Collect fn nodes for two-pass emit (prototypes then bodies)
    let fn_nodes : Vec<I32> = vec_new();
    // Collect global let init rows for tuff_init_globals()
    let init_rows : Vec<*Str> = vec_new();

    let sb = sb_new();

    // ── Preamble: fixed C includes ──────────────────────────────────────────
    sb_append(sb, "#include <stdint.h>\n");
    sb_append(sb, "#include <stddef.h>\n");
    sb_append(sb, "#include <stdio.h>\n");
    sb_append(sb, "#include <stdlib.h>\n");
    sb_append(sb, "#include <string.h>\n");
    sb_append(sb, "#include <errno.h>\n");
    sb_append(sb, "#ifdef _WIN32\n");
    sb_append(sb, "#include <direct.h>\n");
    sb_append(sb, "#else\n");
    sb_append(sb, "#include <sys/stat.h>\n");
    sb_append(sb, "#include <sys/types.h>\n");
    sb_append(sb, "#endif\n\n");
    sb_append(sb, "/* Generated by Tuff selfhost C backend. */\n\n");
    sb_append(sb, "/* Embedded C substrate support */\n");
    sb_append(sb, substrate);
    sb_append(sb, "\n\n");

    // ── First pass: non-fn top-level declarations ────────────────────────────
    let i = 0;
    while (i < len) {
        let node = stmts.vec_get(i);
        let kind = node_kind(node);

        // Collect fn nodes for later
        if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_ACTUAL_FN_DECL) {
            fn_nodes.vec_push(node);
            i = i + 1;
            continue;
        }

        // Skip expect fn declarations
        if (kind == NK_EXPECT_FN_DECL) {
            i = i + 1;
            continue;
        }

        // Global let → forward declaration + deferred initializer
        if (kind == NK_LET_DECL) {
            let name = cc_to_name(get_interned_str(node_get_data1(node)));
            sb_append(sb, "int64_t ");
            sb_append(sb, name);
            sb_append(sb, ";\n");
            init_rows.vec_push(name.str_concat(" = ").str_concat(cc_emit_expr(node_get_data3(node))).str_concat(";"));
            sb_append(sb, "\n");
            i = i + 1;
            continue;
        }

        // Everything else (enums, structs, type aliases, extern fns, etc.)
        let stmt_str = cc_emit_stmt(node);
        if (!stmt_str.str_eq("")) {
            sb_append(sb, stmt_str);
            sb_append(sb, "\n");
        }
        i = i + 1;
    }

    // ── Fn prototypes ────────────────────────────────────────────────────────
    sb_append(sb, "\n");
    i = 0;
    let fn_len = fn_nodes.vec_length();
    while (i < fn_len) {
        let fn_node = fn_nodes.vec_get(i);
        let fn_name = cc_to_name(get_interned_str(node_get_data1(fn_node)));
        let params_str = cc_emit_param_list(node_get_data3(fn_node));
        let ret_type = cc_type_to_c(node_get_data4(fn_node));
        sb_append(sb, cc_emit_prototype(ret_type, fn_name, params_str));
        sb_append(sb, "\n");
        i = i + 1;
    }
    sb_append(sb, "\n");

    // ── Fn bodies ────────────────────────────────────────────────────────────
    i = 0;
    while (i < fn_len) {
        let fn_node = fn_nodes.vec_get(i);
        sb_append(sb, cc_emit_stmt(fn_node));
        sb_append(sb, "\n\n");
        i = i + 1;
    }

    // ── tuff_init_globals ────────────────────────────────────────────────────
    sb_append(sb, "static void tuff_init_globals(void) {\n");
    i = 0;
    let init_len = init_rows.vec_length();
    while (i < init_len) {
        sb_append(sb, "  ");
        sb_append(sb, init_rows.vec_get(i));
        sb_append(sb, "\n");
        i = i + 1;
    }
    sb_append(sb, "}\n\n");

    // ── main() entry point ───────────────────────────────────────────────────
    sb_append(sb, "int main(void) {\n");
    sb_append(sb, "  tuff_init_globals();\n");
    sb_append(sb, "  return (int)tuff_main();\n");
    sb_append(sb, "}\n");

    sb_build(sb)
}

out fn selfhost_codegen_c_marker() : I32 => 0;
