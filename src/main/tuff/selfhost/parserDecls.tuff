let {
    getInternedStr, tokKind, tokValue, vecNew
}
 = selfhost::runtimeLexer;
let {
    pExpect, pParseIdentifier, pAt, pEat, pParseType, pAtKind, pPeek, pMark, pErrorWithTokenContext, nodeKind, nodeNew, nodeSetData1, nodeSetData2, nodeSetData3, nodeGetData1, pPanicLoc, pResultError
}
 = selfhost::parserCore;
let {
    pParseFunction, pParseStruct, pParseEnum, pParseObject, pParseContract, pParseTypeAlias, pParseFor, pParseLifetime
}
 = selfhost::parserDeclsHelpers;
let {
    pParseLet, pParseExternDecl
}
 = selfhost::parserDeclsLetExtern;
let {
    Ok, Err, Result
}
 = selfhost::Result;
let {
    ParseError
}
 = selfhost::errors::ParseError;
fn pNewStmtList(stmts: Vec<I32>) : I32 => {
    let n = nodeNew(NK_STMT_LIST);
    nodeSetData1(n, stmts);
    n
}
fn pParseTemplateWrapper() : I32 => {
    pEat();
     // template
    pParseIdentifier();
    if (pAt(TK_SYMBOL, ":")) {
        pEat();
        pParseType();
    }
    while (pAt(TK_SYMBOL, ",")) {
        pEat();
        pParseIdentifier();
        if (pAt(TK_SYMBOL, ":")) {
            pEat();
            pParseType();
        }
    }
    pExpect(TK_SYMBOL, "{", "Expected '{' after template declaration");
    let stmts = vecNew();
    while (!pAt(TK_SYMBOL, "}")) {
        let stmt = pParseStatement();
        if (nodeKind(stmt) = = NK_BLOCK) {
            let inner = nodeGetData1(stmt);
            let j = 0;
            let __len2 = inner.vecLength();
            while (j < __len2) {
                stmts.vecPush(inner.vecGet(j));
                j = j + 1;
            }
        }
        else {
            stmts.vecPush(stmt);
        }
    }
    pExpect(TK_SYMBOL, "}", "Expected '}' after template block");
    pNewStmtList(stmts)
}
fn pParseModuleWrapper() : I32 => {
    pExpect(TK_KEYWORD, "module", "Expected 'module'");
    pParseIdentifier();
    pExpect(TK_SYMBOL, "{", "Expected '{' after module name");
    let stmts = vecNew();
    while (!pAt(TK_SYMBOL, "}")) {
        let stmt = pParseStatement();
        if (nodeKind(stmt) = = NK_BLOCK) {
            let inner = nodeGetData1(stmt);
            let j = 0;
            let __len1 = inner.vecLength();
            while (j < __len1) {
                stmts.vecPush(inner.vecGet(j));
                j = j + 1;
            }
        }
        else {
            stmts.vecPush(stmt);
        }
    }
    pExpect(TK_SYMBOL, "}", "Expected '}' after module body");
    pNewStmtList(stmts)
}
fn pParseDeclModifiers() : Vec<I32> => {
    let exported = 0;
    let externDecl = 0;
    let copyDecl = 0;
    let expectDecl = 0;
    let actualDecl = 0;
    let consumedModifier = 0;
    let modifierWatchdog = 0;
    while (
    pAt(TK_KEYWORD, "out") ||
    pAt(TK_KEYWORD, "extern") ||
    pAt(TK_KEYWORD, "copy") ||
    pAt(TK_KEYWORD, "expect") ||
    (pAt(TK_IDENTIFIER, "expect") && (tokKind(pPeek(1)) = = TK_KEYWORD || tokKind(pPeek(1)) = = TK_IDENTIFIER)) ||
    pAt(TK_KEYWORD, "actual") ||
    (pAt(TK_IDENTIFIER, "actual") && (tokKind(pPeek(1)) = = TK_KEYWORD || tokKind(pPeek(1)) = = TK_IDENTIFIER))
    ) {
        modifierWatchdog = modifierWatchdog + 1;
        if (modifierWatchdog > 1000) {
            pErrorWithTokenContext("Parser watchdog: declaration-modifier loop exceeded 1000 iterations");
        }
        consumedModifier = 1;
        if (pAt(TK_KEYWORD, "out")) {
            pEat();
            if (exported = = 1) {
                pPanicLoc(
                "E_PARSE_DUPLICATE_MODIFIER",
                "Duplicate 'out' modifier",
                "The 'out' modifier was specified more than once",
                "Remove duplicate 'out' modifiers, keeping only one"
                );
            }
            exported = 1;
        }
        else if (pAt(TK_KEYWORD, "extern")) {
            pEat();
            if (externDecl = = 1) {
                pPanicLoc(
                "E_PARSE_DUPLICATE_MODIFIER",
                "Duplicate 'extern' modifier",
                "The 'extern' modifier was specified more than once",
                "Remove duplicate 'extern' modifiers, keeping only one"
                );
            }
            externDecl = 1;
        }
        else if (pAt(TK_KEYWORD, "copy")) {
            pEat();
            if (copyDecl = = 1) {
                pPanicLoc(
                "E_PARSE_DUPLICATE_MODIFIER",
                "Duplicate 'copy' modifier",
                "The 'copy' modifier was specified more than once",
                "Remove duplicate 'copy' modifiers, keeping only one"
                );
            }
            copyDecl = 1;
        }
        else if (pAt(TK_KEYWORD, "expect") || (pAt(TK_IDENTIFIER, "expect") && (tokKind(pPeek(1)) = = TK_KEYWORD || tokKind(pPeek(1)) = = TK_IDENTIFIER))) {
            pEat();
            if (expectDecl = = 1) {
                pPanicLoc(
                "E_PARSE_DUPLICATE_MODIFIER",
                "Duplicate 'expect' modifier",
                "The 'expect' modifier was specified more than once",
                "Remove duplicate 'expect' modifiers, keeping only one"
                );
            }
            expectDecl = 1;
        }
        else if (pAt(TK_KEYWORD, "actual") || (pAt(TK_IDENTIFIER, "actual") && (tokKind(pPeek(1)) = = TK_KEYWORD || tokKind(pPeek(1)) = = TK_IDENTIFIER))) {
            pEat();
            if (actualDecl = = 1) {
                pPanicLoc(
                "E_PARSE_DUPLICATE_MODIFIER",
                "Duplicate 'actual' modifier",
                "The 'actual' modifier was specified more than once",
                "Remove duplicate 'actual' modifiers, keeping only one"
                );
            }
            actualDecl = 1;
        }
        else {
            pPanicLoc(
            "E_PARSE_INVALID_MODIFIER",
            "Unexpected declaration modifier",
            "Encountered an unrecognized or invalid modifier",
            "Use only valid modifiers: out, extern, copy, expect, actual"
            );
        }
    }
    let mods = vecNew();
    mods.vecPush(exported);
    mods.vecPush(externDecl);
    mods.vecPush(copyDecl);
    mods.vecPush(expectDecl);
    mods.vecPush(actualDecl);
    mods.vecPush(consumedModifier);
    mods
}
fn pParseAfterModifiers(exported: I32, externDecl: I32, copyDecl: I32, expectDecl: I32, actualDecl: I32) : Result<I32, ParseError> => {
    if (expectDecl = = 1 && actualDecl = = 1) {
        return pResultError(
        "E_PARSE_CONFLICTING_MODIFIERS",
        "Cannot combine 'expect' and 'actual' modifiers",
        "These modifiers are mutually exclusive",
        "Use either 'expect' or 'actual', not both"
        );
    }
    let outNode = 0;
    if (externDecl = = 1) {
        if (copyDecl = = 1) {
            return pResultError(
            "E_PARSE_INVALID_MODIFIER",
            "'copy' is not supported on extern declarations",
            "External declarations cannot use the copy modifier",
            "Remove the 'copy' modifier from extern declarations"
            );
        }
        if (expectDecl = = 1 || actualDecl = = 1) {
            return pResultError(
            "E_PARSE_INVALID_MODIFIER",
            "'expect'/'actual' are not supported on extern declarations",
            "External declarations cannot use expect/actual modifiers",
            "Remove the 'expect'/'actual' modifiers from extern declarations"
            );
        }
        if (pAt(TK_KEYWORD, "extern")) {
            pEat();
        }
        if (!(pAt(TK_KEYWORD, "fn") || pAt(TK_KEYWORD, "let") || pAt(TK_KEYWORD, "type"))) {
            return pResultError(
            "E_PARSE_INVALID_MODIFIER",
            "'extern' modifier must be followed by fn, let, or type declaration",
            "The extern modifier can only be used with function, variable, or type declarations",
            "Add fn, let, or type after extern"
            );
        }
        outNode = pParseExternDecl()?;
    }
    else if (pAt(TK_KEYWORD, "struct")) {
        outNode = pParseStruct(copyDecl);
    }
    else if (pAt(TK_KEYWORD, "enum")) {
        outNode = pParseEnum();
    }
    else if (pAt(TK_KEYWORD, "object")) {
        if (copyDecl = = 1) {
            return pResultError(
            "E_PARSE_INVALID_MODIFIER",
            "'copy' is only supported on struct/type declarations",
            "The copy modifier can only be used with struct or type declarations",
            "Remove 'copy' or use it with struct/type declarations"
            );
        }
        if (expectDecl = = 1 || actualDecl = = 1) {
            return pResultError(
            "E_PARSE_INVALID_MODIFIER",
            "'expect'/'actual' are currently supported only on fn declarations",
            "These modifiers are only available for function declarations",
            "Remove 'expect'/'actual' or use them with fn declarations"
            );
        }
        outNode = pParseObject();
    }
    else if (pAt(TK_KEYWORD, "contract")) {
        if (copyDecl = = 1) {
            return pResultError(
            "E_PARSE_INVALID_MODIFIER",
            "'copy' is only supported on struct/type declarations",
            "The copy modifier can only be used with struct or type declarations",
            "Remove 'copy' or use it with struct/type declarations"
            );
        }
        if (expectDecl = = 1 || actualDecl = = 1) {
            return pResultError(
            "E_PARSE_INVALID_MODIFIER",
            "'expect'/'actual' are currently supported only on fn declarations",
            "These modifiers are only available for function declarations",
            "Remove 'expect'/'actual' or use them with fn declarations"
            );
        }
        outNode = pParseContract();
    }
    else if (pAt(TK_KEYWORD, "type")) {
        outNode = pParseTypeAlias(copyDecl);
    }
    else if (pAt(TK_KEYWORD, "fn")) {
        if (copyDecl = = 1) {
            return pResultError(
            "E_PARSE_INVALID_MODIFIER",
            "'copy' is only supported on struct/type declarations",
            "The copy modifier can only be used with struct or type declarations",
            "Remove 'copy' or use it with struct/type declarations"
            );
        }
        let mode = 0;
        if (expectDecl = = 1) {
            mode = 1;
        }
        else if (actualDecl = = 1) {
            mode = 2;
        }
        outNode = pParseFunction(0, mode);
    }
    else if (pAt(TK_KEYWORD, "class")) {
        if (copyDecl = = 1) {
            return pResultError(
            "E_PARSE_INVALID_MODIFIER",
            "'copy' is only supported on struct/type declarations",
            "The copy modifier can only be used with struct or type declarations",
            "Remove 'copy' or use it with struct/type declarations"
            );
        }
        if (expectDecl = = 1 || actualDecl = = 1) {
            return pResultError(
            "E_PARSE_INVALID_MODIFIER",
            "'expect'/'actual' are currently supported only on fn declarations",
            "These modifiers are only available for function declarations",
            "Remove 'expect'/'actual' or use them with fn declarations"
            );
        }
        pEat();
        outNode = pParseFunction(1, 0);
    }
    else if (pAt(TK_KEYWORD, "module")) {
        if (copyDecl = = 1) {
            return pResultError(
            "E_PARSE_INVALID_MODIFIER",
            "'copy' is only supported on struct/type declarations",
            "The copy modifier can only be used with struct or type declarations",
            "Remove 'copy' or use it with struct/type declarations"
            );
        }
        if (expectDecl = = 1 || actualDecl = = 1) {
            return pResultError(
            "E_PARSE_INVALID_MODIFIER",
            "'expect'/'actual' are currently supported only on fn declarations",
            "These modifiers are only available for function declarations",
            "Remove 'expect'/'actual' or use them with fn declarations"
            );
        }
        outNode = pParseModuleWrapper();
    }
    else {
        pErrorWithTokenContext("Expected declaration after modifiers");
        return Err<ParseError> {
            error: ParseError {
                code: "E_PARSE_UNEXPECTED_TOKEN", message: "Unreachable", reason: "", fix: "", line: 0, col: 0
            }
        }
        ;
    }
    if (exported = = 1 && nodeKind(outNode) != NK_STMT_LIST) {
        parseExports.setAdd(getInternedStr(nodeGetData1(outNode)));
    }
    if (pAt(TK_SYMBOL, ";")) {
        pEat();
    }
    let successResult = Ok<I32> {
        value: outNode
    }
    ;
    return successResult;
}
fn pTryParsePlainDeclStatement() : I32 => {
    if (pAt(TK_KEYWORD, "let")) {
        return pParseLet();
    }
    if (pAt(TK_KEYWORD, "struct")) {
        let node = pParseStruct(0);
        if (pAt(TK_SYMBOL, ";")) {
            pEat();
        }
        return node;
    }
    if (pAt(TK_KEYWORD, "enum")) {
        let node = pParseEnum();
        if (pAt(TK_SYMBOL, ";")) {
            pEat();
        }
        return node;
    }
    if (pAt(TK_KEYWORD, "object")) {
        let node = pParseObject();
        if (pAt(TK_SYMBOL, ";")) {
            pEat();
        }
        return node;
    }
    if (pAt(TK_KEYWORD, "module")) {
        let node = pParseModuleWrapper();
        if (pAt(TK_SYMBOL, ";")) {
            pEat();
        }
        return node;
    }
    if (pAt(TK_KEYWORD, "template") || pAt(TK_IDENTIFIER, "template")) {
        let node = pParseTemplateWrapper();
        if (pAt(TK_SYMBOL, ";")) {
            pEat();
        }
        return node;
    }
    if (pAt(TK_KEYWORD, "contract")) {
        let node = pParseContract();
        if (pAt(TK_SYMBOL, ";")) {
            pEat();
        }
        return node;
    }
    if (pAt(TK_KEYWORD, "type")) {
        let node = pParseTypeAlias(0);
        if (pAt(TK_SYMBOL, ";")) {
            pEat();
        }
        return node;
    }
    if (pAt(TK_KEYWORD, "fn")) {
        let node = pParseFunction(0, 0);
        if (pAt(TK_SYMBOL, ";")) {
            pEat();
        }
        return node;
    }
    if (pAt(TK_KEYWORD, "extern")) {
        pEat();
        let externResult = pParseExternDecl();
        if (externResult is struct Err) {
            panicWithCodeLoc(externResult.error.code, externResult.error.message, externResult.error.reason, externResult.error.fix, externResult.error.line, externResult.error.col);
            return 0;
        }
        return externResult.value;
    }
    if (pAt(TK_KEYWORD, "class")) {
        pEat();
        let node = pParseFunction(1, 0);
        if (pAt(TK_SYMBOL, ";")) {
            pEat();
        }
        return node;
    }
    0
}
fn pParseIfStmtOrExprStmt() : I32 => {
    pEat();
    pExpect(TK_SYMBOL, "(", "Expected '(' after if");
    let cond = pParseExpression(0);
    pExpect(TK_SYMBOL, ")", "Expected ')' after condition");
    if (
    pAt(TK_SYMBOL, "{") ||
    pAt(TK_KEYWORD, "break") ||
    pAt(TK_KEYWORD, "continue") ||
    pAt(TK_KEYWORD, "return") ||
    pAt(TK_KEYWORD, "if") ||
    pAt(TK_KEYWORD, "while") ||
    pAt(TK_KEYWORD, "for") ||
    pAt(TK_KEYWORD, "loop") ||
    pAt(TK_KEYWORD, "let")
    ) {
        let thenBranch = 0;
        if (pAt(TK_SYMBOL, "{")) {
            thenBranch = pParseBlock();
        }
        else {
            thenBranch = pParseStatement();
        }
        let elseBranch = 0;
        if (pAt(TK_KEYWORD, "else")) {
            pEat();
            if (pAt(TK_SYMBOL, "{")) {
                elseBranch = pParseBlock();
            }
            else {
                elseBranch = pParseStatement();
            }
        }
        let stmt = nodeNew(NK_IF_STMT);
        nodeSetData1(stmt, cond);
        nodeSetData2(stmt, thenBranch);
        nodeSetData3(stmt, elseBranch);
        return stmt;
    }
    let thenExpr = pParseExpression(0);
    let elseExpr = 0;
    if (pAt(TK_KEYWORD, "else")) {
        pEat();
        if (pAt(TK_SYMBOL, "{")) {
            elseExpr = pParseBlock();
        }
        else {
            elseExpr = pParseExpression(0);
        }
    }
    let ifExpr = nodeNew(NK_IF_EXPR);
    nodeSetData1(ifExpr, cond);
    nodeSetData2(ifExpr, thenExpr);
    nodeSetData3(ifExpr, elseExpr);
    if (pAt(TK_SYMBOL, ";")) {
        pEat();
    }
    else if (!pAt(TK_SYMBOL, "}")) {
        pExpect(TK_SYMBOL, ";", "Expected ';'");
    }
    let estmt = nodeNew(NK_EXPR_STMT);
    nodeSetData1(estmt, ifExpr);
    estmt
}
fn pTryParsePlainControlStatement() : I32 => {
    if (pAt(TK_KEYWORD, "return")) {
        pEat();
        let value = 0;
        if (!pAt(TK_SYMBOL, ";")) {
            value = pParseExpression(0);
        }
        pExpect(TK_SYMBOL, ";", "Expected ';'");
        let node = nodeNew(NK_RETURN_STMT);
        nodeSetData1(node, value);
        return node;
    }
    if (pAt(TK_KEYWORD, "if")) {
        return pParseIfStmtOrExprStmt();
    }
    if (pAt(TK_KEYWORD, "while")) {
        pEat();
        pExpect(TK_SYMBOL, "(", "Expected '('");
        let cond = pParseExpression(0);
        pExpect(TK_SYMBOL, ")", "Expected ')'");
        let body = pParseBlock();
        let node = nodeNew(NK_WHILE_STMT);
        nodeSetData1(node, cond);
        nodeSetData2(node, body);
        return node;
    }
    if (pAt(TK_KEYWORD, "for")) {
        return pParseFor ();
    }
    if (pAt(TK_KEYWORD, "loop")) {
        pEat();
        let body = pParseBlock();
        let node = nodeNew(NK_LOOP_STMT);
        nodeSetData1(node, body);
        return node;
    }
    if (pAt(TK_KEYWORD, "then")) {
        pEat();
        pExpect(TK_SYMBOL, "(", "Expected '(' after then in then-statement");
        pExpect(TK_SYMBOL, ")", "Expected ')' in then-statement parameter list");
        pExpect(TK_SYMBOL, "=>", "Expected '=>' in then-statement");
        if (pAt(TK_SYMBOL, "{")) {
            return pParseBlock();
        }
        let expr = pParseExpression(0);
        pExpect(TK_SYMBOL, ";", "Expected ';' after then-statement expression");
        let estmt = nodeNew(NK_EXPR_STMT);
        nodeSetData1(estmt, expr);
        return estmt;
    }
    if (pAt(TK_KEYWORD, "lifetime")) {
        return pParseLifetime();
    }
    if (pAt(TK_KEYWORD, "into")) {
        pEat();
        let cname = pParseIdentifier();
        pExpect(TK_SYMBOL, ";", "Expected ';' after into statement");
        let node = nodeNew(NK_INTO_STMT);
        nodeSetData1(node, cname);
        return node;
    }
    if (pAt(TK_KEYWORD, "break")) {
        pEat();
        pExpect(TK_SYMBOL, ";", "Expected ';'");
        return nodeNew(NK_BREAK_STMT);
    }
    if (pAt(TK_KEYWORD, "continue")) {
        pEat();
        pExpect(TK_SYMBOL, ";", "Expected ';'");
        return nodeNew(NK_CONTINUE_STMT);
    }
    if (pAt(TK_SYMBOL, "{")) {
        return pParseBlock();
    }
    0
}
fn pParseStatement() : I32 => {
    let mods = pParseDeclModifiers();
    if (mods.vecGet(5) = = 1) {
        let modResultAny = pParseAfterModifiers(mods.vecGet(0), mods.vecGet(1), mods.vecGet(2), mods.vecGet(3), mods.vecGet(4));
        if (modResultAny is struct Err) {
            panicWithCodeLoc(modResultAny.error.code, modResultAny.error.message, modResultAny.error.reason, modResultAny.error.fix, modResultAny.error.line, modResultAny.error.col);
        }
        if (modResultAny is struct Ok) {
            return modResultAny.value;
        }
        panic("Unexpected parser result variant");
        return 0;
    }
    let node = pTryParsePlainDeclStatement();
    if (node != 0) {
        return node;
    }
    node = pTryParsePlainControlStatement();
    if (node != 0) {
        return node;
    }
     // Expression statement
    let expr = pParseExpression(0);
     // Assignment
    if (pAt(TK_SYMBOL, "=")) {
        pEat();
        let value = pParseExpression(0);
        pExpect(TK_SYMBOL, ";", "Expected ';'");
        let node = nodeNew(NK_ASSIGN_STMT);
        nodeSetData1(node, expr);
        nodeSetData2(node, value);
        return node;
    }
     // Compound assignment: x += v, x -= v, etc. (lexed as op token followed by '=')
    if (
    (pAt(TK_SYMBOL, "+") || pAt(TK_SYMBOL, "-") || pAt(TK_SYMBOL, "*") || pAt(TK_SYMBOL, "/") || pAt(TK_SYMBOL, "%") || pAt(TK_SYMBOL, "&") || pAt(TK_SYMBOL, "|") || pAt(TK_SYMBOL, "^")) &&
    tokKind(pPeek(1)) = = TK_SYMBOL &&
    getInternedStr(tokValue(pPeek(1))).strEq("=")
    ) {
        let opTok = pEat();
        pEat();
        let rhs = pParseExpression(0);
        pExpect(TK_SYMBOL, ";", "Expected ';'");
        let bin = nodeNew(NK_BINARY_EXPR);
        nodeSetData1(bin, tokValue(opTok));
        nodeSetData2(bin, expr);
        nodeSetData3(bin, rhs);
        let node = nodeNew(NK_ASSIGN_STMT);
        nodeSetData1(node, expr);
        nodeSetData2(node, bin);
        return node;
    }
    if (pAt(TK_SYMBOL, ";")) {
        pEat();
    }
    else if (!pAt(TK_SYMBOL, "}")) {
        pExpect(TK_SYMBOL, ";", "Expected ';'");
    }
    let stmt = nodeNew(NK_EXPR_STMT);
    nodeSetData1(stmt, expr);
    stmt
}
out fn pParseProgram() : I32 => {
    let stmts = vecNew();
    let atEof = pAtKind(TK_EOF);
    while (!atEof) {
        let before = pMark();
        let stmt = pParseStatement();
        let after = pMark();
        if (after = = before) {
            pErrorWithTokenContext("Parser made no progress while parsing top-level statement");
        }
        if (nodeKind(stmt) = = NK_STMT_LIST) {
            let inner = nodeGetData1(stmt);
            let i = 0;
            let __len = inner.vecLength();
            while (i < __len) {
                stmts.vecPush(inner.vecGet(i));
                i = i + 1;
            }
        }
        else {
            stmts.vecPush(stmt);
        }
        atEof = pAtKind(TK_EOF);
    }
    let node = nodeNew(NK_PROGRAM);
    nodeSetData1(node, stmts);
    node
}
 // ============================================================================
 // Desugar - skip for now, minimal implementation
 // ============================================================================
out fn desugar(program: I32) : I32 => program;
out fn selfhostParserDeclsMarker() : I32 => 0;
