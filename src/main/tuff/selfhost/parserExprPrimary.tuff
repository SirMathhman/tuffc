let {
    pAt, pEat, pExpect, pParseIdentifier, pAtKind, pPeek, pMark, pRestore,
    pParsePattern, pParseType, pErrorWithTokenContext, nodeNew, nodeSetData1, nodeSetData2, nodeSetData3, nodeSetData4, nodeSetData5
}
 = selfhost::parserCore;
let {
    tokKind, tokValue, getInternedStr, vecNew
}
 = selfhost::runtimeLexer;
let {
    pParsePostfix, pGenericSuffixKind
}
 = selfhost::parserExprPostfix;
fn pParsePrimaryArray() : I32 => {
    pEat();
    let items = vecNew();
    if (!pAt(TK_SYMBOL, "]")) {
        items.vecPush(pParseExpression(0));
        while (pAt(TK_SYMBOL, ",")) {
            pEat();
            if (pAt(TK_SYMBOL, "]")) {
                break;
            }
            items.vecPush(pParseExpression(0));
        }
    }
    pExpect(TK_SYMBOL, "]", "Expected ']' in array literal");
    let node = nodeNew(NK_TUPLE_EXPR);
    nodeSetData1(node, items);
    pParsePostfix(node)
}
fn pParsePrimaryBasicLiteral(kind: I32) : I32 => {
    let t = pEat();
    let node = nodeNew(kind);
    nodeSetData1(node, tokValue(t));
    pParsePostfix(node)
}
fn pTryParseParenLambda() : I32 => {
    if (!pAt(TK_SYMBOL, "(")) {
        return 0;
    }
    let mark = pMark();
    pEat();
    let params = vecNew();
    let valid = true;
    if (!pAt(TK_SYMBOL, ")")) {
        while (true) {
            if (!pAtKind(TK_IDENTIFIER)) {
                valid = false;
                break;
            }
            let pname = pParseIdentifier();
            let ptype = 0;
            if (pAt(TK_SYMBOL, ":")) {
                pEat();
                ptype = pParseType();
            }
            let param = vecNew();
            param.vecPush(pname);
            param.vecPush(ptype);
            params.vecPush(param);
            if (pAt(TK_SYMBOL, ",")) {
                pEat();
                continue;
            }
            break;
        }
    }
    if (valid && pAt(TK_SYMBOL, ")")) {
        pEat();
        if (pAt(TK_SYMBOL, "=>")) {
            pEat();
            let body = 0;
            if (pAt(TK_SYMBOL, "{")) {
                body = pParseBlock();
            }
            else {
                body = pParseExpression(0);
            }
            let lam = nodeNew(NK_LAMBDA_EXPR);
            nodeSetData1(lam, params);
            nodeSetData2(lam, body);
            return pParsePostfix(lam);
        }
    }
    pRestore(mark);
    0
}
fn pParsePrimaryFnExpr() : I32 => {
    pEat();
    let fname = 0;
    if (pAtKind(TK_IDENTIFIER)) {
        fname = pParseIdentifier();
    }
    let generics = vecNew();
    if (pAt(TK_SYMBOL, "<")) {
        pEat();
        if (!pAt(TK_SYMBOL, ">")) {
            while (true) {
                generics.vecPush(pParseIdentifier());
                if (pAt(TK_SYMBOL, ":")) {
                    pEat();
                    pParseType();
                }
                if (!pAt(TK_SYMBOL, ",")) {
                    break;
                }
                pEat();
            }
        }
        pExpect(TK_SYMBOL, ">", "Expected '>'");
    }
    pExpect(TK_SYMBOL, "(", "Expected '(' in function expression");
    let params = vecNew();
    if (!pAt(TK_SYMBOL, ")")) {
        while (true) {
            let pname = pParseIdentifier();
            let ptype = 0;
            if (pAt(TK_SYMBOL, ":")) {
                pEat();
                ptype = pParseType();
            }
            let param = vecNew();
            param.vecPush(pname);
            param.vecPush(ptype);
            params.vecPush(param);
            if (!pAt(TK_SYMBOL, ",")) {
                break;
            }
            pEat();
        }
    }
    pExpect(TK_SYMBOL, ")", "Expected ')' after params");
    let ret = 0;
    if (pAt(TK_SYMBOL, ":")) {
        pEat();
        ret = pParseType();
    }
    pExpect(TK_SYMBOL, "=>", "Expected '=>' in function expression");
    let body = 0;
    if (pAt(TK_SYMBOL, "{")) {
        body = pParseBlock();
    }
    else {
        body = pParseExpression(0);
    }
    let fnexpr = nodeNew(NK_FN_EXPR);
    nodeSetData1(fnexpr, fname);
    nodeSetData2(fnexpr, generics);
    nodeSetData3(fnexpr, params);
    nodeSetData4(fnexpr, ret);
    nodeSetData5(fnexpr, body);
    pParsePostfix(fnexpr)
}
fn pTryParseIdentifierLambda() : I32 => {
    if (!(pAtKind(TK_IDENTIFIER) && tokKind(pPeek(1)) = = TK_SYMBOL && getInternedStr(tokValue(pPeek(1))).strEq("=>"))) {
        return 0;
    }
    let pname = pParseIdentifier();
    pExpect(TK_SYMBOL, "=>", "Expected '=>' in lambda expression");
    let param = vecNew();
    param.vecPush(pname);
    param.vecPush(0);
    let params = vecNew();
    params.vecPush(param);
    let body = 0;
    if (pAt(TK_SYMBOL, "{")) {
        body = pParseBlock();
    }
    else {
        body = pParseExpression(0);
    }
    let lam = nodeNew(NK_LAMBDA_EXPR);
    nodeSetData1(lam, params);
    nodeSetData2(lam, body);
    pParsePostfix(lam)
}
fn pParsePrimaryParenOrTuple() : I32 => {
    pEat();
    let first = pParseExpression(0);
    if (pAt(TK_SYMBOL, ",")) {
        let items = vecNew();
        items.vecPush(first);
        while (pAt(TK_SYMBOL, ",")) {
            pEat();
            items.vecPush(pParseExpression(0));
        }
        pExpect(TK_SYMBOL, ")", "Expected ')' after tuple expression");
        let tuple = nodeNew(NK_TUPLE_EXPR);
        nodeSetData1(tuple, items);
        return pParsePostfix(tuple);
    }
    pExpect(TK_SYMBOL, ")", "Expected ')'");
    pParsePostfix(first)
}
fn pParsePrimaryIfExpr() : I32 => {
    pEat();
    pExpect(TK_SYMBOL, "(", "Expected '(' after if");
    let cond = pParseExpression(0);
    pExpect(TK_SYMBOL, ")", "Expected ')' after condition");
    let thenBranch = 0;
    if (pAt(TK_SYMBOL, "{")) {
        thenBranch = pParseBlock();
    }
    else {
        thenBranch = pParseExpression(0);
    }
    let elseBranch = 0;
    if (pAt(TK_KEYWORD, "else")) {
        pEat();
        if (pAt(TK_SYMBOL, "{")) {
            elseBranch = pParseBlock();
        }
        else {
            elseBranch = pParseExpression(0);
        }
    }
    let node = nodeNew(NK_IF_EXPR);
    nodeSetData1(node, cond);
    nodeSetData2(node, thenBranch);
    nodeSetData3(node, elseBranch);
    pParsePostfix(node)
}
fn pParsePrimaryMatchExpr() : I32 => {
    pEat();
    pExpect(TK_SYMBOL, "(", "Expected '(' after match");
    let target = pParseExpression(0);
    pExpect(TK_SYMBOL, ")", "Expected ')' after match target");
    pExpect(TK_SYMBOL, "{", "Expected '{'");
    let cases = vecNew();
    while (!pAt(TK_SYMBOL, "}")) {
        pExpect(TK_KEYWORD, "case", "Expected 'case'");
        let pat = pParsePattern();
        pExpect(TK_SYMBOL, "=", "Expected '='");
        let body = 0;
        if (pAt(TK_SYMBOL, "{")) {
            body = pParseBlock();
        }
        else {
            body = pParseExpression(0);
        }
        pExpect(TK_SYMBOL, ";", "Expected ';' after case");
        let caseNode = vecNew();
        caseNode.vecPush(pat);
        caseNode.vecPush(body);
        cases.vecPush(caseNode);
    }
    pExpect(TK_SYMBOL, "}", "Expected '}'");
    let node = nodeNew(NK_MATCH_EXPR);
    nodeSetData1(node, target);
    nodeSetData2(node, cases);
    node
}
fn pParsePrimaryIdentifierExpr() : I32 => {
    let name = pParseIdentifier();
    let expr = nodeNew(NK_IDENTIFIER);
    nodeSetData1(expr, name);
    let genericArgs = vecNew();
    let isTypeLike = false;
    let nameText = getInternedStr(name);
    if (nameText.strLength() > 0) {
        let c0 = nameText.strCharAt(0);
        if (c0 >= 65 && c0 <= 90) {
            isTypeLike = true;
        }
    }
    if (isTypeLike && pAt(TK_SYMBOL, "<")) {
        let gsk = pGenericSuffixKind();
        if (gsk = = 2 || gsk = = 3) {
            pEat();
            if (!pAt(TK_SYMBOL, ">")) {
                genericArgs.vecPush(pParseGenericArgValueOrType());
                while (pAt(TK_SYMBOL, ",")) {
                    pEat();
                    genericArgs.vecPush(pParseGenericArgValueOrType());
                }
            }
            pExpect(TK_SYMBOL, ">", "Expected '>' in generic struct initializer");
            nodeSetData2(expr, genericArgs);
        }
    }
    if (pAt(TK_SYMBOL, "{")) {
        pEat();
        let fields = vecNew();
        if (!pAt(TK_SYMBOL, "}")) {
            let key = pParseIdentifier();
            pExpect(TK_SYMBOL, ":", "Expected ':' in struct init");
            let val = pParseExpression(0);
            let field = vecNew();
            field.vecPush(key);
            field.vecPush(val);
            fields.vecPush(field);
            while (pAt(TK_SYMBOL, ",")) {
                pEat();
                let key2 = pParseIdentifier();
                pExpect(TK_SYMBOL, ":", "Expected ':'");
                let val2 = pParseExpression(0);
                let field2 = vecNew();
                field2.vecPush(key2);
                field2.vecPush(val2);
                fields.vecPush(field2);
            }
        }
        pExpect(TK_SYMBOL, "}", "Expected '}'");
        let initNode = nodeNew(NK_STRUCT_INIT);
        nodeSetData1(initNode, name);
        nodeSetData2(initNode, fields);
        nodeSetData3(initNode, genericArgs);
        expr = initNode;
    }
    pParsePostfix(expr)
}
out fn pParsePrimary() : I32 => {
    if (pAt(TK_SYMBOL, "[")) {
        return pParsePrimaryArray();
    }
    if (pAtKind(TK_NUMBER)) {
        return pParsePrimaryBasicLiteral(NK_NUMBER_LIT);
    }
    if (pAtKind(TK_BOOL)) {
        return pParsePrimaryBasicLiteral(NK_BOOL_LIT);
    }
    if (pAtKind(TK_STRING)) {
        return pParsePrimaryBasicLiteral(NK_STRING_LIT);
    }
    if (pAtKind(TK_CHAR)) {
        return pParsePrimaryBasicLiteral(NK_CHAR_LIT);
    }
    let parenLambda = pTryParseParenLambda();
    if (parenLambda != 0) {
        return parenLambda;
    }
    if (pAt(TK_KEYWORD, "fn")) {
        return pParsePrimaryFnExpr();
    }
    let idLambda = pTryParseIdentifierLambda();
    if (idLambda != 0) {
        return idLambda;
    }
    if (pAt(TK_SYMBOL, "(")) {
        return pParsePrimaryParenOrTuple();
    }
    if (pAt(TK_KEYWORD, "if")) {
        return pParsePrimaryIfExpr();
    }
    if (pAt(TK_KEYWORD, "match")) {
        return pParsePrimaryMatchExpr();
    }
    if (pAtKind(TK_IDENTIFIER)) {
        return pParsePrimaryIdentifierExpr();
    }
    pErrorWithTokenContext("Expected expression start (identifier, literal, '(', '[', 'if', 'match', or 'fn')");
    0
}
out fn selfhostParserExprPrimaryMarker() : I32 => 0;
