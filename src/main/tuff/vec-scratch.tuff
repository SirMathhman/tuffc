type Alloc<T> = T then free;
extern let {
    malloc, free
}
 = stdlib;
extern fn malloc<T, L : USize>(bytesCount : SizeOf<T> * L) : Alloc<*[T;
0;
L]> | 0;
lifetime t {
    extern fn realloc<T, I : USize, L : USize, L2 : USize >= I>(
    ptr : Alloc<*t [T;
    I;
    L]>,
    bytesCount : SizeOf<T> * L2
    ) : Alloc<*t [T;
    I;
    L2]> | 0;
}
extern fn free<T>(this : Alloc<*[T;
_;
_]>) : Void;
 // No idea why memcpy is defined in string.h, but whatever
extern let {
    memcpy
}
 = string;
 // memcpy<T, SI, DI, DL, Count>
 // Copies Count initialized elements from source (with SI initialized) to destination (with DI init
and DL capacity)
 // Preconditions enforced:
 //   - Count <= SI (don't copy uninitialized bytes from source)
 //   - DI + Count <= DL (destination has space for the copy)
 // Note: caller must manually update destination.init after calling memcpy
extern fn memcpy<T, SI : USize, DI : USize, Count : USize <= SI, DL : USize >= DI + Count>(
to : *mut [T;
DI;
DL],
from : *[T;
SI;
_],
bytesCount : SizeOf<T> * Count
) : Void;
out struct Some<T> {
    field : T
}
;
out object None<T> {
}
;
type Option<T> = Some<T> | None<T>;
out module Option {
    fn flat_map<T, U>(this : Option<T>, f : (T) => Option<U>) : Option<U> => {
        if (this is Some<T>) {
             // Extract the value from Some<T>
            let someValue : Some<T> = this;
            f(someValue.field)
        }
        else {
            None<U>
        }
    }
}
let DEFAULT_SIZE = 10USize;
 // An iterator is just a closure that returns a tuple, where (hasValue, Element)
type Iter<T> = () => (Bool, T);
out module Iter {
     // Move this
    fn filter(this : Iter<T>, predicate : (T) => Bool) : Iter<T> => {
        return () => {
            /*
            Unfortunately, we can't prove that loops in general terminate
            and that hasValue will eventually transition to true to false
            You could stick an absurd cap like Max<I32> to prevent an infinite loop if desired
            */
            loop {
                let (hasValue, element) = this();
                if (predicate(element)) {
                    return (hasValue, element);
                }
                else {
                     // Don't forget to drop element if predicate does not satisfy!
                    if (!hasValue) break;
                }
            }
        }
        ;
    }
    fn first(this : Iter<T>) : Option<T> => {
        let (hasValue, element) = this();
        if (hasValue) Some<T> {
            field : element
        }
        else None<T>
    }
}
out fn Vec<T>() : Option<Vec<T>> => {
     // Associated type, or something like it
     // We need a lookahead for this.size()
    out type Index = USize < this.size();
     // Slice is private so we don't need the "out" keyword
    let mut slice : Alloc<*[T;
    0;
    DEFAULT_SIZE]> | 0 = malloc<T, DEFAULT_SIZE>(sizeOf<T>() * DEFAULT_SIZE);
    if (slice == 0) return None<Vec<T>>;
     // Can also be `lifetime a, b, c, d`, etc. for multiple lifetimes.
    lifetime a {
        out fn addLast(*mut a this, element : T) : Option<*mut a Vec<T>> =>
        set(this.size(), element);
        out fn set(*mut a this, index : USize <= this.size(), element : T) : Option<*mut a Vec<T>>
        => {
             // We don't need a while here, only an if, because index can never be > this.slice.length
            if (index == slice.length) {
                let reallocated = realloc<T, slice.length * 2>(slice, sizeOf<T>() * slice.length *
                2);
                if (reallocated == 0) return None<*mut a Vec<T>>;
                slice = reallocated;
            }
            slice[index] = element;
            Some<*mut a Vec<T>> {
                field : this.this
            }
        }
        out fn clear(*mut this) => {
            /*
            Need to generate a for loop in the C code if T has a destructor
            such that all elements in the slice from 0 to init are destroyed correctly
            Does not generate for types without a destructor
            */
            slice.init = 0;
        }
        out fn removeByIndex(*mut this, index : Index) : T => {
             // Save the element we're removing (guaranteed to be initialized)
            let removed = slice[index];
             // If we're not removing the last element, shift elements leftward
            let elementsToShift = slice.init - index - 1USize;
            if (elementsToShift > 0USize) {
                 // Copy elements [index+1..init) to [index..init-1)
                 // Source: slice + index + 1 has (init - index - 1) initialized elements
                 // Dest: slice + index has init - 1 total capacity after shift
                memcpy<T, elementsToShift, index, slice.length, elementsToShift>(
                slice + index,
                slice + index + 1,
                sizeOf<T>() * elementsToShift
                );
            }
             // Decrement init after shift
            slice.init = slice.init - 1USize;
             // Return the removed element (guaranteed initialized by invariant)
            removed
        }
    }
     // `*this` is implicit
    out fn get(index : Index) : *T => {
        /*
        Pointer math.
        For A, B, where
        - slice is *[T; A; B]
        - index is USize < A
        Then
        - (slice + index) is *[T; A - index; B - index]
        A - index
        A - (USize < A)
        Therefore, there must be at least one element
        *[T; USize >= 1; USize >= 1]
        Always safe to convert *[T; USize >= 1; USize >= 1] to *T
        Remember, these are both C pointers, and neither is fat!
        */
        slice + index
    }
    out fn get_mut(*mut this, index : Index) : *mut T => {
         // Same logic applies as above
        slice + index
    }
    /*
    We set the return type to be USize to deliberately widen the type
    from `this.slice.init` (which is a type in of itself) to `USize`
    */
    out fn size() : USize => slice.init;
    /*
    Because 0USize..size() is always 0USize to size() - 1 inclusive,
    and Index is defined as USize < size(),
    we can guarantee that this return a iterator of all the indices.
    The A..B range syntax creates a built - in Iter,
    or technically () => (Bool, T)
    */
    fn iterIndices() : Iter<Index> => 0USize..size();
     // Like a class
    Some<Vec<T>> {
        field : this
    }
}
contract Equatable {
     // *This just becomes void* in the generated C
    fn equalsTo(other : *This) : Bool;
}
 // Companion
out module Vec {
     // Introduce the template keyword
     // So we don't have to do <T : Equatable> for all three signatures
     // Reduces duplication
    template T : Equatable {
        out fn remove_by_value(*mut this, value : *T) : Option<T> => {
            index_of(this, value).flat_map(index => this.removeByIndex(index))
        }
        out fn contains(this : *Vec<T>, element : *T) : Bool => index_of(element) is Some;
        out fn index_of(this : *Vec<T>, element : *T) : Option<Vec<I32>::Index> => {
            this.iterIndices()
            .filter(index => this.get(index).equalsTo(element))
            .first()
        }
    }
}
