type Alloc<T> = T then free;

extern let { malloc, free } = stdlib;

extern fn malloc<T, L : USize>(bytesCount : SizeOf<T> * L) : Alloc<*[T; 0; L]> | 0;

lifetime t {
    extern fn realloc<T, L : USize>(
        ptr : Alloc<*t [T; _; _ < L]>, 
        bytesCount : SizeOf<T> * L
    ) : Alloc<*t [T; _; L]> | 0;
}

extern fn free<T>(this : Alloc<*[T; _; _]>);

// No idea why memcpy is defined in string.h, but whatever
extern let { memcpy } = string;

/*
This signature might need correction, it's not correct yet:

Type,
SourceInit,
SourceLength,
DestInit,
DestLength
BytesCount

Establishing invariants as:

SourceInit <= SourceLength,
DestInit <= DestLength,
BytesCount <= SourceInit
*/
extern fn memcpy<MinLength : USize, S; D : USize <= L>(
    to : *out mut [Type; DestInit; USize >= DestInit],
    from : *[Type; SourceInit; USize >= SourceInit],
    bytesCount : SizeOf<T> * D
) : Void;

out struct Some<T> { field : T };
out object None<T> {};

type Option<T> = Some<T> | None<T>;

let DEFAULT_SIZE = 10USize;

// An iterator is just a closure that returns a tuple, where (hasValue, Element)
type Iter<T> = () => (Bool, T);
out module Iter {
    // Move this
    fn filter(this : Iter<T>, predicate : (T) => Bool) : Iter<T> => {       
        return () => {
            /*
            Unfortunately, we can't prove that loops in general terminate
            and that hasValue will eventually transition to true to false

            You could stick an absurd cap like Max<I32> to prevent an infinite loop if desired
            */
            loop {
                let (hasValue, element) = this();
                if (predicate(element)) {
                    return (hasValue, element);
                } else {
                    // Don't forget to drop element if predicate does not satisfy!
                    if (!hasValue) break;
                }
            }
        };
    }

    fn first(this : Iter<T>) : Option<T> => {
        let (hasValue, element) = this();
        if (hasValue) Some<T> { field : element } else None<T>
    }
}

out fn Vec<T>() : Option<Vec<T>> => {
    // Associated type, or something like it
    // We need a lookahead for this.size()
    out type Index = USize < this.size();

    // Slice is private so we don't need the "out" keyword
    let mut slice : Alloc<*[T; 0; DEFAULT_SIZE]> | 0 = malloc<T, DEFAULT_SIZE>(sizeOf<T>() * DEFAULT_SIZE);
    if (slice == 0) return None<Vec<T>>;

    // Can also be `lifetime a, b, c, d`, etc. for multiple lifetimes.
    lifetime a {
        out fn addLast(*mut a this, element : T) : Option<*mut a Vec<T>> => 
            set(this.size(), element);

        out fn set(*mut a this, index : USize <= this.size(), element : T) : Option<*mut a Vec<T>> => {
            // We don't need a while here, only an if, because index can never be > this.slice.length
            if (index == slice.length) {
                let reallocated = realloc<T, slice.length * 2>(slice, sizeOf<T>() * slice.length * 2);
                if (reallocated == 0) return None<*mut a Vec<T>>;

                slice = reallocated;
            }

            slice[index] = element;
            Some<*mut a Vec<T>> { field : this.this }
        }

        out fn clear(*mut this) => {
            /*
            Need to generate a for loop in the C code if T has a destructor
            such that all elements in the slice from 0 to init are destroyed correctly

            Does not generate for types without a destructor
            */
            slice.init = 0;
        }
    
        out fn removeByIndex(*mut this, index : Index) : T => {
            // TODO: Shift elements over
            // Then set slice.init manually
            // Use memcpy

            /*
            Return the removed element. This is guaranteed to produce a value.
            Since we know that ALL elements are initialized up to this.slice.init
            and that index is always USize < this.slice.init, there MUST be always a value
            */
        }
    }

    // `*this` is implicit
    out fn get(index : Index) : *T => {
        /*
        Pointer math.

        For A, B, where
        - slice is *[T; A; B]
        - index is USize < A
        Then
        - (slice + index) is *[T; A - index; B - index]

        A - index
        A - (USize < A)

        Therefore, there must be at least one element
        *[T; USize >= 1; USize >= 1]

        Always safe to convert *[T; USize >= 1; USize >= 1] to *T
        Remember, these are both C pointers, and neither is fat!
        */
        slice + index
    }

    out fn get_mut(*mut this, index : Index) : *mut T => {
        // Same logic applies as above
        slice[index]
    }

    /*
    We set the return type to be USize to deliberately widen the type
    from `this.slice.init` (which is a type in of itself) to `USize`
    */
    out fn size() : USize => slice.init;

    /*
    Because 0USize..size() is always 0USize to size() - 1 inclusive,
    and Index is defined as USize < size(),
    we can guarantee that this return a iterator of all the indices.

    The A..B range syntax creates a built-in Iter,
    or technically () => (Bool, T)
    */
    fn iterIndices() : Iter<Index> => 0USize..size();
    
    // Like a class
    Some<Vec<T>> { field : this }
}

contract Equatable {
    // *This just becomes void* in the generated C
    fn equalsTo(other : *This) : Bool;
}

// Companion
out module Vec {
    // Introduce the template keyword
    // So we don't have to do <T : Equatable> for all three signatures
    // Reduces duplication
    template T : Equatable {
        out fn remove_by_value(*mut this, value : *T) : Option<T> => {
            index_of(this, value).flat_map(index => this.removeByIndex(index))
        }

        out fn contains(this : *Vec<T>, element : *T) : Bool => index_of(element) is Some;

        out fn index_of(this : *Vec<T>, element : *T) : Option<Vec::Index> => {
            this.iterIndices()
                .filter(index => this.get(index).equalsTo(element))
                .first()
        }
    }
}