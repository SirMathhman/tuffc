"use strict";

// extern from globalThis

// extern from globalThis

// extern from globalThis

// extern from globalThis

// extern from globalThis

// extern from globalThis

// extern from globalThis

// extern from globalThis

// extern from globalThis

// extern fn str_length

// type StrIndex(...) = ...

// extern fn str_char_at

// extern fn str_slice

// extern fn str_concat

// extern fn str_eq

// extern fn str_from_char_code

// extern fn str_index_of

function str_includes(__this_param, needle) {
  let __tuff_this = undefined;
  return ((() => { const __recv = (typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)); const __prop = __recv?.["str_index_of"]; if (typeof __prop === "function") return __prop(needle); const __dyn = __recv?.table?.str_index_of; return __dyn ? __dyn(__recv.ref, needle) : str_index_of(__recv, needle); })() >= 0);
}

function str_starts_with(__this_param, prefix) {
  let __tuff_this = undefined;
  let plen = (() => { const __recv = prefix; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.plen = plen;
  return ((((() => { const __recv = (typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)); const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() < plen)) ? (() => {
    return false;
  })() : (() => {
    return (() => { const __recv = (() => { const __recv = (typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)); const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, plen); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, plen) : str_slice(__recv, 0, plen); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(prefix); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, prefix) : str_eq(__recv, prefix); })();
  })());
}

// extern fn str_trim

// extern fn str_replace_all

// extern fn char_code

// extern fn int_to_string

const __tuff_outer_for_int_to_string_out = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function int_to_string_out(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_int_to_string_out };
  return int_to_string(n);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.int_to_string_out = int_to_string_out;

function str_index_of_out(__this_param, needle) {
  let __tuff_this = undefined;
  return str_index_of((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)), needle);
}

// extern fn parse_int

// extern type StringBuilder

// extern fn sb_new

// extern fn sb_append

// extern fn sb_append_char

// extern fn sb_build

// extern type Vec

// extern fn __vec_new

// extern fn __vec_push

// extern fn __vec_pop

const __tuff_outer_for_vec_new = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function vec_new() {
  let __tuff_this = { this: __tuff_outer_for_vec_new };
  return __vec_new();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.vec_new = vec_new;

function vec_push(__this_param, item) {
  let __tuff_this = undefined;
  return __vec_push((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)), item);
}

function vec_pop(__this_param) {
  let __tuff_this = undefined;
  return __vec_pop((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)));
}

// extern fn __vec_get

function vec_get(__this_param, i) {
  let __tuff_this = undefined;
  return __vec_get((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)), i);
}

// extern fn __vec_set

// extern fn __vec_length

// extern fn __vec_init

// extern fn __vec_capacity

// extern fn __vec_clear

// extern fn __vec_join

// extern fn __vec_includes

function vec_set(__this_param, i, v) {
  let __tuff_this = undefined;
  return __vec_set((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)), i, v);
}

function vec_length(__this_param) {
  let __tuff_this = undefined;
  return (0 + __vec_length((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this))));
}

function vec_init(__this_param) {
  let __tuff_this = undefined;
  return __vec_init((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)));
}

function vec_capacity(__this_param) {
  let __tuff_this = undefined;
  return __vec_capacity((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)));
}

function vec_clear(__this_param) {
  let __tuff_this = undefined;
  return __vec_clear((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)));
}

function vec_join(__this_param, sep) {
  let __tuff_this = undefined;
  return __vec_join((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)), sep);
}

function vec_includes(__this_param, item) {
  let __tuff_this = undefined;
  return __vec_includes((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)), item);
}

// extern type Map

// extern fn __map_new

// extern fn map_set

// extern fn map_get

// extern fn map_has

// extern fn map_delete

const __tuff_outer_for_map_new = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function map_new() {
  let __tuff_this = { this: __tuff_outer_for_map_new };
  return __map_new();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.map_new = map_new;

// extern type Set

// extern fn __set_new

// extern fn set_add

// extern fn set_has

// extern fn set_delete

const __tuff_outer_for_set_new = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function set_new() {
  let __tuff_this = { this: __tuff_outer_for_set_new };
  return __set_new();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.set_new = set_new;

// extern fn read_file

// extern fn write_file

// extern fn path_join

// extern fn path_dirname

// extern fn print

// extern fn print_error

const __tuff_outer_for_print_error_out = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function print_error_out(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_print_error_out };
  return print_error(s);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.print_error_out = print_error_out;

// extern fn panic

// extern fn panic_with_code

// extern fn panic_with_code_loc

// extern fn get_argc

// extern fn get_argv

// extern fn perf_now

const __tuff_outer_for_perf_now_out = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function perf_now_out() {
  let __tuff_this = { this: __tuff_outer_for_perf_now_out };
  return perf_now();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.perf_now_out = perf_now_out;

// extern fn profile_mark

// extern fn profile_take_json

let TK_EOF = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_EOF = TK_EOF;

let TK_KEYWORD = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_KEYWORD = TK_KEYWORD;

let TK_IDENTIFIER = 2; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_IDENTIFIER = TK_IDENTIFIER;

let TK_NUMBER = 3; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_NUMBER = TK_NUMBER;

let TK_STRING = 4; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_STRING = TK_STRING;

let TK_BOOL = 5; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_BOOL = TK_BOOL;

let TK_SYMBOL = 6; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_SYMBOL = TK_SYMBOL;

let TK_CHAR = 7; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_CHAR = TK_CHAR;

let tok_kinds = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tok_kinds = tok_kinds;

let tok_values = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tok_values = tok_values;

let tok_lines = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tok_lines = tok_lines;

let tok_cols = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tok_cols = tok_cols;

let tok_count = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.tok_count = tok_count;

let trivia_records = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.trivia_records = trivia_records;

const __tuff_outer_for_trivia_sep_field = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function trivia_sep_field() {
  let __tuff_this = { this: __tuff_outer_for_trivia_sep_field };
  return "\u001f";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.trivia_sep_field = trivia_sep_field;

const __tuff_outer_for_trivia_sep_record = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function trivia_sep_record() {
  let __tuff_this = { this: __tuff_outer_for_trivia_sep_record };
  return "\u001e";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.trivia_sep_record = trivia_sep_record;

const __tuff_outer_for_trivia_add = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function trivia_add(kind, text, line, col) {
  let __tuff_this = { kind: kind, text: text, line: line, col: col, this: __tuff_outer_for_trivia_add };
  (() => { const __recv = trivia_records; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = kind; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(trivia_sep_field()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, trivia_sep_field()) : str_concat(__recv, trivia_sep_field()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(text); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, text) : str_concat(__recv, text); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(trivia_sep_field()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, trivia_sep_field()) : str_concat(__recv, trivia_sep_field()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(line)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(line)) : str_concat(__recv, int_to_string(line)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(trivia_sep_field()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, trivia_sep_field()) : str_concat(__recv, trivia_sep_field()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(col)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(col)) : str_concat(__recv, int_to_string(col)); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = kind; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(trivia_sep_field()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, trivia_sep_field()) : str_concat(__recv, trivia_sep_field()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(text); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, text) : str_concat(__recv, text); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(trivia_sep_field()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, trivia_sep_field()) : str_concat(__recv, trivia_sep_field()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(line)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(line)) : str_concat(__recv, int_to_string(line)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(trivia_sep_field()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, trivia_sep_field()) : str_concat(__recv, trivia_sep_field()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(col)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(col)) : str_concat(__recv, int_to_string(col)); })()) : vec_push(__recv, (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = kind; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(trivia_sep_field()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, trivia_sep_field()) : str_concat(__recv, trivia_sep_field()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(text); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, text) : str_concat(__recv, text); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(trivia_sep_field()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, trivia_sep_field()) : str_concat(__recv, trivia_sep_field()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(line)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(line)) : str_concat(__recv, int_to_string(line)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(trivia_sep_field()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, trivia_sep_field()) : str_concat(__recv, trivia_sep_field()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(col)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(col)) : str_concat(__recv, int_to_string(col)); })()); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.trivia_add = trivia_add;

const __tuff_outer_for_lex_take_trivia = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_take_trivia() {
  let __tuff_this = { this: __tuff_outer_for_lex_take_trivia };
  let payload = (() => { const __recv = trivia_records; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(trivia_sep_record()); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, trivia_sep_record()) : vec_join(__recv, trivia_sep_record()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.payload = payload;
  (() => { const __recv = trivia_records; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  return payload;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_take_trivia = lex_take_trivia;

const __tuff_outer_for_tok_add = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tok_add(kind, value, line, col) {
  let __tuff_this = { kind: kind, value: value, line: line, col: col, this: __tuff_outer_for_tok_add };
  let idx = tok_count; if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  (() => { const __recv = tok_kinds; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(kind); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, kind) : vec_push(__recv, kind); })();
  (() => { const __recv = tok_values; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, value) : vec_push(__recv, value); })();
  (() => { const __recv = tok_lines; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(line); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, line) : vec_push(__recv, line); })();
  (() => { const __recv = tok_cols; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(col); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, col) : vec_push(__recv, col); })();
  tok_count = (tok_count + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.tok_count = tok_count;
  return idx;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tok_add = tok_add;

const __tuff_outer_for_tok_kind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tok_kind(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_tok_kind };
  return (() => { const __recv = tok_kinds; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tok_kind = tok_kind;

const __tuff_outer_for_tok_value = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tok_value(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_tok_value };
  return (() => { const __recv = tok_values; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tok_value = tok_value;

const __tuff_outer_for_tok_line = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tok_line(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_tok_line };
  return (() => { const __recv = tok_lines; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tok_line = tok_line;

const __tuff_outer_for_tok_col = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tok_col(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_tok_col };
  return (() => { const __recv = tok_cols; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tok_col = tok_col;

let intern_table = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.intern_table = intern_table;

let intern_map = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.intern_map = intern_map;

const __tuff_outer_for_intern = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function intern(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_intern };
  return (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(s); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, s) : map_has(__recv, s); })()) ? (() => {
    return (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(s); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, s) : map_get(__recv, s); })();
  })() : (() => {
    let idx = (() => { const __recv = intern_table; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
    (() => { const __recv = intern_table; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(s); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, s) : vec_push(__recv, s); })();
    (() => { const __recv = intern_map; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(s, idx); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, s, idx) : map_set(__recv, s, idx); })();
    return idx;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.intern = intern;

const __tuff_outer_for_get_intern = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function get_intern(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_get_intern };
  return (() => { const __recv = intern_table; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.get_intern = get_intern;

const __tuff_outer_for_get_interned_str = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function get_interned_str(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_get_interned_str };
  return get_intern(idx);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.get_interned_str = get_interned_str;

let keywords = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.keywords = keywords;

const __tuff_outer_for_init_keywords = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function init_keywords() {
  let __tuff_this = { this: __tuff_outer_for_init_keywords };
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("fn"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "fn") : set_add(__recv, "fn"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("let"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "let") : set_add(__recv, "let"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("struct"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "struct") : set_add(__recv, "struct"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("enum"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "enum") : set_add(__recv, "enum"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("type"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "type") : set_add(__recv, "type"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("match"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "match") : set_add(__recv, "match"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("case"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "case") : set_add(__recv, "case"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("if"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "if") : set_add(__recv, "if"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("else"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "else") : set_add(__recv, "else"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("for"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "for") : set_add(__recv, "for"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("while"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "while") : set_add(__recv, "while"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("loop"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "loop") : set_add(__recv, "loop"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("in"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "in") : set_add(__recv, "in"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("return"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "return") : set_add(__recv, "return"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("break"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "break") : set_add(__recv, "break"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("continue"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "continue") : set_add(__recv, "continue"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("is"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "is") : set_add(__recv, "is"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("class"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "class") : set_add(__recv, "class"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("object"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "object") : set_add(__recv, "object"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("contract"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "contract") : set_add(__recv, "contract"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("impl"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "impl") : set_add(__recv, "impl"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "into") : set_add(__recv, "into"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("with"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "with") : set_add(__recv, "with"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("out"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "out") : set_add(__recv, "out"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("module"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "module") : set_add(__recv, "module"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("extern"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "extern") : set_add(__recv, "extern"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("copy"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "copy") : set_add(__recv, "copy"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("async"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "async") : set_add(__recv, "async"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("mut"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "mut") : set_add(__recv, "mut"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("move"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "move") : set_add(__recv, "move"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("then"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "then") : set_add(__recv, "then"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("lifetime"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "lifetime") : set_add(__recv, "lifetime"); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.init_keywords = init_keywords;

const __tuff_outer_for_is_keyword = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_keyword(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_is_keyword };
  return (() => { const __recv = keywords; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(s); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, s) : set_has(__recv, s); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_keyword = is_keyword;

let lex_source = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.lex_source = lex_source;

let lex_pos = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.lex_pos = lex_pos;

let lex_line = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lex_line = lex_line;

let lex_col = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lex_col = lex_col;

let lex_len = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.lex_len = lex_len;

const __tuff_outer_for_lex_init = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_init(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_lex_init };
  lex_source = source; if (typeof __tuff_this !== 'undefined') __tuff_this.lex_source = lex_source;
  lex_pos = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.lex_pos = lex_pos;
  lex_line = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lex_line = lex_line;
  lex_col = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lex_col = lex_col;
  lex_len = (() => { const __recv = source; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.lex_len = lex_len;
  (() => { const __recv = tok_kinds; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  (() => { const __recv = tok_values; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  (() => { const __recv = tok_lines; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  (() => { const __recv = tok_cols; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  (() => { const __recv = trivia_records; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  tok_count = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.tok_count = tok_count;
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_init = lex_init;

const __tuff_outer_for_lex_peek = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_peek(offset) {
  let __tuff_this = { offset: offset, this: __tuff_outer_for_lex_peek };
  let p = (lex_pos + offset); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  return (((p >= 0)) ? (() => {
    return (((p < (() => { const __recv = lex_source; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })())) ? (() => {
    return (() => { const __recv = lex_source; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(p); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, p) : str_char_at(__recv, p); })();
  })() : (() => {
    return 0;
  })());
  })() : (() => {
    return 0;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_peek = lex_peek;

const __tuff_outer_for_lex_advance = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_advance() {
  let __tuff_this = { this: __tuff_outer_for_lex_advance };
  let ch = lex_peek(0); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  lex_pos = (lex_pos + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.lex_pos = lex_pos;
  return (((ch === 10)) ? (() => {
    lex_line = (lex_line + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.lex_line = lex_line;
    lex_col = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lex_col = lex_col;
    return ch;
  })() : (() => {
    lex_col = (lex_col + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.lex_col = lex_col;
    return ch;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_advance = lex_advance;

const __tuff_outer_for_is_alpha = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_alpha(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_is_alpha };
  return ((((ch >= 65) && (ch <= 90))) ? (() => {
    return true;
  })() : ((((ch >= 97) && (ch <= 122))) ? (() => {
    return true;
  })() : (((ch === 95)) ? (() => {
    return true;
  })() : (() => {
    return false;
  })())));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_alpha = is_alpha;

const __tuff_outer_for_is_digit = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_digit(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_is_digit };
  return ((ch >= 48) && (ch <= 57));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_digit = is_digit;

const __tuff_outer_for_is_alnum = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_alnum(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_is_alnum };
  return (is_alpha(ch) || is_digit(ch));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_alnum = is_alnum;

const __tuff_outer_for_is_whitespace = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_whitespace(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_is_whitespace };
  return ((((ch === 32) || (ch === 9)) || (ch === 13)) || (ch === 10));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_whitespace = is_whitespace;

const __tuff_outer_for_lex_read_ident = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_read_ident() {
  let __tuff_this = { this: __tuff_outer_for_lex_read_ident };
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  while (is_alnum(lex_peek(0))) {
  sb_append_char(sb, lex_advance());
}
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_read_ident = lex_read_ident;

const __tuff_outer_for_lex_read_number = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_read_number() {
  let __tuff_this = { this: __tuff_outer_for_lex_read_number };
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  if ((lex_peek(0) === 48)) {
  let next = lex_peek(1); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((((next === 120) || (next === 98)) || (next === 111))) {
  sb_append_char(sb, lex_advance());
  sb_append_char(sb, lex_advance());
  while ((is_alnum(lex_peek(0)) || (lex_peek(0) === 95))) {
  let ch = lex_advance(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((ch !== 95)) {
  sb_append_char(sb, ch);
}
}
  return sb_build(sb);
}
}
  while ((is_digit(lex_peek(0)) || (lex_peek(0) === 95))) {
  let ch = lex_advance(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((ch !== 95)) {
  sb_append_char(sb, ch);
}
}
  if (((lex_peek(0) === 46) && is_digit(lex_peek(1)))) {
  sb_append_char(sb, lex_advance());
  while ((is_digit(lex_peek(0)) || (lex_peek(0) === 95))) {
  let ch = lex_advance(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((ch !== 95)) {
  sb_append_char(sb, ch);
}
}
}
  while ((is_alnum(lex_peek(0)) || (lex_peek(0) === 95))) {
  let ch = lex_advance(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((ch !== 95)) {
  sb_append_char(sb, ch);
}
}
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_read_number = lex_read_number;

const __tuff_outer_for_lex_read_string = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_read_string() {
  let __tuff_this = { this: __tuff_outer_for_lex_read_string };
  lex_advance();
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  while (((lex_pos < lex_len) && (lex_peek(0) !== 34))) {
  if ((lex_peek(0) === 92)) {
  sb_append_char(sb, lex_advance());
  sb_append_char(sb, lex_advance());
} else {
  sb_append_char(sb, lex_advance());
}
}
  if ((lex_peek(0) !== 34)) {
  panic_with_code("E_LEX_UNTERMINATED_STRING", (() => { const __recv = (() => { const __recv = (() => { const __recv = "Unterminated string literal at "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(lex_line)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(lex_line)) : str_concat(__recv, int_to_string(lex_line)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(lex_col)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(lex_col)) : str_concat(__recv, int_to_string(lex_col)); })(), "The lexer reached end-of-line or end-of-file before finding the closing quote delimiter for this string.", "Close the string with a matching quote delimiter, or escape embedded quotes.");
}
  lex_advance();
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_read_string = lex_read_string;

const __tuff_outer_for_lex_read_char = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_read_char() {
  let __tuff_this = { this: __tuff_outer_for_lex_read_char };
  lex_advance();
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  while (((lex_pos < lex_len) && (lex_peek(0) !== 39))) {
  sb_append_char(sb, lex_advance());
}
  if ((lex_peek(0) !== 39)) {
  panic_with_code("E_LEX_UNTERMINATED_CHAR", (() => { const __recv = (() => { const __recv = (() => { const __recv = "Unterminated char literal at "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(lex_line)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(lex_line)) : str_concat(__recv, int_to_string(lex_line)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(lex_col)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(lex_col)) : str_concat(__recv, int_to_string(lex_col)); })(), "The lexer reached end-of-line or end-of-file before finding the closing apostrophe delimiter for this char literal.", "Close the char literal with a matching apostrophe and ensure only one character (or valid escape) is inside.");
}
  lex_advance();
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_read_char = lex_read_char;

const __tuff_outer_for_lex_check_two = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_check_two(a, b) {
  let __tuff_this = { a: a, b: b, this: __tuff_outer_for_lex_check_two };
  return ((lex_peek(0) === a) && (lex_peek(1) === b));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_check_two = lex_check_two;

const __tuff_outer_for_lex_try_consume_bom = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_try_consume_bom(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_lex_try_consume_bom };
  if (((((lex_pos === 0) && (ch === 239)) && (lex_peek(1) === 187)) && (lex_peek(2) === 191))) {
  lex_advance();
  lex_advance();
  lex_advance();
  return true;
}
  if (((lex_pos === 0) && ((ch === 65279) || (ch === 65534)))) {
  lex_advance();
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_try_consume_bom = lex_try_consume_bom;

const __tuff_outer_for_lex_try_skip_whitespace_or_comment = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_try_skip_whitespace_or_comment(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_lex_try_skip_whitespace_or_comment };
  if (is_whitespace(ch)) {
  lex_advance();
  return true;
}
  if (((ch === 47) && (lex_peek(1) === 47))) {
  let start_line = lex_line; if (typeof __tuff_this !== 'undefined') __tuff_this.start_line = start_line;
  let start_col = lex_col; if (typeof __tuff_this !== 'undefined') __tuff_this.start_col = start_col;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  while (((lex_pos < lex_len) && (lex_peek(0) !== 10))) {
  sb_append_char(sb, lex_advance());
}
  trivia_add("line_comment", sb_build(sb), start_line, start_col);
  return true;
}
  if (((ch === 47) && (lex_peek(1) === 42))) {
  let start_line = lex_line; if (typeof __tuff_this !== 'undefined') __tuff_this.start_line = start_line;
  let start_col = lex_col; if (typeof __tuff_this !== 'undefined') __tuff_this.start_col = start_col;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append_char(sb, lex_advance());
  sb_append_char(sb, lex_advance());
  while (((lex_pos < lex_len) && (!((lex_peek(0) === 42) && (lex_peek(1) === 47))))) {
  sb_append_char(sb, lex_advance());
}
  if ((lex_pos >= lex_len)) {
  panic_with_code("E_LEX_UNTERMINATED_BLOCK_COMMENT", (() => { const __recv = (() => { const __recv = (() => { const __recv = "Unterminated block comment near "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(lex_line)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(lex_line)) : str_concat(__recv, int_to_string(lex_line)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(lex_col)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(lex_col)) : str_concat(__recv, int_to_string(lex_col)); })(), "A block comment started with '/*' but the lexer did not find a matching '*/' before end-of-file.", "Add a closing '*/' for this comment, or remove the unmatched opening '/*'.");
}
  sb_append_char(sb, lex_advance());
  sb_append_char(sb, lex_advance());
  trivia_add("block_comment", sb_build(sb), start_line, start_col);
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_try_skip_whitespace_or_comment = lex_try_skip_whitespace_or_comment;

const __tuff_outer_for_lex_try_emit_three_char_symbol = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_try_emit_three_char_symbol(start_line, start_col) {
  let __tuff_this = { start_line: start_line, start_col: start_col, this: __tuff_outer_for_lex_try_emit_three_char_symbol };
  if ((((lex_peek(0) === 46) && (lex_peek(1) === 46)) && (lex_peek(2) === 46))) {
  lex_advance();
  lex_advance();
  lex_advance();
  tok_add(TK_SYMBOL, intern("..."), start_line, start_col);
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_try_emit_three_char_symbol = lex_try_emit_three_char_symbol;

const __tuff_outer_for_lex_try_emit_two_char_symbol = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_try_emit_two_char_symbol(start_line, start_col) {
  let __tuff_this = { start_line: start_line, start_col: start_col, this: __tuff_outer_for_lex_try_emit_two_char_symbol };
  if (lex_check_two(61, 62)) {
  lex_advance();
  lex_advance();
  tok_add(TK_SYMBOL, intern("=>"), start_line, start_col);
  return true;
}
  if (lex_check_two(61, 61)) {
  lex_advance();
  lex_advance();
  tok_add(TK_SYMBOL, intern("=="), start_line, start_col);
  return true;
}
  if (lex_check_two(33, 61)) {
  lex_advance();
  lex_advance();
  tok_add(TK_SYMBOL, intern("!="), start_line, start_col);
  return true;
}
  if (lex_check_two(60, 61)) {
  lex_advance();
  lex_advance();
  tok_add(TK_SYMBOL, intern("<="), start_line, start_col);
  return true;
}
  if (lex_check_two(62, 61)) {
  lex_advance();
  lex_advance();
  tok_add(TK_SYMBOL, intern(">="), start_line, start_col);
  return true;
}
  if (lex_check_two(38, 38)) {
  lex_advance();
  lex_advance();
  tok_add(TK_SYMBOL, intern("&&"), start_line, start_col);
  return true;
}
  if (lex_check_two(124, 124)) {
  lex_advance();
  lex_advance();
  tok_add(TK_SYMBOL, intern("||"), start_line, start_col);
  return true;
}
  if (lex_check_two(58, 58)) {
  lex_advance();
  lex_advance();
  tok_add(TK_SYMBOL, intern("::"), start_line, start_col);
  return true;
}
  if (lex_check_two(46, 46)) {
  lex_advance();
  lex_advance();
  tok_add(TK_SYMBOL, intern(".."), start_line, start_col);
  return true;
}
  if (lex_check_two(124, 62)) {
  lex_advance();
  lex_advance();
  tok_add(TK_SYMBOL, intern("|>"), start_line, start_col);
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_try_emit_two_char_symbol = lex_try_emit_two_char_symbol;

const __tuff_outer_for_lex_all = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lex_all() {
  let __tuff_this = { this: __tuff_outer_for_lex_all };
  init_keywords();
  while ((lex_pos < lex_len)) {
  let ch = lex_peek(0); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((lex_try_consume_bom(ch) || lex_try_skip_whitespace_or_comment(ch))) {
  continue;
}
  let start_line = lex_line; if (typeof __tuff_this !== 'undefined') __tuff_this.start_line = start_line;
  let start_col = lex_col; if (typeof __tuff_this !== 'undefined') __tuff_this.start_col = start_col;
  if ((lex_try_emit_three_char_symbol(start_line, start_col) || lex_try_emit_two_char_symbol(start_line, start_col))) {
  continue;
}
  if (is_alpha(ch)) {
  let text = lex_read_ident(); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  if ((() => { const __recv = text; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("true"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "true") : str_eq(__recv, "true"); })()) {
  tok_add(TK_BOOL, 1, start_line, start_col);
} else { if ((() => { const __recv = text; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("false"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "false") : str_eq(__recv, "false"); })()) {
  tok_add(TK_BOOL, 0, start_line, start_col);
} else { if (is_keyword(text)) {
  tok_add(TK_KEYWORD, intern(text), start_line, start_col);
} else {
  tok_add(TK_IDENTIFIER, intern(text), start_line, start_col);
} } }
  continue;
}
  if (is_digit(ch)) {
  let text = lex_read_number(); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  tok_add(TK_NUMBER, intern(text), start_line, start_col);
  continue;
}
  if ((ch === 34)) {
  let text = lex_read_string(); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  tok_add(TK_STRING, intern(text), start_line, start_col);
  continue;
}
  if ((ch === 39)) {
  let text = lex_read_char(); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  tok_add(TK_CHAR, intern(text), start_line, start_col);
  continue;
}
  let sym_text = str_from_char_code(ch); if (typeof __tuff_this !== 'undefined') __tuff_this.sym_text = sym_text;
  if ((((() => { const __recv = sym_text; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() === 1) && (() => { const __recv = "(){}[],:;+-*/%<>=.!?|&"; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop(sym_text); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, sym_text) : str_includes(__recv, sym_text); })())) {
  lex_advance();
  tok_add(TK_SYMBOL, intern(sym_text), start_line, start_col);
  continue;
}
  let display_char = sym_text; if (typeof __tuff_this !== 'undefined') __tuff_this.display_char = display_char;
  if (((() => { const __recv = display_char; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() === 0)) {
  display_char = "<non-printable>"; if (typeof __tuff_this !== 'undefined') __tuff_this.display_char = display_char;
}
  panic_with_code("E_LEX_UNEXPECTED_CHARACTER", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Unexpected character '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(display_char); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, display_char) : str_concat(__recv, display_char); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' (code "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' (code ") : str_concat(__recv, "' (code "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(ch)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(ch)) : str_concat(__recv, int_to_string(ch)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") at "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") at ") : str_concat(__recv, ") at "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(start_line)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(start_line)) : str_concat(__recv, int_to_string(start_line)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(start_col)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(start_col)) : str_concat(__recv, int_to_string(start_col)); })(), "This character is not valid in the current lexical context and cannot be tokenized as part of Tuff syntax.", "Remove/replace the character, save source as UTF-8 without BOM, and use only supported symbols/identifiers in source text.");
}
  tok_add(TK_EOF, intern("<eof>"), lex_line, lex_col);
  return tok_count;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lex_all = lex_all;

const __tuff_outer_for_count_effective_token_lines = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function count_effective_token_lines() {
  let __tuff_this = { this: __tuff_outer_for_count_effective_token_lines };
  let seen = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.seen = seen;
  let count = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < tok_count)) {
  if ((tok_kind(i) !== TK_EOF)) {
  let line = (() => { const __recv = tok_lines; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.line = line;
  if ((!(() => { const __recv = seen; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(line); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, line) : map_has(__recv, line); })())) {
  (() => { const __recv = seen; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(line, 1); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, line, 1) : map_set(__recv, line, 1); })();
  count = (count + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return count;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.count_effective_token_lines = count_effective_token_lines;

const __tuff_outer_for_lint_effective_line_count = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_effective_line_count() {
  let __tuff_this = { this: __tuff_outer_for_lint_effective_line_count };
  return count_effective_token_lines();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_effective_line_count = lint_effective_line_count;

const __tuff_outer_for_lint_assert_file_length = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_assert_file_length(filePath, maxEffectiveLines) {
  let __tuff_this = { filePath: filePath, maxEffectiveLines: maxEffectiveLines, this: __tuff_outer_for_lint_assert_file_length };
  let count = count_effective_token_lines(); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  if ((count > maxEffectiveLines)) {
  panic_with_code("E_LINT_FILE_TOO_LONG", (() => { const __recv = (() => { const __recv = "File exceeds "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(maxEffectiveLines)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(maxEffectiveLines)) : str_concat(__recv, int_to_string(maxEffectiveLines)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = " effective lines ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(count)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(count)) : str_concat(__recv, int_to_string(count)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = " effective lines ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(count)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(count)) : str_concat(__recv, int_to_string(count)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })()) : str_concat(__recv, (() => { const __recv = (() => { const __recv = " effective lines ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(count)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(count)) : str_concat(__recv, int_to_string(count)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })()); })(), "Large files are harder to review and maintain; this file exceeds the maximum effective line budget after excluding comments and blank lines.", (() => { const __recv = (() => { const __recv = "Split this file into smaller modules so each file has at most "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(maxEffectiveLines)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(maxEffectiveLines)) : str_concat(__recv, int_to_string(maxEffectiveLines)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" non-comment, non-whitespace lines."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " non-comment, non-whitespace lines.") : str_concat(__recv, " non-comment, non-whitespace lines."); })());
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_assert_file_length = lint_assert_file_length;

const __tuff_outer_for_selfhost_runtime_lexer_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_runtime_lexer_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_runtime_lexer_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_runtime_lexer_marker = selfhost_runtime_lexer_marker;

let NK_PROGRAM = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_PROGRAM = NK_PROGRAM;

let NK_FN_DECL = 2; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_FN_DECL = NK_FN_DECL;

let NK_STRUCT_DECL = 3; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_STRUCT_DECL = NK_STRUCT_DECL;

let NK_TYPE_ALIAS = 4; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_TYPE_ALIAS = NK_TYPE_ALIAS;

let NK_LET_DECL = 5; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_LET_DECL = NK_LET_DECL;

let NK_IMPORT_DECL = 6; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_IMPORT_DECL = NK_IMPORT_DECL;

let NK_EXPR_STMT = 7; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_EXPR_STMT = NK_EXPR_STMT;

let NK_RETURN_STMT = 8; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_RETURN_STMT = NK_RETURN_STMT;

let NK_IF_STMT = 9; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_IF_STMT = NK_IF_STMT;

let NK_WHILE_STMT = 10; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_WHILE_STMT = NK_WHILE_STMT;

let NK_FOR_STMT = 11; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_FOR_STMT = NK_FOR_STMT;

let NK_BLOCK = 12; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_BLOCK = NK_BLOCK;

let NK_ASSIGN_STMT = 13; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_ASSIGN_STMT = NK_ASSIGN_STMT;

let NK_BREAK_STMT = 14; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_BREAK_STMT = NK_BREAK_STMT;

let NK_CONTINUE_STMT = 15; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_CONTINUE_STMT = NK_CONTINUE_STMT;

let NK_CLASS_FN_DECL = 16; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_CLASS_FN_DECL = NK_CLASS_FN_DECL;

let NK_EXTERN_LET_DECL = 18; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_EXTERN_LET_DECL = NK_EXTERN_LET_DECL;

let NK_EXTERN_TYPE_DECL = 19; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_EXTERN_TYPE_DECL = NK_EXTERN_TYPE_DECL;

let NK_EXPECT_FN_DECL = 61; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_EXPECT_FN_DECL = NK_EXPECT_FN_DECL;

let NK_ACTUAL_FN_DECL = 62; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_ACTUAL_FN_DECL = NK_ACTUAL_FN_DECL;

let NK_OBJECT_DECL = 63; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_OBJECT_DECL = NK_OBJECT_DECL;

let NK_LOOP_STMT = 64; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_LOOP_STMT = NK_LOOP_STMT;

let NK_CONTRACT_DECL = 65; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_CONTRACT_DECL = NK_CONTRACT_DECL;

let NK_INTO_STMT = 66; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_INTO_STMT = NK_INTO_STMT;

let NK_LIFETIME_STMT = 67; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_LIFETIME_STMT = NK_LIFETIME_STMT;

let NK_STMT_LIST = 68; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_STMT_LIST = NK_STMT_LIST;

let NK_EXTERN_IMPORT_DECL = 69; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_EXTERN_IMPORT_DECL = NK_EXTERN_IMPORT_DECL;

let NK_ENUM_DECL = 60; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_ENUM_DECL = NK_ENUM_DECL;

let NK_DEP_TYPE_ALIAS = 70; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_DEP_TYPE_ALIAS = NK_DEP_TYPE_ALIAS;

let NK_APPLIED_TYPE = 71; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_APPLIED_TYPE = NK_APPLIED_TYPE;

let NK_NUMBER_LIT = 20; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_NUMBER_LIT = NK_NUMBER_LIT;

let NK_BOOL_LIT = 21; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_BOOL_LIT = NK_BOOL_LIT;

let NK_STRING_LIT = 22; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_STRING_LIT = NK_STRING_LIT;

let NK_CHAR_LIT = 23; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_CHAR_LIT = NK_CHAR_LIT;

let NK_IDENTIFIER = 24; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_IDENTIFIER = NK_IDENTIFIER;

let NK_BINARY_EXPR = 25; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_BINARY_EXPR = NK_BINARY_EXPR;

let NK_UNARY_EXPR = 26; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_UNARY_EXPR = NK_UNARY_EXPR;

let NK_CALL_EXPR = 27; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_CALL_EXPR = NK_CALL_EXPR;

let NK_MEMBER_EXPR = 28; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_MEMBER_EXPR = NK_MEMBER_EXPR;

let NK_INDEX_EXPR = 29; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_INDEX_EXPR = NK_INDEX_EXPR;

let NK_STRUCT_INIT = 30; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_STRUCT_INIT = NK_STRUCT_INIT;

let NK_IF_EXPR = 31; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_IF_EXPR = NK_IF_EXPR;

let NK_MATCH_EXPR = 32; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_MATCH_EXPR = NK_MATCH_EXPR;

let NK_IS_EXPR = 33; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_IS_EXPR = NK_IS_EXPR;

let NK_UNWRAP_EXPR = 34; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_UNWRAP_EXPR = NK_UNWRAP_EXPR;

let NK_LAMBDA_EXPR = 35; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_LAMBDA_EXPR = NK_LAMBDA_EXPR;

let NK_FN_EXPR = 36; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_FN_EXPR = NK_FN_EXPR;

let NK_TUPLE_EXPR = 37; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_TUPLE_EXPR = NK_TUPLE_EXPR;

let NK_NAMED_TYPE = 40; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_NAMED_TYPE = NK_NAMED_TYPE;

let NK_POINTER_TYPE = 41; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_POINTER_TYPE = NK_POINTER_TYPE;

let NK_ARRAY_TYPE = 42; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_ARRAY_TYPE = NK_ARRAY_TYPE;

let NK_TUPLE_TYPE = 43; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_TUPLE_TYPE = NK_TUPLE_TYPE;

let NK_REFINEMENT_TYPE = 44; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_REFINEMENT_TYPE = NK_REFINEMENT_TYPE;

let NK_UNION_TYPE = 45; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_UNION_TYPE = NK_UNION_TYPE;

let NK_FUNCTION_TYPE = 46; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_FUNCTION_TYPE = NK_FUNCTION_TYPE;

let NK_WILDCARD_PAT = 50; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_WILDCARD_PAT = NK_WILDCARD_PAT;

let NK_LITERAL_PAT = 51; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_LITERAL_PAT = NK_LITERAL_PAT;

let NK_NAME_PAT = 52; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_NAME_PAT = NK_NAME_PAT;

let NK_STRUCT_PAT = 53; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_STRUCT_PAT = NK_STRUCT_PAT;

const __tuff_outer_for_selfhost_parser_kinds_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_parser_kinds_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_parser_kinds_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_parser_kinds_marker = selfhost_parser_kinds_marker;

let node_kinds = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.node_kinds = node_kinds;

let node_data1 = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.node_data1 = node_data1;

let node_data2 = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.node_data2 = node_data2;

let node_data3 = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.node_data3 = node_data3;

let node_data4 = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.node_data4 = node_data4;

let node_data5 = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.node_data5 = node_data5;

let node_toks = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.node_toks = node_toks;

let node_count = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.node_count = node_count;

const __tuff_outer_for_node_new = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_new(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_node_new };
  let idx = node_count; if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  (() => { const __recv = node_kinds; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(kind); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, kind) : vec_push(__recv, kind); })();
  (() => { const __recv = node_data1; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  (() => { const __recv = node_data2; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  (() => { const __recv = node_data3; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  (() => { const __recv = node_data4; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  (() => { const __recv = node_data5; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  (() => { const __recv = node_toks; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(parse_pos); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, parse_pos) : vec_push(__recv, parse_pos); })();
  node_count = (node_count + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.node_count = node_count;
  return idx;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_new = node_new;

const __tuff_outer_for_node_kind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_kind(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_node_kind };
  return (() => { const __recv = node_kinds; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_kind = node_kind;

const __tuff_outer_for_node_set_data1 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_set_data1(idx, v) {
  let __tuff_this = { idx: idx, v: v, this: __tuff_outer_for_node_set_data1 };
  (() => { const __recv = node_data1; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(idx, v); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, idx, v) : vec_set(__recv, idx, v); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_set_data1 = node_set_data1;

const __tuff_outer_for_node_set_data2 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_set_data2(idx, v) {
  let __tuff_this = { idx: idx, v: v, this: __tuff_outer_for_node_set_data2 };
  (() => { const __recv = node_data2; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(idx, v); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, idx, v) : vec_set(__recv, idx, v); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_set_data2 = node_set_data2;

const __tuff_outer_for_node_set_data3 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_set_data3(idx, v) {
  let __tuff_this = { idx: idx, v: v, this: __tuff_outer_for_node_set_data3 };
  (() => { const __recv = node_data3; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(idx, v); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, idx, v) : vec_set(__recv, idx, v); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_set_data3 = node_set_data3;

const __tuff_outer_for_node_set_data4 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_set_data4(idx, v) {
  let __tuff_this = { idx: idx, v: v, this: __tuff_outer_for_node_set_data4 };
  (() => { const __recv = node_data4; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(idx, v); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, idx, v) : vec_set(__recv, idx, v); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_set_data4 = node_set_data4;

const __tuff_outer_for_node_set_data5 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_set_data5(idx, v) {
  let __tuff_this = { idx: idx, v: v, this: __tuff_outer_for_node_set_data5 };
  (() => { const __recv = node_data5; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(idx, v); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, idx, v) : vec_set(__recv, idx, v); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_set_data5 = node_set_data5;

const __tuff_outer_for_node_get_data1 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_get_data1(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_node_get_data1 };
  return (() => { const __recv = node_data1; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_get_data1 = node_get_data1;

const __tuff_outer_for_node_get_data2 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_get_data2(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_node_get_data2 };
  return (() => { const __recv = node_data2; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_get_data2 = node_get_data2;

const __tuff_outer_for_node_get_data3 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_get_data3(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_node_get_data3 };
  return (() => { const __recv = node_data3; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_get_data3 = node_get_data3;

const __tuff_outer_for_node_get_data4 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_get_data4(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_node_get_data4 };
  return (() => { const __recv = node_data4; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_get_data4 = node_get_data4;

const __tuff_outer_for_node_get_data5 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_get_data5(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_node_get_data5 };
  return (() => { const __recv = node_data5; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_get_data5 = node_get_data5;

const __tuff_outer_for_node_get_line = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_get_line(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_node_get_line };
  return tok_line((() => { const __recv = node_toks; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_get_line = node_get_line;

const __tuff_outer_for_node_get_col = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function node_get_col(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_node_get_col };
  return tok_col((() => { const __recv = node_toks; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, idx) : vec_get(__recv, idx); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.node_get_col = node_get_col;

let parse_pos = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.parse_pos = parse_pos;

let parse_exports = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.parse_exports = parse_exports;

const __tuff_outer_for_parse_init = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function parse_init() {
  let __tuff_this = { this: __tuff_outer_for_parse_init };
  parse_pos = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.parse_pos = parse_pos;
  parse_exports = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.parse_exports = parse_exports;
  (() => { const __recv = node_kinds; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  (() => { const __recv = node_data1; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  (() => { const __recv = node_data2; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  (() => { const __recv = node_data3; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  (() => { const __recv = node_data4; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  (() => { const __recv = node_data5; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  (() => { const __recv = node_toks; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  (() => { const __recv = node_kinds; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  (() => { const __recv = node_data1; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  (() => { const __recv = node_data2; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  (() => { const __recv = node_data3; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  (() => { const __recv = node_data4; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  (() => { const __recv = node_data5; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  (() => { const __recv = node_toks; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  node_count = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.node_count = node_count;
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.parse_init = parse_init;

const __tuff_outer_for_p_peek = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_peek(offset) {
  let __tuff_this = { offset: offset, this: __tuff_outer_for_p_peek };
  let idx = (parse_pos + offset); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  return (((idx >= tok_count)) ? (() => {
    return (tok_count - 1);
  })() : (() => {
    return idx;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_peek = p_peek;

const __tuff_outer_for_p_mark = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_mark() {
  let __tuff_this = { this: __tuff_outer_for_p_mark };
  return parse_pos;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_mark = p_mark;

const __tuff_outer_for_p_restore = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_restore(mark) {
  let __tuff_this = { mark: mark, this: __tuff_outer_for_p_restore };
  parse_pos = mark; if (typeof __tuff_this !== 'undefined') __tuff_this.parse_pos = parse_pos;
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_restore = p_restore;

const __tuff_outer_for_p_at_kind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_at_kind(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_p_at_kind };
  return (tok_kind(p_peek(0)) === kind);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_at_kind = p_at_kind;

const __tuff_outer_for_p_at_value = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_at_value(val) {
  let __tuff_this = { val: val, this: __tuff_outer_for_p_at_value };
  let v = tok_value(p_peek(0)); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  return ((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(val); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, val) : map_has(__recv, val); })() && ((() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(val); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, val) : map_get(__recv, val); })() === v));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_at_value = p_at_value;

const __tuff_outer_for_p_at = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_at(kind, val) {
  let __tuff_this = { kind: kind, val: val, this: __tuff_outer_for_p_at };
  return (p_at_kind(kind) && p_at_value(val));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_at = p_at;

const __tuff_outer_for_p_eat = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_eat() {
  let __tuff_this = { this: __tuff_outer_for_p_eat };
  let t = p_peek(0); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  parse_pos = (parse_pos + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.parse_pos = parse_pos;
  return t;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_eat = p_eat;

const __tuff_outer_for_p_token_kind_name = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_token_kind_name(knd) {
  let __tuff_this = { knd: knd, this: __tuff_outer_for_p_token_kind_name };
  if ((knd === TK_EOF)) {
  return "eof";
}
  if ((knd === TK_KEYWORD)) {
  return "keyword";
}
  if ((knd === TK_IDENTIFIER)) {
  return "identifier";
}
  if ((knd === TK_NUMBER)) {
  return "number";
}
  if ((knd === TK_STRING)) {
  return "string";
}
  if ((knd === TK_BOOL)) {
  return "bool";
}
  if ((knd === TK_SYMBOL)) {
  return "symbol";
}
  if ((knd === TK_CHAR)) {
  return "char";
}
  return "token";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_token_kind_name = p_token_kind_name;

const __tuff_outer_for_p_token_value_for_error = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_token_value_for_error(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_p_token_value_for_error };
  let knd = tok_kind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.knd = knd;
  if ((knd === TK_BOOL)) {
  if ((tok_value(t) === 0)) {
  return "false";
}
  return "true";
}
  if ((((((((knd === TK_KEYWORD) || (knd === TK_IDENTIFIER)) || (knd === TK_NUMBER)) || (knd === TK_STRING)) || (knd === TK_SYMBOL)) || (knd === TK_CHAR)) || (knd === TK_EOF))) {
  let raw = get_intern(tok_value(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.raw = raw;
  if (((knd === TK_SYMBOL) && ((() => { const __recv = raw; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() === 0))) {
  return "<empty-symbol>";
}
  return raw;
}
  return "<unknown>";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_token_value_for_error = p_token_value_for_error;

const __tuff_outer_for_p_token_debug_at = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_token_debug_at(i) {
  let __tuff_this = { i: i, this: __tuff_outer_for_p_token_debug_at };
  if (((i < 0) || (i >= tok_count))) {
  return "<none>";
}
  let kname = p_token_kind_name(tok_kind(i)); if (typeof __tuff_this !== 'undefined') __tuff_this.kname = kname;
  let val = p_token_value_for_error(i); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  let line = int_to_string(tok_line(i)); if (typeof __tuff_this !== 'undefined') __tuff_this.line = line;
  let col = int_to_string(tok_col(i)); if (typeof __tuff_this !== 'undefined') __tuff_this.col = col;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = kname; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(val); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, val) : str_concat(__recv, val); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" @"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " @") : str_concat(__recv, " @"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(line); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, line) : str_concat(__recv, line); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(col); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, col) : str_concat(__recv, col); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_token_debug_at = p_token_debug_at;

const __tuff_outer_for_p_error_with_token_context = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_error_with_token_context(msg) {
  let __tuff_this = { msg: msg, this: __tuff_outer_for_p_error_with_token_context };
  let t = p_peek(0); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let cur_idx = t; if (typeof __tuff_this !== 'undefined') __tuff_this.cur_idx = cur_idx;
  let prev_idx = (parse_pos - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.prev_idx = prev_idx;
  let next_idx = (parse_pos + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.next_idx = next_idx;
  let found_kind = p_token_kind_name(tok_kind(cur_idx)); if (typeof __tuff_this !== 'undefined') __tuff_this.found_kind = found_kind;
  let value = p_token_value_for_error(cur_idx); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  let line = int_to_string(tok_line(cur_idx)); if (typeof __tuff_this !== 'undefined') __tuff_this.line = line;
  let col = int_to_string(tok_col(cur_idx)); if (typeof __tuff_this !== 'undefined') __tuff_this.col = col;
  let prev_tok = p_token_debug_at(prev_idx); if (typeof __tuff_this !== 'undefined') __tuff_this.prev_tok = prev_tok;
  let cur_tok = p_token_debug_at(cur_idx); if (typeof __tuff_this !== 'undefined') __tuff_this.cur_tok = cur_tok;
  let next_tok = p_token_debug_at(next_idx); if (typeof __tuff_this !== 'undefined') __tuff_this.next_tok = next_tok;
  panic((() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = msg; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" (found "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " (found ") : str_concat(__recv, " (found "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(found_kind); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, found_kind) : str_concat(__recv, found_kind); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, value) : str_concat(__recv, value); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" at "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " at ") : str_concat(__recv, " at "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(line); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, line) : str_concat(__recv, line); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(col); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, col) : str_concat(__recv, col); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; context: [prev="); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; context: [prev=") : str_concat(__recv, "; context: [prev="); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prev_tok); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prev_tok) : str_concat(__recv, prev_tok); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(", current="); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ", current=") : str_concat(__recv, ", current="); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cur_tok); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cur_tok) : str_concat(__recv, cur_tok); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(", next="); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ", next=") : str_concat(__recv, ", next="); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(next_tok); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, next_tok) : str_concat(__recv, next_tok); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "]") : str_concat(__recv, "]"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })());
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_error_with_token_context = p_error_with_token_context;

const __tuff_outer_for_p_expect_kind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_expect_kind(kind, msg) {
  let __tuff_this = { kind: kind, msg: msg, this: __tuff_outer_for_p_expect_kind };
  if ((!p_at_kind(kind))) {
  p_error_with_token_context(msg);
}
  return p_eat();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_expect_kind = p_expect_kind;

const __tuff_outer_for_p_expect = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_expect(kind, val, msg) {
  let __tuff_this = { kind: kind, val: val, msg: msg, this: __tuff_outer_for_p_expect };
  if ((!p_at(kind, val))) {
  p_error_with_token_context(msg);
}
  return p_eat();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_expect = p_expect;

const __tuff_outer_for_p_parse_identifier = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_identifier() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_identifier };
  let t = p_expect_kind(TK_IDENTIFIER, "Expected identifier"); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  return tok_value(t);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_identifier = p_parse_identifier;

const __tuff_outer_for_p_can_start_type_tok = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_can_start_type_tok() {
  let __tuff_this = { this: __tuff_outer_for_p_can_start_type_tok };
  if (p_at_kind(TK_IDENTIFIER)) {
  return true;
}
  if (p_at(TK_SYMBOL, "*")) {
  return true;
}
  if (p_at(TK_SYMBOL, "[")) {
  return true;
}
  if (p_at(TK_SYMBOL, "(")) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_can_start_type_tok = p_can_start_type_tok;

const __tuff_outer_for_p_can_start_type_tok_at = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_can_start_type_tok_at(offset) {
  let __tuff_this = { offset: offset, this: __tuff_outer_for_p_can_start_type_tok_at };
  let idx = p_peek(offset); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  let k = tok_kind(idx); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === TK_IDENTIFIER)) {
  return true;
}
  if ((k === TK_SYMBOL)) {
  let s = get_intern(tok_value(idx)); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  if ((((() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "*") : str_eq(__recv, "*"); })() || (() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("["); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "[") : str_eq(__recv, "["); })()) || (() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "(") : str_eq(__recv, "("); })())) {
  return true;
}
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_can_start_type_tok_at = p_can_start_type_tok_at;

const __tuff_outer_for_p_can_start_type_after_lifetime_tok_at = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_can_start_type_after_lifetime_tok_at(offset) {
  let __tuff_this = { offset: offset, this: __tuff_outer_for_p_can_start_type_after_lifetime_tok_at };
  let idx = p_peek(offset); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  let k = tok_kind(idx); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === TK_IDENTIFIER)) {
  return true;
}
  if ((k === TK_SYMBOL)) {
  let s = get_intern(tok_value(idx)); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  if ((((() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "*") : str_eq(__recv, "*"); })() || (() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("["); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "[") : str_eq(__recv, "["); })()) || (() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "(") : str_eq(__recv, "("); })())) {
  return true;
}
}
  if ((k === TK_KEYWORD)) {
  let kw = get_intern(tok_value(idx)); if (typeof __tuff_this !== 'undefined') __tuff_this.kw = kw;
  if (((((() => { const __recv = kw; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("mut"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "mut") : str_eq(__recv, "mut"); })() || (() => { const __recv = kw; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("move"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "move") : str_eq(__recv, "move"); })()) || (() => { const __recv = kw; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("out"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "out") : str_eq(__recv, "out"); })()) || (() => { const __recv = kw; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("uninit"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "uninit") : str_eq(__recv, "uninit"); })())) {
  return true;
}
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_can_start_type_after_lifetime_tok_at = p_can_start_type_after_lifetime_tok_at;

const __tuff_outer_for_p_can_start_refinement_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_can_start_refinement_expr() {
  let __tuff_this = { this: __tuff_outer_for_p_can_start_refinement_expr };
  if (p_at_kind(TK_NUMBER)) {
  return true;
}
  if (p_at_kind(TK_IDENTIFIER)) {
  return true;
}
  if (p_at_kind(TK_BOOL)) {
  return true;
}
  if (p_at_kind(TK_STRING)) {
  return true;
}
  if (p_at(TK_SYMBOL, "(")) {
  return true;
}
  if (p_at(TK_SYMBOL, "-")) {
  return true;
}
  if (p_at(TK_SYMBOL, "!")) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_can_start_refinement_expr = p_can_start_refinement_expr;

const __tuff_outer_for_p_can_start_refinement_expr_at = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_can_start_refinement_expr_at(offset) {
  let __tuff_this = { offset: offset, this: __tuff_outer_for_p_can_start_refinement_expr_at };
  let idx = p_peek(offset); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  let k = tok_kind(idx); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((((((k === TK_NUMBER) || (k === TK_IDENTIFIER)) || (k === TK_BOOL)) || (k === TK_STRING)) || (k === TK_CHAR))) {
  return true;
}
  if ((k === TK_SYMBOL)) {
  let s = get_intern(tok_value(idx)); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  if ((((() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "(") : str_eq(__recv, "("); })() || (() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "-") : str_eq(__recv, "-"); })()) || (() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("!"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "!") : str_eq(__recv, "!"); })())) {
  return true;
}
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_can_start_refinement_expr_at = p_can_start_refinement_expr_at;

const __tuff_outer_for_p_parse_type_primary_pointer = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_type_primary_pointer() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_type_primary_pointer };
  p_eat();
  let mutable = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.mutable = mutable;
  let move_ptr = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.move_ptr = move_ptr;
  let life_name = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.life_name = life_name;
  let progressed = true; if (typeof __tuff_this !== 'undefined') __tuff_this.progressed = progressed;
  while (progressed) {
  progressed = false; if (typeof __tuff_this !== 'undefined') __tuff_this.progressed = progressed;
  if (((mutable === 0) && p_at(TK_KEYWORD, "mut"))) {
  p_eat();
  mutable = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.mutable = mutable;
  progressed = true; if (typeof __tuff_this !== 'undefined') __tuff_this.progressed = progressed;
} else { if (((move_ptr === 0) && p_at(TK_KEYWORD, "move"))) {
  p_eat();
  move_ptr = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.move_ptr = move_ptr;
  progressed = true; if (typeof __tuff_this !== 'undefined') __tuff_this.progressed = progressed;
} else { if ((((life_name === 0) && p_at_kind(TK_IDENTIFIER)) && p_can_start_type_after_lifetime_tok_at(1))) {
  life_name = tok_value(p_eat()); if (typeof __tuff_this !== 'undefined') __tuff_this.life_name = life_name;
  progressed = true; if (typeof __tuff_this !== 'undefined') __tuff_this.progressed = progressed;
} } }
}
  let inner = p_parse_type_primary(); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let node = node_new(NK_POINTER_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, mutable);
  node_set_data2(node, inner);
  node_set_data3(node, move_ptr);
  node_set_data4(node, life_name);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_type_primary_pointer = p_parse_type_primary_pointer;

const __tuff_outer_for_p_parse_type_primary_array = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_type_primary_array() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_type_primary_array };
  p_eat();
  let elem = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.elem = elem;
  let init = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.init = init;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
  init = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.init = init;
  p_expect(TK_SYMBOL, ";", "Expected ';' in array type");
  total = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  p_expect(TK_SYMBOL, "]", "Expected ']'");
  let node = node_new(NK_ARRAY_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, elem);
  node_set_data2(node, init);
  node_set_data3(node, total);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_type_primary_array = p_parse_type_primary_array;

const __tuff_outer_for_p_try_skip_named_tuple_member_label = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_try_skip_named_tuple_member_label() {
  let __tuff_this = { this: __tuff_outer_for_p_try_skip_named_tuple_member_label };
  if (((tok_kind(p_peek(0)) === TK_IDENTIFIER) && (tok_kind(p_peek(1)) === TK_SYMBOL))) {
  let sym = get_intern(tok_value(p_peek(1))); if (typeof __tuff_this !== 'undefined') __tuff_this.sym = sym;
  if ((() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ":") : str_eq(__recv, ":"); })()) {
  p_eat();
  p_eat();
}
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_try_skip_named_tuple_member_label = p_try_skip_named_tuple_member_label;

const __tuff_outer_for_p_parse_type_primary_tuple_or_fn = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_type_primary_tuple_or_fn() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_type_primary_tuple_or_fn };
  p_eat();
  let members = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.members = members;
  if ((!p_at(TK_SYMBOL, ")"))) {
  p_try_skip_named_tuple_member_label();
  (() => { const __recv = members; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_type()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_type()) : vec_push(__recv, p_parse_type()); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  p_try_skip_named_tuple_member_label();
  (() => { const __recv = members; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_type()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_type()) : vec_push(__recv, p_parse_type()); })();
}
}
  p_expect(TK_SYMBOL, ")", "Expected ')' in tuple type");
  if (p_at(TK_SYMBOL, "=>")) {
  p_eat();
  let ret = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
  let fnty = node_new(NK_FUNCTION_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.fnty = fnty;
  node_set_data1(fnty, members);
  node_set_data2(fnty, ret);
  return fnty;
}
  let node = node_new(NK_TUPLE_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, members);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_type_primary_tuple_or_fn = p_parse_type_primary_tuple_or_fn;

const __tuff_outer_for_p_parse_type_primary_numeric_sentinel = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_type_primary_numeric_sentinel() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_type_primary_numeric_sentinel };
  let t = p_eat(); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let raw = get_intern(tok_value(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.raw = raw;
  if ((!((() => { const __recv = raw; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("0USize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "0USize") : str_eq(__recv, "0USize"); })() || (() => { const __recv = raw; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("0"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "0") : str_eq(__recv, "0"); })()))) {
  panic("Only 0 or 0USize is supported as a type-level numeric sentinel");
}
  let base = node_new(NK_NAMED_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  node_set_data1(base, intern("USize"));
  node_set_data2(base, vec_new());
  let lit = node_new(NK_NUMBER_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.lit = lit;
  node_set_data1(lit, tok_value(t));
  let refine = node_new(NK_REFINEMENT_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.refine = refine;
  node_set_data1(refine, base);
  node_set_data2(refine, intern("=="));
  node_set_data3(refine, lit);
  return refine;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_type_primary_numeric_sentinel = p_parse_type_primary_numeric_sentinel;

const __tuff_outer_for_p_parse_type_primary_named_or_applied = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_type_primary_named_or_applied() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_type_primary_named_or_applied };
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let generics = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  while (p_at(TK_SYMBOL, "::")) {
  p_eat();
  p_parse_identifier();
}
  let would_be_member_refine = false; if (typeof __tuff_this !== 'undefined') __tuff_this.would_be_member_refine = would_be_member_refine;
  if (p_at(TK_SYMBOL, "<")) {
  let k1 = tok_kind(p_peek(1)); if (typeof __tuff_this !== 'undefined') __tuff_this.k1 = k1;
  let k2 = tok_kind(p_peek(2)); if (typeof __tuff_this !== 'undefined') __tuff_this.k2 = k2;
  if (((k1 === TK_IDENTIFIER) && (k2 === TK_SYMBOL))) {
  let s2 = get_intern(tok_value(p_peek(2))); if (typeof __tuff_this !== 'undefined') __tuff_this.s2 = s2;
  if (((() => { const __recv = s2; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ".") : str_eq(__recv, "."); })() || (() => { const __recv = s2; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "(") : str_eq(__recv, "("); })())) {
  would_be_member_refine = true; if (typeof __tuff_this !== 'undefined') __tuff_this.would_be_member_refine = would_be_member_refine;
}
}
}
  if (((p_at(TK_SYMBOL, "<") && p_can_start_type_tok_at(1)) && (!would_be_member_refine))) {
  p_eat();
  if ((!p_at(TK_SYMBOL, ">"))) {
  (() => { const __recv = generics; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_type()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_type()) : vec_push(__recv, p_parse_type()); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = generics; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_type()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_type()) : vec_push(__recv, p_parse_type()); })();
}
}
  p_expect(TK_SYMBOL, ">", "Expected '>' in generic args");
}
  let type_node = node_new(NK_NAMED_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.type_node = type_node;
  node_set_data1(type_node, name);
  node_set_data2(type_node, generics);
  if ((p_at(TK_SYMBOL, "(") && ((() => { const __recv = generics; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 0))) {
  p_eat();
  let args = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if ((!p_at(TK_SYMBOL, ")"))) {
  (() => { const __recv = args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_expression(0)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_expression(0)) : vec_push(__recv, p_parse_expression(0)); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_expression(0)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_expression(0)) : vec_push(__recv, p_parse_expression(0)); })();
}
}
  p_expect(TK_SYMBOL, ")", "Expected ')' after type-application arguments");
  let applied = node_new(NK_APPLIED_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.applied = applied;
  node_set_data1(applied, name);
  node_set_data2(applied, args);
  return applied;
}
  return type_node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_type_primary_named_or_applied = p_parse_type_primary_named_or_applied;

const __tuff_outer_for_p_parse_type_primary = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_type_primary() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_type_primary };
  if (p_at(TK_SYMBOL, "*")) {
  return p_parse_type_primary_pointer();
}
  if (p_at(TK_SYMBOL, "[")) {
  return p_parse_type_primary_array();
}
  if (p_at(TK_SYMBOL, "(")) {
  return p_parse_type_primary_tuple_or_fn();
}
  if (p_at_kind(TK_NUMBER)) {
  return p_parse_type_primary_numeric_sentinel();
}
  return p_parse_type_primary_named_or_applied();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_type_primary = p_parse_type_primary;

const __tuff_outer_for_p_parse_type = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_type() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_type };
  let type_node = p_parse_type_primary(); if (typeof __tuff_this !== 'undefined') __tuff_this.type_node = type_node;
  let has_refine = ((((p_at(TK_SYMBOL, "!=") || p_at(TK_SYMBOL, "<")) || p_at(TK_SYMBOL, ">")) || p_at(TK_SYMBOL, "<=")) || p_at(TK_SYMBOL, ">=")); if (typeof __tuff_this !== 'undefined') __tuff_this.has_refine = has_refine;
  let starts_generic_call_suffix = false; if (typeof __tuff_this !== 'undefined') __tuff_this.starts_generic_call_suffix = starts_generic_call_suffix;
  if ((p_at(TK_SYMBOL, ">") && (tok_kind(p_peek(1)) === TK_SYMBOL))) {
  let next_sym = get_intern(tok_value(p_peek(1))); if (typeof __tuff_this !== 'undefined') __tuff_this.next_sym = next_sym;
  if ((() => { const __recv = next_sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "(") : str_eq(__recv, "("); })()) {
  starts_generic_call_suffix = true; if (typeof __tuff_this !== 'undefined') __tuff_this.starts_generic_call_suffix = starts_generic_call_suffix;
}
}
  if (((has_refine && p_can_start_refinement_expr_at(1)) && (!starts_generic_call_suffix))) {
  let op = tok_value(p_eat()); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let val_expr = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.val_expr = val_expr;
  let refine = node_new(NK_REFINEMENT_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.refine = refine;
  node_set_data1(refine, type_node);
  node_set_data2(refine, op);
  node_set_data3(refine, val_expr);
  type_node = refine; if (typeof __tuff_this !== 'undefined') __tuff_this.type_node = type_node;
}
  while (((((p_at(TK_SYMBOL, "+") || p_at(TK_SYMBOL, "-")) || p_at(TK_SYMBOL, "*")) || p_at(TK_SYMBOL, "/")) || p_at(TK_SYMBOL, "%"))) {
  let op = tok_value(p_eat()); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let right = p_parse_type_primary(); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let bin = node_new(NK_BINARY_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.bin = bin;
  node_set_data1(bin, op);
  node_set_data2(bin, type_node);
  node_set_data3(bin, right);
  type_node = bin; if (typeof __tuff_this !== 'undefined') __tuff_this.type_node = type_node;
}
  while ((p_at(TK_SYMBOL, "|") || p_at(TK_SYMBOL, "|>"))) {
  let is_extract = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.is_extract = is_extract;
  if (p_at(TK_SYMBOL, "|>")) {
  is_extract = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.is_extract = is_extract;
}
  p_eat();
  let right = p_parse_type_primary(); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let union_node = node_new(NK_UNION_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.union_node = union_node;
  node_set_data1(union_node, type_node);
  node_set_data2(union_node, right);
  node_set_data3(union_node, is_extract);
  type_node = union_node; if (typeof __tuff_this !== 'undefined') __tuff_this.type_node = type_node;
}
  return type_node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_type = p_parse_type;

const __tuff_outer_for_p_parse_pattern = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_pattern() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_pattern };
  if ((p_at(TK_SYMBOL, "_") || p_at(TK_IDENTIFIER, "_"))) {
  p_eat();
  return node_new(NK_WILDCARD_PAT);
}
  if (p_at_kind(TK_NUMBER)) {
  let t = p_eat(); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let node = node_new(NK_LITERAL_PAT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, tok_value(t));
  return node;
}
  if (p_at_kind(TK_BOOL)) {
  let t = p_eat(); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let node = node_new(NK_LITERAL_PAT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, tok_value(t));
  return node;
}
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((p_at(TK_SYMBOL, "<") && p_can_start_type_tok_at(1))) {
  p_eat();
  if ((!p_at(TK_SYMBOL, ">"))) {
  p_parse_type();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  p_parse_type();
}
}
  p_expect(TK_SYMBOL, ">", "Expected '>' in pattern generic args");
}
  if (p_at(TK_SYMBOL, "{")) {
  p_eat();
  let fields = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  if ((!p_at(TK_SYMBOL, "}"))) {
  (() => { const __recv = fields; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = fields; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
}
}
  p_expect(TK_SYMBOL, "}", "Expected '}' in pattern");
  let node = node_new(NK_STRUCT_PAT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  node_set_data2(node, fields);
  return node;
}
  let node = node_new(NK_NAME_PAT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_pattern = p_parse_pattern;

const __tuff_outer_for_selfhost_parser_core_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_parser_core_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_parser_core_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_parser_core_marker = selfhost_parser_core_marker;

const __tuff_outer_for_p_parse_constraint_value_atom = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_constraint_value_atom() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_constraint_value_atom };
  if (p_at_kind(TK_IDENTIFIER)) {
  let n = node_new(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  node_set_data1(n, tok_value(p_eat()));
  return n;
}
  if (p_at_kind(TK_NUMBER)) {
  let n = node_new(NK_NUMBER_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  node_set_data1(n, tok_value(p_eat()));
  return n;
}
  if (p_at_kind(TK_BOOL)) {
  let n = node_new(NK_BOOL_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  node_set_data1(n, tok_value(p_eat()));
  return n;
}
  if (p_at_kind(TK_STRING)) {
  let n = node_new(NK_STRING_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  node_set_data1(n, tok_value(p_eat()));
  return n;
}
  if (p_at_kind(TK_CHAR)) {
  let n = node_new(NK_CHAR_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  node_set_data1(n, tok_value(p_eat()));
  return n;
}
  if (p_at(TK_SYMBOL, "(")) {
  p_eat();
  let inner = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  p_expect(TK_SYMBOL, ")", "Expected ')' in generic constraint expression");
  return inner;
}
  return p_parse_type_primary();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_constraint_value_atom = p_parse_constraint_value_atom;

const __tuff_outer_for_p_parse_constraint_value_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_constraint_value_expr() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_constraint_value_expr };
  let left = p_parse_constraint_value_atom(); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  while (((((p_at(TK_SYMBOL, "+") || p_at(TK_SYMBOL, "-")) || p_at(TK_SYMBOL, "*")) || p_at(TK_SYMBOL, "/")) || p_at(TK_SYMBOL, "%"))) {
  let op = tok_value(p_eat()); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let right = p_parse_constraint_value_atom(); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let bin = node_new(NK_BINARY_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.bin = bin;
  node_set_data1(bin, op);
  node_set_data2(bin, left);
  node_set_data3(bin, right);
  left = bin; if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
}
  return left;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_constraint_value_expr = p_parse_constraint_value_expr;

const __tuff_outer_for_p_parse_generic_constraint_type = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_generic_constraint_type() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_generic_constraint_type };
  let type_node = p_parse_type_primary(); if (typeof __tuff_this !== 'undefined') __tuff_this.type_node = type_node;
  let starts_generic_call_suffix = false; if (typeof __tuff_this !== 'undefined') __tuff_this.starts_generic_call_suffix = starts_generic_call_suffix;
  if ((p_at(TK_SYMBOL, ">") && (tok_kind(p_peek(1)) === TK_SYMBOL))) {
  let next_sym = get_intern(tok_value(p_peek(1))); if (typeof __tuff_this !== 'undefined') __tuff_this.next_sym = next_sym;
  if ((() => { const __recv = next_sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "(") : str_eq(__recv, "("); })()) {
  starts_generic_call_suffix = true; if (typeof __tuff_this !== 'undefined') __tuff_this.starts_generic_call_suffix = starts_generic_call_suffix;
}
}
  let has_refine = ((((((p_at(TK_SYMBOL, "!=") || p_at(TK_SYMBOL, "<")) || p_at(TK_SYMBOL, ">")) || p_at(TK_SYMBOL, "<=")) || p_at(TK_SYMBOL, ">=")) && p_can_start_refinement_expr_at(1)) && (!starts_generic_call_suffix)); if (typeof __tuff_this !== 'undefined') __tuff_this.has_refine = has_refine;
  if (has_refine) {
  let op = tok_value(p_eat()); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let value = p_parse_constraint_value_expr(); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  let refine = node_new(NK_REFINEMENT_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.refine = refine;
  node_set_data1(refine, type_node);
  node_set_data2(refine, op);
  node_set_data3(refine, value);
  type_node = refine; if (typeof __tuff_this !== 'undefined') __tuff_this.type_node = type_node;
}
  while ((p_at(TK_SYMBOL, "|") || p_at(TK_SYMBOL, "|>"))) {
  let is_extract = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.is_extract = is_extract;
  if (p_at(TK_SYMBOL, "|>")) {
  is_extract = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.is_extract = is_extract;
}
  p_eat();
  let right = p_parse_type_primary(); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let union_node = node_new(NK_UNION_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.union_node = union_node;
  node_set_data1(union_node, type_node);
  node_set_data2(union_node, right);
  node_set_data3(union_node, is_extract);
  type_node = union_node; if (typeof __tuff_this !== 'undefined') __tuff_this.type_node = type_node;
}
  return type_node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_generic_constraint_type = p_parse_generic_constraint_type;

const __tuff_outer_for_p_parse_decl_generics = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_decl_generics(close_message) {
  let __tuff_this = { close_message: close_message, this: __tuff_outer_for_p_parse_decl_generics };
  let generics = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  if (p_at(TK_SYMBOL, "<")) {
  p_eat();
  if ((!p_at(TK_SYMBOL, ">"))) {
  while (true) {
  (() => { const __recv = generics; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  p_parse_generic_constraint_type();
}
  if ((!p_at(TK_SYMBOL, ","))) {
  break;
}
  p_eat();
}
}
  p_expect(TK_SYMBOL, ">", close_message);
}
  return generics;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_decl_generics = p_parse_decl_generics;

const __tuff_outer_for_p_parse_function = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_function(is_class, mode) {
  let __tuff_this = { is_class: is_class, mode: mode, this: __tuff_outer_for_p_parse_function };
  p_expect(TK_KEYWORD, "fn", "Expected 'fn'");
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let generics = p_parse_decl_generics("Expected '>'"); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  p_expect(TK_SYMBOL, "(", "Expected '('");
  let params = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  if ((!p_at(TK_SYMBOL, ")"))) {
  while (true) {
  let pname = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (p_at(TK_SYMBOL, "*")) {
  ptype = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (p_at_kind(TK_IDENTIFIER)) {
  pname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
} else {
  if ((node_kind(ptype) === NK_POINTER_TYPE)) {
  let inner = node_get_data2(ptype); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  if (((inner !== 0) && (node_kind(inner) === NK_NAMED_TYPE))) {
  let inner_name = node_get_data1(inner); if (typeof __tuff_this !== 'undefined') __tuff_this.inner_name = inner_name;
  if ((() => { const __recv = get_intern(inner_name); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })()) {
  pname = inner_name; if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
} else {
  p_expect_kind(TK_IDENTIFIER, "Expected identifier");
}
} else {
  p_expect_kind(TK_IDENTIFIER, "Expected identifier");
}
} else {
  p_expect_kind(TK_IDENTIFIER, "Expected identifier");
}
}
} else {
  pname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  ptype = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
}
  let param = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, pname) : vec_push(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, ptype) : vec_push(__recv, ptype); })();
  (() => { const __recv = params; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, param) : vec_push(__recv, param); })();
  if ((!p_at(TK_SYMBOL, ","))) {
  break;
}
  p_eat();
}
}
  p_expect(TK_SYMBOL, ")", "Expected ')'");
  let ret_type = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ret_type = ret_type;
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  ret_type = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ret_type = ret_type;
}
  let body = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if ((mode === 1)) {
  p_expect(TK_SYMBOL, ";", "Expected ';' after expect function declaration");
} else {
  p_expect(TK_SYMBOL, "=>", "Expected '=>'");
  if (p_at(TK_SYMBOL, "{")) {
  body = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
} else {
  body = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
}
  if ((node_kind(body) !== NK_BLOCK)) {
  if (((!p_at(TK_SYMBOL, "}")) && (!p_at_kind(TK_EOF)))) {
  p_expect(TK_SYMBOL, ";", "Expected ';'");
}
}
}
  let kind = NK_FN_DECL; if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((is_class === 1)) {
  kind = NK_CLASS_FN_DECL; if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
} else { if ((mode === 1)) {
  kind = NK_EXPECT_FN_DECL; if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
} else { if ((mode === 2)) {
  kind = NK_ACTUAL_FN_DECL; if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
} } }
  let node = node_new(kind); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  node_set_data2(node, generics);
  node_set_data3(node, params);
  node_set_data4(node, ret_type);
  node_set_data5(node, body);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_function = p_parse_function;

const __tuff_outer_for_p_parse_struct = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_struct(is_copy) {
  let __tuff_this = { is_copy: is_copy, this: __tuff_outer_for_p_parse_struct };
  p_expect(TK_KEYWORD, "struct", "Expected 'struct'");
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let generics = p_parse_decl_generics("Expected '>'"); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  p_expect(TK_SYMBOL, "{", "Expected '{'");
  let fields = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  while ((!p_at(TK_SYMBOL, "}"))) {
  let fname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  p_expect(TK_SYMBOL, ":", "Expected ':'");
  let ftype = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ftype = ftype;
  let field = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  (() => { const __recv = field; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, fname) : vec_push(__recv, fname); })();
  (() => { const __recv = field; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(ftype); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, ftype) : vec_push(__recv, ftype); })();
  (() => { const __recv = fields; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(field); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, field) : vec_push(__recv, field); })();
  if ((p_at(TK_SYMBOL, ",") || p_at(TK_SYMBOL, ";"))) {
  p_eat();
}
}
  p_expect(TK_SYMBOL, "}", "Expected '}'");
  let node = node_new(NK_STRUCT_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  node_set_data2(node, generics);
  node_set_data3(node, fields);
  node_set_data4(node, is_copy);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_struct = p_parse_struct;

const __tuff_outer_for_p_parse_enum = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_enum() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_enum };
  p_expect(TK_KEYWORD, "enum", "Expected 'enum'");
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  p_expect(TK_SYMBOL, "{", "Expected '{' after enum name");
  let variants = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.variants = variants;
  while ((!p_at(TK_SYMBOL, "}"))) {
  (() => { const __recv = variants; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
  if ((p_at(TK_SYMBOL, ",") || p_at(TK_SYMBOL, ";"))) {
  p_eat();
}
}
  p_expect(TK_SYMBOL, "}", "Expected '}' after enum body");
  let node = node_new(NK_ENUM_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  node_set_data2(node, variants);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_enum = p_parse_enum;

const __tuff_outer_for_p_parse_object = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_object() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_object };
  p_expect(TK_KEYWORD, "object", "Expected 'object'");
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let generics = p_parse_decl_generics("Expected '>'"); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  p_expect(TK_SYMBOL, "{", "Expected '{' after object name");
  let inputs = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.inputs = inputs;
  while ((!p_at(TK_SYMBOL, "}"))) {
  p_expect(TK_KEYWORD, "in", "Expected 'in' in object input declaration");
  p_expect(TK_KEYWORD, "let", "Expected 'let' in object input declaration");
  let input_name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.input_name = input_name;
  p_expect(TK_SYMBOL, ":", "Expected ':' in object input declaration");
  let input_type = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.input_type = input_type;
  p_expect(TK_SYMBOL, ";", "Expected ';' after object input declaration");
  let input_field = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.input_field = input_field;
  (() => { const __recv = input_field; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(input_name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, input_name) : vec_push(__recv, input_name); })();
  (() => { const __recv = input_field; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(input_type); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, input_type) : vec_push(__recv, input_type); })();
  (() => { const __recv = inputs; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(input_field); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, input_field) : vec_push(__recv, input_field); })();
}
  p_expect(TK_SYMBOL, "}", "Expected '}' after object body");
  let node = node_new(NK_OBJECT_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  node_set_data2(node, generics);
  node_set_data3(node, inputs);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_object = p_parse_object;

const __tuff_outer_for_p_parse_contract = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_contract() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_contract };
  p_expect(TK_KEYWORD, "contract", "Expected 'contract'");
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  p_expect(TK_SYMBOL, "{", "Expected '{' after contract name");
  let methods = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.methods = methods;
  while ((!p_at(TK_SYMBOL, "}"))) {
  p_expect(TK_KEYWORD, "fn", "Expected 'fn' in contract declaration");
  let mname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.mname = mname;
  let mgenerics = p_parse_decl_generics("Expected '>' after contract method generics"); if (typeof __tuff_this !== 'undefined') __tuff_this.mgenerics = mgenerics;
  p_expect(TK_SYMBOL, "(", "Expected '(' in contract method signature");
  let params = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  if ((!p_at(TK_SYMBOL, ")"))) {
  while (true) {
  let pname = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  let implicit_this = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.implicit_this = implicit_this;
  if (p_at(TK_SYMBOL, "*")) {
  p_eat();
  if (p_at(TK_KEYWORD, "mut")) {
  p_eat();
}
  pname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  implicit_this = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.implicit_this = implicit_this;
} else {
  pname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  ptype = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
}
  let param = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, pname) : vec_push(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, ptype) : vec_push(__recv, ptype); })();
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(implicit_this); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, implicit_this) : vec_push(__recv, implicit_this); })();
  (() => { const __recv = params; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, param) : vec_push(__recv, param); })();
  if ((!p_at(TK_SYMBOL, ","))) {
  break;
}
  p_eat();
}
}
  p_expect(TK_SYMBOL, ")", "Expected ')' after contract method params");
  let ret = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  ret = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
}
  p_expect(TK_SYMBOL, ";", "Expected ';' after contract method signature");
  let method = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.method = method;
  (() => { const __recv = method; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(mname); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, mname) : vec_push(__recv, mname); })();
  (() => { const __recv = method; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(mgenerics); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, mgenerics) : vec_push(__recv, mgenerics); })();
  (() => { const __recv = method; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(params); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, params) : vec_push(__recv, params); })();
  (() => { const __recv = method; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(ret); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, ret) : vec_push(__recv, ret); })();
  (() => { const __recv = methods; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(method); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, method) : vec_push(__recv, method); })();
}
  p_expect(TK_SYMBOL, "}", "Expected '}' after contract body");
  let node = node_new(NK_CONTRACT_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  node_set_data2(node, methods);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_contract = p_parse_contract;

const __tuff_outer_for_p_parse_type_alias = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_type_alias(is_copy) {
  let __tuff_this = { is_copy: is_copy, this: __tuff_outer_for_p_parse_type_alias };
  p_expect(TK_KEYWORD, "type", "Expected 'type'");
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if (p_at(TK_SYMBOL, "(")) {
  p_eat();
  let value_params = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.value_params = value_params;
  if ((!p_at(TK_SYMBOL, ")"))) {
  while (true) {
  let pname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  ptype = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
  let param = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, pname) : vec_push(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, ptype) : vec_push(__recv, ptype); })();
  (() => { const __recv = value_params; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, param) : vec_push(__recv, param); })();
  if ((!p_at(TK_SYMBOL, ","))) {
  break;
}
  p_eat();
}
}
  p_expect(TK_SYMBOL, ")", "Expected ')' after dep-type-alias value params");
  p_expect(TK_SYMBOL, "=", "Expected '=' in dep-type-alias");
  let aliased = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.aliased = aliased;
  let destructor_name = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
  if (p_at(TK_KEYWORD, "then")) {
  p_eat();
  destructor_name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
}
  p_expect(TK_SYMBOL, ";", "Expected ';' after dep-type-alias");
  let node = node_new(NK_DEP_TYPE_ALIAS); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  node_set_data2(node, value_params);
  node_set_data3(node, aliased);
  node_set_data4(node, is_copy);
  node_set_data5(node, destructor_name);
  return node;
}
  let generics = p_parse_decl_generics("Expected '>'"); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  p_expect(TK_SYMBOL, "=", "Expected '='");
  let aliased = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.aliased = aliased;
  let destructor_name = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
  if (p_at(TK_KEYWORD, "then")) {
  p_eat();
  destructor_name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
}
  p_expect(TK_SYMBOL, ";", "Expected ';'");
  let node = node_new(NK_TYPE_ALIAS); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  node_set_data2(node, generics);
  node_set_data3(node, aliased);
  node_set_data4(node, is_copy);
  node_set_data5(node, destructor_name);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_type_alias = p_parse_type_alias;

const __tuff_outer_for_p_parse_for = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_for() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_for };
  p_expect(TK_KEYWORD, "for", "Expected 'for'");
  p_expect(TK_SYMBOL, "(", "Expected '('");
  let iter = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.iter = iter;
  p_expect(TK_KEYWORD, "in", "Expected 'in'");
  let start = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.start = start;
  p_expect(TK_SYMBOL, "..", "Expected '..'");
  let end = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
  p_expect(TK_SYMBOL, ")", "Expected ')'");
  let body = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let node = node_new(NK_FOR_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, iter);
  node_set_data2(node, start);
  node_set_data3(node, end);
  node_set_data4(node, body);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_for = p_parse_for;

const __tuff_outer_for_p_parse_lifetime = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_lifetime() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_lifetime };
  p_expect(TK_KEYWORD, "lifetime", "Expected 'lifetime'");
  let names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  (() => { const __recv = names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
}
  let body = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let node = node_new(NK_LIFETIME_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, names);
  node_set_data2(node, body);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_lifetime = p_parse_lifetime;

const __tuff_outer_for_selfhost_parser_decls_helpers_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_parser_decls_helpers_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_parser_decls_helpers_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_parser_decls_helpers_marker = selfhost_parser_decls_helpers_marker;

let parse_temp_counter = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.parse_temp_counter = parse_temp_counter;

const __tuff_outer_for_p_new_temp_name = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_new_temp_name(prefix) {
  let __tuff_this = { prefix: prefix, this: __tuff_outer_for_p_new_temp_name };
  parse_temp_counter = (parse_temp_counter + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.parse_temp_counter = parse_temp_counter;
  return intern((() => { const __recv = prefix; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(parse_temp_counter)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(parse_temp_counter)) : str_concat(__recv, int_to_string(parse_temp_counter)); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_new_temp_name = p_new_temp_name;

const __tuff_outer_for_p_decls_let_extern_new_stmt_list = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_decls_let_extern_new_stmt_list(stmts) {
  let __tuff_this = { stmts: stmts, this: __tuff_outer_for_p_decls_let_extern_new_stmt_list };
  let n = node_new(NK_STMT_LIST); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  node_set_data1(n, stmts);
  return n;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_decls_let_extern_new_stmt_list = p_decls_let_extern_new_stmt_list;

const __tuff_outer_for_p_parse_let = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_let() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_let };
  p_expect(TK_KEYWORD, "let", "Expected 'let'");
  if (p_at(TK_KEYWORD, "mut")) {
  p_eat();
}
  if (p_at(TK_SYMBOL, "{")) {
  p_eat();
  let names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  if ((!p_at(TK_SYMBOL, "}"))) {
  (() => { const __recv = names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
}
}
  p_expect(TK_SYMBOL, "}", "Expected '}'");
  p_expect(TK_SYMBOL, "=", "Expected '='");
  let parts = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.parts = parts;
  (() => { const __recv = parts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
  while (p_at(TK_SYMBOL, "::")) {
  p_eat();
  (() => { const __recv = parts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
}
  p_expect(TK_SYMBOL, ";", "Expected ';'");
  let node = node_new(NK_IMPORT_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, names);
  node_set_data2(node, parts);
  return node;
}
  if (p_at(TK_SYMBOL, "(")) {
  p_eat();
  let names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  if ((!p_at(TK_SYMBOL, ")"))) {
  (() => { const __recv = names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
}
}
  p_expect(TK_SYMBOL, ")", "Expected ')' in tuple let destructuring");
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  p_parse_type();
}
  p_expect(TK_SYMBOL, "=", "Expected '=' in tuple let destructuring");
  let rhs = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.rhs = rhs;
  p_expect(TK_SYMBOL, ";", "Expected ';' after tuple let destructuring");
  let lowered = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.lowered = lowered;
  let tmp_name = p_new_temp_name("__tuple_tmp_"); if (typeof __tuff_this !== 'undefined') __tuff_this.tmp_name = tmp_name;
  let tmp_decl = node_new(NK_LET_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.tmp_decl = tmp_decl;
  node_set_data1(tmp_decl, tmp_name);
  node_set_data2(tmp_decl, 0);
  node_set_data3(tmp_decl, rhs);
  (() => { const __recv = lowered; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(tmp_decl); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, tmp_decl) : vec_push(__recv, tmp_decl); })();
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = names; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let tmp_ident = node_new(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.tmp_ident = tmp_ident;
  node_set_data1(tmp_ident, tmp_name);
  let idx_lit = node_new(NK_NUMBER_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.idx_lit = idx_lit;
  node_set_data1(idx_lit, intern(int_to_string(i)));
  let idx_expr = node_new(NK_INDEX_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.idx_expr = idx_expr;
  node_set_data1(idx_expr, tmp_ident);
  node_set_data2(idx_expr, idx_lit);
  let elem_decl = node_new(NK_LET_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.elem_decl = elem_decl;
  node_set_data1(elem_decl, (() => { const __recv = names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })());
  node_set_data2(elem_decl, 0);
  node_set_data3(elem_decl, idx_expr);
  (() => { const __recv = lowered; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(elem_decl); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, elem_decl) : vec_push(__recv, elem_decl); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return p_decls_let_extern_new_stmt_list(lowered);
}
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let vtype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.vtype = vtype;
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  vtype = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.vtype = vtype;
}
  p_expect(TK_SYMBOL, "=", "Expected '='");
  let value = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  p_expect(TK_SYMBOL, ";", "Expected ';'");
  let node = node_new(NK_LET_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  node_set_data2(node, vtype);
  node_set_data3(node, value);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_let = p_parse_let;

const __tuff_outer_for_p_le_parse_constraint_value_atom = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_le_parse_constraint_value_atom() {
  let __tuff_this = { this: __tuff_outer_for_p_le_parse_constraint_value_atom };
  if (p_at_kind(TK_IDENTIFIER)) {
  let n = node_new(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  node_set_data1(n, tok_value(p_eat()));
  return n;
}
  if (p_at_kind(TK_NUMBER)) {
  let n = node_new(NK_NUMBER_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  node_set_data1(n, tok_value(p_eat()));
  return n;
}
  if (p_at_kind(TK_BOOL)) {
  let n = node_new(NK_BOOL_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  node_set_data1(n, tok_value(p_eat()));
  return n;
}
  if (p_at_kind(TK_STRING)) {
  let n = node_new(NK_STRING_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  node_set_data1(n, tok_value(p_eat()));
  return n;
}
  if (p_at_kind(TK_CHAR)) {
  let n = node_new(NK_CHAR_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  node_set_data1(n, tok_value(p_eat()));
  return n;
}
  if (p_at(TK_SYMBOL, "(")) {
  p_eat();
  let inner = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  p_expect(TK_SYMBOL, ")", "Expected ')' in generic constraint expression");
  return inner;
}
  return p_parse_type_primary();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_le_parse_constraint_value_atom = p_le_parse_constraint_value_atom;

const __tuff_outer_for_p_le_parse_constraint_value_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_le_parse_constraint_value_expr() {
  let __tuff_this = { this: __tuff_outer_for_p_le_parse_constraint_value_expr };
  let left = p_le_parse_constraint_value_atom(); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  while (((((p_at(TK_SYMBOL, "+") || p_at(TK_SYMBOL, "-")) || p_at(TK_SYMBOL, "*")) || p_at(TK_SYMBOL, "/")) || p_at(TK_SYMBOL, "%"))) {
  let op = tok_value(p_eat()); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let right = p_le_parse_constraint_value_atom(); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let bin = node_new(NK_BINARY_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.bin = bin;
  node_set_data1(bin, op);
  node_set_data2(bin, left);
  node_set_data3(bin, right);
  left = bin; if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
}
  return left;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_le_parse_constraint_value_expr = p_le_parse_constraint_value_expr;

const __tuff_outer_for_p_le_parse_generic_constraint_type = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_le_parse_generic_constraint_type() {
  let __tuff_this = { this: __tuff_outer_for_p_le_parse_generic_constraint_type };
  let type_node = p_parse_type_primary(); if (typeof __tuff_this !== 'undefined') __tuff_this.type_node = type_node;
  let starts_generic_call_suffix = false; if (typeof __tuff_this !== 'undefined') __tuff_this.starts_generic_call_suffix = starts_generic_call_suffix;
  if ((p_at(TK_SYMBOL, ">") && (tok_kind(p_peek(1)) === TK_SYMBOL))) {
  let next_sym = get_intern(tok_value(p_peek(1))); if (typeof __tuff_this !== 'undefined') __tuff_this.next_sym = next_sym;
  if ((() => { const __recv = next_sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "(") : str_eq(__recv, "("); })()) {
  starts_generic_call_suffix = true; if (typeof __tuff_this !== 'undefined') __tuff_this.starts_generic_call_suffix = starts_generic_call_suffix;
}
}
  let has_refine = ((((((p_at(TK_SYMBOL, "!=") || p_at(TK_SYMBOL, "<")) || p_at(TK_SYMBOL, ">")) || p_at(TK_SYMBOL, "<=")) || p_at(TK_SYMBOL, ">=")) && p_can_start_refinement_expr_at(1)) && (!starts_generic_call_suffix)); if (typeof __tuff_this !== 'undefined') __tuff_this.has_refine = has_refine;
  if (has_refine) {
  let op = tok_value(p_eat()); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let value = p_le_parse_constraint_value_expr(); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  let refine = node_new(NK_REFINEMENT_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.refine = refine;
  node_set_data1(refine, type_node);
  node_set_data2(refine, op);
  node_set_data3(refine, value);
  type_node = refine; if (typeof __tuff_this !== 'undefined') __tuff_this.type_node = type_node;
}
  while ((p_at(TK_SYMBOL, "|") || p_at(TK_SYMBOL, "|>"))) {
  let is_extract = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.is_extract = is_extract;
  if (p_at(TK_SYMBOL, "|>")) {
  is_extract = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.is_extract = is_extract;
}
  p_eat();
  let right = p_parse_type_primary(); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let union_node = node_new(NK_UNION_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.union_node = union_node;
  node_set_data1(union_node, type_node);
  node_set_data2(union_node, right);
  node_set_data3(union_node, is_extract);
  type_node = union_node; if (typeof __tuff_this !== 'undefined') __tuff_this.type_node = type_node;
}
  return type_node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_le_parse_generic_constraint_type = p_le_parse_generic_constraint_type;

const __tuff_outer_for_p_le_parse_decl_generics = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_le_parse_decl_generics(close_message) {
  let __tuff_this = { close_message: close_message, this: __tuff_outer_for_p_le_parse_decl_generics };
  let generics = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  if (p_at(TK_SYMBOL, "<")) {
  p_eat();
  if ((!p_at(TK_SYMBOL, ">"))) {
  while (true) {
  (() => { const __recv = generics; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  p_le_parse_generic_constraint_type();
}
  if ((!p_at(TK_SYMBOL, ","))) {
  break;
}
  p_eat();
}
}
  p_expect(TK_SYMBOL, ">", close_message);
}
  return generics;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_le_parse_decl_generics = p_le_parse_decl_generics;

const __tuff_outer_for_p_parse_extern_fn_decl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_extern_fn_decl() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_extern_fn_decl };
  p_expect(TK_KEYWORD, "fn", "Expected 'fn'");
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let generics = p_le_parse_decl_generics("Expected '>'"); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  p_expect(TK_SYMBOL, "(", "Expected '('");
  let params = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  if ((!p_at(TK_SYMBOL, ")"))) {
  while (true) {
  let pname = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (p_at(TK_SYMBOL, "*")) {
  ptype = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  pname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
} else {
  pname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  ptype = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
}
  let param = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, pname) : vec_push(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, ptype) : vec_push(__recv, ptype); })();
  (() => { const __recv = params; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, param) : vec_push(__recv, param); })();
  if ((!p_at(TK_SYMBOL, ","))) {
  break;
}
  p_eat();
}
}
  p_expect(TK_SYMBOL, ")", "Expected ')'");
  let ret_type = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ret_type = ret_type;
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  ret_type = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ret_type = ret_type;
}
  p_expect(TK_SYMBOL, ";", "Expected ';' after extern fn");
  let node = node_new(NK_FN_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  node_set_data2(node, generics);
  node_set_data3(node, params);
  node_set_data4(node, ret_type);
  node_set_data5(node, 0);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_extern_fn_decl = p_parse_extern_fn_decl;

const __tuff_outer_for_p_parse_extern_decl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_extern_decl() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_extern_decl };
  if (p_at(TK_KEYWORD, "fn")) {
  return p_parse_extern_fn_decl();
}
  if (p_at(TK_KEYWORD, "let")) {
  p_eat();
  if (p_at(TK_SYMBOL, "{")) {
  p_eat();
  let names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  if ((!p_at(TK_SYMBOL, "}"))) {
  (() => { const __recv = names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
}
}
  p_expect(TK_SYMBOL, "}", "Expected '}' after extern let bindings");
  p_expect(TK_SYMBOL, "=", "Expected '=' in extern let bindings");
  let source_parts = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.source_parts = source_parts;
  (() => { const __recv = source_parts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
  while (p_at(TK_SYMBOL, "::")) {
  p_eat();
  (() => { const __recv = source_parts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
}
  p_expect(TK_SYMBOL, ";", "Expected ';' after extern let bindings");
  let node = node_new(NK_EXTERN_IMPORT_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, names);
  node_set_data2(node, source_parts);
  return node;
}
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let typ = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.typ = typ;
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  typ = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.typ = typ;
}
  p_expect(TK_SYMBOL, ";", "Expected ';' after extern let");
  let node = node_new(NK_EXTERN_LET_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  node_set_data2(node, typ);
  return node;
}
  if (p_at(TK_KEYWORD, "type")) {
  p_eat();
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let generics = p_le_parse_decl_generics("Expected '>' after extern type generics"); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  let destructor_name = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
  if (p_at(TK_KEYWORD, "then")) {
  p_eat();
  destructor_name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
}
  p_expect(TK_SYMBOL, ";", "Expected ';' after extern type");
  let node = node_new(NK_EXTERN_TYPE_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, name);
  node_set_data2(node, generics);
  node_set_data5(node, destructor_name);
  return node;
}
  return panic("Expected fn, let, or type after extern");
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_extern_decl = p_parse_extern_decl;

const __tuff_outer_for_selfhost_parser_decls_let_extern_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_parser_decls_let_extern_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_parser_decls_let_extern_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_parser_decls_let_extern_marker = selfhost_parser_decls_let_extern_marker;

const __tuff_outer_for_p_new_stmt_list = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_new_stmt_list(stmts) {
  let __tuff_this = { stmts: stmts, this: __tuff_outer_for_p_new_stmt_list };
  let n = node_new(NK_STMT_LIST); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  node_set_data1(n, stmts);
  return n;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_new_stmt_list = p_new_stmt_list;

const __tuff_outer_for_p_parse_template_wrapper = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_template_wrapper() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_template_wrapper };
  p_eat();
  p_parse_identifier();
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  p_parse_type();
}
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  p_parse_identifier();
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  p_parse_type();
}
}
  p_expect(TK_SYMBOL, "{", "Expected '{' after template declaration");
  let stmts = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  while ((!p_at(TK_SYMBOL, "}"))) {
  let stmt = p_parse_statement(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if ((node_kind(stmt) === NK_BLOCK)) {
  let inner = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < (() => { const __recv = inner; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  (() => { const __recv = stmts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = inner; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = inner; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()) : vec_push(__recv, (() => { const __recv = inner; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
} else {
  (() => { const __recv = stmts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(stmt); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, stmt) : vec_push(__recv, stmt); })();
}
}
  p_expect(TK_SYMBOL, "}", "Expected '}' after template block");
  return p_new_stmt_list(stmts);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_template_wrapper = p_parse_template_wrapper;

const __tuff_outer_for_p_parse_module_wrapper = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_module_wrapper() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_module_wrapper };
  p_expect(TK_KEYWORD, "module", "Expected 'module'");
  p_parse_identifier();
  p_expect(TK_SYMBOL, "{", "Expected '{' after module name");
  let stmts = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  while ((!p_at(TK_SYMBOL, "}"))) {
  let stmt = p_parse_statement(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if ((node_kind(stmt) === NK_BLOCK)) {
  let inner = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < (() => { const __recv = inner; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  (() => { const __recv = stmts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = inner; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = inner; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()) : vec_push(__recv, (() => { const __recv = inner; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
} else {
  (() => { const __recv = stmts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(stmt); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, stmt) : vec_push(__recv, stmt); })();
}
}
  p_expect(TK_SYMBOL, "}", "Expected '}' after module body");
  return p_new_stmt_list(stmts);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_module_wrapper = p_parse_module_wrapper;

const __tuff_outer_for_p_parse_decl_modifiers = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_decl_modifiers() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_decl_modifiers };
  let exported = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.exported = exported;
  let extern_decl = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.extern_decl = extern_decl;
  let copy_decl = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.copy_decl = copy_decl;
  let expect_decl = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.expect_decl = expect_decl;
  let actual_decl = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.actual_decl = actual_decl;
  let consumed_modifier = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.consumed_modifier = consumed_modifier;
  let modifier_watchdog = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.modifier_watchdog = modifier_watchdog;
  while (((((((p_at(TK_KEYWORD, "out") || p_at(TK_KEYWORD, "extern")) || p_at(TK_KEYWORD, "copy")) || p_at(TK_KEYWORD, "expect")) || (p_at(TK_IDENTIFIER, "expect") && ((tok_kind(p_peek(1)) === TK_KEYWORD) || (tok_kind(p_peek(1)) === TK_IDENTIFIER)))) || p_at(TK_KEYWORD, "actual")) || (p_at(TK_IDENTIFIER, "actual") && ((tok_kind(p_peek(1)) === TK_KEYWORD) || (tok_kind(p_peek(1)) === TK_IDENTIFIER))))) {
  modifier_watchdog = (modifier_watchdog + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.modifier_watchdog = modifier_watchdog;
  if ((modifier_watchdog > 1000)) {
  p_error_with_token_context("Parser watchdog: declaration-modifier loop exceeded 1000 iterations");
}
  consumed_modifier = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.consumed_modifier = consumed_modifier;
  if (p_at(TK_KEYWORD, "out")) {
  p_eat();
  if ((exported === 1)) {
  panic("Duplicate 'out' modifier");
}
  exported = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.exported = exported;
} else { if (p_at(TK_KEYWORD, "extern")) {
  p_eat();
  if ((extern_decl === 1)) {
  panic("Duplicate 'extern' modifier");
}
  extern_decl = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.extern_decl = extern_decl;
} else { if (p_at(TK_KEYWORD, "copy")) {
  p_eat();
  if ((copy_decl === 1)) {
  panic("Duplicate 'copy' modifier");
}
  copy_decl = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.copy_decl = copy_decl;
} else { if ((p_at(TK_KEYWORD, "expect") || (p_at(TK_IDENTIFIER, "expect") && ((tok_kind(p_peek(1)) === TK_KEYWORD) || (tok_kind(p_peek(1)) === TK_IDENTIFIER))))) {
  p_eat();
  if ((expect_decl === 1)) {
  panic("Duplicate 'expect' modifier");
}
  expect_decl = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.expect_decl = expect_decl;
} else { if ((p_at(TK_KEYWORD, "actual") || (p_at(TK_IDENTIFIER, "actual") && ((tok_kind(p_peek(1)) === TK_KEYWORD) || (tok_kind(p_peek(1)) === TK_IDENTIFIER))))) {
  p_eat();
  if ((actual_decl === 1)) {
  panic("Duplicate 'actual' modifier");
}
  actual_decl = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.actual_decl = actual_decl;
} else {
  panic("Unexpected declaration modifier");
} } } } }
}
  let mods = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.mods = mods;
  (() => { const __recv = mods; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(exported); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, exported) : vec_push(__recv, exported); })();
  (() => { const __recv = mods; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(extern_decl); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, extern_decl) : vec_push(__recv, extern_decl); })();
  (() => { const __recv = mods; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(copy_decl); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, copy_decl) : vec_push(__recv, copy_decl); })();
  (() => { const __recv = mods; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(expect_decl); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, expect_decl) : vec_push(__recv, expect_decl); })();
  (() => { const __recv = mods; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(actual_decl); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, actual_decl) : vec_push(__recv, actual_decl); })();
  (() => { const __recv = mods; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(consumed_modifier); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, consumed_modifier) : vec_push(__recv, consumed_modifier); })();
  return mods;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_decl_modifiers = p_parse_decl_modifiers;

const __tuff_outer_for_p_parse_after_modifiers = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_after_modifiers(exported, extern_decl, copy_decl, expect_decl, actual_decl) {
  let __tuff_this = { exported: exported, extern_decl: extern_decl, copy_decl: copy_decl, expect_decl: expect_decl, actual_decl: actual_decl, this: __tuff_outer_for_p_parse_after_modifiers };
  if (((expect_decl === 1) && (actual_decl === 1))) {
  panic("Cannot combine 'expect' and 'actual' modifiers");
}
  let out_node = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.out_node = out_node;
  if ((extern_decl === 1)) {
  if ((copy_decl === 1)) {
  panic("'copy' is not supported on extern declarations");
}
  if (((expect_decl === 1) || (actual_decl === 1))) {
  panic("'expect'/'actual' are not supported on extern declarations");
}
  if (p_at(TK_KEYWORD, "extern")) {
  p_eat();
}
  if ((!((p_at(TK_KEYWORD, "fn") || p_at(TK_KEYWORD, "let")) || p_at(TK_KEYWORD, "type")))) {
  panic("'extern' modifier must be followed by fn, let, or type declaration");
}
  out_node = p_parse_extern_decl(); if (typeof __tuff_this !== 'undefined') __tuff_this.out_node = out_node;
} else { if (p_at(TK_KEYWORD, "struct")) {
  out_node = p_parse_struct(copy_decl); if (typeof __tuff_this !== 'undefined') __tuff_this.out_node = out_node;
} else { if (p_at(TK_KEYWORD, "enum")) {
  out_node = p_parse_enum(); if (typeof __tuff_this !== 'undefined') __tuff_this.out_node = out_node;
} else { if (p_at(TK_KEYWORD, "object")) {
  if ((copy_decl === 1)) {
  panic("'copy' is only supported on struct/type declarations");
}
  if (((expect_decl === 1) || (actual_decl === 1))) {
  panic("'expect'/'actual' are currently supported only on fn declarations");
}
  out_node = p_parse_object(); if (typeof __tuff_this !== 'undefined') __tuff_this.out_node = out_node;
} else { if (p_at(TK_KEYWORD, "contract")) {
  if ((copy_decl === 1)) {
  panic("'copy' is only supported on struct/type declarations");
}
  if (((expect_decl === 1) || (actual_decl === 1))) {
  panic("'expect'/'actual' are currently supported only on fn declarations");
}
  out_node = p_parse_contract(); if (typeof __tuff_this !== 'undefined') __tuff_this.out_node = out_node;
} else { if (p_at(TK_KEYWORD, "type")) {
  out_node = p_parse_type_alias(copy_decl); if (typeof __tuff_this !== 'undefined') __tuff_this.out_node = out_node;
} else { if (p_at(TK_KEYWORD, "fn")) {
  if ((copy_decl === 1)) {
  panic("'copy' is only supported on struct/type declarations");
}
  let mode = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
  if ((expect_decl === 1)) {
  mode = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
} else { if ((actual_decl === 1)) {
  mode = 2; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
} }
  out_node = p_parse_function(0, mode); if (typeof __tuff_this !== 'undefined') __tuff_this.out_node = out_node;
} else { if (p_at(TK_KEYWORD, "class")) {
  if ((copy_decl === 1)) {
  panic("'copy' is only supported on struct/type declarations");
}
  if (((expect_decl === 1) || (actual_decl === 1))) {
  panic("'expect'/'actual' are currently supported only on fn declarations");
}
  p_eat();
  out_node = p_parse_function(1, 0); if (typeof __tuff_this !== 'undefined') __tuff_this.out_node = out_node;
} else { if (p_at(TK_KEYWORD, "module")) {
  if ((copy_decl === 1)) {
  panic("'copy' is only supported on struct/type declarations");
}
  if (((expect_decl === 1) || (actual_decl === 1))) {
  panic("'expect'/'actual' are currently supported only on fn declarations");
}
  out_node = p_parse_module_wrapper(); if (typeof __tuff_this !== 'undefined') __tuff_this.out_node = out_node;
} else {
  p_error_with_token_context("Expected declaration after modifiers");
} } } } } } } } }
  if (((exported === 1) && (node_kind(out_node) !== NK_STMT_LIST))) {
  (() => { const __recv = parse_exports; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(out_node))); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(out_node))) : set_add(__recv, get_interned_str(node_get_data1(out_node))); })();
}
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
}
  return out_node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_after_modifiers = p_parse_after_modifiers;

const __tuff_outer_for_p_try_parse_plain_decl_statement = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_try_parse_plain_decl_statement() {
  let __tuff_this = { this: __tuff_outer_for_p_try_parse_plain_decl_statement };
  if (p_at(TK_KEYWORD, "let")) {
  return p_parse_let();
}
  if (p_at(TK_KEYWORD, "struct")) {
  let node = p_parse_struct(0); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
}
  return node;
}
  if (p_at(TK_KEYWORD, "enum")) {
  let node = p_parse_enum(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
}
  return node;
}
  if (p_at(TK_KEYWORD, "object")) {
  let node = p_parse_object(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
}
  return node;
}
  if (p_at(TK_KEYWORD, "module")) {
  let node = p_parse_module_wrapper(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
}
  return node;
}
  if ((p_at(TK_KEYWORD, "template") || p_at(TK_IDENTIFIER, "template"))) {
  let node = p_parse_template_wrapper(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
}
  return node;
}
  if (p_at(TK_KEYWORD, "contract")) {
  let node = p_parse_contract(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
}
  return node;
}
  if (p_at(TK_KEYWORD, "type")) {
  let node = p_parse_type_alias(0); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
}
  return node;
}
  if (p_at(TK_KEYWORD, "fn")) {
  let node = p_parse_function(0, 0); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
}
  return node;
}
  if (p_at(TK_KEYWORD, "extern")) {
  p_eat();
  return p_parse_extern_decl();
}
  if (p_at(TK_KEYWORD, "class")) {
  p_eat();
  let node = p_parse_function(1, 0); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
}
  return node;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_try_parse_plain_decl_statement = p_try_parse_plain_decl_statement;

const __tuff_outer_for_p_parse_if_stmt_or_expr_stmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_if_stmt_or_expr_stmt() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_if_stmt_or_expr_stmt };
  p_eat();
  p_expect(TK_SYMBOL, "(", "Expected '(' after if");
  let cond = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  p_expect(TK_SYMBOL, ")", "Expected ')' after condition");
  if (((((((((p_at(TK_SYMBOL, "{") || p_at(TK_KEYWORD, "break")) || p_at(TK_KEYWORD, "continue")) || p_at(TK_KEYWORD, "return")) || p_at(TK_KEYWORD, "if")) || p_at(TK_KEYWORD, "while")) || p_at(TK_KEYWORD, "for")) || p_at(TK_KEYWORD, "loop")) || p_at(TK_KEYWORD, "let"))) {
  let then_branch = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.then_branch = then_branch;
  if (p_at(TK_SYMBOL, "{")) {
  then_branch = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.then_branch = then_branch;
} else {
  then_branch = p_parse_statement(); if (typeof __tuff_this !== 'undefined') __tuff_this.then_branch = then_branch;
}
  let else_branch = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.else_branch = else_branch;
  if (p_at(TK_KEYWORD, "else")) {
  p_eat();
  if (p_at(TK_SYMBOL, "{")) {
  else_branch = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.else_branch = else_branch;
} else {
  else_branch = p_parse_statement(); if (typeof __tuff_this !== 'undefined') __tuff_this.else_branch = else_branch;
}
}
  let stmt = node_new(NK_IF_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  node_set_data1(stmt, cond);
  node_set_data2(stmt, then_branch);
  node_set_data3(stmt, else_branch);
  return stmt;
}
  let then_expr = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.then_expr = then_expr;
  let else_expr = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.else_expr = else_expr;
  if (p_at(TK_KEYWORD, "else")) {
  p_eat();
  if (p_at(TK_SYMBOL, "{")) {
  else_expr = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.else_expr = else_expr;
} else {
  else_expr = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.else_expr = else_expr;
}
}
  let if_expr = node_new(NK_IF_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.if_expr = if_expr;
  node_set_data1(if_expr, cond);
  node_set_data2(if_expr, then_expr);
  node_set_data3(if_expr, else_expr);
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
} else { if ((!p_at(TK_SYMBOL, "}"))) {
  p_expect(TK_SYMBOL, ";", "Expected ';'");
} }
  let estmt = node_new(NK_EXPR_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.estmt = estmt;
  node_set_data1(estmt, if_expr);
  return estmt;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_if_stmt_or_expr_stmt = p_parse_if_stmt_or_expr_stmt;

const __tuff_outer_for_p_try_parse_plain_control_statement = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_try_parse_plain_control_statement() {
  let __tuff_this = { this: __tuff_outer_for_p_try_parse_plain_control_statement };
  if (p_at(TK_KEYWORD, "return")) {
  p_eat();
  let value = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  if ((!p_at(TK_SYMBOL, ";"))) {
  value = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
}
  p_expect(TK_SYMBOL, ";", "Expected ';'");
  let node = node_new(NK_RETURN_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, value);
  return node;
}
  if (p_at(TK_KEYWORD, "if")) {
  return p_parse_if_stmt_or_expr_stmt();
}
  if (p_at(TK_KEYWORD, "while")) {
  p_eat();
  p_expect(TK_SYMBOL, "(", "Expected '('");
  let cond = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  p_expect(TK_SYMBOL, ")", "Expected ')'");
  let body = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let node = node_new(NK_WHILE_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, cond);
  node_set_data2(node, body);
  return node;
}
  if (p_at(TK_KEYWORD, "for")) {
  return p_parse_for();
}
  if (p_at(TK_KEYWORD, "loop")) {
  p_eat();
  let body = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let node = node_new(NK_LOOP_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, body);
  return node;
}
  if (p_at(TK_KEYWORD, "then")) {
  p_eat();
  p_expect(TK_SYMBOL, "(", "Expected '(' after then in then-statement");
  p_expect(TK_SYMBOL, ")", "Expected ')' in then-statement parameter list");
  p_expect(TK_SYMBOL, "=>", "Expected '=>' in then-statement");
  if (p_at(TK_SYMBOL, "{")) {
  return p_parse_block();
}
  let expr = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  p_expect(TK_SYMBOL, ";", "Expected ';' after then-statement expression");
  let estmt = node_new(NK_EXPR_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.estmt = estmt;
  node_set_data1(estmt, expr);
  return estmt;
}
  if (p_at(TK_KEYWORD, "lifetime")) {
  return p_parse_lifetime();
}
  if (p_at(TK_KEYWORD, "into")) {
  p_eat();
  let cname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
  p_expect(TK_SYMBOL, ";", "Expected ';' after into statement");
  let node = node_new(NK_INTO_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, cname);
  return node;
}
  if (p_at(TK_KEYWORD, "break")) {
  p_eat();
  p_expect(TK_SYMBOL, ";", "Expected ';'");
  return node_new(NK_BREAK_STMT);
}
  if (p_at(TK_KEYWORD, "continue")) {
  p_eat();
  p_expect(TK_SYMBOL, ";", "Expected ';'");
  return node_new(NK_CONTINUE_STMT);
}
  if (p_at(TK_SYMBOL, "{")) {
  return p_parse_block();
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_try_parse_plain_control_statement = p_try_parse_plain_control_statement;

const __tuff_outer_for_p_parse_statement = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_statement() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_statement };
  let mods = p_parse_decl_modifiers(); if (typeof __tuff_this !== 'undefined') __tuff_this.mods = mods;
  if (((() => { const __recv = mods; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(5); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 5) : vec_get(__recv, 5); })() === 1)) {
  return p_parse_after_modifiers((() => { const __recv = mods; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(), (() => { const __recv = mods; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), (() => { const __recv = mods; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 2) : vec_get(__recv, 2); })(), (() => { const __recv = mods; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(3); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 3) : vec_get(__recv, 3); })(), (() => { const __recv = mods; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(4); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 4) : vec_get(__recv, 4); })());
}
  let node = p_try_parse_plain_decl_statement(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if ((node !== 0)) {
  return node;
}
  node = p_try_parse_plain_control_statement(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if ((node !== 0)) {
  return node;
}
  let expr = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  if (p_at(TK_SYMBOL, "=")) {
  p_eat();
  let value = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  p_expect(TK_SYMBOL, ";", "Expected ';'");
  let node = node_new(NK_ASSIGN_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, expr);
  node_set_data2(node, value);
  return node;
}
  if ((((((((((p_at(TK_SYMBOL, "+") || p_at(TK_SYMBOL, "-")) || p_at(TK_SYMBOL, "*")) || p_at(TK_SYMBOL, "/")) || p_at(TK_SYMBOL, "%")) || p_at(TK_SYMBOL, "&")) || p_at(TK_SYMBOL, "|")) || p_at(TK_SYMBOL, "^")) && (tok_kind(p_peek(1)) === TK_SYMBOL)) && (() => { const __recv = get_interned_str(tok_value(p_peek(1))); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "=") : str_eq(__recv, "="); })())) {
  let op_tok = p_eat(); if (typeof __tuff_this !== 'undefined') __tuff_this.op_tok = op_tok;
  p_eat();
  let rhs = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.rhs = rhs;
  p_expect(TK_SYMBOL, ";", "Expected ';'");
  let bin = node_new(NK_BINARY_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.bin = bin;
  node_set_data1(bin, tok_value(op_tok));
  node_set_data2(bin, expr);
  node_set_data3(bin, rhs);
  let node = node_new(NK_ASSIGN_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, expr);
  node_set_data2(node, bin);
  return node;
}
  if (p_at(TK_SYMBOL, ";")) {
  p_eat();
} else { if ((!p_at(TK_SYMBOL, "}"))) {
  p_expect(TK_SYMBOL, ";", "Expected ';'");
} }
  let stmt = node_new(NK_EXPR_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  node_set_data1(stmt, expr);
  return stmt;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_statement = p_parse_statement;

const __tuff_outer_for_p_parse_program = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_program() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_program };
  let stmts = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let at_eof = p_at_kind(TK_EOF); if (typeof __tuff_this !== 'undefined') __tuff_this.at_eof = at_eof;
  while ((!at_eof)) {
  let before = p_mark(); if (typeof __tuff_this !== 'undefined') __tuff_this.before = before;
  let stmt = p_parse_statement(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let after = p_mark(); if (typeof __tuff_this !== 'undefined') __tuff_this.after = after;
  if ((after === before)) {
  p_error_with_token_context("Parser made no progress while parsing top-level statement");
}
  if ((node_kind(stmt) === NK_STMT_LIST)) {
  let inner = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = inner; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  (() => { const __recv = stmts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = inner; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = inner; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()) : vec_push(__recv, (() => { const __recv = inner; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
} else {
  (() => { const __recv = stmts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(stmt); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, stmt) : vec_push(__recv, stmt); })();
}
  at_eof = p_at_kind(TK_EOF); if (typeof __tuff_this !== 'undefined') __tuff_this.at_eof = at_eof;
}
  let node = node_new(NK_PROGRAM); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, stmts);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_program = p_parse_program;

const __tuff_outer_for_desugar = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function desugar(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_desugar };
  return program;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.desugar = desugar;

const __tuff_outer_for_selfhost_parser_decls_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_parser_decls_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_parser_decls_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_parser_decls_marker = selfhost_parser_decls_marker;

const __tuff_outer_for_rslv_utils_panic_node = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslv_utils_panic_node(err_node, code, msg, reason, fix) {
  let __tuff_this = { err_node: err_node, code: code, msg: msg, reason: reason, fix: fix, this: __tuff_outer_for_rslv_utils_panic_node };
  return panic_with_code_loc(code, msg, reason, fix, node_get_line(err_node), node_get_col(err_node));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslv_utils_panic_node = rslv_utils_panic_node;

const __tuff_outer_for_levenshtein_distance = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function levenshtein_distance(a, b) {
  let __tuff_this = { a: a, b: b, this: __tuff_outer_for_levenshtein_distance };
  let an = (0 + (() => { const __recv = a; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.an = an;
  let bn = (0 + (() => { const __recv = b; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.bn = bn;
  if ((an === 0)) {
  return bn;
}
  if ((bn === 0)) {
  return an;
}
  let prev = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.prev = prev;
  let curr = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.curr = curr;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j <= bn)) {
  (() => { const __recv = prev; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, j) : vec_push(__recv, j); })();
  (() => { const __recv = curr; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  let i = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i <= an)) {
  (() => { const __recv = curr; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(0, i); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, 0, i) : vec_set(__recv, 0, i); })();
  let j2 = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.j2 = j2;
  while ((j2 <= bn)) {
  let cost = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cost = cost;
  if (((() => { const __recv = a; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i - 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i - 1)) : str_char_at(__recv, (i - 1)); })() !== (() => { const __recv = b; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((j2 - 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (j2 - 1)) : str_char_at(__recv, (j2 - 1)); })())) {
  cost = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cost = cost;
}
  let del_cost = ((() => { const __recv = prev; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j2); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j2) : vec_get(__recv, j2); })() + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.del_cost = del_cost;
  let ins_cost = ((() => { const __recv = curr; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop((j2 - 1)); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, (j2 - 1)) : vec_get(__recv, (j2 - 1)); })() + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.ins_cost = ins_cost;
  let rep_cost = ((() => { const __recv = prev; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop((j2 - 1)); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, (j2 - 1)) : vec_get(__recv, (j2 - 1)); })() + cost); if (typeof __tuff_this !== 'undefined') __tuff_this.rep_cost = rep_cost;
  let best = del_cost; if (typeof __tuff_this !== 'undefined') __tuff_this.best = best;
  if ((ins_cost < best)) {
  best = ins_cost; if (typeof __tuff_this !== 'undefined') __tuff_this.best = best;
}
  if ((rep_cost < best)) {
  best = rep_cost; if (typeof __tuff_this !== 'undefined') __tuff_this.best = best;
}
  (() => { const __recv = curr; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(j2, best); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, j2, best) : vec_set(__recv, j2, best); })();
  j2 = (j2 + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j2 = j2;
}
  let k = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  while ((k <= bn)) {
  (() => { const __recv = prev; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(k, (() => { const __recv = curr; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, k) : vec_get(__recv, k); })()); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, k, (() => { const __recv = curr; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, k) : vec_get(__recv, k); })()) : vec_set(__recv, k, (() => { const __recv = curr; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, k) : vec_get(__recv, k); })()); })();
  k = (k + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = prev; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(bn); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, bn) : vec_get(__recv, bn); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.levenshtein_distance = levenshtein_distance;

const __tuff_outer_for_rslv_utils_find_did_you_mean = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslv_utils_find_did_you_mean(name, candidates) {
  let __tuff_this = { name: name, candidates: candidates, this: __tuff_outer_for_rslv_utils_find_did_you_mean };
  let best = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.best = best;
  let best_dist = 9999; if (typeof __tuff_this !== 'undefined') __tuff_this.best_dist = best_dist;
  let name_len = (0 + (() => { const __recv = name; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.name_len = name_len;
  let threshold = ((name_len / 3) + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.threshold = threshold;
  if ((threshold > 3)) {
  threshold = 3; if (typeof __tuff_this !== 'undefined') __tuff_this.threshold = threshold;
}
  let n = (() => { const __recv = candidates; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  let ci = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ci = ci;
  while ((ci < n)) {
  let cand = (() => { const __recv = candidates; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(ci); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, ci) : vec_get(__recv, ci); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cand = cand;
  let dist = levenshtein_distance(name, cand); if (typeof __tuff_this !== 'undefined') __tuff_this.dist = dist;
  if (((dist <= threshold) && (dist < best_dist))) {
  best_dist = dist; if (typeof __tuff_this !== 'undefined') __tuff_this.best_dist = best_dist;
  best = cand; if (typeof __tuff_this !== 'undefined') __tuff_this.best = best;
}
  ci = (ci + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.ci = ci;
}
  return best;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslv_utils_find_did_you_mean = rslv_utils_find_did_you_mean;

const __tuff_outer_for_fn_type_sig = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fn_type_sig(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_fn_type_sig };
  if ((t === 0)) {
  return "_";
}
  let k = node_kind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_NAMED_TYPE)) {
  return get_interned_str(node_get_data1(t));
}
  if ((k === NK_POINTER_TYPE)) {
  let mutv = node_get_data1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.mutv = mutv;
  let inner = fn_type_sig(node_get_data2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let life_idx = node_get_data4(t); if (typeof __tuff_this !== 'undefined') __tuff_this.life_idx = life_idx;
  let life_prefix = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.life_prefix = life_prefix;
  if ((life_idx !== 0)) {
  life_prefix = (() => { const __recv = get_interned_str(life_idx); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.life_prefix = life_prefix;
}
  if ((mutv === 1)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(life_prefix); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, life_prefix) : str_concat(__recv, life_prefix); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "mut ") : str_concat(__recv, "mut "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })();
}
  return (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(life_prefix); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, life_prefix) : str_concat(__recv, life_prefix); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })();
}
  if ((k === NK_ARRAY_TYPE)) {
  return "Array";
}
  if ((k === NK_TUPLE_TYPE)) {
  return "Tuple";
}
  if ((k === NK_REFINEMENT_TYPE)) {
  return (() => { const __recv = (() => { const __recv = "Ref<"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fn_type_sig(node_get_data1(t))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fn_type_sig(node_get_data1(t))) : str_concat(__recv, fn_type_sig(node_get_data1(t))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(">"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ">") : str_concat(__recv, ">"); })();
}
  if ((k === NK_APPLIED_TYPE)) {
  return (() => { const __recv = get_interned_str(node_get_data1(t)); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(...)"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(...)") : str_concat(__recv, "(...)"); })();
}
  if ((k === NK_UNION_TYPE)) {
  return (() => { const __recv = (() => { const __recv = fn_type_sig(node_get_data1(t)); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "|") : str_concat(__recv, "|"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fn_type_sig(node_get_data2(t))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fn_type_sig(node_get_data2(t))) : str_concat(__recv, fn_type_sig(node_get_data2(t))); })();
}
  if ((k === NK_FUNCTION_TYPE)) {
  let parts = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.parts = parts;
  let ps = node_get_data1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.ps = ps;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = ps; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  (() => { const __recv = parts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(fn_type_sig((() => { const __recv = ps; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, fn_type_sig((() => { const __recv = ps; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())) : vec_push(__recv, fn_type_sig((() => { const __recv = ps; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = parts; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ",") : vec_join(__recv, ","); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = parts; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ",") : vec_join(__recv, ","); })()) : str_concat(__recv, (() => { const __recv = parts; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ",") : vec_join(__recv, ","); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")=>"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")=>") : str_concat(__recv, ")=>"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fn_type_sig(node_get_data2(t))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fn_type_sig(node_get_data2(t))) : str_concat(__recv, fn_type_sig(node_get_data2(t))); })();
}
  return "Unknown";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fn_type_sig = fn_type_sig;

const __tuff_outer_for_fn_decl_sig = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fn_decl_sig(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_fn_decl_sig };
  let gens = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.gens = gens;
  let params = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let ret = node_get_data4(n); if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
  let pparts = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.pparts = pparts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let p = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let pname = get_interned_str((() => { const __recv = p; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = fn_type_sig((() => { const __recv = p; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  (() => { const __recv = pparts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = pname; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ptype) : str_concat(__recv, ptype); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = pname; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ptype) : str_concat(__recv, ptype); })()) : vec_push(__recv, (() => { const __recv = (() => { const __recv = pname; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ptype) : str_concat(__recv, ptype); })()); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let gcount_len = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gcount_len = gcount_len;
  let gcount = int_to_string(gcount_len); if (typeof __tuff_this !== 'undefined') __tuff_this.gcount = gcount;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "g="; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(gcount); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, gcount) : str_concat(__recv, gcount); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";p="); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";p=") : str_concat(__recv, ";p="); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = pparts; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ",") : vec_join(__recv, ","); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = pparts; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ",") : vec_join(__recv, ","); })()) : str_concat(__recv, (() => { const __recv = pparts; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ",") : vec_join(__recv, ","); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";r="); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";r=") : str_concat(__recv, ";r="); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fn_type_sig(ret)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fn_type_sig(ret)) : str_concat(__recv, fn_type_sig(ret)); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fn_decl_sig = fn_decl_sig;

const __tuff_outer_for_rslv_utils_validate_expect_actual_pairs = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslv_utils_validate_expect_actual_pairs(body) {
  let __tuff_this = { body: body, this: __tuff_outer_for_rslv_utils_validate_expect_actual_pairs };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = body; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if (((kind === NK_EXPECT_FN_DECL) || (kind === NK_ACTUAL_FN_DECL))) {
  let name = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let expect_count = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.expect_count = expect_count;
  let actual_count = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.actual_count = actual_count;
  let expect_node = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.expect_node = expect_node;
  let actual_node = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.actual_node = actual_node;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < len)) {
  let cand = (() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cand = cand;
  let ck = node_kind(cand); if (typeof __tuff_this !== 'undefined') __tuff_this.ck = ck;
  if ((((ck === NK_EXPECT_FN_DECL) || (ck === NK_ACTUAL_FN_DECL)) && (() => { const __recv = get_interned_str(node_get_data1(cand)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, name) : str_eq(__recv, name); })())) {
  if ((ck === NK_EXPECT_FN_DECL)) {
  expect_count = (expect_count + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.expect_count = expect_count;
  expect_node = cand; if (typeof __tuff_this !== 'undefined') __tuff_this.expect_node = expect_node;
} else {
  actual_count = (actual_count + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.actual_count = actual_count;
  actual_node = cand; if (typeof __tuff_this !== 'undefined') __tuff_this.actual_node = actual_node;
}
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  if (((expect_count !== 1) || (actual_count !== 1))) {
  rslv_utils_panic_node(stmt, "E_EXPECT_ACTUAL_PAIRING", (() => { const __recv = (() => { const __recv = "expect/actual pairing requires exactly one expect and one actual for '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "Platform declarations require exactly one expect and one actual declaration for each symbol.", "Declare exactly one 'expect fn' and one matching 'actual fn' for each platform symbol.");
}
  if ((!(() => { const __recv = fn_decl_sig(expect_node); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(fn_decl_sig(actual_node)); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, fn_decl_sig(actual_node)) : str_eq(__recv, fn_decl_sig(actual_node)); })())) {
  rslv_utils_panic_node(stmt, "E_EXPECT_ACTUAL_SIGNATURE_MISMATCH", (() => { const __recv = (() => { const __recv = "expect/actual signatures do not match for '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "An expect declaration and its actual implementation have different signatures.", "Make generic params, parameter list, and return type identical between expect and actual declarations.");
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslv_utils_validate_expect_actual_pairs = rslv_utils_validate_expect_actual_pairs;

const __tuff_outer_for_rslv_utils_scope_define = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslv_utils_scope_define(scopes, depth, name, err_node) {
  let __tuff_this = { scopes: scopes, depth: depth, name: name, err_node: err_node, this: __tuff_outer_for_rslv_utils_scope_define };
  let scope = (() => { const __recv = scopes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(depth); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, depth) : vec_get(__recv, depth); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.scope = scope;
  if ((() => { const __recv = scope; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })()) {
  rslv_utils_panic_node(err_node, "E_RESOLVE_SHADOWING", (() => { const __recv = "Variable shadowing/redeclaration is not allowed: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(), "A name was declared multiple times in the same lexical scope.", "Rename one of the bindings or move it to a different scope.");
}
  (() => { const __recv = scope; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, name) : set_add(__recv, name); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslv_utils_scope_define = rslv_utils_scope_define;

const __tuff_outer_for_rslv_utils_scope_has = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslv_utils_scope_has(scopes, depth, name) {
  let __tuff_this = { scopes: scopes, depth: depth, name: name, this: __tuff_outer_for_rslv_utils_scope_has };
  let i = depth; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i >= 0)) {
  if ((() => { const __recv = (() => { const __recv = scopes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })()) {
  return true;
}
  i = (i - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslv_utils_scope_has = rslv_utils_scope_has;

const __tuff_outer_for_rslv_utils_is_host_builtin_name = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslv_utils_is_host_builtin_name(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_rslv_utils_is_host_builtin_name };
  return (((((((((() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("sizeOf"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "sizeOf") : str_eq(__recv, "sizeOf"); })() || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("malloc"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "malloc") : str_eq(__recv, "malloc"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("realloc"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "realloc") : str_eq(__recv, "realloc"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("free"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "free") : str_eq(__recv, "free"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("memcpy"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "memcpy") : str_eq(__recv, "memcpy"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("memset"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "memset") : str_eq(__recv, "memset"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("drop"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "drop") : str_eq(__recv, "drop"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("panic"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "panic") : str_eq(__recv, "panic"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslv_utils_is_host_builtin_name = rslv_utils_is_host_builtin_name;

const __tuff_outer_for_lifetime_scope_has = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lifetime_scope_has(resolve_lifetime_scopes, name) {
  let __tuff_this = { resolve_lifetime_scopes: resolve_lifetime_scopes, name: name, this: __tuff_outer_for_lifetime_scope_has };
  let len = (() => { const __recv = resolve_lifetime_scopes; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  if ((() => { const __recv = (() => { const __recv = resolve_lifetime_scopes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })()) {
  return true;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lifetime_scope_has = lifetime_scope_has;

const __tuff_outer_for_rslv_utils_resolve_type_lifetimes = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslv_utils_resolve_type_lifetimes(t, resolve_lifetime_scopes, err_node) {
  let __tuff_this = { t: t, resolve_lifetime_scopes: resolve_lifetime_scopes, err_node: err_node, this: __tuff_outer_for_rslv_utils_resolve_type_lifetimes };
  if ((t === 0)) {
  return 0;
}
  let k = node_kind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_POINTER_TYPE)) {
  let life_idx = node_get_data4(t); if (typeof __tuff_this !== 'undefined') __tuff_this.life_idx = life_idx;
  if ((life_idx !== 0)) {
  let lname = get_interned_str(life_idx); if (typeof __tuff_this !== 'undefined') __tuff_this.lname = lname;
  if ((!lifetime_scope_has(resolve_lifetime_scopes, lname))) {
  rslv_utils_panic_node(err_node, "E_RESOLVE_UNDEFINED_LIFETIME", (() => { const __recv = (() => { const __recv = "Undefined lifetime '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lname) : str_concat(__recv, lname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "A pointer type annotation references a lifetime name that is not declared in any active lifetime block.", "Declare the lifetime in an enclosing `lifetime ... { ... }` block before using it in pointer types.");
}
}
  rslv_utils_resolve_type_lifetimes(node_get_data2(t), resolve_lifetime_scopes, err_node);
  return 0;
}
  if ((k === NK_ARRAY_TYPE)) {
  rslv_utils_resolve_type_lifetimes(node_get_data1(t), resolve_lifetime_scopes, err_node);
  return 0;
}
  if ((k === NK_REFINEMENT_TYPE)) {
  rslv_utils_resolve_type_lifetimes(node_get_data1(t), resolve_lifetime_scopes, err_node);
  return 0;
}
  if ((k === NK_UNION_TYPE)) {
  rslv_utils_resolve_type_lifetimes(node_get_data1(t), resolve_lifetime_scopes, err_node);
  rslv_utils_resolve_type_lifetimes(node_get_data2(t), resolve_lifetime_scopes, err_node);
  return 0;
}
  if ((k === NK_TUPLE_TYPE)) {
  let members = node_get_data1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.members = members;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = members; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  rslv_utils_resolve_type_lifetimes((() => { const __recv = members; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), resolve_lifetime_scopes, err_node);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((k === NK_FUNCTION_TYPE)) {
  let ps = node_get_data1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.ps = ps;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = ps; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  rslv_utils_resolve_type_lifetimes((() => { const __recv = ps; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), resolve_lifetime_scopes, err_node);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  rslv_utils_resolve_type_lifetimes(node_get_data2(t), resolve_lifetime_scopes, err_node);
  return 0;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslv_utils_resolve_type_lifetimes = rslv_utils_resolve_type_lifetimes;

const __tuff_outer_for_selfhost_resolver_utils_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_resolver_utils_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_resolver_utils_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_resolver_utils_marker = selfhost_resolver_utils_marker;

let rslv_current_node = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.rslv_current_node = rslv_current_node;

const __tuff_outer_for_rslv_panic_loc = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslv_panic_loc(code, msg, reason, fix) {
  let __tuff_this = { code: code, msg: msg, reason: reason, fix: fix, this: __tuff_outer_for_rslv_panic_loc };
  return panic_with_code_loc(code, msg, reason, fix, node_get_line(rslv_current_node), node_get_col(rslv_current_node));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslv_panic_loc = rslv_panic_loc;

let resolve_lifetime_scopes = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_lifetime_scopes = resolve_lifetime_scopes;

let resolve_global_decl_nodes = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_global_decl_nodes = resolve_global_decl_nodes;

let resolve_global_names_list = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_global_names_list = resolve_global_names_list;

const __tuff_outer_for_resolve_expr_identifier = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_expr_identifier(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolve_expr_identifier };
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((((!rslv_utils_scope_has(scopes, depth, name)) && (!(() => { const __recv = globals; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })())) && (!rslv_utils_is_host_builtin_name(name)))) {
  let suggestion = rslv_utils_find_did_you_mean(name, resolve_global_names_list); if (typeof __tuff_this !== 'undefined') __tuff_this.suggestion = suggestion;
  let fix_msg = "Declare the identifier before use or import it from the correct module."; if (typeof __tuff_this !== 'undefined') __tuff_this.fix_msg = fix_msg;
  if ((!(() => { const __recv = suggestion; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  fix_msg = (() => { const __recv = (() => { const __recv = "Did you mean '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(suggestion); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, suggestion) : str_concat(__recv, suggestion); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'? Declare or import it from the correct module."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'? Declare or import it from the correct module.") : str_concat(__recv, "'? Declare or import it from the correct module."); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fix_msg = fix_msg;
}
  rslv_panic_loc("E_RESOLVE_UNKNOWN_IDENTIFIER", (() => { const __recv = "Unknown identifier: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(), "The identifier is not declared in local scope, global declarations, or imports.", fix_msg);
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_expr_identifier = resolve_expr_identifier;

const __tuff_outer_for_resolve_expr_call = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_expr_call(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolve_expr_call };
  let callee = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  if (((node_kind(callee) === NK_IDENTIFIER) && (() => { const __recv = get_interned_str(node_get_data1(callee)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("drop"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "drop") : str_eq(__recv, "drop"); })())) {
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() !== 1)) {
  rslv_panic_loc("E_RESOLVE_UNKNOWN_IDENTIFIER", "drop expects exactly one argument", "Built-in drop requires exactly one receiver value.", "Use drop(value) or value.drop() with exactly one receiver value.");
}
  resolve_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(), globals, scopes, depth);
  return 0;
}
  if ((((node_kind(callee) === NK_IDENTIFIER) && (() => { const __recv = get_interned_str(node_get_data1(callee)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "into") : str_eq(__recv, "into"); })()) && (node_get_data3(n) === 1))) {
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() < 1)) {
  rslv_panic_loc("E_RESOLVE_UNKNOWN_IDENTIFIER", "into conversion requires a receiver", "Method-sugar into conversion requires a source value as receiver.", "Use value.into<Contract>(...) with a receiver value.");
}
  let type_args = node_get_data4(n); if (typeof __tuff_this !== 'undefined') __tuff_this.type_args = type_args;
  let contract_name = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.contract_name = contract_name;
  if ((((() => { const __recv = type_args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 1) && (node_kind((() => { const __recv = type_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()) === NK_NAMED_TYPE))) {
  contract_name = get_interned_str(node_get_data1((() => { const __recv = type_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })())); if (typeof __tuff_this !== 'undefined') __tuff_this.contract_name = contract_name;
}
  let contract_label = contract_name; if (typeof __tuff_this !== 'undefined') __tuff_this.contract_label = contract_label;
  if ((() => { const __recv = contract_label; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) {
  contract_label = "<missing>"; if (typeof __tuff_this !== 'undefined') __tuff_this.contract_label = contract_label;
}
  if (((() => { const __recv = contract_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })() || (!(() => { const __recv = globals; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(contract_name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, contract_name) : set_has(__recv, contract_name); })()))) {
  rslv_panic_loc("E_RESOLVE_UNKNOWN_IDENTIFIER", (() => { const __recv = (() => { const __recv = "Unknown contract '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(contract_label); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, contract_label) : str_concat(__recv, contract_label); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "An into conversion referenced a contract that is not declared in scope.", "Use value.into<Contract>(...) with a declared contract name.");
}
  resolve_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(), globals, scopes, depth);
  let i = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  resolve_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), globals, scopes, depth);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((node_get_data3(n) !== 1)) {
  resolve_expr(node_get_data1(n), globals, scopes, depth);
}
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  resolve_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), globals, scopes, depth);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_expr_call = resolve_expr_call;

const __tuff_outer_for_resolve_expr_match = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_expr_match(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolve_expr_match };
  resolve_expr(node_get_data1(n), globals, scopes, depth);
  let cases = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let case_node = (() => { const __recv = cases; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.case_node = case_node;
  let pat = (() => { const __recv = case_node; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  let body = (() => { const __recv = case_node; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let next_depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.next_depth = next_depth;
  (() => { const __recv = scopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  if ((node_kind(pat) === NK_STRUCT_PAT)) {
  let fields = node_get_data2(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let fLen = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fLen = fLen;
  while ((j < fLen)) {
  rslv_utils_scope_define(scopes, next_depth, get_interned_str((() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()), pat);
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
} else { if ((node_kind(pat) === NK_NAME_PAT)) {
  let pat_name = get_interned_str(node_get_data1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.pat_name = pat_name;
  if ((!(() => { const __recv = globals; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(pat_name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, pat_name) : set_has(__recv, pat_name); })())) {
  rslv_utils_scope_define(scopes, next_depth, pat_name, pat);
}
} }
  resolve_stmt(body, globals, scopes, next_depth);
  (() => { const __recv = scopes; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_expr_match = resolve_expr_match;

const __tuff_outer_for_resolve_expr_lambda = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_expr_lambda(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolve_expr_lambda };
  let next_depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.next_depth = next_depth;
  (() => { const __recv = scopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  let params = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let param = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  rslv_utils_scope_define(scopes, next_depth, get_interned_str((() => { const __recv = param; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()), n);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  resolve_stmt(node_get_data2(n), globals, scopes, next_depth);
  (() => { const __recv = scopes; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_expr_lambda = resolve_expr_lambda;

const __tuff_outer_for_resolve_expr_fn_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_expr_fn_expr(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolve_expr_fn_expr };
  let next_depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.next_depth = next_depth;
  (() => { const __recv = scopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  let fname_idx = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fname_idx = fname_idx;
  if ((fname_idx !== 0)) {
  rslv_utils_scope_define(scopes, next_depth, get_interned_str(fname_idx), n);
}
  let params = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let param = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  rslv_utils_scope_define(scopes, next_depth, get_interned_str((() => { const __recv = param; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()), n);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  resolve_stmt(node_get_data5(n), globals, scopes, next_depth);
  (() => { const __recv = scopes; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_expr_fn_expr = resolve_expr_fn_expr;

const __tuff_outer_for_resolve_stmt_block = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_stmt_block(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolve_stmt_block };
  let next_depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.next_depth = next_depth;
  (() => { const __recv = scopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  let stmts = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let stmt_kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt_kind = stmt_kind;
  if ((((stmt_kind === NK_FN_DECL) || (stmt_kind === NK_CLASS_FN_DECL)) || (stmt_kind === NK_ACTUAL_FN_DECL))) {
  rslv_utils_scope_define(scopes, next_depth, get_interned_str(node_get_data1(stmt)), stmt);
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  resolve_stmt((() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), globals, scopes, next_depth);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  (() => { const __recv = scopes; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_stmt_block = resolve_stmt_block;

const __tuff_outer_for_resolve_stmt_fn_decl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_stmt_fn_decl(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolve_stmt_fn_decl };
  let next_depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.next_depth = next_depth;
  (() => { const __recv = scopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  let params = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let param = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  rslv_utils_scope_define(scopes, next_depth, get_interned_str((() => { const __recv = param; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()), n);
  rslv_utils_resolve_type_lifetimes((() => { const __recv = param; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), resolve_lifetime_scopes, n);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  rslv_utils_resolve_type_lifetimes(node_get_data4(n), resolve_lifetime_scopes, n);
  resolve_stmt(node_get_data5(n), globals, scopes, next_depth);
  (() => { const __recv = scopes; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_stmt_fn_decl = resolve_stmt_fn_decl;

const __tuff_outer_for_resolve_stmt_let_or_import = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_stmt_let_or_import(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolve_stmt_let_or_import };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LET_DECL)) {
  if ((node_get_data2(n) !== 0)) {
  rslv_utils_resolve_type_lifetimes(node_get_data2(n), resolve_lifetime_scopes, n);
}
  resolve_expr(node_get_data3(n), globals, scopes, depth);
  rslv_utils_scope_define(scopes, depth, get_interned_str(node_get_data1(n)), n);
  return 1;
}
  if ((kind === NK_IMPORT_DECL)) {
  let names = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = names; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  rslv_utils_scope_define(scopes, depth, get_interned_str((() => { const __recv = names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()), n);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 1;
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  return 1;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_stmt_let_or_import = resolve_stmt_let_or_import;

const __tuff_outer_for_resolve_stmt_flow = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_stmt_flow(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolve_stmt_flow };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_EXPR_STMT)) {
  resolve_expr(node_get_data1(n), globals, scopes, depth);
  return 1;
}
  if ((kind === NK_ASSIGN_STMT)) {
  resolve_expr(node_get_data1(n), globals, scopes, depth);
  resolve_expr(node_get_data2(n), globals, scopes, depth);
  return 1;
}
  if ((kind === NK_RETURN_STMT)) {
  resolve_expr(node_get_data1(n), globals, scopes, depth);
  return 1;
}
  if ((kind === NK_IF_STMT)) {
  resolve_expr(node_get_data1(n), globals, scopes, depth);
  resolve_stmt(node_get_data2(n), globals, scopes, depth);
  if ((node_get_data3(n) !== 0)) {
  resolve_stmt(node_get_data3(n), globals, scopes, depth);
}
  return 1;
}
  if ((kind === NK_FOR_STMT)) {
  let next_depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.next_depth = next_depth;
  (() => { const __recv = scopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  rslv_utils_scope_define(scopes, next_depth, get_interned_str(node_get_data1(n)), n);
  resolve_expr(node_get_data2(n), globals, scopes, next_depth);
  resolve_expr(node_get_data3(n), globals, scopes, next_depth);
  resolve_stmt(node_get_data4(n), globals, scopes, next_depth);
  (() => { const __recv = scopes; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  return 1;
}
  if ((kind === NK_WHILE_STMT)) {
  resolve_expr(node_get_data1(n), globals, scopes, depth);
  resolve_stmt(node_get_data2(n), globals, scopes, depth);
  return 1;
}
  if ((kind === NK_LOOP_STMT)) {
  resolve_stmt(node_get_data1(n), globals, scopes, depth);
  return 1;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_stmt_flow = resolve_stmt_flow;

const __tuff_outer_for_resolve_stmt_lifetime_or_into = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_stmt_lifetime_or_into(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolve_stmt_lifetime_or_into };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LIFETIME_STMT)) {
  let next_depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.next_depth = next_depth;
  (() => { const __recv = scopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  let lifetime_names = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.lifetime_names = lifetime_names;
  let lifetime_scope = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.lifetime_scope = lifetime_scope;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = lifetime_names; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let lname = get_interned_str((() => { const __recv = lifetime_names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.lname = lname;
  if ((() => { const __recv = lifetime_scope; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(lname); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, lname) : set_has(__recv, lname); })()) {
  rslv_panic_loc("E_RESOLVE_DUPLICATE_LIFETIME", (() => { const __recv = (() => { const __recv = "Duplicate lifetime name '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lname) : str_concat(__recv, lname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' in lifetime block"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' in lifetime block") : str_concat(__recv, "' in lifetime block"); })(), "A lifetime block contains duplicate lifetime names.", "Use unique lifetime names within a lifetime declaration block.");
}
  (() => { const __recv = lifetime_scope; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(lname); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, lname) : set_add(__recv, lname); })();
  rslv_utils_scope_define(scopes, next_depth, lname, n);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  (() => { const __recv = resolve_lifetime_scopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(lifetime_scope); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, lifetime_scope) : vec_push(__recv, lifetime_scope); })();
  resolve_stmt(node_get_data2(n), globals, scopes, next_depth);
  (() => { const __recv = resolve_lifetime_scopes; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  (() => { const __recv = scopes; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  return 1;
}
  if ((kind === NK_INTO_STMT)) {
  let cname = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
  if ((!(() => { const __recv = globals; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, cname) : set_has(__recv, cname); })())) {
  rslv_panic_loc("E_RESOLVE_UNKNOWN_IDENTIFIER", (() => { const __recv = "Unknown contract: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cname) : str_concat(__recv, cname); })(), "An into statement referenced a contract that is not declared in scope.", "Declare the contract before using 'into'.");
}
  return 1;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_stmt_lifetime_or_into = resolve_stmt_lifetime_or_into;

const __tuff_outer_for_resolve_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_expr(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolve_expr };
  if ((n === 0)) {
  return 0;
}
  rslv_current_node = n; if (typeof __tuff_this !== 'undefined') __tuff_this.rslv_current_node = rslv_current_node;
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_IDENTIFIER)) {
  return resolve_expr_identifier(n, globals, scopes, depth);
}
  if ((kind === NK_BINARY_EXPR)) {
  resolve_expr(node_get_data2(n), globals, scopes, depth);
  resolve_expr(node_get_data3(n), globals, scopes, depth);
  return 0;
}
  if (((kind === NK_UNARY_EXPR) || (kind === NK_UNWRAP_EXPR))) {
  resolve_expr(node_get_data2(n), globals, scopes, depth);
  if ((kind === NK_UNWRAP_EXPR)) {
  resolve_expr(node_get_data1(n), globals, scopes, depth);
}
  return 0;
}
  if ((kind === NK_CALL_EXPR)) {
  return resolve_expr_call(n, globals, scopes, depth);
}
  if ((kind === NK_MEMBER_EXPR)) {
  resolve_expr(node_get_data1(n), globals, scopes, depth);
  return 0;
}
  if ((kind === NK_INDEX_EXPR)) {
  resolve_expr(node_get_data1(n), globals, scopes, depth);
  resolve_expr(node_get_data2(n), globals, scopes, depth);
  return 0;
}
  if ((kind === NK_STRUCT_INIT)) {
  let type_name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.type_name = type_name;
  if ((!(() => { const __recv = globals; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, type_name) : set_has(__recv, type_name); })())) {
  rslv_panic_loc("E_RESOLVE_UNKNOWN_STRUCT", (() => { const __recv = "Unknown struct/type in initializer: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, type_name) : str_concat(__recv, type_name); })(), "A struct initializer referenced a type that is not declared in the merged module scope.", "Declare the struct/type first or import the module that defines it.");
}
  let fields = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  resolve_expr((() => { const __recv = field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), globals, scopes, depth);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_TUPLE_EXPR)) {
  let items = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = items; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  resolve_expr((() => { const __recv = items; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), globals, scopes, depth);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_IF_EXPR)) {
  resolve_expr(node_get_data1(n), globals, scopes, depth);
  resolve_stmt(node_get_data2(n), globals, scopes, depth);
  if ((node_get_data3(n) !== 0)) {
  resolve_stmt(node_get_data3(n), globals, scopes, depth);
}
  return 0;
}
  if ((kind === NK_MATCH_EXPR)) {
  return resolve_expr_match(n, globals, scopes, depth);
}
  if ((kind === NK_IS_EXPR)) {
  resolve_expr(node_get_data1(n), globals, scopes, depth);
  return 0;
}
  if ((kind === NK_LAMBDA_EXPR)) {
  return resolve_expr_lambda(n, globals, scopes, depth);
}
  if ((kind === NK_FN_EXPR)) {
  return resolve_expr_fn_expr(n, globals, scopes, depth);
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_expr = resolve_expr;

const __tuff_outer_for_resolve_stmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_stmt(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolve_stmt };
  if ((n === 0)) {
  return 0;
}
  rslv_current_node = n; if (typeof __tuff_this !== 'undefined') __tuff_this.rslv_current_node = rslv_current_node;
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_BLOCK)) {
  return resolve_stmt_block(n, globals, scopes, depth);
}
  if ((kind === NK_EXPECT_FN_DECL)) {
  return 0;
}
  if ((kind === NK_CONTRACT_DECL)) {
  return 0;
}
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  return resolve_stmt_fn_decl(n, globals, scopes, depth);
}
  if ((resolve_stmt_let_or_import(n, globals, scopes, depth) === 1)) {
  return 0;
}
  if ((resolve_stmt_flow(n, globals, scopes, depth) === 1)) {
  return 0;
}
  if ((resolve_stmt_lifetime_or_into(n, globals, scopes, depth) === 1)) {
  return 0;
}
  if (((((((((((kind === NK_TYPE_ALIAS) || (kind === NK_DEP_TYPE_ALIAS)) || (kind === NK_STRUCT_DECL)) || (kind === NK_ENUM_DECL)) || (kind === NK_EXTERN_LET_DECL)) || (kind === NK_EXTERN_TYPE_DECL)) || (kind === NK_EXTERN_IMPORT_DECL)) || (kind === NK_OBJECT_DECL)) || (kind === NK_CONTRACT_DECL)) || (kind === NK_EXPECT_FN_DECL))) {
  return 0;
}
  resolve_expr(n, globals, scopes, depth);
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_stmt = resolve_stmt;

const __tuff_outer_for_resolve_names = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolve_names(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_resolve_names };
  (() => { const __recv = resolve_lifetime_scopes; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  (() => { const __recv = resolve_global_names_list; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  resolve_global_decl_nodes = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_global_decl_nodes = resolve_global_decl_nodes;
  let globals = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.globals = globals;
  let body = node_get_data1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  rslv_utils_validate_expect_actual_pairs(body);
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = body; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if (((((((((((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL)) || (kind === NK_STRUCT_DECL)) || (kind === NK_ENUM_DECL)) || (kind === NK_OBJECT_DECL)) || (kind === NK_CONTRACT_DECL)) || (kind === NK_TYPE_ALIAS)) || (kind === NK_DEP_TYPE_ALIAS)) || (kind === NK_LET_DECL)) || (kind === NK_EXTERN_LET_DECL)) || (kind === NK_EXTERN_TYPE_DECL))) {
  let gname = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.gname = gname;
  if ((() => { const __recv = globals; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(gname); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, gname) : set_has(__recv, gname); })()) {
  let first_node = (() => { const __recv = resolve_global_decl_nodes; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(gname); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, gname) : map_get(__recv, gname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.first_node = first_node;
  let first_line = int_to_string(node_get_line(first_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.first_line = first_line;
  let first_col = int_to_string(node_get_col(first_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.first_col = first_col;
  rslv_panic_loc("E_RESOLVE_SHADOWING", (() => { const __recv = "Duplicate global declaration: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(gname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, gname) : str_concat(__recv, gname); })(), (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "First declared at line "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(first_line); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, first_line) : str_concat(__recv, first_line); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(", col "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ", col ") : str_concat(__recv, ", col "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(first_col); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, first_col) : str_concat(__recv, first_col); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })(), "Rename one of the global declarations or split conflicting declarations into separate modules.");
}
  (() => { const __recv = globals; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(gname); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, gname) : set_add(__recv, gname); })();
  (() => { const __recv = resolve_global_names_list; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(gname); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, gname) : vec_push(__recv, gname); })();
  (() => { const __recv = resolve_global_decl_nodes; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(gname, stmt); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, gname, stmt) : map_set(__recv, gname, stmt); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let topScopes = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.topScopes = topScopes;
  (() => { const __recv = topScopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  resolve_stmt((() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), globals, topScopes, 0);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return program;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolve_names = resolve_names;

const __tuff_outer_for_selfhost_resolver_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_resolver_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_resolver_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_resolver_marker = selfhost_resolver_marker;

let tc_current_node = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.tc_current_node = tc_current_node;

let tc_type_name_cache = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_type_name_cache = tc_type_name_cache;

const __tuff_outer_for_tc_panic_loc = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tc_panic_loc(code, msg, reason, fix) {
  let __tuff_this = { code: code, msg: msg, reason: reason, fix: fix, this: __tuff_outer_for_tc_panic_loc };
  return panic_with_code_loc(code, msg, reason, fix, node_get_line(tc_current_node), node_get_col(tc_current_node));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tc_panic_loc = tc_panic_loc;

const __tuff_outer_for_union_type_contains = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function union_type_contains(union_name, candidate) {
  let __tuff_this = { union_name: union_name, candidate: candidate, this: __tuff_outer_for_union_type_contains };
  let start = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.start = start;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = union_name; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })())) {
  if (((() => { const __recv = union_name; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })() === 124)) {
  if ((() => { const __recv = (() => { const __recv = union_name; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(start, i); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, start, i) : str_slice(__recv, start, i); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(candidate); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, candidate) : str_eq(__recv, candidate); })()) {
  return true;
}
  start = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.start = start;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = (() => { const __recv = union_name; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(start, (() => { const __recv = union_name; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, start, (() => { const __recv = union_name; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()) : str_slice(__recv, start, (() => { const __recv = union_name; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(candidate); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, candidate) : str_eq(__recv, candidate); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.union_type_contains = union_type_contains;

const __tuff_outer_for_is_this_return_type_for = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_this_return_type_for(actual, declared) {
  let __tuff_this = { actual: actual, declared: declared, this: __tuff_outer_for_is_this_return_type_for };
  if ((!(() => { const __recv = actual; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("__this_"); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "__this_") : str_starts_with(__recv, "__this_"); })())) {
  return false;
}
  let n = (() => { const __recv = actual; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  return (() => { const __recv = (() => { const __recv = actual; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(7, n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 7, n) : str_slice(__recv, 7, n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(declared); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, declared) : str_eq(__recv, declared); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_this_return_type_for = is_this_return_type_for;

const __tuff_outer_for_type_name_from_type_node = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function type_name_from_type_node(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_type_name_from_type_node };
  if ((() => { const __recv = tc_type_name_cache; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(t); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, t) : map_has(__recv, t); })()) {
  return (() => { const __recv = tc_type_name_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(t); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, t) : map_get(__recv, t); })();
}
  if ((t === 0)) {
  (() => { const __recv = tc_type_name_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(t, "Unknown"); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, t, "Unknown") : map_set(__recv, t, "Unknown"); })();
  return "Unknown";
}
  let result = "Unknown"; if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  let k = node_kind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === 40)) {
  result = get_interned_str(node_get_data1(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  let generic_args = node_get_data2(t); if (typeof __tuff_this !== 'undefined') __tuff_this.generic_args = generic_args;
  let named_actual_arity = (() => { const __recv = generic_args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.named_actual_arity = named_actual_arity;
  if ((() => { const __recv = tc_extern_type_params; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(result); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, result) : map_has(__recv, result); })()) {
  let extern_expected_arity = (() => { const __recv = tc_extern_type_params; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(result); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, result) : map_get(__recv, result); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.extern_expected_arity = extern_expected_arity;
  if ((named_actual_arity !== extern_expected_arity)) {
  tc_panic_loc("E_TYPE_APPLIED_ARITY", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "'"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(result); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, result) : str_concat(__recv, result); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' applied with "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' applied with ") : str_concat(__recv, "' applied with "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(named_actual_arity)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(named_actual_arity)) : str_concat(__recv, int_to_string(named_actual_arity)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" argument(s), expected "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " argument(s), expected ") : str_concat(__recv, " argument(s), expected "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(extern_expected_arity)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(extern_expected_arity)) : str_concat(__recv, int_to_string(extern_expected_arity)); })(), "Extern types must be applied with exactly the number of generic parameters declared by their extern type declaration.", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Provide exactly "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(extern_expected_arity)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(extern_expected_arity)) : str_concat(__recv, int_to_string(extern_expected_arity)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" argument(s) to '"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " argument(s) to '") : str_concat(__recv, " argument(s) to '"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(result); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, result) : str_concat(__recv, result); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'.") : str_concat(__recv, "'."); })());
}
}
  (() => { const __recv = tc_type_name_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, t, result) : map_set(__recv, t, result); })();
  return result;
}
  if ((k === 41)) {
  let mutable = node_get_data1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.mutable = mutable;
  let inner = type_name_from_type_node(node_get_data2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let move_ptr = node_get_data3(t); if (typeof __tuff_this !== 'undefined') __tuff_this.move_ptr = move_ptr;
  let life_idx = node_get_data4(t); if (typeof __tuff_this !== 'undefined') __tuff_this.life_idx = life_idx;
  let life_prefix = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.life_prefix = life_prefix;
  if ((life_idx !== 0)) {
  life_prefix = (() => { const __recv = get_interned_str(life_idx); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.life_prefix = life_prefix;
}
  if ((move_ptr === 1)) {
  result = (() => { const __recv = (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(life_prefix); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, life_prefix) : str_concat(__recv, life_prefix); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("move "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "move ") : str_concat(__recv, "move "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  (() => { const __recv = tc_type_name_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, t, result) : map_set(__recv, t, result); })();
  return result;
}
  if ((mutable === 1)) {
  result = (() => { const __recv = (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(life_prefix); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, life_prefix) : str_concat(__recv, life_prefix); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "mut ") : str_concat(__recv, "mut "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  (() => { const __recv = tc_type_name_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, t, result) : map_set(__recv, t, result); })();
  return result;
}
  result = (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(life_prefix); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, life_prefix) : str_concat(__recv, life_prefix); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  (() => { const __recv = tc_type_name_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, t, result) : map_set(__recv, t, result); })();
  return result;
}
  if ((k === 44)) {
  result = type_name_from_type_node(node_get_data1(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  (() => { const __recv = tc_type_name_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, t, result) : map_set(__recv, t, result); })();
  return result;
}
  if ((k === 71)) {
  let alias_name = get_interned_str(node_get_data1(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  let args = node_get_data2(t); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let actual_arity = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.actual_arity = actual_arity;
  if ((() => { const __recv = tc_extern_type_params; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, alias_name) : map_has(__recv, alias_name); })()) {
  let extern_expected_arity = (() => { const __recv = tc_extern_type_params; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, alias_name) : map_get(__recv, alias_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.extern_expected_arity = extern_expected_arity;
  if ((actual_arity !== extern_expected_arity)) {
  tc_panic_loc("E_TYPE_APPLIED_ARITY", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "'"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias_name) : str_concat(__recv, alias_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' applied with "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' applied with ") : str_concat(__recv, "' applied with "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(actual_arity)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(actual_arity)) : str_concat(__recv, int_to_string(actual_arity)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" argument(s), expected "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " argument(s), expected ") : str_concat(__recv, " argument(s), expected "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(extern_expected_arity)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(extern_expected_arity)) : str_concat(__recv, int_to_string(extern_expected_arity)); })(), "Extern types must be applied with exactly the number of generic parameters declared by their extern type declaration.", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Provide exactly "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(extern_expected_arity)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(extern_expected_arity)) : str_concat(__recv, int_to_string(extern_expected_arity)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" argument(s) to '"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " argument(s) to '") : str_concat(__recv, " argument(s) to '"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias_name) : str_concat(__recv, alias_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'.") : str_concat(__recv, "'."); })());
}
}
  if ((() => { const __recv = tc_dep_type_alias_params; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, alias_name) : map_has(__recv, alias_name); })()) {
  let expected_arity = (() => { const __recv = tc_dep_type_alias_params; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, alias_name) : map_get(__recv, alias_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_arity = expected_arity;
  if ((actual_arity !== expected_arity)) {
  tc_panic_loc("E_TYPE_APPLIED_ARITY", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "'"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias_name) : str_concat(__recv, alias_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' applied with "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' applied with ") : str_concat(__recv, "' applied with "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(actual_arity)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(actual_arity)) : str_concat(__recv, int_to_string(actual_arity)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" argument(s), expected "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " argument(s), expected ") : str_concat(__recv, " argument(s), expected "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(expected_arity)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(expected_arity)) : str_concat(__recv, int_to_string(expected_arity)); })(), "Dependent type aliases must be applied with exactly the number of arguments declared in the type parameter list.", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Provide exactly "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(expected_arity)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(expected_arity)) : str_concat(__recv, int_to_string(expected_arity)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" argument(s) to '"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " argument(s) to '") : str_concat(__recv, " argument(s) to '"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias_name) : str_concat(__recv, alias_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'.") : str_concat(__recv, "'."); })());
}
}
  result = alias_name; if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  (() => { const __recv = tc_type_name_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, t, result) : map_set(__recv, t, result); })();
  return result;
}
  if ((k === 45)) {
  let left = type_name_from_type_node(node_get_data1(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  let right = type_name_from_type_node(node_get_data2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  result = (() => { const __recv = (() => { const __recv = left; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "|") : str_concat(__recv, "|"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, right) : str_concat(__recv, right); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  (() => { const __recv = tc_type_name_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, t, result) : map_set(__recv, t, result); })();
  return result;
}
  (() => { const __recv = tc_type_name_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, t, result) : map_set(__recv, t, result); })();
  return result;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.type_name_from_type_node = type_name_from_type_node;

const __tuff_outer_for_pointer_types_compatible = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pointer_types_compatible(expected, actual) {
  let __tuff_this = { expected: expected, actual: actual, this: __tuff_outer_for_pointer_types_compatible };
  if ((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(actual); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, actual) : str_eq(__recv, actual); })()) {
  return true;
}
  if ((() => { const __recv = expected; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, "|") : str_includes(__recv, "|"); })()) {
  if (union_type_contains(expected, actual)) {
  return true;
}
}
  if (((() => { const __recv = expected; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "*") : str_starts_with(__recv, "*"); })() && (() => { const __recv = actual; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "*") : str_starts_with(__recv, "*"); })())) {
  let expected_body = (() => { const __recv = expected; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(1, (() => { const __recv = expected; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 1, (() => { const __recv = expected; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()) : str_slice(__recv, 1, (() => { const __recv = expected; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_body = expected_body;
  let actual_body = (() => { const __recv = actual; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(1, (() => { const __recv = actual; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 1, (() => { const __recv = actual; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()) : str_slice(__recv, 1, (() => { const __recv = actual; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.actual_body = actual_body;
  let expected_has_life = (((!(() => { const __recv = expected_body; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "mut ") : str_starts_with(__recv, "mut "); })()) && (!(() => { const __recv = expected_body; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("move "); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "move ") : str_starts_with(__recv, "move "); })())) && (() => { const __recv = expected_body; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, " ") : str_includes(__recv, " "); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_has_life = expected_has_life;
  let actual_has_life = (((!(() => { const __recv = actual_body; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "mut ") : str_starts_with(__recv, "mut "); })()) && (!(() => { const __recv = actual_body; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("move "); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "move ") : str_starts_with(__recv, "move "); })())) && (() => { const __recv = actual_body; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, " ") : str_includes(__recv, " "); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.actual_has_life = actual_has_life;
  if (expected_has_life) {
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = expected_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })())) {
  if (((() => { const __recv = expected_body; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })() === 32)) {
  break;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  if ((i < (() => { const __recv = expected_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })())) {
  expected_body = (() => { const __recv = expected_body; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((i + 1), (() => { const __recv = expected_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (i + 1), (() => { const __recv = expected_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()) : str_slice(__recv, (i + 1), (() => { const __recv = expected_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_body = expected_body;
}
}
  if (actual_has_life) {
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < (() => { const __recv = actual_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })())) {
  if (((() => { const __recv = actual_body; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, j) : str_char_at(__recv, j); })() === 32)) {
  break;
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  if ((j < (() => { const __recv = actual_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })())) {
  actual_body = (() => { const __recv = actual_body; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((j + 1), (() => { const __recv = actual_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (j + 1), (() => { const __recv = actual_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()) : str_slice(__recv, (j + 1), (() => { const __recv = actual_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.actual_body = actual_body;
}
}
  if (((!(() => { const __recv = expected_body; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "mut ") : str_starts_with(__recv, "mut "); })()) && (() => { const __recv = actual_body; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "mut ") : str_starts_with(__recv, "mut "); })())) {
  let expected_inner = expected_body; if (typeof __tuff_this !== 'undefined') __tuff_this.expected_inner = expected_inner;
  let actual_inner = (() => { const __recv = actual_body; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(4, (() => { const __recv = actual_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 4, (() => { const __recv = actual_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()) : str_slice(__recv, 4, (() => { const __recv = actual_body; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.actual_inner = actual_inner;
  return (() => { const __recv = expected_inner; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(actual_inner); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, actual_inner) : str_eq(__recv, actual_inner); })();
}
  if (((() => { const __recv = expected_body; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "mut ") : str_starts_with(__recv, "mut "); })() && (!(() => { const __recv = actual_body; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "mut ") : str_starts_with(__recv, "mut "); })()))) {
  return false;
}
  return (() => { const __recv = expected_body; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(actual_body); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, actual_body) : str_eq(__recv, actual_body); })();
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pointer_types_compatible = pointer_types_compatible;

const __tuff_outer_for_str_ends_with_local = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function str_ends_with_local(s, suffix) {
  let __tuff_this = { s: s, suffix: suffix, this: __tuff_outer_for_str_ends_with_local };
  let ns = (() => { const __recv = s; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ns = ns;
  let nf = (() => { const __recv = suffix; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.nf = nf;
  if ((nf > ns)) {
  return false;
}
  return (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((ns - nf), ns); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (ns - nf), ns) : str_slice(__recv, (ns - nf), ns); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(suffix); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, suffix) : str_eq(__recv, suffix); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.str_ends_with_local = str_ends_with_local;

const __tuff_outer_for_is_number_literal_with_suffix = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_number_literal_with_suffix(n, suffix) {
  let __tuff_this = { n: n, suffix: suffix, this: __tuff_outer_for_is_number_literal_with_suffix };
  if (((n === 0) || (node_kind(n) !== NK_NUMBER_LIT))) {
  return false;
}
  let text = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  return str_ends_with_local(text, suffix);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_number_literal_with_suffix = is_number_literal_with_suffix;

const __tuff_outer_for_is_usize_zero_literal_node = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_usize_zero_literal_node(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_is_usize_zero_literal_node };
  if ((!is_number_literal_with_suffix(n, "USize"))) {
  return false;
}
  return (() => { const __recv = get_interned_str(node_get_data1(n)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("0USize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "0USize") : str_eq(__recv, "0USize"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_usize_zero_literal_node = is_usize_zero_literal_node;

const __tuff_outer_for_is_nullable_pointer_type_name = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_nullable_pointer_type_name(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_is_nullable_pointer_type_name };
  if ((!(() => { const __recv = name; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, "|") : str_includes(__recv, "|"); })())) {
  return false;
}
  if (((() => { const __recv = name; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "*") : str_starts_with(__recv, "*"); })() && str_ends_with_local(name, "|USize"))) {
  return true;
}
  if (((() => { const __recv = name; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("USize|*"); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "USize|*") : str_starts_with(__recv, "USize|*"); })() && (() => { const __recv = name; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, "*") : str_includes(__recv, "*"); })())) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_nullable_pointer_type_name = is_nullable_pointer_type_name;

const __tuff_outer_for_numeric_types_compatible = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function numeric_types_compatible(expected, actual, rhs) {
  let __tuff_this = { expected: expected, actual: actual, rhs: rhs, this: __tuff_outer_for_numeric_types_compatible };
  if ((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(actual); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, actual) : str_eq(__recv, actual); })()) {
  return true;
}
  if (((((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "USize") : str_eq(__recv, "USize"); })() && (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I32") : str_eq(__recv, "I32"); })()) && (rhs !== 0)) && (node_kind(rhs) === NK_NUMBER_LIT))) {
  let lit = get_interned_str(node_get_data1(rhs)); if (typeof __tuff_this !== 'undefined') __tuff_this.lit = lit;
  return (!(() => { const __recv = lit; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "-") : str_starts_with(__recv, "-"); })());
}
  if (((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "USize") : str_eq(__recv, "USize"); })() && (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I32") : str_eq(__recv, "I32"); })())) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I32") : str_eq(__recv, "I32"); })() && (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "USize") : str_eq(__recv, "USize"); })())) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U16") : str_eq(__recv, "U16"); })() && (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U8") : str_eq(__recv, "U8"); })())) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U32") : str_eq(__recv, "U32"); })() && ((() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U8") : str_eq(__recv, "U8"); })() || (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U16") : str_eq(__recv, "U16"); })()))) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U64"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U64") : str_eq(__recv, "U64"); })() && (((() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U8") : str_eq(__recv, "U8"); })() || (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U16") : str_eq(__recv, "U16"); })()) || (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U32") : str_eq(__recv, "U32"); })()))) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U128"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U128") : str_eq(__recv, "U128"); })() && ((((() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U8") : str_eq(__recv, "U8"); })() || (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U16") : str_eq(__recv, "U16"); })()) || (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U32") : str_eq(__recv, "U32"); })()) || (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U64"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U64") : str_eq(__recv, "U64"); })()))) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "USize") : str_eq(__recv, "USize"); })() && ((((() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U8") : str_eq(__recv, "U8"); })() || (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U16") : str_eq(__recv, "U16"); })()) || (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U32") : str_eq(__recv, "U32"); })()) || (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U64"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U64") : str_eq(__recv, "U64"); })()))) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.numeric_types_compatible = numeric_types_compatible;

const __tuff_outer_for_is_type_variable_name = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_type_variable_name(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_is_type_variable_name };
  if (((() => { const __recv = name; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() !== 1)) {
  return false;
}
  let ch = char_code(name); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  return ((ch >= 65) && (ch <= 90));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_type_variable_name = is_type_variable_name;

const __tuff_outer_for_runtime_opaque_handle_compatible = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function runtime_opaque_handle_compatible(expected, actual) {
  let __tuff_this = { expected: expected, actual: actual, this: __tuff_outer_for_runtime_opaque_handle_compatible };
  if (((() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I32") : str_eq(__recv, "I32"); })() && (((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Vec"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Vec") : str_eq(__recv, "Vec"); })() || (() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Map"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Map") : str_eq(__recv, "Map"); })()) || (() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Set"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Set") : str_eq(__recv, "Set"); })()))) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I32") : str_eq(__recv, "I32"); })() && (((() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Vec"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Vec") : str_eq(__recv, "Vec"); })() || (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Map"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Map") : str_eq(__recv, "Map"); })()) || (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Set"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Set") : str_eq(__recv, "Set"); })()))) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.runtime_opaque_handle_compatible = runtime_opaque_handle_compatible;

const __tuff_outer_for_type_name_with_alias_base = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function type_name_with_alias_base(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_type_name_with_alias_base };
  if ((() => { const __recv = tc_alias_base_type; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  return (() => { const __recv = tc_alias_base_type; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })();
}
  return name;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.type_name_with_alias_base = type_name_with_alias_base;

const __tuff_outer_for_type_names_compatible = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function type_names_compatible(expected, actual, rhs) {
  let __tuff_this = { expected: expected, actual: actual, rhs: rhs, this: __tuff_outer_for_type_names_compatible };
  if (((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Unknown") : str_eq(__recv, "Unknown"); })() || (() => { const __recv = actual; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Unknown") : str_eq(__recv, "Unknown"); })())) {
  return true;
}
  if ((() => { const __recv = expected; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(actual); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, actual) : str_eq(__recv, actual); })()) {
  return true;
}
  if ((is_type_variable_name(expected) || is_type_variable_name(actual))) {
  return true;
}
  let expected_base = type_name_with_alias_base(expected); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_base = expected_base;
  let actual_base = type_name_with_alias_base(actual); if (typeof __tuff_this !== 'undefined') __tuff_this.actual_base = actual_base;
  if ((() => { const __recv = expected_base; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(actual_base); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, actual_base) : str_eq(__recv, actual_base); })()) {
  return true;
}
  if (runtime_opaque_handle_compatible(expected_base, actual_base)) {
  return true;
}
  if (pointer_types_compatible(expected_base, actual_base)) {
  return true;
}
  if (numeric_types_compatible(expected_base, actual_base, rhs)) {
  return true;
}
  if (runtime_opaque_handle_compatible(expected, actual)) {
  return true;
}
  if (pointer_types_compatible(expected, actual)) {
  return true;
}
  if (numeric_types_compatible(expected, actual, rhs)) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.type_names_compatible = type_names_compatible;

const __tuff_outer_for_infer_expr_type_name = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function infer_expr_type_name(n, fn_return_types, local_types) {
  let __tuff_this = { n: n, fn_return_types: fn_return_types, local_types: local_types, this: __tuff_outer_for_infer_expr_type_name };
  if ((n === 0)) {
  return "Unknown";
}
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === 20)) {
  let text = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  if (str_ends_with_local(text, "USize")) {
  return "USize";
}
  if (str_ends_with_local(text, "ISize")) {
  return "ISize";
}
  if (str_ends_with_local(text, "U128")) {
  return "U128";
}
  if (str_ends_with_local(text, "I128")) {
  return "I128";
}
  if (str_ends_with_local(text, "U64")) {
  return "U64";
}
  if (str_ends_with_local(text, "I64")) {
  return "I64";
}
  if (str_ends_with_local(text, "U32")) {
  return "U32";
}
  if (str_ends_with_local(text, "I32")) {
  return "I32";
}
  if (str_ends_with_local(text, "U16")) {
  return "U16";
}
  if (str_ends_with_local(text, "I16")) {
  return "I16";
}
  if (str_ends_with_local(text, "U8")) {
  return "U8";
}
  if (str_ends_with_local(text, "I8")) {
  return "I8";
}
  return "I32";
}
  if ((kind === 21)) {
  return "Bool";
}
  if ((kind === 22)) {
  return "*Str";
}
  if ((kind === 23)) {
  return "Char";
}
  if ((kind === 24)) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = local_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  return (() => { const __recv = local_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })();
}
  if ((() => { const __recv = tc_global_value_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  return (() => { const __recv = tc_global_value_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })();
}
  return "Unknown";
}
  if ((kind === 26)) {
  let op = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let inner = infer_expr_type_name(node_get_data2(n), fn_return_types, local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&") : str_eq(__recv, "&"); })()) {
  return (() => { const __recv = "*"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })();
}
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&mut"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&mut") : str_eq(__recv, "&mut"); })()) {
  return (() => { const __recv = "*mut "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })();
}
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("!"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "!") : str_eq(__recv, "!"); })()) {
  return "Bool";
}
  return inner;
}
  if ((kind === 25)) {
  let op = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((((((((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("=="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "==") : str_eq(__recv, "=="); })() || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "!=") : str_eq(__recv, "!="); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<") : str_eq(__recv, "<"); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<=") : str_eq(__recv, "<="); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(">"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ">") : str_eq(__recv, ">"); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(">="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ">=") : str_eq(__recv, ">="); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&&"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&&") : str_eq(__recv, "&&"); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("||"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "||") : str_eq(__recv, "||"); })())) {
  return "Bool";
}
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(".."); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "..") : str_eq(__recv, ".."); })()) {
  return "Iter";
}
  return infer_expr_type_name(node_get_data2(n), fn_return_types, local_types);
}
  if ((kind === 27)) {
  let callee = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  if ((node_kind(callee) === 24)) {
  let fname = get_interned_str(node_get_data1(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if (((() => { const __recv = fname; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "into") : str_eq(__recv, "into"); })() && (node_get_data3(n) === 1))) {
  let type_args = node_get_data4(n); if (typeof __tuff_this !== 'undefined') __tuff_this.type_args = type_args;
  if ((((() => { const __recv = type_args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 1) && (node_kind((() => { const __recv = type_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()) === NK_NAMED_TYPE))) {
  let cname = get_interned_str(node_get_data1((() => { const __recv = type_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })())); if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
  return (() => { const __recv = "__dyn_"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cname) : str_concat(__recv, cname); })();
}
  return "Unknown";
}
  if ((() => { const __recv = fn_return_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, fname) : map_has(__recv, fname); })()) {
  return (() => { const __recv = fn_return_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, fname) : map_get(__recv, fname); })();
}
}
  if ((node_kind(callee) === NK_MEMBER_EXPR)) {
  let method_name = get_interned_str(node_get_data2(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.method_name = method_name;
  if ((() => { const __recv = fn_return_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(method_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, method_name) : map_has(__recv, method_name); })()) {
  return (() => { const __recv = fn_return_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(method_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, method_name) : map_get(__recv, method_name); })();
}
}
}
  if ((kind === NK_TUPLE_EXPR)) {
  return "Unknown";
}
  return "Unknown";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.infer_expr_type_name = infer_expr_type_name;

const __tuff_outer_for_expr_is_number_literal_nonzero = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function expr_is_number_literal_nonzero(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_expr_is_number_literal_nonzero };
  if (((n === 0) || (node_kind(n) !== NK_NUMBER_LIT))) {
  return false;
}
  return (!(() => { const __recv = get_interned_str(node_get_data1(n)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("0"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "0") : str_eq(__recv, "0"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.expr_is_number_literal_nonzero = expr_is_number_literal_nonzero;

const __tuff_outer_for_is_decimal_digits = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_decimal_digits(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_is_decimal_digits };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if (((() => { const __recv = s; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() === 0)) {
  return false;
}
  while ((i < (() => { const __recv = s; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })())) {
  let ch = (() => { const __recv = s; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if (((ch < 48) || (ch > 57))) {
  return false;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return true;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_decimal_digits = is_decimal_digits;

const __tuff_outer_for_try_get_decimal_literal_value = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function try_get_decimal_literal_value(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_try_get_decimal_literal_value };
  if (((n === 0) || (node_kind(n) !== NK_NUMBER_LIT))) {
  return 0;
}
  let text = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  if ((!is_decimal_digits(text))) {
  return 0;
}
  return parse_int(text);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.try_get_decimal_literal_value = try_get_decimal_literal_value;

const __tuff_outer_for_try_get_known_int_value = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function try_get_known_int_value(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_try_get_known_int_value };
  if ((n === 0)) {
  return (-2147483649);
}
  let k = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_NUMBER_LIT)) {
  let text = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  if (is_decimal_digits(text)) {
  return parse_int(text);
}
  return (-2147483649);
}
  if ((k === NK_IDENTIFIER)) {
  let vname = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.vname = vname;
  if ((() => { const __recv = tc_var_literal_values; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(vname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, vname) : map_has(__recv, vname); })()) {
  return (() => { const __recv = tc_var_literal_values; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(vname); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, vname) : map_get(__recv, vname); })();
}
}
  return (-2147483649);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.try_get_known_int_value = try_get_known_int_value;

const __tuff_outer_for_known_int_value_is_valid = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function known_int_value_is_valid(v) {
  let __tuff_this = { v: v, this: __tuff_outer_for_known_int_value_is_valid };
  return ((v >= (-2147483648)) && (v <= 2147483647));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.known_int_value_is_valid = known_int_value_is_valid;

const __tuff_outer_for_is_decimal_zero_literal = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_decimal_zero_literal(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_is_decimal_zero_literal };
  if (((n === 0) || (node_kind(n) !== NK_NUMBER_LIT))) {
  return false;
}
  return (() => { const __recv = get_interned_str(node_get_data1(n)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("0"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "0") : str_eq(__recv, "0"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_decimal_zero_literal = is_decimal_zero_literal;

let tc_array_init_bounds = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_array_init_bounds = tc_array_init_bounds;

let tc_index_upper_bounds = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_index_upper_bounds = tc_index_upper_bounds;

let tc_call_bounds = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_call_bounds = tc_call_bounds;

let fn_param_call_bounds = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_param_call_bounds = fn_param_call_bounds;

let tc_var_literal_values = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_var_literal_values = tc_var_literal_values;

let tc_global_value_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_global_value_types = tc_global_value_types;

let tc_alias_union_tags = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_alias_union_tags = tc_alias_union_tags;

let tc_type_alias_names = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_type_alias_names = tc_type_alias_names;

let tc_dep_type_alias_params = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_dep_type_alias_params = tc_dep_type_alias_params;

let tc_extern_type_params = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_extern_type_params = tc_extern_type_params;

let tc_contract_names = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_contract_names = tc_contract_names;

let tc_destructor_alias_by_alias = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_destructor_alias_by_alias = tc_destructor_alias_by_alias;

let tc_destructor_alias_names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_destructor_alias_names = tc_destructor_alias_names;

let tc_alias_base_type = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_alias_base_type = tc_alias_base_type;

let tc_fn_this_fields = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_fn_this_fields = tc_fn_this_fields;

const __tuff_outer_for_type_node_is_destructor_receiver = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function type_node_is_destructor_receiver(t, alias_name) {
  let __tuff_this = { t: t, alias_name: alias_name, this: __tuff_outer_for_type_node_is_destructor_receiver };
  if ((t === 0)) {
  return false;
}
  if (((node_kind(t) === NK_NAMED_TYPE) && (() => { const __recv = get_interned_str(node_get_data1(t)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, alias_name) : str_eq(__recv, alias_name); })())) {
  return true;
}
  if (((node_kind(t) === NK_POINTER_TYPE) && (node_get_data3(t) === 1))) {
  return (() => { const __recv = type_name_from_type_node(node_get_data2(t)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, alias_name) : str_eq(__recv, alias_name); })();
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.type_node_is_destructor_receiver = type_node_is_destructor_receiver;

const __tuff_outer_for_collect_union_named_tags = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function collect_union_named_tags(type_node, tags) {
  let __tuff_this = { type_node: type_node, tags: tags, this: __tuff_outer_for_collect_union_named_tags };
  if ((type_node === 0)) {
  return 0;
}
  let kind = node_kind(type_node); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_UNION_TYPE)) {
  collect_union_named_tags(node_get_data1(type_node), tags);
  collect_union_named_tags(node_get_data2(type_node), tags);
  return 0;
}
  if ((kind === NK_NAMED_TYPE)) {
  (() => { const __recv = tags; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(type_node))); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(type_node))) : vec_push(__recv, get_interned_str(node_get_data1(type_node))); })();
  return 0;
}
  if ((kind === NK_REFINEMENT_TYPE)) {
  collect_union_named_tags(node_get_data1(type_node), tags);
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.collect_union_named_tags = collect_union_named_tags;

const __tuff_outer_for_try_get_nonnegative_integer_literal = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function try_get_nonnegative_integer_literal(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_try_get_nonnegative_integer_literal };
  if (((n === 0) || (node_kind(n) !== NK_NUMBER_LIT))) {
  return (-1);
}
  let text = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  if (str_ends_with_local(text, "USize")) {
  let len = (() => { const __recv = text; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let raw = (() => { const __recv = text; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (len - 5)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (len - 5)) : str_slice(__recv, 0, (len - 5)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.raw = raw;
  if ((!is_decimal_digits(raw))) {
  return (-1);
}
  return parse_int(raw);
}
  if ((!is_decimal_digits(text))) {
  return (-1);
}
  return parse_int(text);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.try_get_nonnegative_integer_literal = try_get_nonnegative_integer_literal;

const __tuff_outer_for_try_get_array_init_bound_from_type_node = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function try_get_array_init_bound_from_type_node(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_try_get_array_init_bound_from_type_node };
  if ((t === 0)) {
  return (-1);
}
  let k = node_kind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_REFINEMENT_TYPE)) {
  return try_get_array_init_bound_from_type_node(node_get_data1(t));
}
  if ((k === NK_POINTER_TYPE)) {
  return try_get_array_init_bound_from_type_node(node_get_data2(t));
}
  if ((k === NK_ARRAY_TYPE)) {
  return try_get_nonnegative_integer_literal(node_get_data2(t));
}
  return (-1);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.try_get_array_init_bound_from_type_node = try_get_array_init_bound_from_type_node;

const __tuff_outer_for_try_get_index_upper_bound_from_type_node = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function try_get_index_upper_bound_from_type_node(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_try_get_index_upper_bound_from_type_node };
  if (((t === 0) || (node_kind(t) !== NK_REFINEMENT_TYPE))) {
  return (-1);
}
  let base = node_get_data1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  if (((base === 0) || (node_kind(base) !== NK_NAMED_TYPE))) {
  return (-1);
}
  let base_name = get_interned_str(node_get_data1(base)); if (typeof __tuff_this !== 'undefined') __tuff_this.base_name = base_name;
  if ((!(() => { const __recv = base_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "USize") : str_eq(__recv, "USize"); })())) {
  return (-1);
}
  let lit = try_get_nonnegative_integer_literal(node_get_data3(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.lit = lit;
  if ((lit < 0)) {
  return (-1);
}
  let op = get_interned_str(node_get_data2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<") : str_eq(__recv, "<"); })()) {
  return (lit - 1);
}
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<=") : str_eq(__recv, "<="); })()) {
  return lit;
}
  return (-1);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.try_get_index_upper_bound_from_type_node = try_get_index_upper_bound_from_type_node;

const __tuff_outer_for_is_zero_numeric_literal_node = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_zero_numeric_literal_node(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_is_zero_numeric_literal_node };
  if (((n === 0) || (node_kind(n) !== NK_NUMBER_LIT))) {
  return false;
}
  let text = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  return ((() => { const __recv = text; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("0"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "0") : str_eq(__recv, "0"); })() || (() => { const __recv = text; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("0USize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "0USize") : str_eq(__recv, "0USize"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_zero_numeric_literal_node = is_zero_numeric_literal_node;

const __tuff_outer_for_try_extract_fn_call_constraint = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function try_extract_fn_call_constraint(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_try_extract_fn_call_constraint };
  if (((t === 0) || (node_kind(t) !== NK_REFINEMENT_TYPE))) {
  return "";
}
  let base = node_get_data1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  if (((base === 0) || (node_kind(base) !== NK_NAMED_TYPE))) {
  return "";
}
  let base_name = get_interned_str(node_get_data1(base)); if (typeof __tuff_this !== 'undefined') __tuff_this.base_name = base_name;
  if ((((!(() => { const __recv = base_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "USize") : str_eq(__recv, "USize"); })()) && (!(() => { const __recv = base_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I32") : str_eq(__recv, "I32"); })())) && (!(() => { const __recv = base_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("ISize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "ISize") : str_eq(__recv, "ISize"); })()))) {
  return "";
}
  let op = get_interned_str(node_get_data2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((!(() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<") : str_eq(__recv, "<"); })()) && (!(() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<=") : str_eq(__recv, "<="); })()))) {
  return "";
}
  let constraint_expr = node_get_data3(t); if (typeof __tuff_this !== 'undefined') __tuff_this.constraint_expr = constraint_expr;
  if (((constraint_expr === 0) || (node_kind(constraint_expr) !== NK_CALL_EXPR))) {
  return "";
}
  let callee = node_get_data1(constraint_expr); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  let args = node_get_data2(constraint_expr); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((callee === 0) || (node_kind(callee) !== NK_IDENTIFIER))) {
  return "";
}
  if (((() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() !== 1)) {
  return "";
}
  let arg0 = (() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.arg0 = arg0;
  if (((arg0 === 0) || (node_kind(arg0) !== NK_IDENTIFIER))) {
  return "";
}
  let fn_name = get_interned_str(node_get_data1(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_name = fn_name;
  let ref_param_name = get_interned_str(node_get_data1(arg0)); if (typeof __tuff_this !== 'undefined') __tuff_this.ref_param_name = ref_param_name;
  return (() => { const __recv = (() => { const __recv = fn_name; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(ref_param_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ref_param_name) : str_concat(__recv, ref_param_name); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.try_extract_fn_call_constraint = try_extract_fn_call_constraint;

const __tuff_outer_for_expr_is_proven_nonzero = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function expr_is_proven_nonzero(n, nonnull_ptrs) {
  let __tuff_this = { n: n, nonnull_ptrs: nonnull_ptrs, this: __tuff_outer_for_expr_is_proven_nonzero };
  if (expr_is_number_literal_nonzero(n)) {
  return true;
}
  if (((n !== 0) && (node_kind(n) === NK_IDENTIFIER))) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })();
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.expr_is_proven_nonzero = expr_is_proven_nonzero;

const __tuff_outer_for_type_node_proves_nonzero = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function type_node_proves_nonzero(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_type_node_proves_nonzero };
  if (((t === 0) || (node_kind(t) !== NK_REFINEMENT_TYPE))) {
  return false;
}
  let op = get_interned_str(node_get_data2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if ((!(() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "!=") : str_eq(__recv, "!="); })())) {
  return false;
}
  return is_zero_numeric_literal_node(node_get_data3(t));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.type_node_proves_nonzero = type_node_proves_nonzero;

const __tuff_outer_for_typecheck_if_expr_branch = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheck_if_expr_branch(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs) {
  let __tuff_this = { n: n, fn_arities: fn_arities, fn_param_types: fn_param_types, fn_return_types: fn_return_types, local_types: local_types, nonnull_ptrs: nonnull_ptrs, this: __tuff_outer_for_typecheck_if_expr_branch };
  let cond = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  typecheck_expr(cond, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  let cond_name = infer_expr_type_name(cond, fn_return_types, local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.cond_name = cond_name;
  if (((!(() => { const __recv = cond_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Bool"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Bool") : str_eq(__recv, "Bool"); })()) && (!(() => { const __recv = cond_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Unknown") : str_eq(__recv, "Unknown"); })()))) {
  tc_panic_loc("E_TYPE_IF_CONDITION", (() => { const __recv = "if condition must be Bool, got "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond_name) : str_concat(__recv, cond_name); })(), "Conditional branches require a boolean predicate, but the given expression has a non-Bool type.", "Return or compute a Bool expression in the if condition.");
}
  let ie_then_key = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.ie_then_key = ie_then_key;
  let ie_else_key = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.ie_else_key = ie_else_key;
  let ie_cb_key = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.ie_cb_key = ie_cb_key;
  let ie_cb_value = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.ie_cb_value = ie_cb_value;
  if ((node_kind(cond) === NK_BINARY_EXPR)) {
  let bop = get_interned_str(node_get_data1(cond)); if (typeof __tuff_this !== 'undefined') __tuff_this.bop = bop;
  let bleft = node_get_data2(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.bleft = bleft;
  let bright = node_get_data3(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.bright = bright;
  if ((() => { const __recv = bop; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "!=") : str_eq(__recv, "!="); })()) {
  if ((((() => { const __recv = ie_then_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })() && (node_kind(bleft) === NK_IDENTIFIER)) && (is_usize_zero_literal_node(bright) || is_zero_numeric_literal_node(bright)))) {
  ie_then_key = get_interned_str(node_get_data1(bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.ie_then_key = ie_then_key;
}
  if ((((() => { const __recv = ie_then_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })() && (node_kind(bright) === NK_IDENTIFIER)) && (is_usize_zero_literal_node(bleft) || is_zero_numeric_literal_node(bleft)))) {
  ie_then_key = get_interned_str(node_get_data1(bright)); if (typeof __tuff_this !== 'undefined') __tuff_this.ie_then_key = ie_then_key;
}
}
  if ((() => { const __recv = bop; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("=="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "==") : str_eq(__recv, "=="); })()) {
  if ((((() => { const __recv = ie_else_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })() && (node_kind(bleft) === NK_IDENTIFIER)) && is_zero_numeric_literal_node(bright))) {
  ie_else_key = get_interned_str(node_get_data1(bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.ie_else_key = ie_else_key;
}
  if ((((() => { const __recv = ie_else_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })() && (node_kind(bright) === NK_IDENTIFIER)) && is_zero_numeric_literal_node(bleft))) {
  ie_else_key = get_interned_str(node_get_data1(bright)); if (typeof __tuff_this !== 'undefined') __tuff_this.ie_else_key = ie_else_key;
}
}
  if (((((() => { const __recv = bop; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<") : str_eq(__recv, "<"); })() || (() => { const __recv = bop; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<=") : str_eq(__recv, "<="); })()) && (node_kind(bleft) === NK_IDENTIFIER)) && (node_kind(bright) === NK_CALL_EXPR))) {
  let ie_cb_callee = node_get_data1(bright); if (typeof __tuff_this !== 'undefined') __tuff_this.ie_cb_callee = ie_cb_callee;
  let ie_cb_args = node_get_data2(bright); if (typeof __tuff_this !== 'undefined') __tuff_this.ie_cb_args = ie_cb_args;
  if ((((node_kind(ie_cb_callee) === NK_IDENTIFIER) && ((() => { const __recv = ie_cb_args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 1)) && (node_kind((() => { const __recv = ie_cb_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()) === NK_IDENTIFIER))) {
  ie_cb_key = get_interned_str(node_get_data1(bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.ie_cb_key = ie_cb_key;
  ie_cb_value = (() => { const __recv = (() => { const __recv = get_interned_str(node_get_data1(ie_cb_callee)); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1((() => { const __recv = ie_cb_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1((() => { const __recv = ie_cb_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))) : str_concat(__recv, get_interned_str(node_get_data1((() => { const __recv = ie_cb_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ie_cb_value = ie_cb_value;
}
}
}
  let ie_then_present = false; if (typeof __tuff_this !== 'undefined') __tuff_this.ie_then_present = ie_then_present;
  if ((!(() => { const __recv = ie_then_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  ie_then_present = (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(ie_then_key); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, ie_then_key) : map_has(__recv, ie_then_key); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ie_then_present = ie_then_present;
  (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(ie_then_key, 1); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, ie_then_key, 1) : map_set(__recv, ie_then_key, 1); })();
}
  let ie_cb_was_present = false; if (typeof __tuff_this !== 'undefined') __tuff_this.ie_cb_was_present = ie_cb_was_present;
  if ((!(() => { const __recv = ie_cb_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  ie_cb_was_present = (() => { const __recv = tc_call_bounds; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(ie_cb_key); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, ie_cb_key) : map_has(__recv, ie_cb_key); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ie_cb_was_present = ie_cb_was_present;
  (() => { const __recv = tc_call_bounds; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(ie_cb_key, ie_cb_value); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, ie_cb_key, ie_cb_value) : map_set(__recv, ie_cb_key, ie_cb_value); })();
}
  typecheck_stmt(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, "Unknown");
  if (((!(() => { const __recv = ie_then_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) && (!ie_then_present))) {
  (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_delete"]; if (typeof __prop === "function") return __prop(ie_then_key); const __dyn = __recv?.table?.map_delete; return __dyn ? __dyn(__recv.ref, ie_then_key) : map_delete(__recv, ie_then_key); })();
}
  if (((!(() => { const __recv = ie_cb_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) && (!ie_cb_was_present))) {
  (() => { const __recv = tc_call_bounds; const __prop = __recv?.["map_delete"]; if (typeof __prop === "function") return __prop(ie_cb_key); const __dyn = __recv?.table?.map_delete; return __dyn ? __dyn(__recv.ref, ie_cb_key) : map_delete(__recv, ie_cb_key); })();
}
  if ((node_get_data3(n) !== 0)) {
  let ie_else_present = false; if (typeof __tuff_this !== 'undefined') __tuff_this.ie_else_present = ie_else_present;
  if ((!(() => { const __recv = ie_else_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  ie_else_present = (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(ie_else_key); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, ie_else_key) : map_has(__recv, ie_else_key); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ie_else_present = ie_else_present;
  (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(ie_else_key, 1); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, ie_else_key, 1) : map_set(__recv, ie_else_key, 1); })();
}
  typecheck_stmt(node_get_data3(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, "Unknown");
  if (((!(() => { const __recv = ie_else_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) && (!ie_else_present))) {
  (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_delete"]; if (typeof __prop === "function") return __prop(ie_else_key); const __dyn = __recv?.table?.map_delete; return __dyn ? __dyn(__recv.ref, ie_else_key) : map_delete(__recv, ie_else_key); })();
}
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheck_if_expr_branch = typecheck_if_expr_branch;

const __tuff_outer_for_typecheck_match_expr_branch = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheck_match_expr_branch(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs) {
  let __tuff_this = { n: n, fn_arities: fn_arities, fn_param_types: fn_param_types, fn_return_types: fn_return_types, local_types: local_types, nonnull_ptrs: nonnull_ptrs, this: __tuff_outer_for_typecheck_match_expr_branch };
  let target = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  typecheck_expr(target, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  let target_name = infer_expr_type_name(target, fn_return_types, local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.target_name = target_name;
  let expected_tags = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_tags = expected_tags;
  if ((() => { const __recv = tc_alias_union_tags; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(target_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, target_name) : map_has(__recv, target_name); })()) {
  expected_tags = (() => { const __recv = tc_alias_union_tags; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(target_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, target_name) : map_get(__recv, target_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_tags = expected_tags;
}
  let cases = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let seen_tags = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.seen_tags = seen_tags;
  let has_wildcard = false; if (typeof __tuff_this !== 'undefined') __tuff_this.has_wildcard = has_wildcard;
  while ((i < len)) {
  let case_node = (() => { const __recv = cases; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.case_node = case_node;
  let pat = (() => { const __recv = case_node; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  if ((node_kind(pat) === NK_WILDCARD_PAT)) {
  has_wildcard = true; if (typeof __tuff_this !== 'undefined') __tuff_this.has_wildcard = has_wildcard;
}
  if (((node_kind(pat) === NK_NAME_PAT) || (node_kind(pat) === NK_STRUCT_PAT))) {
  (() => { const __recv = seen_tags; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(pat))); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(pat))) : set_add(__recv, get_interned_str(node_get_data1(pat))); })();
}
  typecheck_stmt((() => { const __recv = case_node; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, "Unknown");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  if ((((() => { const __recv = expected_tags; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() > 0) && (!has_wildcard))) {
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let jlen = (() => { const __recv = expected_tags; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.jlen = jlen;
  while ((j < jlen)) {
  let tag = (() => { const __recv = expected_tags; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tag = tag;
  if ((!(() => { const __recv = seen_tags; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(tag); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, tag) : set_has(__recv, tag); })())) {
  tc_panic_loc("E_TYPE_MATCH_NON_EXHAUSTIVE", (() => { const __recv = "Non-exhaustive match: missing case for "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(tag); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, tag) : str_concat(__recv, tag); })(), "A match expression over a known union type does not handle all variants.", "Add missing case arms or include a wildcard case '_'.");
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheck_match_expr_branch = typecheck_match_expr_branch;

const __tuff_outer_for_typecheck_if_stmt_branch = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheck_if_stmt_branch(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, expected_return_type) {
  let __tuff_this = { n: n, fn_arities: fn_arities, fn_param_types: fn_param_types, fn_return_types: fn_return_types, local_types: local_types, nonnull_ptrs: nonnull_ptrs, expected_return_type: expected_return_type, this: __tuff_outer_for_typecheck_if_stmt_branch };
  let cond = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  typecheck_expr(cond, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  let cond_name = infer_expr_type_name(cond, fn_return_types, local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.cond_name = cond_name;
  if (((!(() => { const __recv = cond_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Bool"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Bool") : str_eq(__recv, "Bool"); })()) && (!(() => { const __recv = cond_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Unknown") : str_eq(__recv, "Unknown"); })()))) {
  tc_panic_loc("E_TYPE_IF_CONDITION", (() => { const __recv = "if condition must be Bool, got "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond_name) : str_concat(__recv, cond_name); })(), "Conditional branches require a boolean predicate, but the given expression has a non-Bool type.", "Return or compute a Bool expression in the if condition.");
}
  let then_inject_key = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.then_inject_key = then_inject_key;
  let else_inject_key = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.else_inject_key = else_inject_key;
  let cb_then_key = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.cb_then_key = cb_then_key;
  let cb_then_value = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.cb_then_value = cb_then_value;
  if ((node_kind(cond) === NK_BINARY_EXPR)) {
  let bop = get_interned_str(node_get_data1(cond)); if (typeof __tuff_this !== 'undefined') __tuff_this.bop = bop;
  let bleft = node_get_data2(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.bleft = bleft;
  let bright = node_get_data3(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.bright = bright;
  if ((() => { const __recv = bop; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "!=") : str_eq(__recv, "!="); })()) {
  if ((((() => { const __recv = then_inject_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })() && (node_kind(bleft) === NK_IDENTIFIER)) && (is_usize_zero_literal_node(bright) || is_zero_numeric_literal_node(bright)))) {
  then_inject_key = get_interned_str(node_get_data1(bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.then_inject_key = then_inject_key;
}
  if ((((() => { const __recv = then_inject_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })() && (node_kind(bright) === NK_IDENTIFIER)) && (is_usize_zero_literal_node(bleft) || is_zero_numeric_literal_node(bleft)))) {
  then_inject_key = get_interned_str(node_get_data1(bright)); if (typeof __tuff_this !== 'undefined') __tuff_this.then_inject_key = then_inject_key;
}
}
  if ((() => { const __recv = bop; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("=="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "==") : str_eq(__recv, "=="); })()) {
  if ((((() => { const __recv = else_inject_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })() && (node_kind(bleft) === NK_IDENTIFIER)) && is_zero_numeric_literal_node(bright))) {
  else_inject_key = get_interned_str(node_get_data1(bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.else_inject_key = else_inject_key;
}
  if ((((() => { const __recv = else_inject_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })() && (node_kind(bright) === NK_IDENTIFIER)) && is_zero_numeric_literal_node(bleft))) {
  else_inject_key = get_interned_str(node_get_data1(bright)); if (typeof __tuff_this !== 'undefined') __tuff_this.else_inject_key = else_inject_key;
}
}
  if (((((() => { const __recv = bop; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<") : str_eq(__recv, "<"); })() || (() => { const __recv = bop; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<=") : str_eq(__recv, "<="); })()) && (node_kind(bleft) === NK_IDENTIFIER)) && (node_kind(bright) === NK_CALL_EXPR))) {
  let cb_callee = node_get_data1(bright); if (typeof __tuff_this !== 'undefined') __tuff_this.cb_callee = cb_callee;
  let cb_args = node_get_data2(bright); if (typeof __tuff_this !== 'undefined') __tuff_this.cb_args = cb_args;
  if ((((node_kind(cb_callee) === NK_IDENTIFIER) && ((() => { const __recv = cb_args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 1)) && (node_kind((() => { const __recv = cb_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()) === NK_IDENTIFIER))) {
  cb_then_key = get_interned_str(node_get_data1(bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.cb_then_key = cb_then_key;
  cb_then_value = (() => { const __recv = (() => { const __recv = get_interned_str(node_get_data1(cb_callee)); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1((() => { const __recv = cb_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1((() => { const __recv = cb_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))) : str_concat(__recv, get_interned_str(node_get_data1((() => { const __recv = cb_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cb_then_value = cb_then_value;
}
}
}
  let narrowed_ident = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.narrowed_ident = narrowed_ident;
  let had_prev_narrowed = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.had_prev_narrowed = had_prev_narrowed;
  let prev_narrowed_type = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.prev_narrowed_type = prev_narrowed_type;
  if ((node_kind(cond) === NK_IS_EXPR)) {
  let subject = node_get_data1(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.subject = subject;
  let pat = node_get_data2(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  if (((node_kind(subject) === NK_IDENTIFIER) && ((node_kind(pat) === NK_NAME_PAT) || (node_kind(pat) === NK_STRUCT_PAT)))) {
  narrowed_ident = get_interned_str(node_get_data1(subject)); if (typeof __tuff_this !== 'undefined') __tuff_this.narrowed_ident = narrowed_ident;
  let narrowed_type = get_interned_str(node_get_data1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.narrowed_type = narrowed_type;
  if ((() => { const __recv = local_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(narrowed_ident); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, narrowed_ident) : map_has(__recv, narrowed_ident); })()) {
  had_prev_narrowed = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.had_prev_narrowed = had_prev_narrowed;
  prev_narrowed_type = (() => { const __recv = local_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(narrowed_ident); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, narrowed_ident) : map_get(__recv, narrowed_ident); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.prev_narrowed_type = prev_narrowed_type;
}
  (() => { const __recv = local_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(narrowed_ident, narrowed_type); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, narrowed_ident, narrowed_type) : map_set(__recv, narrowed_ident, narrowed_type); })();
}
}
  let then_was_present = false; if (typeof __tuff_this !== 'undefined') __tuff_this.then_was_present = then_was_present;
  if ((!(() => { const __recv = then_inject_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  then_was_present = (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(then_inject_key); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, then_inject_key) : map_has(__recv, then_inject_key); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.then_was_present = then_was_present;
  (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(then_inject_key, 1); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, then_inject_key, 1) : map_set(__recv, then_inject_key, 1); })();
}
  let cb_then_was_present = false; if (typeof __tuff_this !== 'undefined') __tuff_this.cb_then_was_present = cb_then_was_present;
  if ((!(() => { const __recv = cb_then_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  cb_then_was_present = (() => { const __recv = tc_call_bounds; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(cb_then_key); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, cb_then_key) : map_has(__recv, cb_then_key); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cb_then_was_present = cb_then_was_present;
  (() => { const __recv = tc_call_bounds; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(cb_then_key, cb_then_value); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, cb_then_key, cb_then_value) : map_set(__recv, cb_then_key, cb_then_value); })();
}
  typecheck_stmt(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, expected_return_type);
  if (((!(() => { const __recv = then_inject_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) && (!then_was_present))) {
  (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_delete"]; if (typeof __prop === "function") return __prop(then_inject_key); const __dyn = __recv?.table?.map_delete; return __dyn ? __dyn(__recv.ref, then_inject_key) : map_delete(__recv, then_inject_key); })();
}
  if (((!(() => { const __recv = cb_then_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) && (!cb_then_was_present))) {
  (() => { const __recv = tc_call_bounds; const __prop = __recv?.["map_delete"]; if (typeof __prop === "function") return __prop(cb_then_key); const __dyn = __recv?.table?.map_delete; return __dyn ? __dyn(__recv.ref, cb_then_key) : map_delete(__recv, cb_then_key); })();
}
  if ((!(() => { const __recv = narrowed_ident; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  if ((had_prev_narrowed === 1)) {
  (() => { const __recv = local_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(narrowed_ident, prev_narrowed_type); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, narrowed_ident, prev_narrowed_type) : map_set(__recv, narrowed_ident, prev_narrowed_type); })();
} else {
  (() => { const __recv = local_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(narrowed_ident, "Unknown"); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, narrowed_ident, "Unknown") : map_set(__recv, narrowed_ident, "Unknown"); })();
}
}
  if ((node_get_data3(n) !== 0)) {
  let else_was_present = false; if (typeof __tuff_this !== 'undefined') __tuff_this.else_was_present = else_was_present;
  if ((!(() => { const __recv = else_inject_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  else_was_present = (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(else_inject_key); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, else_inject_key) : map_has(__recv, else_inject_key); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.else_was_present = else_was_present;
  (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(else_inject_key, 1); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, else_inject_key, 1) : map_set(__recv, else_inject_key, 1); })();
}
  typecheck_stmt(node_get_data3(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, expected_return_type);
  if (((!(() => { const __recv = else_inject_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) && (!else_was_present))) {
  (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_delete"]; if (typeof __prop === "function") return __prop(else_inject_key); const __dyn = __recv?.table?.map_delete; return __dyn ? __dyn(__recv.ref, else_inject_key) : map_delete(__recv, else_inject_key); })();
}
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheck_if_stmt_branch = typecheck_if_stmt_branch;

const __tuff_outer_for_typecheck_member_or_index_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheck_member_or_index_expr(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs) {
  let __tuff_this = { n: n, fn_arities: fn_arities, fn_param_types: fn_param_types, fn_return_types: fn_return_types, local_types: local_types, nonnull_ptrs: nonnull_ptrs, this: __tuff_outer_for_typecheck_member_or_index_expr };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_MEMBER_EXPR)) {
  let obj = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.obj = obj;
  let obj_name = infer_expr_type_name(obj, fn_return_types, local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.obj_name = obj_name;
  if (is_nullable_pointer_type_name(obj_name)) {
  let guarded = false; if (typeof __tuff_this !== 'undefined') __tuff_this.guarded = guarded;
  if ((node_kind(obj) === NK_IDENTIFIER)) {
  let oname = get_interned_str(node_get_data1(obj)); if (typeof __tuff_this !== 'undefined') __tuff_this.oname = oname;
  guarded = (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(oname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, oname) : map_has(__recv, oname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.guarded = guarded;
}
  if ((!guarded)) {
  tc_panic_loc("E_SAFETY_NULLABLE_POINTER_GUARD", "Nullable pointer access requires guard", "A nullable pointer must be proven non-null before pointer-consuming operations.", "Guard with if (p != 0USize) or if (0USize != p) before member access.");
}
}
  if ((() => { const __recv = obj_name; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("__this_"); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "__this_") : str_starts_with(__recv, "__this_"); })()) {
  let fn_name = (() => { const __recv = obj_name; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(7, (() => { const __recv = obj_name; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 7, (() => { const __recv = obj_name; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()) : str_slice(__recv, 7, (() => { const __recv = obj_name; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_name = fn_name;
  if ((() => { const __recv = tc_fn_this_fields; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(fn_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, fn_name) : map_has(__recv, fn_name); })()) {
  let field_names = (() => { const __recv = tc_fn_this_fields; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(fn_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, fn_name) : map_get(__recv, fn_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field_names = field_names;
  let field = get_interned_str(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  if ((!(() => { const __recv = field_names; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(field); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, field) : set_has(__recv, field); })())) {
  tc_panic_loc("E_TYPE_MEMBER_NOT_FOUND", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Field '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(field); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, field) : str_concat(__recv, field); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' does not exist on '"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' does not exist on '") : str_concat(__recv, "' does not exist on '"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fn_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fn_name) : str_concat(__recv, fn_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' scope"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' scope") : str_concat(__recv, "' scope"); })(), "The function's 'this' struct does not declare the accessed field.", "Check that the field is declared in the function body or use a different access path.");
}
}
}
  typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  return 1;
}
  if ((kind === NK_INDEX_EXPR)) {
  let target_node = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.target_node = target_node;
  let target_name = infer_expr_type_name(target_node, fn_return_types, local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.target_name = target_name;
  if (is_nullable_pointer_type_name(target_name)) {
  let guarded = false; if (typeof __tuff_this !== 'undefined') __tuff_this.guarded = guarded;
  if ((node_kind(target_node) === NK_IDENTIFIER)) {
  let tname = get_interned_str(node_get_data1(target_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.tname = tname;
  guarded = (() => { const __recv = nonnull_ptrs; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(tname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, tname) : map_has(__recv, tname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.guarded = guarded;
}
  if ((!guarded)) {
  tc_panic_loc("E_SAFETY_NULLABLE_POINTER_GUARD", "Nullable pointer indexing requires guard", "A nullable pointer must be proven non-null before pointer-consuming operations.", "Guard with if (p != 0USize) or if (0USize != p) before indexing.");
}
}
  if ((node_kind(target_node) === NK_IDENTIFIER)) {
  let tname = get_interned_str(node_get_data1(target_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.tname = tname;
  if ((() => { const __recv = tc_array_init_bounds; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(tname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, tname) : map_has(__recv, tname); })()) {
  let bound = (() => { const __recv = tc_array_init_bounds; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(tname); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, tname) : map_get(__recv, tname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.bound = bound;
  if ((bound >= 0)) {
  let index_node = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.index_node = index_node;
  let index_max = (-1); if (typeof __tuff_this !== 'undefined') __tuff_this.index_max = index_max;
  if ((node_kind(index_node) === NK_IDENTIFIER)) {
  let iname = get_interned_str(node_get_data1(index_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.iname = iname;
  if ((() => { const __recv = tc_index_upper_bounds; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(iname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, iname) : map_has(__recv, iname); })()) {
  index_max = (() => { const __recv = tc_index_upper_bounds; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(iname); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, iname) : map_get(__recv, iname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.index_max = index_max;
}
}
  if ((index_max < 0)) {
  index_max = try_get_nonnegative_integer_literal(index_node); if (typeof __tuff_this !== 'undefined') __tuff_this.index_max = index_max;
}
  if ((index_max < 0)) {
  tc_panic_loc("E_SAFETY_ARRAY_BOUNDS_UNPROVEN", "Cannot prove array index bound safety", "The array index does not have a proven upper bound under strict safety checks.", "Guard index with 'if (i < arr.length)' before indexing.");
}
  if ((index_max >= bound)) {
  tc_panic_loc("E_SAFETY_ARRAY_BOUNDS", "Array index may be out of bounds", "The proven index upper bound can exceed initialized array length.", "Ensure 0 <= index < initialized length.");
}
}
}
}
  typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  typecheck_expr(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  return 1;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheck_member_or_index_expr = typecheck_member_or_index_expr;

const __tuff_outer_for_typecheck_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheck_expr(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs) {
  let __tuff_this = { n: n, fn_arities: fn_arities, fn_param_types: fn_param_types, fn_return_types: fn_return_types, local_types: local_types, nonnull_ptrs: nonnull_ptrs, this: __tuff_outer_for_typecheck_expr };
  if ((n === 0)) {
  return 0;
}
  tc_current_node = n; if (typeof __tuff_this !== 'undefined') __tuff_this.tc_current_node = tc_current_node;
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_BINARY_EXPR)) {
  typecheck_expr(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  typecheck_expr(node_get_data3(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  let op = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("/"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "/") : str_eq(__recv, "/"); })() && (!expr_is_proven_nonzero(node_get_data3(n), nonnull_ptrs)))) {
  let denom_node = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.denom_node = denom_node;
  let denom_desc = "denominator"; if (typeof __tuff_this !== 'undefined') __tuff_this.denom_desc = denom_desc;
  if ((node_kind(denom_node) === NK_IDENTIFIER)) {
  denom_desc = (() => { const __recv = (() => { const __recv = "denominator `"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(denom_node))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(denom_node))) : str_concat(__recv, get_interned_str(node_get_data1(denom_node))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("`"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "`") : str_concat(__recv, "`"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.denom_desc = denom_desc;
}
  tc_panic_loc("E_SAFETY_DIV_BY_ZERO", "Division by zero cannot be ruled out at compile time", (() => { const __recv = (() => { const __recv = "The "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(denom_desc); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, denom_desc) : str_concat(__recv, denom_desc); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" is not proven non-zero; any value including 0 is possible."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " is not proven non-zero; any value including 0 is possible.") : str_concat(__recv, " is not proven non-zero; any value including 0 is possible."); })(), "Prove denominator != 0 via refinement type or control-flow guard.");
}
  if (((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("%"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "%") : str_eq(__recv, "%"); })() && (!expr_is_proven_nonzero(node_get_data3(n), nonnull_ptrs)))) {
  let mod_node = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.mod_node = mod_node;
  let mod_desc = "modulo denominator"; if (typeof __tuff_this !== 'undefined') __tuff_this.mod_desc = mod_desc;
  if ((node_kind(mod_node) === NK_IDENTIFIER)) {
  mod_desc = (() => { const __recv = (() => { const __recv = "modulo denominator `"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(mod_node))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(mod_node))) : str_concat(__recv, get_interned_str(node_get_data1(mod_node))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("`"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "`") : str_concat(__recv, "`"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.mod_desc = mod_desc;
}
  tc_panic_loc("E_SAFETY_MOD_BY_ZERO", "Modulo by zero cannot be ruled out at compile time", (() => { const __recv = (() => { const __recv = "The "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(mod_desc); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, mod_desc) : str_concat(__recv, mod_desc); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" is not proven non-zero; any value including 0 is possible."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " is not proven non-zero; any value including 0 is possible.") : str_concat(__recv, " is not proven non-zero; any value including 0 is possible."); })(), "Prove denominator != 0 via refinement type or control-flow guard.");
}
  if ((((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("+"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "+") : str_eq(__recv, "+"); })() || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "-") : str_eq(__recv, "-"); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "*") : str_eq(__recv, "*"); })())) {
  let lnode = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.lnode = lnode;
  let rnode = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.rnode = rnode;
  let left = try_get_known_int_value(lnode); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  let right = try_get_known_int_value(rnode); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  if ((known_int_value_is_valid(left) && known_int_value_is_valid(right))) {
  let result = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("+"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "+") : str_eq(__recv, "+"); })()) {
  result = (left + right); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
} else { if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "-") : str_eq(__recv, "-"); })()) {
  result = (left - right); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
} else {
  result = (left * right); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
} }
  if (((result < (-2147483648)) || (result > 2147483647))) {
  let left_desc = int_to_string(left); if (typeof __tuff_this !== 'undefined') __tuff_this.left_desc = left_desc;
  let right_desc = int_to_string(right); if (typeof __tuff_this !== 'undefined') __tuff_this.right_desc = right_desc;
  if ((node_kind(lnode) === NK_IDENTIFIER)) {
  left_desc = (() => { const __recv = (() => { const __recv = get_interned_str(node_get_data1(lnode)); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("="); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "=") : str_concat(__recv, "="); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(left)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(left)) : str_concat(__recv, int_to_string(left)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.left_desc = left_desc;
}
  if ((node_kind(rnode) === NK_IDENTIFIER)) {
  right_desc = (() => { const __recv = (() => { const __recv = get_interned_str(node_get_data1(rnode)); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("="); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "=") : str_concat(__recv, "="); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(right)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(right)) : str_concat(__recv, int_to_string(right)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.right_desc = right_desc;
}
  let witness = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = left_desc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, op) : str_concat(__recv, op); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(right_desc); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, right_desc) : str_concat(__recv, right_desc); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(result)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(result)) : str_concat(__recv, int_to_string(result)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(", which is outside I32 range [-2147483648, 2147483647]"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ", which is outside I32 range [-2147483648, 2147483647]") : str_concat(__recv, ", which is outside I32 range [-2147483648, 2147483647]"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.witness = witness;
  tc_panic_loc("E_SAFETY_INTEGER_OVERFLOW", (() => { const __recv = (() => { const __recv = "Integer overflow/underflow proven possible for '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, op) : str_concat(__recv, op); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), witness, "Constrain operands or use a wider intermediate type before narrowing.");
}
}
}
  return 0;
}
  if (((kind === NK_UNARY_EXPR) || (kind === NK_UNWRAP_EXPR))) {
  if ((kind === NK_UNARY_EXPR)) {
  typecheck_expr(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
} else {
  typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
}
  return 0;
}
  if ((kind === NK_CALL_EXPR)) {
  let callee = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let arg_count = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.arg_count = arg_count;
  let fname = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if ((node_kind(callee) === NK_IDENTIFIER)) {
  fname = get_interned_str(node_get_data1(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if ((() => { const __recv = fname; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("drop"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "drop") : str_eq(__recv, "drop"); })()) {
  if ((arg_count !== 1)) {
  tc_panic_loc("E_TYPE_ARG_COUNT", "drop expects exactly one argument", "The drop builtin requires one argument representing the value to drop.", "Call drop(value) with exactly one argument.");
}
  let target = (() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let target_name = infer_expr_type_name(target, fn_return_types, local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.target_name = target_name;
  if ((!(() => { const __recv = tc_destructor_alias_by_alias; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(target_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, target_name) : map_has(__recv, target_name); })())) {
  tc_panic_loc("E_TYPE_DESTRUCTOR_NOT_FOUND", (() => { const __recv = (() => { const __recv = "Type '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(target_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, target_name) : str_concat(__recv, target_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' does not have an associated destructor"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' does not have an associated destructor") : str_concat(__recv, "' does not have an associated destructor"); })(), "drop can only be called for values whose alias type declares a destructor.", "Define `type Alias = Base then destructorName;` and use that alias for dropped values.");
}
  return 0;
}
  if (((() => { const __recv = fname; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "into") : str_eq(__recv, "into"); })() && (node_get_data3(n) === 1))) {
  if ((arg_count < 1)) {
  tc_panic_loc("E_TYPE_ARG_COUNT", "into conversion requires a receiver", "Method-sugar into conversion requires a source value as receiver.", "Use value.into<Contract>(...) with a receiver value.");
}
  let type_args = node_get_data4(n); if (typeof __tuff_this !== 'undefined') __tuff_this.type_args = type_args;
  let cname = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
  if ((((() => { const __recv = type_args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 1) && (node_kind((() => { const __recv = type_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()) === NK_NAMED_TYPE))) {
  cname = get_interned_str(node_get_data1((() => { const __recv = type_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })())); if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
}
  let cname_label = cname; if (typeof __tuff_this !== 'undefined') __tuff_this.cname_label = cname_label;
  if ((() => { const __recv = cname_label; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) {
  cname_label = "<missing>"; if (typeof __tuff_this !== 'undefined') __tuff_this.cname_label = cname_label;
}
  if (((() => { const __recv = cname; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })() || (!(() => { const __recv = tc_contract_names; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, cname) : set_has(__recv, cname); })()))) {
  tc_panic_loc("E_TYPE_INTO_UNKNOWN_CONTRACT", (() => { const __recv = (() => { const __recv = "Unknown contract '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cname_label); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cname_label) : str_concat(__recv, cname_label); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' in into conversion"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' in into conversion") : str_concat(__recv, "' in into conversion"); })(), "An into conversion referenced a contract that is not declared.", "Declare the contract before converting with into.");
}
  typecheck_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  let j = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < arg_count)) {
  typecheck_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  return 0;
}
  if ((() => { const __recv = fn_arities; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, fname) : map_has(__recv, fname); })()) {
  let expected = (() => { const __recv = fn_arities; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, fname) : map_get(__recv, fname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expected = expected;
  if ((expected !== arg_count)) {
  let msg = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Function "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fname) : str_concat(__recv, fname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = " expects "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(expected)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(expected)) : str_concat(__recv, int_to_string(expected)); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = " expects "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(expected)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(expected)) : str_concat(__recv, int_to_string(expected)); })()) : str_concat(__recv, (() => { const __recv = " expects "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(expected)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(expected)) : str_concat(__recv, int_to_string(expected)); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = " args, got "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(arg_count)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(arg_count)) : str_concat(__recv, int_to_string(arg_count)); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = " args, got "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(arg_count)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(arg_count)) : str_concat(__recv, int_to_string(arg_count)); })()) : str_concat(__recv, (() => { const __recv = " args, got "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(arg_count)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(arg_count)) : str_concat(__recv, int_to_string(arg_count)); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.msg = msg;
  tc_panic_loc("E_TYPE_ARG_COUNT", msg, "A function call provided a different number of arguments than the function signature requires.", "Pass exactly the number of parameters declared by the function.");
}
}
  if (((!(() => { const __recv = fn_arities; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, fname) : map_has(__recv, fname); })()) && (() => { const __recv = tc_dep_type_alias_params; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, fname) : map_has(__recv, fname); })())) {
  let expected_arity = (() => { const __recv = tc_dep_type_alias_params; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, fname) : map_get(__recv, fname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_arity = expected_arity;
  if ((arg_count !== expected_arity)) {
  tc_panic_loc("E_TYPE_APPLIED_ARITY", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "'"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fname) : str_concat(__recv, fname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' applied with "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' applied with ") : str_concat(__recv, "' applied with "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(arg_count)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(arg_count)) : str_concat(__recv, int_to_string(arg_count)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" argument(s), expected "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " argument(s), expected ") : str_concat(__recv, " argument(s), expected "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(expected_arity)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(expected_arity)) : str_concat(__recv, int_to_string(expected_arity)); })(), "Dependent type aliases must be applied with exactly the number of arguments declared in the type parameter list.", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Provide exactly "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(expected_arity)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(expected_arity)) : str_concat(__recv, int_to_string(expected_arity)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" argument(s) to '"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " argument(s) to '") : str_concat(__recv, " argument(s) to '"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fname) : str_concat(__recv, fname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'.") : str_concat(__recv, "'."); })());
}
}
  if ((() => { const __recv = fn_param_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, fname) : map_has(__recv, fname); })()) {
  let expected_types = (() => { const __recv = fn_param_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, fname) : map_get(__recv, fname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_types = expected_types;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < arg_count)) {
  let arg_node = (() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.arg_node = arg_node;
  let arg_name = infer_expr_type_name(arg_node, fn_return_types, local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.arg_name = arg_name;
  let expected_name = (() => { const __recv = expected_types; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_name = expected_name;
  if (((() => { const __recv = expected_name; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "*") : str_starts_with(__recv, "*"); })() && is_nullable_pointer_type_name(arg_name))) {
  tc_panic_loc("E_SAFETY_NULLABLE_POINTER_GUARD", "Call requires nullable pointer guard", "A nullable pointer argument must be proven non-null before pointer-consuming calls.", "Guard pointer use with if (p != 0USize) or if (0USize != p) before the call.");
}
  if (((!type_names_compatible(expected_name, arg_name, arg_node)) && (!(() => { const __recv = tc_type_alias_names; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(expected_name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, expected_name) : set_has(__recv, expected_name); })()))) {
  let msg = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Type mismatch in call to "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fname) : str_concat(__recv, fname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" arg "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " arg ") : str_concat(__recv, " arg "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((j + 1))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((j + 1))) : str_concat(__recv, int_to_string((j + 1))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(": expected "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ": expected ") : str_concat(__recv, ": expected "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(expected_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, expected_name) : str_concat(__recv, expected_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(", got "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ", got ") : str_concat(__recv, ", got "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(arg_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, arg_name) : str_concat(__recv, arg_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.msg = msg;
  tc_panic_loc("E_TYPE_ARG_MISMATCH", msg, "A function argument type does not match the corresponding parameter type.", "Update the call argument or function parameter type so both sides are compatible.");
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
}
  if ((() => { const __recv = fn_param_call_bounds; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, fname) : map_has(__recv, fname); })()) {
  let call_bounds_vec = (() => { const __recv = fn_param_call_bounds; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, fname) : map_get(__recv, fname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.call_bounds_vec = call_bounds_vec;
  let cj = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cj = cj;
  while (((cj < (() => { const __recv = call_bounds_vec; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()) && (cj < arg_count))) {
  let cb = (() => { const __recv = call_bounds_vec; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(cj); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, cj) : vec_get(__recv, cj); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cb = cb;
  if ((!(() => { const __recv = cb; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  let cb_sep = (() => { const __recv = cb; const __prop = __recv?.["str_index_of"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_index_of; return __dyn ? __dyn(__recv.ref, ":") : str_index_of(__recv, ":"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cb_sep = cb_sep;
  let cb_fn = (() => { const __recv = cb; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, cb_sep); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, cb_sep) : str_slice(__recv, 0, cb_sep); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cb_fn = cb_fn;
  let cb_ref_idx = parse_int((() => { const __recv = cb; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((cb_sep + 1), (() => { const __recv = cb; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (cb_sep + 1), (() => { const __recv = cb; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()) : str_slice(__recv, (cb_sep + 1), (() => { const __recv = cb; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.cb_ref_idx = cb_ref_idx;
  let constrained_arg = (() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(cj); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, cj) : vec_get(__recv, cj); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.constrained_arg = constrained_arg;
  if ((((node_kind(constrained_arg) === NK_IDENTIFIER) && (cb_ref_idx >= 0)) && (cb_ref_idx < arg_count))) {
  let constrained_name = get_interned_str(node_get_data1(constrained_arg)); if (typeof __tuff_this !== 'undefined') __tuff_this.constrained_name = constrained_name;
  let ref_arg = (() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(cb_ref_idx); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, cb_ref_idx) : vec_get(__recv, cb_ref_idx); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ref_arg = ref_arg;
  if ((node_kind(ref_arg) === NK_IDENTIFIER)) {
  let ref_arg_name = get_interned_str(node_get_data1(ref_arg)); if (typeof __tuff_this !== 'undefined') __tuff_this.ref_arg_name = ref_arg_name;
  let expected_bound = (() => { const __recv = (() => { const __recv = cb_fn; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(ref_arg_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ref_arg_name) : str_concat(__recv, ref_arg_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_bound = expected_bound;
  let proven = ((() => { const __recv = tc_call_bounds; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(constrained_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, constrained_name) : map_has(__recv, constrained_name); })() && (() => { const __recv = (() => { const __recv = tc_call_bounds; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(constrained_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, constrained_name) : map_get(__recv, constrained_name); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(expected_bound); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, expected_bound) : str_eq(__recv, expected_bound); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.proven = proven;
  if ((!proven)) {
  let msg = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Call to '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fname) : str_concat(__recv, fname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' argument "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' argument ") : str_concat(__recv, "' argument "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((cj + 1))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((cj + 1))) : str_concat(__recv, int_to_string((cj + 1))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" ('"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ('") : str_concat(__recv, " ('"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(constrained_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, constrained_name) : str_concat(__recv, constrained_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("')"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "')") : str_concat(__recv, "')"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" must be proven < "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " must be proven < ") : str_concat(__recv, " must be proven < "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cb_fn); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cb_fn) : str_concat(__recv, cb_fn); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(ref_arg_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ref_arg_name) : str_concat(__recv, ref_arg_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.msg = msg;
  tc_panic_loc("E_SAFETY_STR_BOUNDS_UNPROVEN", msg, "The argument does not have a proven upper bound matching the parameter constraint.", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Guard the call with 'if ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(constrained_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, constrained_name) : str_concat(__recv, constrained_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" < "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " < ") : str_concat(__recv, " < "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cb_fn); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cb_fn) : str_concat(__recv, cb_fn); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(ref_arg_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ref_arg_name) : str_concat(__recv, ref_arg_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("))' before calling "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "))' before calling ") : str_concat(__recv, "))' before calling "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fname) : str_concat(__recv, fname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })());
}
}
}
}
  cj = (cj + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cj = cj;
}
}
}
  typecheck_expr(callee, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < arg_count)) {
  typecheck_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((typecheck_member_or_index_expr(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs) === 1)) {
  return 0;
}
  if ((kind === NK_STRUCT_INIT)) {
  let fields = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  typecheck_expr((() => { const __recv = field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_TUPLE_EXPR)) {
  let items = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = items; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  typecheck_expr((() => { const __recv = items; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_IF_EXPR)) {
  typecheck_if_expr_branch(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  return 0;
}
  if ((kind === NK_MATCH_EXPR)) {
  typecheck_match_expr_branch(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  return 0;
}
  if ((kind === NK_IS_EXPR)) {
  typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  return 0;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheck_expr = typecheck_expr;

const __tuff_outer_for_typecheck_stmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheck_stmt(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, expected_return_type) {
  let __tuff_this = { n: n, fn_arities: fn_arities, fn_param_types: fn_param_types, fn_return_types: fn_return_types, local_types: local_types, nonnull_ptrs: nonnull_ptrs, expected_return_type: expected_return_type, this: __tuff_outer_for_typecheck_stmt };
  if ((n === 0)) {
  return 0;
}
  tc_current_node = n; if (typeof __tuff_this !== 'undefined') __tuff_this.tc_current_node = tc_current_node;
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_BLOCK)) {
  let stmts = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  typecheck_stmt((() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, expected_return_type);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_EXPECT_FN_DECL)) {
  return 0;
}
  if ((kind === NK_CONTRACT_DECL)) {
  return 0;
}
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  let prev_array_bounds = tc_array_init_bounds; if (typeof __tuff_this !== 'undefined') __tuff_this.prev_array_bounds = prev_array_bounds;
  let prev_index_bounds = tc_index_upper_bounds; if (typeof __tuff_this !== 'undefined') __tuff_this.prev_index_bounds = prev_index_bounds;
  let prev_var_literals = tc_var_literal_values; if (typeof __tuff_this !== 'undefined') __tuff_this.prev_var_literals = prev_var_literals;
  tc_array_init_bounds = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_array_init_bounds = tc_array_init_bounds;
  tc_index_upper_bounds = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_index_upper_bounds = tc_index_upper_bounds;
  tc_var_literal_values = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_var_literal_values = tc_var_literal_values;
  let fn_local_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_local_types = fn_local_types;
  let fn_nonnull_ptrs = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_nonnull_ptrs = fn_nonnull_ptrs;
  let params = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let p = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let pname = get_interned_str((() => { const __recv = p; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = (() => { const __recv = p; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if ((ptype !== 0)) {
  (() => { const __recv = fn_local_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(pname, type_name_from_type_node(ptype)); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, pname, type_name_from_type_node(ptype)) : map_set(__recv, pname, type_name_from_type_node(ptype)); })();
  let arr_init_bound = try_get_array_init_bound_from_type_node(ptype); if (typeof __tuff_this !== 'undefined') __tuff_this.arr_init_bound = arr_init_bound;
  if ((arr_init_bound >= 0)) {
  (() => { const __recv = tc_array_init_bounds; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(pname, arr_init_bound); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, pname, arr_init_bound) : map_set(__recv, pname, arr_init_bound); })();
}
  let index_upper_bound = try_get_index_upper_bound_from_type_node(ptype); if (typeof __tuff_this !== 'undefined') __tuff_this.index_upper_bound = index_upper_bound;
  if ((index_upper_bound >= 0)) {
  (() => { const __recv = tc_index_upper_bounds; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(pname, index_upper_bound); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, pname, index_upper_bound) : map_set(__recv, pname, index_upper_bound); })();
}
  if (type_node_proves_nonzero(ptype)) {
  (() => { const __recv = fn_nonnull_ptrs; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(pname, 1); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, pname, 1) : map_set(__recv, pname, 1); })();
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let expected_name = type_name_from_type_node(node_get_data4(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_name = expected_name;
  let fn_body = node_get_data5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_body = fn_body;
  let fname_str = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname_str = fname_str;
  let has_this_param = false; if (typeof __tuff_this !== 'undefined') __tuff_this.has_this_param = has_this_param;
  let pi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.pi = pi;
  while ((pi < (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  if ((() => { const __recv = get_interned_str((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(pi); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, pi) : vec_get(__recv, pi); })(); const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })()) {
  has_this_param = true; if (typeof __tuff_this !== 'undefined') __tuff_this.has_this_param = has_this_param;
}
  pi = (pi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.pi = pi;
}
  if (((!has_this_param) && (node_get_data4(n) === 0))) {
  let terminates_with_this = false; if (typeof __tuff_this !== 'undefined') __tuff_this.terminates_with_this = terminates_with_this;
  if ((node_kind(fn_body) === NK_BLOCK)) {
  let body_stmts = node_get_data1(fn_body); if (typeof __tuff_this !== 'undefined') __tuff_this.body_stmts = body_stmts;
  let blen = (() => { const __recv = body_stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.blen = blen;
  if ((blen > 0)) {
  let last_stmt = (() => { const __recv = body_stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop((blen - 1)); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, (blen - 1)) : vec_get(__recv, (blen - 1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.last_stmt = last_stmt;
  if ((node_kind(last_stmt) === NK_EXPR_STMT)) {
  let last_expr = node_get_data1(last_stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.last_expr = last_expr;
  if (((node_kind(last_expr) === NK_IDENTIFIER) && (() => { const __recv = get_interned_str(node_get_data1(last_expr)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })())) {
  terminates_with_this = true; if (typeof __tuff_this !== 'undefined') __tuff_this.terminates_with_this = terminates_with_this;
}
}
}
} else { if ((node_kind(fn_body) === NK_IDENTIFIER)) {
  if ((() => { const __recv = get_interned_str(node_get_data1(fn_body)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })()) {
  terminates_with_this = true; if (typeof __tuff_this !== 'undefined') __tuff_this.terminates_with_this = terminates_with_this;
}
} }
  if (terminates_with_this) {
  let this_fields = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.this_fields = this_fields;
  (() => { const __recv = this_fields; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, "this") : set_add(__recv, "this"); })();
  let qi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.qi = qi;
  while ((qi < (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let pn = get_interned_str((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(qi); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, qi) : vec_get(__recv, qi); })(); const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pn = pn;
  if ((!(() => { const __recv = pn; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })())) {
  (() => { const __recv = this_fields; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(pn); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, pn) : set_add(__recv, pn); })();
}
  qi = (qi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.qi = qi;
}
  if ((node_kind(fn_body) === NK_BLOCK)) {
  let body_stmts = node_get_data1(fn_body); if (typeof __tuff_this !== 'undefined') __tuff_this.body_stmts = body_stmts;
  let bi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.bi = bi;
  let blen2 = (() => { const __recv = body_stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.blen2 = blen2;
  while ((bi < blen2)) {
  let bstmt = (() => { const __recv = body_stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(bi); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, bi) : vec_get(__recv, bi); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.bstmt = bstmt;
  let bkind = node_kind(bstmt); if (typeof __tuff_this !== 'undefined') __tuff_this.bkind = bkind;
  if ((bkind === NK_LET_DECL)) {
  (() => { const __recv = this_fields; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(bstmt))); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(bstmt))) : set_add(__recv, get_interned_str(node_get_data1(bstmt))); })();
}
  if (((bkind === NK_FN_DECL) || (bkind === NK_CLASS_FN_DECL))) {
  (() => { const __recv = this_fields; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(bstmt))); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(bstmt))) : set_add(__recv, get_interned_str(node_get_data1(bstmt))); })();
}
  bi = (bi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.bi = bi;
}
}
  (() => { const __recv = tc_fn_this_fields; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(fname_str, this_fields); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, fname_str, this_fields) : map_set(__recv, fname_str, this_fields); })();
  (() => { const __recv = fn_return_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(fname_str, (() => { const __recv = "__this_"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fname_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fname_str) : str_concat(__recv, fname_str); })()); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, fname_str, (() => { const __recv = "__this_"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fname_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fname_str) : str_concat(__recv, fname_str); })()) : map_set(__recv, fname_str, (() => { const __recv = "__this_"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fname_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fname_str) : str_concat(__recv, fname_str); })()); })();
}
}
  typecheck_stmt(node_get_data5(n), fn_arities, fn_param_types, fn_return_types, fn_local_types, fn_nonnull_ptrs, expected_name);
  let body = node_get_data5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if ((node_kind(body) !== NK_BLOCK)) {
  let body_name = infer_expr_type_name(body, fn_return_types, fn_local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.body_name = body_name;
  if ((!type_names_compatible(expected_name, body_name, body))) {
  let fname = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  tc_panic_loc("E_TYPE_RETURN_MISMATCH", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Function "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fname) : str_concat(__recv, fname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" return type mismatch: expected "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " return type mismatch: expected ") : str_concat(__recv, " return type mismatch: expected "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(expected_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, expected_name) : str_concat(__recv, expected_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(", got "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ", got ") : str_concat(__recv, ", got "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(body_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, body_name) : str_concat(__recv, body_name); })(), "The function body expression type does not match the declared return type.", "Update the function return type annotation or adjust the returned expression.");
}
}
  tc_array_init_bounds = prev_array_bounds; if (typeof __tuff_this !== 'undefined') __tuff_this.tc_array_init_bounds = tc_array_init_bounds;
  tc_index_upper_bounds = prev_index_bounds; if (typeof __tuff_this !== 'undefined') __tuff_this.tc_index_upper_bounds = tc_index_upper_bounds;
  tc_var_literal_values = prev_var_literals; if (typeof __tuff_this !== 'undefined') __tuff_this.tc_var_literal_values = tc_var_literal_values;
  return 0;
}
  if ((kind === NK_LET_DECL)) {
  let declared_type = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.declared_type = declared_type;
  let rhs = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.rhs = rhs;
  typecheck_expr(rhs, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  let rhs_name = infer_expr_type_name(rhs, fn_return_types, local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.rhs_name = rhs_name;
  if ((declared_type !== 0)) {
  let declared_name = type_name_from_type_node(declared_type); if (typeof __tuff_this !== 'undefined') __tuff_this.declared_name = declared_name;
  if ((((!type_names_compatible(declared_name, rhs_name, rhs)) && (!(() => { const __recv = tc_type_alias_names; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(declared_name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, declared_name) : set_has(__recv, declared_name); })())) && (!is_this_return_type_for(rhs_name, declared_name)))) {
  let vname = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.vname = vname;
  let msg = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Type mismatch for let "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(vname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, vname) : str_concat(__recv, vname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(": expected "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ": expected ") : str_concat(__recv, ": expected "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(declared_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, declared_name) : str_concat(__recv, declared_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(", got "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ", got ") : str_concat(__recv, ", got "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(rhs_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, rhs_name) : str_concat(__recv, rhs_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.msg = msg;
  tc_panic_loc("E_TYPE_LET_MISMATCH", msg, "An explicit let type annotation does not match the assigned RHS expression type.", "Update the explicit type annotation or change the RHS expression to match.");
}
  let lname = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.lname = lname;
  (() => { const __recv = local_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(lname, declared_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, lname, declared_name) : map_set(__recv, lname, declared_name); })();
  let arr_init_bound = try_get_array_init_bound_from_type_node(declared_type); if (typeof __tuff_this !== 'undefined') __tuff_this.arr_init_bound = arr_init_bound;
  if ((arr_init_bound >= 0)) {
  (() => { const __recv = tc_array_init_bounds; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(lname, arr_init_bound); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, lname, arr_init_bound) : map_set(__recv, lname, arr_init_bound); })();
}
  let index_upper_bound = try_get_index_upper_bound_from_type_node(declared_type); if (typeof __tuff_this !== 'undefined') __tuff_this.index_upper_bound = index_upper_bound;
  if ((index_upper_bound >= 0)) {
  (() => { const __recv = tc_index_upper_bounds; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(lname, index_upper_bound); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, lname, index_upper_bound) : map_set(__recv, lname, index_upper_bound); })();
}
} else { if ((!(() => { const __recv = rhs_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Unknown") : str_eq(__recv, "Unknown"); })())) {
  (() => { const __recv = local_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n)), rhs_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n)), rhs_name) : map_set(__recv, get_interned_str(node_get_data1(n)), rhs_name); })();
} }
  let lit_val = try_get_known_int_value(rhs); if (typeof __tuff_this !== 'undefined') __tuff_this.lit_val = lit_val;
  if (known_int_value_is_valid(lit_val)) {
  (() => { const __recv = tc_var_literal_values; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n)), lit_val); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n)), lit_val) : map_set(__recv, get_interned_str(node_get_data1(n)), lit_val); })();
}
  return 0;
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  return 0;
}
  if ((kind === NK_EXPR_STMT)) {
  typecheck_expr(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  return 0;
}
  if ((kind === NK_ASSIGN_STMT)) {
  let target = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let value = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  typecheck_expr(target, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  typecheck_expr(value, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  if ((node_kind(target) === NK_IDENTIFIER)) {
  let tname = get_interned_str(node_get_data1(target)); if (typeof __tuff_this !== 'undefined') __tuff_this.tname = tname;
  if ((() => { const __recv = local_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(tname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, tname) : map_has(__recv, tname); })()) {
  let expected_name = (() => { const __recv = local_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(tname); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, tname) : map_get(__recv, tname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expected_name = expected_name;
  let value_name = infer_expr_type_name(value, fn_return_types, local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.value_name = value_name;
  if (((!type_names_compatible(expected_name, value_name, value)) && (!(() => { const __recv = tc_type_alias_names; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(expected_name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, expected_name) : set_has(__recv, expected_name); })()))) {
  tc_panic_loc("E_TYPE_ASSIGN_MISMATCH", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Assignment mismatch for "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(tname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, tname) : str_concat(__recv, tname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(": expected "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ": expected ") : str_concat(__recv, ": expected "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(expected_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, expected_name) : str_concat(__recv, expected_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(", got "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ", got ") : str_concat(__recv, ", got "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(value_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, value_name) : str_concat(__recv, value_name); })(), "The assigned value type is incompatible with the declared variable type.", "Assign a compatible value or change the variable type declaration.");
}
}
}
  return 0;
}
  if ((kind === NK_RETURN_STMT)) {
  let value = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  typecheck_expr(value, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  if ((!(() => { const __recv = expected_return_type; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Unknown") : str_eq(__recv, "Unknown"); })())) {
  let value_name = infer_expr_type_name(value, fn_return_types, local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.value_name = value_name;
  if ((!type_names_compatible(expected_return_type, value_name, value))) {
  tc_panic_loc("E_TYPE_RETURN_MISMATCH", (() => { const __recv = (() => { const __recv = (() => { const __recv = "Return type mismatch: expected "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(expected_return_type); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, expected_return_type) : str_concat(__recv, expected_return_type); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(", got "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ", got ") : str_concat(__recv, ", got "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(value_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, value_name) : str_concat(__recv, value_name); })(), "A return statement produced a value incompatible with the function's declared return type.", "Return a value of the declared type or adjust the function return annotation.");
}
}
  return 0;
}
  if ((kind === NK_IF_STMT)) {
  typecheck_if_stmt_branch(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, expected_return_type);
  return 0;
}
  if ((kind === NK_FOR_STMT)) {
  typecheck_expr(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  typecheck_expr(node_get_data3(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  typecheck_stmt(node_get_data4(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, expected_return_type);
  return 0;
}
  if ((kind === NK_WHILE_STMT)) {
  let cond = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  typecheck_expr(cond, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  let cond_name = infer_expr_type_name(cond, fn_return_types, local_types); if (typeof __tuff_this !== 'undefined') __tuff_this.cond_name = cond_name;
  if (((!(() => { const __recv = cond_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Bool"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Bool") : str_eq(__recv, "Bool"); })()) && (!(() => { const __recv = cond_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Unknown") : str_eq(__recv, "Unknown"); })()))) {
  tc_panic_loc("E_TYPE_IF_CONDITION", (() => { const __recv = "if condition must be Bool, got "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond_name) : str_concat(__recv, cond_name); })(), "Conditional branches require a boolean predicate, but the given expression has a non-Bool type.", "Return or compute a Bool expression in the condition.");
}
  let wh_cb_key = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.wh_cb_key = wh_cb_key;
  let wh_cb_value = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.wh_cb_value = wh_cb_value;
  if ((node_kind(cond) === NK_BINARY_EXPR)) {
  let wh_bop = get_interned_str(node_get_data1(cond)); if (typeof __tuff_this !== 'undefined') __tuff_this.wh_bop = wh_bop;
  let wh_bleft = node_get_data2(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.wh_bleft = wh_bleft;
  let wh_bright = node_get_data3(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.wh_bright = wh_bright;
  if (((((() => { const __recv = wh_bop; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<") : str_eq(__recv, "<"); })() || (() => { const __recv = wh_bop; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<=") : str_eq(__recv, "<="); })()) && (node_kind(wh_bleft) === NK_IDENTIFIER)) && (node_kind(wh_bright) === NK_CALL_EXPR))) {
  let wh_callee = node_get_data1(wh_bright); if (typeof __tuff_this !== 'undefined') __tuff_this.wh_callee = wh_callee;
  let wh_args = node_get_data2(wh_bright); if (typeof __tuff_this !== 'undefined') __tuff_this.wh_args = wh_args;
  if ((((node_kind(wh_callee) === NK_IDENTIFIER) && ((() => { const __recv = wh_args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 1)) && (node_kind((() => { const __recv = wh_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()) === NK_IDENTIFIER))) {
  wh_cb_key = get_interned_str(node_get_data1(wh_bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.wh_cb_key = wh_cb_key;
  wh_cb_value = (() => { const __recv = (() => { const __recv = get_interned_str(node_get_data1(wh_callee)); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1((() => { const __recv = wh_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1((() => { const __recv = wh_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))) : str_concat(__recv, get_interned_str(node_get_data1((() => { const __recv = wh_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.wh_cb_value = wh_cb_value;
}
}
}
  let wh_cb_was_present = false; if (typeof __tuff_this !== 'undefined') __tuff_this.wh_cb_was_present = wh_cb_was_present;
  if ((!(() => { const __recv = wh_cb_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  wh_cb_was_present = (() => { const __recv = tc_call_bounds; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(wh_cb_key); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, wh_cb_key) : map_has(__recv, wh_cb_key); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.wh_cb_was_present = wh_cb_was_present;
  (() => { const __recv = tc_call_bounds; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(wh_cb_key, wh_cb_value); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, wh_cb_key, wh_cb_value) : map_set(__recv, wh_cb_key, wh_cb_value); })();
}
  typecheck_stmt(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, expected_return_type);
  if (((!(() => { const __recv = wh_cb_key; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) && (!wh_cb_was_present))) {
  (() => { const __recv = tc_call_bounds; const __prop = __recv?.["map_delete"]; if (typeof __prop === "function") return __prop(wh_cb_key); const __dyn = __recv?.table?.map_delete; return __dyn ? __dyn(__recv.ref, wh_cb_key) : map_delete(__recv, wh_cb_key); })();
}
  return 0;
}
  if ((kind === NK_LOOP_STMT)) {
  typecheck_stmt(node_get_data1(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, expected_return_type);
  return 0;
}
  if ((kind === NK_LIFETIME_STMT)) {
  typecheck_stmt(node_get_data2(n), fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs, expected_return_type);
  return 0;
}
  if ((kind === NK_INTO_STMT)) {
  let cname = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
  if ((!(() => { const __recv = tc_contract_names; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, cname) : set_has(__recv, cname); })())) {
  tc_panic_loc("E_TYPE_UNKNOWN_CONTRACT", (() => { const __recv = (() => { const __recv = "Unknown contract '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cname) : str_concat(__recv, cname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' in into statement"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' in into statement") : str_concat(__recv, "' in into statement"); })(), "An into statement referenced a contract that is not declared.", "Declare the contract before using 'into'.");
}
  return 0;
}
  if ((kind === NK_TYPE_ALIAS)) {
  let alias_name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  (() => { const __recv = tc_type_alias_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, alias_name) : set_add(__recv, alias_name); })();
  let destructor_name_idx = node_get_data5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name_idx = destructor_name_idx;
  if ((destructor_name_idx !== 0)) {
  let destructor_name = get_interned_str(destructor_name_idx); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
  (() => { const __recv = tc_destructor_alias_by_alias; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, destructor_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, destructor_name) : map_set(__recv, alias_name, destructor_name); })();
  (() => { const __recv = tc_destructor_alias_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, alias_name) : vec_push(__recv, alias_name); })();
}
  return 0;
}
  if ((kind === NK_DEP_TYPE_ALIAS)) {
  let alias_name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  (() => { const __recv = tc_type_alias_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, alias_name) : set_add(__recv, alias_name); })();
  let value_params = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.value_params = value_params;
  (() => { const __recv = tc_dep_type_alias_params; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()) : map_set(__recv, alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); })();
  let alias_base_type = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_base_type = alias_base_type;
  let alias_base_type_name = type_name_from_type_node(alias_base_type); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_base_type_name = alias_base_type_name;
  if ((!(() => { const __recv = alias_base_type_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Unknown") : str_eq(__recv, "Unknown"); })())) {
  (() => { const __recv = tc_alias_base_type; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, alias_base_type_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, alias_base_type_name) : map_set(__recv, alias_name, alias_base_type_name); })();
}
  return 0;
}
  if ((kind === NK_EXTERN_TYPE_DECL)) {
  let alias_name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  (() => { const __recv = tc_type_alias_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, alias_name) : set_add(__recv, alias_name); })();
  let value_params = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.value_params = value_params;
  (() => { const __recv = tc_extern_type_params; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()) : map_set(__recv, alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); })();
  let destructor_name_idx = node_get_data5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name_idx = destructor_name_idx;
  if ((destructor_name_idx !== 0)) {
  let destructor_name = get_interned_str(destructor_name_idx); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
  (() => { const __recv = tc_destructor_alias_by_alias; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, destructor_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, destructor_name) : map_set(__recv, alias_name, destructor_name); })();
  (() => { const __recv = tc_destructor_alias_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, alias_name) : vec_push(__recv, alias_name); })();
}
  return 0;
}
  typecheck_expr(n, fn_arities, fn_param_types, fn_return_types, local_types, nonnull_ptrs);
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheck_stmt = typecheck_stmt;

const __tuff_outer_for_typecheck_program_with_options_impl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheck_program_with_options_impl(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_typecheck_program_with_options_impl };
  let fn_arities = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_arities = fn_arities;
  let fn_param_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_param_types = fn_param_types;
  let fn_return_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_return_types = fn_return_types;
  let fn_nodes = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_nodes = fn_nodes;
  let local_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.local_types = local_types;
  tc_global_value_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_global_value_types = tc_global_value_types;
  tc_alias_union_tags = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_alias_union_tags = tc_alias_union_tags;
  tc_type_alias_names = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_type_alias_names = tc_type_alias_names;
  tc_dep_type_alias_params = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_dep_type_alias_params = tc_dep_type_alias_params;
  tc_extern_type_params = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_extern_type_params = tc_extern_type_params;
  tc_contract_names = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_contract_names = tc_contract_names;
  tc_destructor_alias_by_alias = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_destructor_alias_by_alias = tc_destructor_alias_by_alias;
  tc_destructor_alias_names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_destructor_alias_names = tc_destructor_alias_names;
  tc_fn_this_fields = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_fn_this_fields = tc_fn_this_fields;
  tc_alias_base_type = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_alias_base_type = tc_alias_base_type;
  tc_type_name_cache = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_type_name_cache = tc_type_name_cache;
  tc_call_bounds = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tc_call_bounds = tc_call_bounds;
  fn_param_call_bounds = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_param_call_bounds = fn_param_call_bounds;
  let body = node_get_data1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let pre_i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.pre_i = pre_i;
  let pre_len = (() => { const __recv = body; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pre_len = pre_len;
  while ((pre_i < pre_len)) {
  let pre_stmt = (() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(pre_i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, pre_i) : vec_get(__recv, pre_i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pre_stmt = pre_stmt;
  let pre_kind = node_kind(pre_stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.pre_kind = pre_kind;
  if ((pre_kind === NK_EXTERN_TYPE_DECL)) {
  let alias_name = get_interned_str(node_get_data1(pre_stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  (() => { const __recv = tc_type_alias_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, alias_name) : set_add(__recv, alias_name); })();
  let value_params = node_get_data2(pre_stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.value_params = value_params;
  (() => { const __recv = tc_extern_type_params; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()) : map_set(__recv, alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); })();
}
  if ((pre_kind === NK_DEP_TYPE_ALIAS)) {
  let alias_name = get_interned_str(node_get_data1(pre_stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  (() => { const __recv = tc_type_alias_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, alias_name) : set_add(__recv, alias_name); })();
  let value_params = node_get_data2(pre_stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.value_params = value_params;
  (() => { const __recv = tc_dep_type_alias_params; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()) : map_set(__recv, alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); })();
}
  pre_i = (pre_i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.pre_i = pre_i;
}
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = body; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  let name = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  (() => { const __recv = fn_nodes; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(name, stmt); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, name, stmt) : map_set(__recv, name, stmt); })();
  let params = node_get_data3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  (() => { const __recv = fn_arities; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(name, (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, name, (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()) : map_set(__recv, name, (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); })();
  let param_types = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.param_types = param_types;
  let param_call_bounds_vec = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.param_call_bounds_vec = param_call_bounds_vec;
  let p = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  while ((p < (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let param = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(p); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, p) : vec_get(__recv, p); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  let param_type_node = (() => { const __recv = param; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.param_type_node = param_type_node;
  (() => { const __recv = param_types; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(type_name_from_type_node(param_type_node)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, type_name_from_type_node(param_type_node)) : vec_push(__recv, type_name_from_type_node(param_type_node)); })();
  let raw_constraint = try_extract_fn_call_constraint(param_type_node); if (typeof __tuff_this !== 'undefined') __tuff_this.raw_constraint = raw_constraint;
  if ((!(() => { const __recv = raw_constraint; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  let sep = (() => { const __recv = raw_constraint; const __prop = __recv?.["str_index_of"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_index_of; return __dyn ? __dyn(__recv.ref, ":") : str_index_of(__recv, ":"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.sep = sep;
  let fn_part = (() => { const __recv = raw_constraint; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, sep); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, sep) : str_slice(__recv, 0, sep); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_part = fn_part;
  let ref_name = (() => { const __recv = raw_constraint; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((sep + 1), (() => { const __recv = raw_constraint; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (sep + 1), (() => { const __recv = raw_constraint; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()) : str_slice(__recv, (sep + 1), (() => { const __recv = raw_constraint; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ref_name = ref_name;
  let ref_idx = (-1); if (typeof __tuff_this !== 'undefined') __tuff_this.ref_idx = ref_idx;
  let pi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.pi = pi;
  while ((pi < (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let pi_name = get_interned_str((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(pi); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, pi) : vec_get(__recv, pi); })(); const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pi_name = pi_name;
  if ((() => { const __recv = pi_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(ref_name); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ref_name) : str_eq(__recv, ref_name); })()) {
  ref_idx = pi; if (typeof __tuff_this !== 'undefined') __tuff_this.ref_idx = ref_idx;
}
  pi = (pi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.pi = pi;
}
  if ((ref_idx >= 0)) {
  (() => { const __recv = param_call_bounds_vec; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = fn_part; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(ref_idx)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(ref_idx)) : str_concat(__recv, int_to_string(ref_idx)); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = fn_part; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(ref_idx)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(ref_idx)) : str_concat(__recv, int_to_string(ref_idx)); })()) : vec_push(__recv, (() => { const __recv = (() => { const __recv = fn_part; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(ref_idx)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(ref_idx)) : str_concat(__recv, int_to_string(ref_idx)); })()); })();
} else {
  (() => { const __recv = param_call_bounds_vec; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, "") : vec_push(__recv, ""); })();
}
} else {
  (() => { const __recv = param_call_bounds_vec; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, "") : vec_push(__recv, ""); })();
}
  p = (p + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
}
  (() => { const __recv = fn_param_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(name, param_types); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, name, param_types) : map_set(__recv, name, param_types); })();
  (() => { const __recv = fn_param_call_bounds; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(name, param_call_bounds_vec); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, name, param_call_bounds_vec) : map_set(__recv, name, param_call_bounds_vec); })();
  let ret_type = node_get_data4(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.ret_type = ret_type;
  (() => { const __recv = fn_return_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(name, type_name_from_type_node(ret_type)); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, name, type_name_from_type_node(ret_type)) : map_set(__recv, name, type_name_from_type_node(ret_type)); })();
}
  if ((kind === NK_EXTERN_LET_DECL)) {
  let vname = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.vname = vname;
  let vtype = node_get_data2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.vtype = vtype;
  let tname = type_name_from_type_node(vtype); if (typeof __tuff_this !== 'undefined') __tuff_this.tname = tname;
  (() => { const __recv = local_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(vname, tname); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, vname, tname) : map_set(__recv, vname, tname); })();
  (() => { const __recv = tc_global_value_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(vname, tname); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, vname, tname) : map_set(__recv, vname, tname); })();
}
  if ((kind === NK_TYPE_ALIAS)) {
  let alias_name = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  (() => { const __recv = tc_type_alias_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, alias_name) : set_add(__recv, alias_name); })();
  let alias_type = node_get_data3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_type = alias_type;
  let tags = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.tags = tags;
  collect_union_named_tags(alias_type, tags);
  if (((() => { const __recv = tags; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() > 0)) {
  (() => { const __recv = tc_alias_union_tags; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, tags); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, tags) : map_set(__recv, alias_name, tags); })();
}
  let destructor_name_idx = node_get_data5(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name_idx = destructor_name_idx;
  if ((destructor_name_idx !== 0)) {
  let destructor_name = get_interned_str(destructor_name_idx); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
  (() => { const __recv = tc_destructor_alias_by_alias; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, destructor_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, destructor_name) : map_set(__recv, alias_name, destructor_name); })();
  (() => { const __recv = tc_destructor_alias_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, alias_name) : vec_push(__recv, alias_name); })();
}
  let alias_base_type = node_get_data3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_base_type = alias_base_type;
  let alias_base_type_name = type_name_from_type_node(alias_base_type); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_base_type_name = alias_base_type_name;
  if ((!(() => { const __recv = alias_base_type_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Unknown") : str_eq(__recv, "Unknown"); })())) {
  (() => { const __recv = tc_alias_base_type; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, alias_base_type_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, alias_base_type_name) : map_set(__recv, alias_name, alias_base_type_name); })();
}
}
  if ((kind === NK_DEP_TYPE_ALIAS)) {
  let alias_name = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  (() => { const __recv = tc_type_alias_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, alias_name) : set_add(__recv, alias_name); })();
  let value_params = node_get_data2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.value_params = value_params;
  (() => { const __recv = tc_dep_type_alias_params; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()) : map_set(__recv, alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); })();
  let alias_base_type = node_get_data3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_base_type = alias_base_type;
  let alias_base_type_name = type_name_from_type_node(alias_base_type); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_base_type_name = alias_base_type_name;
  if ((!(() => { const __recv = alias_base_type_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Unknown") : str_eq(__recv, "Unknown"); })())) {
  (() => { const __recv = tc_alias_base_type; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, alias_base_type_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, alias_base_type_name) : map_set(__recv, alias_name, alias_base_type_name); })();
}
}
  if ((kind === NK_EXTERN_TYPE_DECL)) {
  let alias_name = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  (() => { const __recv = tc_type_alias_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, alias_name) : set_add(__recv, alias_name); })();
  let value_params = node_get_data2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.value_params = value_params;
  (() => { const __recv = tc_extern_type_params; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()) : map_set(__recv, alias_name, (() => { const __recv = value_params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); })();
  let destructor_name_idx = node_get_data5(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name_idx = destructor_name_idx;
  if ((destructor_name_idx !== 0)) {
  let destructor_name = get_interned_str(destructor_name_idx); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
  (() => { const __recv = tc_destructor_alias_by_alias; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, destructor_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, destructor_name) : map_set(__recv, alias_name, destructor_name); })();
  (() => { const __recv = tc_destructor_alias_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, alias_name) : vec_push(__recv, alias_name); })();
}
}
  if ((kind === NK_CONTRACT_DECL)) {
  (() => { const __recv = tc_contract_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(stmt))); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(stmt))) : set_add(__recv, get_interned_str(node_get_data1(stmt))); })();
}
  if ((kind === NK_LET_DECL)) {
  let vname = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.vname = vname;
  let vtype = node_get_data2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.vtype = vtype;
  if ((vtype !== 0)) {
  (() => { const __recv = tc_global_value_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(vname, type_name_from_type_node(vtype)); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, vname, type_name_from_type_node(vtype)) : map_set(__recv, vname, type_name_from_type_node(vtype)); })();
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let destructor_alias_count = (() => { const __recv = tc_destructor_alias_names; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_alias_count = destructor_alias_count;
  while ((i < destructor_alias_count)) {
  let alias_name = (() => { const __recv = tc_destructor_alias_names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  let destructor_name = (() => { const __recv = tc_destructor_alias_by_alias; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, alias_name) : map_get(__recv, alias_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
  if ((!(() => { const __recv = fn_nodes; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(destructor_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, destructor_name) : map_has(__recv, destructor_name); })())) {
  tc_panic_loc("E_TYPE_DESTRUCTOR_NOT_FOUND", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Destructor '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(destructor_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, destructor_name) : str_concat(__recv, destructor_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' for alias '"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' for alias '") : str_concat(__recv, "' for alias '"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias_name) : str_concat(__recv, alias_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' was not found"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' was not found") : str_concat(__recv, "' was not found"); })(), "A type alias referenced a destructor function that does not exist.", "Declare the destructor function before using it in 'type Alias = ... then destructor'.");
}
  let fn_node = (() => { const __recv = fn_nodes; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(destructor_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, destructor_name) : map_get(__recv, destructor_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_node = fn_node;
  let params = node_get_data3(fn_node); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let valid = true; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
  if (((() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() !== 1)) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
} else {
  let p0 = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p0 = p0;
  let pname = get_interned_str((() => { const __recv = p0; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = (() => { const __recv = p0; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if ((!(() => { const __recv = pname; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })())) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
}
  if ((!type_node_is_destructor_receiver(ptype, alias_name))) {
  let ptype_name = type_name_from_type_node(ptype); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype_name = ptype_name;
  let base_type_ok = ((() => { const __recv = tc_alias_base_type; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, alias_name) : map_has(__recv, alias_name); })() && (() => { const __recv = ptype_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop((() => { const __recv = tc_alias_base_type; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, alias_name) : map_get(__recv, alias_name); })()); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, (() => { const __recv = tc_alias_base_type; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, alias_name) : map_get(__recv, alias_name); })()) : str_eq(__recv, (() => { const __recv = tc_alias_base_type; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, alias_name) : map_get(__recv, alias_name); })()); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.base_type_ok = base_type_ok;
  if ((!base_type_ok)) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
}
}
}
  let ret_name = type_name_from_type_node(node_get_data4(fn_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.ret_name = ret_name;
  if (((!(() => { const __recv = ret_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Void"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Void") : str_eq(__recv, "Void"); })()) && (!(() => { const __recv = ret_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Unknown") : str_eq(__recv, "Unknown"); })()))) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
}
  if ((!valid)) {
  tc_panic_loc("E_TYPE_DESTRUCTOR_SIGNATURE", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Destructor '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(destructor_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, destructor_name) : str_concat(__recv, destructor_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' must have signature fn "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' must have signature fn ") : str_concat(__recv, "' must have signature fn "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(destructor_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, destructor_name) : str_concat(__recv, destructor_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(this : "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(this : ") : str_concat(__recv, "(this : "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias_name) : str_concat(__recv, alias_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("<...>) : Void"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "<...>) : Void") : str_concat(__recv, "<...>) : Void"); })(), "Destructor signatures must follow the required receiver and return type contract.", "Use exactly one receiver parameter named 'this' with the alias type (or legacy '*move AliasType') and return Void.");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  typecheck_stmt((() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), fn_arities, fn_param_types, fn_return_types, local_types, map_new(), "Unknown");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return program;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheck_program_with_options_impl = typecheck_program_with_options_impl;

const __tuff_outer_for_typecheck_program_impl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheck_program_impl(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_typecheck_program_impl };
  return typecheck_program_with_options_impl(program);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheck_program_impl = typecheck_program_impl;

const __tuff_outer_for_selfhost_typecheck_impl_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_typecheck_impl_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_typecheck_impl_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_typecheck_impl_marker = selfhost_typecheck_impl_marker;

const __tuff_outer_for_typecheck_program_with_options = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheck_program_with_options(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_typecheck_program_with_options };
  return typecheck_program_with_options_impl(program);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheck_program_with_options = typecheck_program_with_options;

const __tuff_outer_for_typecheck_program = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheck_program(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_typecheck_program };
  return typecheck_program_impl(program);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheck_program = typecheck_program;

const __tuff_outer_for_selfhost_typecheck_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_typecheck_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_typecheck_marker };
  return selfhost_typecheck_impl_marker();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_typecheck_marker = selfhost_typecheck_marker;

let bc_current_node = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.bc_current_node = bc_current_node;

let bc_global_value_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.bc_global_value_types = bc_global_value_types;

let bc_copy_types = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.bc_copy_types = bc_copy_types;

let bc_copy_alias_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.bc_copy_alias_types = bc_copy_alias_types;

let bc_copy_alias_names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.bc_copy_alias_names = bc_copy_alias_names;

let bc_destructor_aliases = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.bc_destructor_aliases = bc_destructor_aliases;

let bc_destructor_alias_names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.bc_destructor_alias_names = bc_destructor_alias_names;

const __tuff_outer_for_bc_str_ends_with_local = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bc_str_ends_with_local(s, suffix) {
  let __tuff_this = { s: s, suffix: suffix, this: __tuff_outer_for_bc_str_ends_with_local };
  let ns = (() => { const __recv = s; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ns = ns;
  let nf = (() => { const __recv = suffix; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.nf = nf;
  if ((nf > ns)) {
  return false;
}
  return (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((ns - nf), ns); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (ns - nf), ns) : str_slice(__recv, (ns - nf), ns); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(suffix); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, suffix) : str_eq(__recv, suffix); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bc_str_ends_with_local = bc_str_ends_with_local;

const __tuff_outer_for_bc_type_name_from_type_node = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bc_type_name_from_type_node(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_bc_type_name_from_type_node };
  if ((t === 0)) {
  return "Unknown";
}
  let k = node_kind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_NAMED_TYPE)) {
  return get_interned_str(node_get_data1(t));
}
  if ((k === NK_REFINEMENT_TYPE)) {
  return bc_type_name_from_type_node(node_get_data1(t));
}
  if ((k === NK_POINTER_TYPE)) {
  let mutable = node_get_data1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.mutable = mutable;
  let inner = bc_type_name_from_type_node(node_get_data2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let move_ptr = node_get_data3(t); if (typeof __tuff_this !== 'undefined') __tuff_this.move_ptr = move_ptr;
  let life_idx = node_get_data4(t); if (typeof __tuff_this !== 'undefined') __tuff_this.life_idx = life_idx;
  let life_prefix = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.life_prefix = life_prefix;
  if ((life_idx !== 0)) {
  life_prefix = (() => { const __recv = get_interned_str(life_idx); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.life_prefix = life_prefix;
}
  if ((move_ptr === 1)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(life_prefix); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, life_prefix) : str_concat(__recv, life_prefix); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("move "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "move ") : str_concat(__recv, "move "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })();
}
  if ((mutable === 1)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(life_prefix); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, life_prefix) : str_concat(__recv, life_prefix); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "mut ") : str_concat(__recv, "mut "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })();
}
  return (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(life_prefix); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, life_prefix) : str_concat(__recv, life_prefix); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })();
}
  if ((k === NK_UNION_TYPE)) {
  let left = bc_type_name_from_type_node(node_get_data1(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  let right = bc_type_name_from_type_node(node_get_data2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  return (() => { const __recv = (() => { const __recv = left; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "|") : str_concat(__recv, "|"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, right) : str_concat(__recv, right); })();
}
  return "Unknown";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bc_type_name_from_type_node = bc_type_name_from_type_node;

const __tuff_outer_for_is_copy_primitive = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_copy_primitive(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_is_copy_primitive };
  return ((((((((((((((((() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I8"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I8") : str_eq(__recv, "I8"); })() || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I16"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I16") : str_eq(__recv, "I16"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I32") : str_eq(__recv, "I32"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I64"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I64") : str_eq(__recv, "I64"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I128"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I128") : str_eq(__recv, "I128"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U8") : str_eq(__recv, "U8"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U16") : str_eq(__recv, "U16"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U32") : str_eq(__recv, "U32"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U64"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U64") : str_eq(__recv, "U64"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U128"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U128") : str_eq(__recv, "U128"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "USize") : str_eq(__recv, "USize"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("ISize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "ISize") : str_eq(__recv, "ISize"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("F32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "F32") : str_eq(__recv, "F32"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("F64"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "F64") : str_eq(__recv, "F64"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Bool"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Bool") : str_eq(__recv, "Bool"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Char"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Char") : str_eq(__recv, "Char"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_copy_primitive = is_copy_primitive;

const __tuff_outer_for_is_copy_type = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_copy_type(type_name, extern_type_names) {
  let __tuff_this = { type_name: type_name, extern_type_names: extern_type_names, this: __tuff_outer_for_is_copy_type };
  if ((() => { const __recv = type_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Unknown") : str_eq(__recv, "Unknown"); })()) {
  return false;
}
  if ((() => { const __recv = type_name; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "*") : str_starts_with(__recv, "*"); })()) {
  return true;
}
  if (is_copy_primitive(type_name)) {
  return true;
}
  if ((() => { const __recv = bc_destructor_aliases; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, type_name) : map_has(__recv, type_name); })()) {
  return false;
}
  if ((((() => { const __recv = type_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Vec"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Vec") : str_eq(__recv, "Vec"); })() || (() => { const __recv = type_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Map"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Map") : str_eq(__recv, "Map"); })()) || (() => { const __recv = type_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Set"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Set") : str_eq(__recv, "Set"); })())) {
  return true;
}
  if ((() => { const __recv = bc_copy_types; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, type_name) : set_has(__recv, type_name); })()) {
  return true;
}
  if ((() => { const __recv = extern_type_names; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, type_name) : set_has(__recv, type_name); })()) {
  return false;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_copy_type = is_copy_type;

const __tuff_outer_for_bc_find_copy_alias_type = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bc_find_copy_alias_type(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_bc_find_copy_alias_type };
  if ((() => { const __recv = bc_copy_alias_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  return (() => { const __recv = bc_copy_alias_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })();
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bc_find_copy_alias_type = bc_find_copy_alias_type;

const __tuff_outer_for_bc_type_node_is_copyable = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bc_type_node_is_copyable(t, extern_type_names, visiting_aliases) {
  let __tuff_this = { t: t, extern_type_names: extern_type_names, visiting_aliases: visiting_aliases, this: __tuff_outer_for_bc_type_node_is_copyable };
  if ((t === 0)) {
  return false;
}
  let k = node_kind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_NAMED_TYPE)) {
  let name = get_interned_str(node_get_data1(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = bc_destructor_aliases; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  return false;
}
  if (is_copy_primitive(name)) {
  return true;
}
  if ((((() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Vec"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Vec") : str_eq(__recv, "Vec"); })() || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Map"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Map") : str_eq(__recv, "Map"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Set"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Set") : str_eq(__recv, "Set"); })())) {
  return true;
}
  if ((() => { const __recv = bc_copy_types; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })()) {
  return true;
}
  if ((() => { const __recv = extern_type_names; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })()) {
  return false;
}
  let alias_type = bc_find_copy_alias_type(name); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_type = alias_type;
  if ((alias_type !== 0)) {
  if ((() => { const __recv = visiting_aliases; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })()) {
  return false;
}
  (() => { const __recv = visiting_aliases; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, name) : set_add(__recv, name); })();
  let ok = bc_type_node_is_copyable(alias_type, extern_type_names, visiting_aliases); if (typeof __tuff_this !== 'undefined') __tuff_this.ok = ok;
  (() => { const __recv = visiting_aliases; const __prop = __recv?.["set_delete"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_delete; return __dyn ? __dyn(__recv.ref, name) : set_delete(__recv, name); })();
  return ok;
}
  return false;
}
  if ((k === NK_REFINEMENT_TYPE)) {
  return bc_type_node_is_copyable(node_get_data1(t), extern_type_names, visiting_aliases);
}
  if ((k === NK_POINTER_TYPE)) {
  return true;
}
  if ((k === NK_UNION_TYPE)) {
  return (bc_type_node_is_copyable(node_get_data1(t), extern_type_names, visiting_aliases) && bc_type_node_is_copyable(node_get_data2(t), extern_type_names, visiting_aliases));
}
  if ((k === NK_TUPLE_TYPE)) {
  let members = node_get_data1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.members = members;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = members; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  if ((!bc_type_node_is_copyable((() => { const __recv = members; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), extern_type_names, visiting_aliases))) {
  return false;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bc_type_node_is_copyable = bc_type_node_is_copyable;

const __tuff_outer_for_bc_type_node_is_destructor_receiver = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bc_type_node_is_destructor_receiver(t, alias_name) {
  let __tuff_this = { t: t, alias_name: alias_name, this: __tuff_outer_for_bc_type_node_is_destructor_receiver };
  if ((t === 0)) {
  return false;
}
  if (((node_kind(t) === NK_NAMED_TYPE) && (() => { const __recv = get_interned_str(node_get_data1(t)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, alias_name) : str_eq(__recv, alias_name); })())) {
  return true;
}
  if (((node_kind(t) === NK_POINTER_TYPE) && (node_get_data3(t) === 1))) {
  return (() => { const __recv = bc_type_name_from_type_node(node_get_data2(t)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, alias_name) : str_eq(__recv, alias_name); })();
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bc_type_node_is_destructor_receiver = bc_type_node_is_destructor_receiver;

const __tuff_outer_for_bc_infer_expr_type_name = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bc_infer_expr_type_name(n, env_types, fn_return_types) {
  let __tuff_this = { n: n, env_types: env_types, fn_return_types: fn_return_types, this: __tuff_outer_for_bc_infer_expr_type_name };
  if ((n === 0)) {
  return "Unknown";
}
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_NUMBER_LIT)) {
  let text = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  if (bc_str_ends_with_local(text, "USize")) {
  return "USize";
}
  return "I32";
}
  if ((kind === NK_BOOL_LIT)) {
  return "Bool";
}
  if ((kind === NK_STRING_LIT)) {
  return "*Str";
}
  if ((kind === NK_CHAR_LIT)) {
  return "Char";
}
  if ((kind === NK_IDENTIFIER)) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = env_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  return (() => { const __recv = env_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })();
}
  if ((() => { const __recv = bc_global_value_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  return (() => { const __recv = bc_global_value_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })();
}
  return "Unknown";
}
  if ((kind === NK_UNARY_EXPR)) {
  let op = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let inner = bc_infer_expr_type_name(node_get_data2(n), env_types, fn_return_types); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&") : str_eq(__recv, "&"); })()) {
  return (() => { const __recv = "*"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })();
}
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&mut"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&mut") : str_eq(__recv, "&mut"); })()) {
  return (() => { const __recv = "*mut "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })();
}
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("!"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "!") : str_eq(__recv, "!"); })()) {
  return "Bool";
}
  return inner;
}
  if ((kind === NK_BINARY_EXPR)) {
  let op = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((((((((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("=="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "==") : str_eq(__recv, "=="); })() || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "!=") : str_eq(__recv, "!="); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<") : str_eq(__recv, "<"); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<=") : str_eq(__recv, "<="); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(">"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ">") : str_eq(__recv, ">"); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(">="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ">=") : str_eq(__recv, ">="); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&&"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&&") : str_eq(__recv, "&&"); })()) || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("||"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "||") : str_eq(__recv, "||"); })())) {
  return "Bool";
}
  return bc_infer_expr_type_name(node_get_data2(n), env_types, fn_return_types);
}
  if ((kind === NK_CALL_EXPR)) {
  let callee = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  if ((node_kind(callee) === NK_IDENTIFIER)) {
  let fname = get_interned_str(node_get_data1(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if ((() => { const __recv = fn_return_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, fname) : map_has(__recv, fname); })()) {
  return (() => { const __recv = fn_return_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, fname) : map_get(__recv, fname); })();
}
}
}
  if ((kind === NK_STRUCT_INIT)) {
  return get_interned_str(node_get_data1(n));
}
  return "Unknown";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bc_infer_expr_type_name = bc_infer_expr_type_name;

const __tuff_outer_for_place_new = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function place_new(base, path) {
  let __tuff_this = { base: base, path: path, this: __tuff_outer_for_place_new };
  let p = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  (() => { const __recv = p; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, base) : vec_push(__recv, base); })();
  (() => { const __recv = p; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(path); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, path) : vec_push(__recv, path); })();
  return p;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.place_new = place_new;

const __tuff_outer_for_place_is_valid = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function place_is_valid(p) {
  let __tuff_this = { p: p, this: __tuff_outer_for_place_is_valid };
  return ((() => { const __recv = p; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 2);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.place_is_valid = place_is_valid;

const __tuff_outer_for_place_base = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function place_base(p) {
  let __tuff_this = { p: p, this: __tuff_outer_for_place_base };
  return (() => { const __recv = p; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.place_base = place_base;

const __tuff_outer_for_place_path = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function place_path(p) {
  let __tuff_this = { p: p, this: __tuff_outer_for_place_path };
  return (() => { const __recv = p; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.place_path = place_path;

const __tuff_outer_for_canonical_place = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function canonical_place(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_canonical_place };
  if ((n === 0)) {
  return vec_new();
}
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_IDENTIFIER)) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return place_new(name, name);
}
  if ((kind === NK_MEMBER_EXPR)) {
  let base = canonical_place(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  if ((!place_is_valid(base))) {
  return vec_new();
}
  let prop = get_interned_str(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  return place_new(place_base(base), (() => { const __recv = (() => { const __recv = place_path(base); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prop) : str_concat(__recv, prop); })());
}
  if ((kind === NK_INDEX_EXPR)) {
  let base = canonical_place(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  if ((!place_is_valid(base))) {
  return vec_new();
}
  return place_new(place_base(base), (() => { const __recv = place_path(base); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("[]"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "[]") : str_concat(__recv, "[]"); })());
}
  return vec_new();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.canonical_place = canonical_place;

const __tuff_outer_for_places_conflict = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function places_conflict(a_base, a_path, b_base, b_path) {
  let __tuff_this = { a_base: a_base, a_path: a_path, b_base: b_base, b_path: b_path, this: __tuff_outer_for_places_conflict };
  if ((!(() => { const __recv = a_base; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(b_base); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, b_base) : str_eq(__recv, b_base); })())) {
  return false;
}
  if ((() => { const __recv = a_path; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(b_path); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, b_path) : str_eq(__recv, b_path); })()) {
  return true;
}
  if (((() => { const __recv = a_path; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop("[]"); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, "[]") : str_includes(__recv, "[]"); })() || (() => { const __recv = b_path; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop("[]"); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, "[]") : str_includes(__recv, "[]"); })())) {
  return true;
}
  return ((() => { const __recv = a_path; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop((() => { const __recv = b_path; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })()); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, (() => { const __recv = b_path; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })()) : str_starts_with(__recv, (() => { const __recv = b_path; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })()); })() || (() => { const __recv = b_path; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop((() => { const __recv = a_path; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })()); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, (() => { const __recv = a_path; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })()) : str_starts_with(__recv, (() => { const __recv = a_path; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })()); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.places_conflict = places_conflict;

const __tuff_outer_for_state_new = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_new() {
  let __tuff_this = { this: __tuff_outer_for_state_new };
  let s = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  (() => { const __recv = s; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  (() => { const __recv = s; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(vec_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, vec_new()) : vec_push(__recv, vec_new()); })();
  (() => { const __recv = s; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(vec_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, vec_new()) : vec_push(__recv, vec_new()); })();
  (() => { const __recv = s; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(vec_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, vec_new()) : vec_push(__recv, vec_new()); })();
  (() => { const __recv = s; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  (() => { const __recv = s; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(vec_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, vec_new()) : vec_push(__recv, vec_new()); })();
  return s;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_new = state_new;

const __tuff_outer_for_state_moved_set = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_moved_set(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_state_moved_set };
  return (() => { const __recv = state; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_moved_set = state_moved_set;

const __tuff_outer_for_state_moved_vec = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_moved_vec(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_state_moved_vec };
  return (() => { const __recv = state; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_moved_vec = state_moved_vec;

const __tuff_outer_for_state_loans = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_loans(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_state_loans };
  return (() => { const __recv = state; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 2) : vec_get(__recv, 2); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_loans = state_loans;

const __tuff_outer_for_state_scope_starts = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_scope_starts(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_state_scope_starts };
  return (() => { const __recv = state; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(3); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 3) : vec_get(__recv, 3); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_scope_starts = state_scope_starts;

const __tuff_outer_for_state_dropped_set = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_dropped_set(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_state_dropped_set };
  return (() => { const __recv = state; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(4); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 4) : vec_get(__recv, 4); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_dropped_set = state_dropped_set;

const __tuff_outer_for_state_dropped_vec = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_dropped_vec(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_state_dropped_vec };
  return (() => { const __recv = state; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(5); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 5) : vec_get(__recv, 5); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_dropped_vec = state_dropped_vec;

const __tuff_outer_for_state_moved_has = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_moved_has(state, name) {
  let __tuff_this = { state: state, name: name, this: __tuff_outer_for_state_moved_has };
  return (() => { const __recv = state_moved_set(state); const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_moved_has = state_moved_has;

const __tuff_outer_for_state_dropped_has = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_dropped_has(state, name) {
  let __tuff_this = { state: state, name: name, this: __tuff_outer_for_state_dropped_has };
  return (() => { const __recv = state_dropped_set(state); const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_dropped_has = state_dropped_has;

const __tuff_outer_for_state_moved_add = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_moved_add(state, name) {
  let __tuff_this = { state: state, name: name, this: __tuff_outer_for_state_moved_add };
  if ((!(() => { const __recv = state_moved_set(state); const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })())) {
  (() => { const __recv = state_moved_set(state); const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, name) : set_add(__recv, name); })();
  (() => { const __recv = state_moved_vec(state); const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, name) : vec_push(__recv, name); })();
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_moved_add = state_moved_add;

const __tuff_outer_for_state_moved_delete = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_moved_delete(state, name) {
  let __tuff_this = { state: state, name: name, this: __tuff_outer_for_state_moved_delete };
  (() => { const __recv = state_moved_set(state); const __prop = __recv?.["set_delete"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_delete; return __dyn ? __dyn(__recv.ref, name) : set_delete(__recv, name); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_moved_delete = state_moved_delete;

const __tuff_outer_for_state_dropped_add = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_dropped_add(state, name) {
  let __tuff_this = { state: state, name: name, this: __tuff_outer_for_state_dropped_add };
  if ((!(() => { const __recv = state_dropped_set(state); const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })())) {
  (() => { const __recv = state_dropped_set(state); const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, name) : set_add(__recv, name); })();
  (() => { const __recv = state_dropped_vec(state); const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, name) : vec_push(__recv, name); })();
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_dropped_add = state_dropped_add;

const __tuff_outer_for_state_dropped_delete = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_dropped_delete(state, name) {
  let __tuff_this = { state: state, name: name, this: __tuff_outer_for_state_dropped_delete };
  (() => { const __recv = state_dropped_set(state); const __prop = __recv?.["set_delete"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_delete; return __dyn ? __dyn(__recv.ref, name) : set_delete(__recv, name); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_dropped_delete = state_dropped_delete;

const __tuff_outer_for_state_begin_scope = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_begin_scope(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_state_begin_scope };
  (() => { const __recv = state_scope_starts(state); const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = state_loans(state); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = state_loans(state); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()) : vec_push(__recv, (() => { const __recv = state_loans(state); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_begin_scope = state_begin_scope;

const __tuff_outer_for_state_end_scope = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_end_scope(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_state_end_scope };
  let starts = state_scope_starts(state); if (typeof __tuff_this !== 'undefined') __tuff_this.starts = starts;
  if (((() => { const __recv = starts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 0)) {
  return 0;
}
  let start = (() => { const __recv = starts; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.start = start;
  let loans = state_loans(state); if (typeof __tuff_this !== 'undefined') __tuff_this.loans = loans;
  while (((() => { const __recv = loans; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() > start)) {
  (() => { const __recv = loans; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_end_scope = state_end_scope;

const __tuff_outer_for_state_add_loan = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_add_loan(state, kind, base, path) {
  let __tuff_this = { state: state, kind: kind, base: base, path: path, this: __tuff_outer_for_state_add_loan };
  let entry = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.entry = entry;
  (() => { const __recv = entry; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(kind); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, kind) : vec_push(__recv, kind); })();
  (() => { const __recv = entry; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, base) : vec_push(__recv, base); })();
  (() => { const __recv = entry; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(path); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, path) : vec_push(__recv, path); })();
  (() => { const __recv = state_loans(state); const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(entry); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, entry) : vec_push(__recv, entry); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_add_loan = state_add_loan;

const __tuff_outer_for_state_any_conflicting_loan = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_any_conflicting_loan(state, base, path) {
  let __tuff_this = { state: state, base: base, path: path, this: __tuff_outer_for_state_any_conflicting_loan };
  let loans = state_loans(state); if (typeof __tuff_this !== 'undefined') __tuff_this.loans = loans;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = loans; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let e = (() => { const __recv = loans; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.e = e;
  let eb = (() => { const __recv = e; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.eb = eb;
  let ep = (() => { const __recv = e; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 2) : vec_get(__recv, 2); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ep = ep;
  if (places_conflict(base, path, eb, ep)) {
  return true;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_any_conflicting_loan = state_any_conflicting_loan;

const __tuff_outer_for_state_conflicting_mut_loan = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_conflicting_mut_loan(state, base, path) {
  let __tuff_this = { state: state, base: base, path: path, this: __tuff_outer_for_state_conflicting_mut_loan };
  let loans = state_loans(state); if (typeof __tuff_this !== 'undefined') __tuff_this.loans = loans;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = loans; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let e = (() => { const __recv = loans; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.e = e;
  if (((() => { const __recv = e; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })() === 2)) {
  let eb = (() => { const __recv = e; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.eb = eb;
  let ep = (() => { const __recv = e; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 2) : vec_get(__recv, 2); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ep = ep;
  if (places_conflict(base, path, eb, ep)) {
  return true;
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_conflicting_mut_loan = state_conflicting_mut_loan;

const __tuff_outer_for_state_conflicting_immut_loan = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_conflicting_immut_loan(state, base, path) {
  let __tuff_this = { state: state, base: base, path: path, this: __tuff_outer_for_state_conflicting_immut_loan };
  let loans = state_loans(state); if (typeof __tuff_this !== 'undefined') __tuff_this.loans = loans;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = loans; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let e = (() => { const __recv = loans; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.e = e;
  if (((() => { const __recv = e; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })() === 1)) {
  let eb = (() => { const __recv = e; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.eb = eb;
  let ep = (() => { const __recv = e; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 2) : vec_get(__recv, 2); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ep = ep;
  if (places_conflict(base, path, eb, ep)) {
  return true;
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_conflicting_immut_loan = state_conflicting_immut_loan;

const __tuff_outer_for_state_clone = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_clone(src) {
  let __tuff_this = { src: src, this: __tuff_outer_for_state_clone };
  let dst = state_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.dst = dst;
  let srcMoved = state_moved_vec(src); if (typeof __tuff_this !== 'undefined') __tuff_this.srcMoved = srcMoved;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = srcMoved; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  state_moved_add(dst, (() => { const __recv = srcMoved; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let srcLoans = state_loans(src); if (typeof __tuff_this !== 'undefined') __tuff_this.srcLoans = srcLoans;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  len = (() => { const __recv = srcLoans; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let e = (() => { const __recv = srcLoans; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.e = e;
  state_add_loan(dst, (() => { const __recv = e; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(), (() => { const __recv = e; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), (() => { const __recv = e; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 2) : vec_get(__recv, 2); })());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let srcScopes = state_scope_starts(src); if (typeof __tuff_this !== 'undefined') __tuff_this.srcScopes = srcScopes;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  len = (() => { const __recv = srcScopes; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = state_scope_starts(dst); const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = srcScopes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = srcScopes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()) : vec_push(__recv, (() => { const __recv = srcScopes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let srcDropped = state_dropped_vec(src); if (typeof __tuff_this !== 'undefined') __tuff_this.srcDropped = srcDropped;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  len = (() => { const __recv = srcDropped; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  state_dropped_add(dst, (() => { const __recv = srcDropped; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return dst;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_clone = state_clone;

const __tuff_outer_for_state_merge_moved_from_branches = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function state_merge_moved_from_branches(dst, a, b) {
  let __tuff_this = { dst: dst, a: a, b: b, this: __tuff_outer_for_state_merge_moved_from_branches };
  let newSet = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.newSet = newSet;
  let newVec = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.newVec = newVec;
  let av = state_moved_vec(a); if (typeof __tuff_this !== 'undefined') __tuff_this.av = av;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = av; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let n = (() => { const __recv = av; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  if (((() => { const __recv = state_moved_set(a); const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, n) : set_has(__recv, n); })() && (!(() => { const __recv = newSet; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, n) : set_has(__recv, n); })()))) {
  (() => { const __recv = newSet; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, n) : set_add(__recv, n); })();
  (() => { const __recv = newVec; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, n) : vec_push(__recv, n); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let bv = state_moved_vec(b); if (typeof __tuff_this !== 'undefined') __tuff_this.bv = bv;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  len = (() => { const __recv = bv; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let n = (() => { const __recv = bv; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  if (((() => { const __recv = state_moved_set(b); const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, n) : set_has(__recv, n); })() && (!(() => { const __recv = newSet; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, n) : set_has(__recv, n); })()))) {
  (() => { const __recv = newSet; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, n) : set_add(__recv, n); })();
  (() => { const __recv = newVec; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, n) : vec_push(__recv, n); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  (() => { const __recv = dst; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(0, newSet); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, 0, newSet) : vec_set(__recv, 0, newSet); })();
  (() => { const __recv = dst; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(1, newVec); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, 1, newVec) : vec_set(__recv, 1, newVec); })();
  let droppedSet = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.droppedSet = droppedSet;
  let droppedVec = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.droppedVec = droppedVec;
  let adv = state_dropped_vec(a); if (typeof __tuff_this !== 'undefined') __tuff_this.adv = adv;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  len = (() => { const __recv = adv; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let n = (() => { const __recv = adv; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  if (((() => { const __recv = state_dropped_set(a); const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, n) : set_has(__recv, n); })() && (!(() => { const __recv = droppedSet; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, n) : set_has(__recv, n); })()))) {
  (() => { const __recv = droppedSet; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, n) : set_add(__recv, n); })();
  (() => { const __recv = droppedVec; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, n) : vec_push(__recv, n); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let bdv = state_dropped_vec(b); if (typeof __tuff_this !== 'undefined') __tuff_this.bdv = bdv;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  len = (() => { const __recv = bdv; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let n = (() => { const __recv = bdv; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  if (((() => { const __recv = state_dropped_set(b); const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, n) : set_has(__recv, n); })() && (!(() => { const __recv = droppedSet; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, n) : set_has(__recv, n); })()))) {
  (() => { const __recv = droppedSet; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, n) : set_add(__recv, n); })();
  (() => { const __recv = droppedVec; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, n) : vec_push(__recv, n); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  (() => { const __recv = dst; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(4, droppedSet); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, 4, droppedSet) : vec_set(__recv, 4, droppedSet); })();
  (() => { const __recv = dst; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(5, droppedVec); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, 5, droppedVec) : vec_set(__recv, 5, droppedVec); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.state_merge_moved_from_branches = state_merge_moved_from_branches;

const __tuff_outer_for_panic_borrow = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function panic_borrow(code, message, fix) {
  let __tuff_this = { code: code, message: message, fix: fix, this: __tuff_outer_for_panic_borrow };
  return panic_with_code_loc(code, message, "Borrowing and ownership rules require exclusive mutable access or shared immutable access, and disallow use-after-move.", fix, node_get_line(bc_current_node), node_get_col(bc_current_node));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.panic_borrow = panic_borrow;

const __tuff_outer_for_ensure_readable = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ensure_readable(expr, state) {
  let __tuff_this = { expr: expr, state: state, this: __tuff_outer_for_ensure_readable };
  let p = canonical_place(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  if ((!place_is_valid(p))) {
  return 0;
}
  let base = place_base(p); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  if ((() => { const __recv = bc_global_value_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, base) : map_has(__recv, base); })()) {
  return 0;
}
  if (state_dropped_has(state, base)) {
  panic_borrow("E_BORROW_USE_AFTER_DROP", (() => { const __recv = (() => { const __recv = "Use of dropped value '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, base) : str_concat(__recv, base); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "Do not use a value after explicit or implicit drop; move/copy before dropping if needed.");
}
  if (state_moved_has(state, base)) {
  panic_borrow("E_BORROW_USE_AFTER_MOVE", (() => { const __recv = (() => { const __recv = "Use of moved value '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, base) : str_concat(__recv, base); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "Reinitialize the value before use, or borrow it before moving.");
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ensure_readable = ensure_readable;

const __tuff_outer_for_consume_place = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function consume_place(expr, state, env_types, fn_return_types, extern_type_names) {
  let __tuff_this = { expr: expr, state: state, env_types: env_types, fn_return_types: fn_return_types, extern_type_names: extern_type_names, this: __tuff_outer_for_consume_place };
  let p = canonical_place(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  if ((!place_is_valid(p))) {
  return 0;
}
  let base = place_base(p); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  let path = place_path(p); if (typeof __tuff_this !== 'undefined') __tuff_this.path = path;
  if ((() => { const __recv = base; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("__tuple_tmp_"); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "__tuple_tmp_") : str_starts_with(__recv, "__tuple_tmp_"); })()) {
  return 0;
}
  if ((() => { const __recv = bc_global_value_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, base) : map_has(__recv, base); })()) {
  return 0;
}
  if (state_dropped_has(state, base)) {
  panic_borrow("E_BORROW_USE_AFTER_DROP", (() => { const __recv = (() => { const __recv = "Use of dropped value '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, base) : str_concat(__recv, base); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "Do not use a value after explicit or implicit drop; move/copy before dropping if needed.");
}
  if (state_moved_has(state, base)) {
  panic_borrow("E_BORROW_USE_AFTER_MOVE", (() => { const __recv = (() => { const __recv = "Use of moved value '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, base) : str_concat(__recv, base); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "Reinitialize the value before use, or borrow it with '&' / '&mut' instead of moving.");
}
  if (state_any_conflicting_loan(state, base, path)) {
  panic_borrow("E_BORROW_MOVE_WHILE_BORROWED", (() => { const __recv = (() => { const __recv = "Cannot move '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, base) : str_concat(__recv, base); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' while it is borrowed"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' while it is borrowed") : str_concat(__recv, "' while it is borrowed"); })(), "Ensure all borrows end before moving, or pass a borrow (&/&mut) instead.");
}
  let ty = bc_infer_expr_type_name(expr, env_types, fn_return_types); if (typeof __tuff_this !== 'undefined') __tuff_this.ty = ty;
  if ((!is_copy_type(ty, extern_type_names))) {
  state_moved_add(state, base);
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.consume_place = consume_place;

const __tuff_outer_for_check_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function check_expr(expr, state, env_types, fn_return_types, extern_type_names, global_fn_names, mode) {
  let __tuff_this = { expr: expr, state: state, env_types: env_types, fn_return_types: fn_return_types, extern_type_names: extern_type_names, global_fn_names: global_fn_names, mode: mode, this: __tuff_outer_for_check_expr };
  if ((expr === 0)) {
  return 0;
}
  bc_current_node = expr; if (typeof __tuff_this !== 'undefined') __tuff_this.bc_current_node = bc_current_node;
  if (((() => { const __recv = mode; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("move"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "move") : str_eq(__recv, "move"); })() && (node_kind(expr) === NK_IDENTIFIER))) {
  let nm = get_interned_str(node_get_data1(expr)); if (typeof __tuff_this !== 'undefined') __tuff_this.nm = nm;
  if ((() => { const __recv = global_fn_names; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(nm); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, nm) : set_has(__recv, nm); })()) {
  return 0;
}
}
  if ((node_kind(expr) === NK_UNARY_EXPR)) {
  let op = get_interned_str(node_get_data1(expr)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&") : str_eq(__recv, "&"); })() || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&mut"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&mut") : str_eq(__recv, "&mut"); })())) {
  let target = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let p = canonical_place(target); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  if ((!place_is_valid(p))) {
  if ((node_kind(target) === NK_STRUCT_INIT)) {
  check_expr(target, state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  return 0;
}
  panic_borrow("E_BORROW_INVALID_TARGET", "Borrow target is not a place expression", "Borrow only identifiers, fields, or index places (e.g. &x, &obj.f, &arr[i]).");
}
  ensure_readable(target, state);
  let base = place_base(p); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  let path = place_path(p); if (typeof __tuff_this !== 'undefined') __tuff_this.path = path;
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&") : str_eq(__recv, "&"); })()) {
  if (state_conflicting_mut_loan(state, base, path)) {
  panic_borrow("E_BORROW_IMMUT_WHILE_MUT", (() => { const __recv = (() => { const __recv = "Cannot immutably borrow '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, base) : str_concat(__recv, base); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' because it is mutably borrowed"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' because it is mutably borrowed") : str_concat(__recv, "' because it is mutably borrowed"); })(), "End the mutable borrow first, or borrow mutably in a non-overlapping scope.");
}
  state_add_loan(state, 1, base, path);
} else {
  if ((state_conflicting_mut_loan(state, base, path) || state_conflicting_immut_loan(state, base, path))) {
  panic_borrow("E_BORROW_MUT_CONFLICT", (() => { const __recv = (() => { const __recv = "Cannot mutably borrow '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, base) : str_concat(__recv, base); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' because it is already borrowed"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' because it is already borrowed") : str_concat(__recv, "' because it is already borrowed"); })(), "Ensure no active borrows overlap this place before taking '&mut'.");
}
  state_add_loan(state, 2, base, path);
}
  return 0;
}
}
  let kind = node_kind(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((((kind === NK_IDENTIFIER) || (kind === NK_MEMBER_EXPR)) || (kind === NK_INDEX_EXPR))) {
  if ((() => { const __recv = mode; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("read"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "read") : str_eq(__recv, "read"); })()) {
  ensure_readable(expr, state);
  return 0;
}
  consume_place(expr, state, env_types, fn_return_types, extern_type_names);
  return 0;
}
  if (((((kind === NK_NUMBER_LIT) || (kind === NK_BOOL_LIT)) || (kind === NK_STRING_LIT)) || (kind === NK_CHAR_LIT))) {
  return 0;
}
  if ((kind === NK_UNARY_EXPR)) {
  check_expr(node_get_data2(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  return 0;
}
  if ((kind === NK_BINARY_EXPR)) {
  check_expr(node_get_data2(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  check_expr(node_get_data3(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  return 0;
}
  if ((kind === NK_CALL_EXPR)) {
  let callee = node_get_data1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  if (((node_kind(callee) === NK_IDENTIFIER) && (() => { const __recv = get_interned_str(node_get_data1(callee)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("drop"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "drop") : str_eq(__recv, "drop"); })())) {
  let args = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() !== 1)) {
  panic_borrow("E_BORROW_INVALID_TARGET", "drop expects exactly one argument", "Call drop with exactly one local/place value such as drop(x) or x.drop().");
}
  let target = (() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let p = canonical_place(target); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  if ((!place_is_valid(p))) {
  panic_borrow("E_BORROW_INVALID_TARGET", "drop target must be a place expression", "Call drop with a local/place value such as drop(x) or x.drop().");
}
  let base = place_base(p); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  let path = place_path(p); if (typeof __tuff_this !== 'undefined') __tuff_this.path = path;
  if (state_dropped_has(state, base)) {
  panic_borrow("E_BORROW_DOUBLE_DROP", (() => { const __recv = (() => { const __recv = "Double drop of '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, base) : str_concat(__recv, base); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "Ensure each owned value is dropped exactly once.");
}
  let target_type = bc_infer_expr_type_name(target, env_types, fn_return_types); if (typeof __tuff_this !== 'undefined') __tuff_this.target_type = target_type;
  if ((!(() => { const __recv = bc_destructor_aliases; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(target_type); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, target_type) : map_has(__recv, target_type); })())) {
  panic_borrow("E_BORROW_DROP_MISSING_DESTRUCTOR", (() => { const __recv = (() => { const __recv = "Type '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(target_type); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, target_type) : str_concat(__recv, target_type); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' has no associated destructor"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' has no associated destructor") : str_concat(__recv, "' has no associated destructor"); })(), "Associate a destructor via 'type Alias = Base then destructorName;' and use that alias type.");
}
  ensure_readable(target, state);
  if (state_any_conflicting_loan(state, base, path)) {
  panic_borrow("E_BORROW_MOVE_WHILE_BORROWED", (() => { const __recv = (() => { const __recv = "Cannot drop '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, base) : str_concat(__recv, base); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' while it is borrowed"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' while it is borrowed") : str_concat(__recv, "' while it is borrowed"); })(), "Ensure all borrows end before dropping the value.");
}
  state_dropped_add(state, base);
  state_moved_add(state, base);
  return 0;
}
  if ((((node_kind(callee) === NK_IDENTIFIER) && (() => { const __recv = get_interned_str(node_get_data1(callee)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "into") : str_eq(__recv, "into"); })()) && (node_get_data3(expr) === 1))) {
  let args = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() >= 1)) {
  let receiver = (() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.receiver = receiver;
  let receiver_mode = "read"; if (typeof __tuff_this !== 'undefined') __tuff_this.receiver_mode = receiver_mode;
  if (place_is_valid(canonical_place(receiver))) {
  receiver_mode = "move"; if (typeof __tuff_this !== 'undefined') __tuff_this.receiver_mode = receiver_mode;
}
  check_expr(receiver, state, env_types, fn_return_types, extern_type_names, global_fn_names, receiver_mode);
}
  let i = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  check_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((!((node_kind(callee) === NK_IDENTIFIER) && (() => { const __recv = global_fn_names; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(callee))); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(callee))) : set_has(__recv, get_interned_str(node_get_data1(callee))); })()))) {
  check_expr(callee, state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
}
  let args = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  check_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_STRUCT_INIT)) {
  let fields = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  check_expr((() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_TUPLE_EXPR)) {
  let items = node_get_data1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = items; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  check_expr((() => { const __recv = items; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_IF_EXPR)) {
  check_expr(node_get_data1(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  let then_state = state_clone(state); if (typeof __tuff_this !== 'undefined') __tuff_this.then_state = then_state;
  check_stmt(node_get_data2(expr), then_state, env_types, fn_return_types, extern_type_names, global_fn_names);
  if ((node_get_data3(expr) !== 0)) {
  let else_state = state_clone(state); if (typeof __tuff_this !== 'undefined') __tuff_this.else_state = else_state;
  check_stmt(node_get_data3(expr), else_state, env_types, fn_return_types, extern_type_names, global_fn_names);
  state_merge_moved_from_branches(state, then_state, else_state);
} else {
  state_merge_moved_from_branches(state, then_state, state);
}
  return 0;
}
  if ((kind === NK_MATCH_EXPR)) {
  check_expr(node_get_data1(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  let cases = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let merged = state_clone(state); if (typeof __tuff_this !== 'undefined') __tuff_this.merged = merged;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let c = (() => { const __recv = cases; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.c = c;
  let branch = state_clone(state); if (typeof __tuff_this !== 'undefined') __tuff_this.branch = branch;
  check_stmt((() => { const __recv = c; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), branch, env_types, fn_return_types, extern_type_names, global_fn_names);
  state_merge_moved_from_branches(merged, merged, branch);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  state_merge_moved_from_branches(state, merged, state);
  return 0;
}
  if ((kind === NK_IS_EXPR)) {
  check_expr(node_get_data1(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  return 0;
}
  if ((kind === NK_UNWRAP_EXPR)) {
  check_expr(node_get_data1(expr), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  return 0;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.check_expr = check_expr;

const __tuff_outer_for_bc_stmt_diverges = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bc_stmt_diverges(stmt) {
  let __tuff_this = { stmt: stmt, this: __tuff_outer_for_bc_stmt_diverges };
  if ((stmt === 0)) {
  return false;
}
  let k = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_RETURN_STMT)) {
  return true;
}
  if ((k === NK_BLOCK)) {
  let stmts = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return false;
}
  return bc_stmt_diverges((() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop((len - 1)); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, (len - 1)) : vec_get(__recv, (len - 1)); })());
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bc_stmt_diverges = bc_stmt_diverges;

const __tuff_outer_for_check_block = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function check_block(block, state, env_types, fn_return_types, extern_type_names, global_fn_names) {
  let __tuff_this = { block: block, state: state, env_types: env_types, fn_return_types: fn_return_types, extern_type_names: extern_type_names, global_fn_names: global_fn_names, this: __tuff_outer_for_check_block };
  state_begin_scope(state);
  let stmts = node_get_data1(block); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  check_stmt((() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), state, env_types, fn_return_types, extern_type_names, global_fn_names);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return state_end_scope(state);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.check_block = check_block;

const __tuff_outer_for_check_stmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function check_stmt(stmt, state, env_types, fn_return_types, extern_type_names, global_fn_names) {
  let __tuff_this = { stmt: stmt, state: state, env_types: env_types, fn_return_types: fn_return_types, extern_type_names: extern_type_names, global_fn_names: global_fn_names, this: __tuff_outer_for_check_stmt };
  if ((stmt === 0)) {
  return 0;
}
  bc_current_node = stmt; if (typeof __tuff_this !== 'undefined') __tuff_this.bc_current_node = bc_current_node;
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LET_DECL)) {
  let rhs = node_get_data3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.rhs = rhs;
  let mode = "read"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
  let p = canonical_place(rhs); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  if (place_is_valid(p)) {
  if ((node_kind(rhs) === NK_IDENTIFIER)) {
  mode = "move"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
} else {
  mode = "read"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
}
}
  check_expr(rhs, state, env_types, fn_return_types, extern_type_names, global_fn_names, mode);
  let name = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let tnode = node_get_data2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.tnode = tnode;
  if ((tnode !== 0)) {
  (() => { const __recv = env_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(name, bc_type_name_from_type_node(tnode)); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, name, bc_type_name_from_type_node(tnode)) : map_set(__recv, name, bc_type_name_from_type_node(tnode)); })();
} else {
  (() => { const __recv = env_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(name, bc_infer_expr_type_name(rhs, env_types, fn_return_types)); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, name, bc_infer_expr_type_name(rhs, env_types, fn_return_types)) : map_set(__recv, name, bc_infer_expr_type_name(rhs, env_types, fn_return_types)); })();
}
  state_moved_delete(state, name);
  state_dropped_delete(state, name);
  return 0;
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  return 0;
}
  if ((kind === NK_ASSIGN_STMT)) {
  let target = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let tplace = canonical_place(target); if (typeof __tuff_this !== 'undefined') __tuff_this.tplace = tplace;
  if (place_is_valid(tplace)) {
  let base = place_base(tplace); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  let path = place_path(tplace); if (typeof __tuff_this !== 'undefined') __tuff_this.path = path;
  if (state_any_conflicting_loan(state, base, path)) {
  panic_borrow("E_BORROW_ASSIGN_WHILE_BORROWED", (() => { const __recv = (() => { const __recv = "Cannot assign to '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, base) : str_concat(__recv, base); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' while it is borrowed"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' while it is borrowed") : str_concat(__recv, "' while it is borrowed"); })(), "End active borrows before assignment, or assign in a non-overlapping scope.");
}
}
  let rhs = node_get_data2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.rhs = rhs;
  let mode = "read"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
  let rhs_place = canonical_place(rhs); if (typeof __tuff_this !== 'undefined') __tuff_this.rhs_place = rhs_place;
  if (place_is_valid(rhs_place)) {
  mode = "move"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
}
  check_expr(rhs, state, env_types, fn_return_types, extern_type_names, global_fn_names, mode);
  if ((node_kind(target) === NK_IDENTIFIER)) {
  let target_name = get_interned_str(node_get_data1(target)); if (typeof __tuff_this !== 'undefined') __tuff_this.target_name = target_name;
  state_moved_delete(state, target_name);
  state_dropped_delete(state, target_name);
}
  return 0;
}
  if ((kind === NK_EXPR_STMT)) {
  check_expr(node_get_data1(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names, "move");
  return 0;
}
  if ((kind === NK_RETURN_STMT)) {
  let v = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  if ((v !== 0)) {
  let mode = "read"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
  if (place_is_valid(canonical_place(v))) {
  mode = "move"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
}
  check_expr(v, state, env_types, fn_return_types, extern_type_names, global_fn_names, mode);
}
  return 0;
}
  if ((kind === NK_IF_STMT)) {
  check_expr(node_get_data1(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  let then_branch = node_get_data2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.then_branch = then_branch;
  let else_branch = node_get_data3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.else_branch = else_branch;
  let then_state = state_clone(state); if (typeof __tuff_this !== 'undefined') __tuff_this.then_state = then_state;
  check_stmt(then_branch, then_state, env_types, fn_return_types, extern_type_names, global_fn_names);
  let then_diverges = bc_stmt_diverges(then_branch); if (typeof __tuff_this !== 'undefined') __tuff_this.then_diverges = then_diverges;
  if ((else_branch !== 0)) {
  let else_state = state_clone(state); if (typeof __tuff_this !== 'undefined') __tuff_this.else_state = else_state;
  check_stmt(else_branch, else_state, env_types, fn_return_types, extern_type_names, global_fn_names);
  let else_diverges = bc_stmt_diverges(else_branch); if (typeof __tuff_this !== 'undefined') __tuff_this.else_diverges = else_diverges;
  if ((then_diverges && else_diverges)) {
  state_merge_moved_from_branches(state, then_state, else_state);
} else { if (then_diverges) {
  state_merge_moved_from_branches(state, else_state, else_state);
} else { if (else_diverges) {
  state_merge_moved_from_branches(state, then_state, then_state);
} else {
  state_merge_moved_from_branches(state, then_state, else_state);
} } }
} else {
  if (then_diverges) {
  0;
} else {
  state_merge_moved_from_branches(state, then_state, state);
}
}
  return 0;
}
  if ((kind === NK_FOR_STMT)) {
  check_expr(node_get_data2(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  check_expr(node_get_data3(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  state_begin_scope(state);
  (() => { const __recv = env_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(stmt)), "I32"); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(stmt)), "I32") : map_set(__recv, get_interned_str(node_get_data1(stmt)), "I32"); })();
  check_stmt(node_get_data4(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names);
  state_end_scope(state);
  return 0;
}
  if ((kind === NK_WHILE_STMT)) {
  check_expr(node_get_data1(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names, "read");
  state_begin_scope(state);
  check_stmt(node_get_data2(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names);
  state_end_scope(state);
  return 0;
}
  if ((kind === NK_LOOP_STMT)) {
  state_begin_scope(state);
  check_stmt(node_get_data1(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names);
  state_end_scope(state);
  return 0;
}
  if ((kind === NK_BLOCK)) {
  check_block(stmt, state, env_types, fn_return_types, extern_type_names, global_fn_names);
  return 0;
}
  if ((kind === NK_LIFETIME_STMT)) {
  check_stmt(node_get_data2(stmt), state, env_types, fn_return_types, extern_type_names, global_fn_names);
  return 0;
}
  if (((kind === NK_CONTRACT_DECL) || (kind === NK_INTO_STMT))) {
  return 0;
}
  if ((kind === NK_FN_DECL)) {
  let fn_state = state_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_state = fn_state;
  let fn_env = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_env = fn_env;
  let params = node_get_data3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let p = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let pname = get_interned_str((() => { const __recv = p; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = (() => { const __recv = p; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  (() => { const __recv = fn_env; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(pname, bc_type_name_from_type_node(ptype)); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, pname, bc_type_name_from_type_node(ptype)) : map_set(__recv, pname, bc_type_name_from_type_node(ptype)); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let body = node_get_data5(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if ((node_kind(body) === NK_BLOCK)) {
  check_block(body, fn_state, fn_env, fn_return_types, extern_type_names, global_fn_names);
} else {
  check_expr(body, fn_state, fn_env, fn_return_types, extern_type_names, global_fn_names, "move");
}
  return 0;
}
  check_expr(stmt, state, env_types, fn_return_types, extern_type_names, global_fn_names, "move");
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.check_stmt = check_stmt;

const __tuff_outer_for_borrowcheck_program_impl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function borrowcheck_program_impl(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_borrowcheck_program_impl };
  let fn_return_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_return_types = fn_return_types;
  let extern_type_names = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.extern_type_names = extern_type_names;
  let global_type_by_name = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.global_type_by_name = global_type_by_name;
  let global_fn_names = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.global_fn_names = global_fn_names;
  let body = node_get_data1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  bc_copy_types = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.bc_copy_types = bc_copy_types;
  bc_copy_alias_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.bc_copy_alias_types = bc_copy_alias_types;
  bc_copy_alias_names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.bc_copy_alias_names = bc_copy_alias_names;
  bc_destructor_aliases = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.bc_destructor_aliases = bc_destructor_aliases;
  bc_destructor_alias_names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.bc_destructor_alias_names = bc_destructor_alias_names;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = body; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_EXTERN_TYPE_DECL)) {
  (() => { const __recv = extern_type_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(stmt))); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(stmt))) : set_add(__recv, get_interned_str(node_get_data1(stmt))); })();
}
  if ((kind === NK_FN_DECL)) {
  let fname = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  (() => { const __recv = global_fn_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, fname) : set_add(__recv, fname); })();
  (() => { const __recv = fn_return_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(fname, bc_type_name_from_type_node(node_get_data4(stmt))); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, fname, bc_type_name_from_type_node(node_get_data4(stmt))) : map_set(__recv, fname, bc_type_name_from_type_node(node_get_data4(stmt))); })();
}
  if (((kind === NK_LET_DECL) || (kind === NK_EXTERN_LET_DECL))) {
  (() => { const __recv = global_type_by_name; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(stmt)), bc_type_name_from_type_node(node_get_data2(stmt))); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(stmt)), bc_type_name_from_type_node(node_get_data2(stmt))) : map_set(__recv, get_interned_str(node_get_data1(stmt)), bc_type_name_from_type_node(node_get_data2(stmt))); })();
}
  if ((kind === NK_ENUM_DECL)) {
  (() => { const __recv = bc_copy_types; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(stmt))); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(stmt))) : set_add(__recv, get_interned_str(node_get_data1(stmt))); })();
}
  if (((kind === NK_STRUCT_DECL) && (node_get_data4(stmt) === 1))) {
  (() => { const __recv = bc_copy_types; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(stmt))); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(stmt))) : set_add(__recv, get_interned_str(node_get_data1(stmt))); })();
}
  if (((kind === NK_TYPE_ALIAS) && (node_get_data4(stmt) === 1))) {
  let alias_name = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  (() => { const __recv = bc_copy_alias_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, alias_name) : vec_push(__recv, alias_name); })();
  (() => { const __recv = bc_copy_alias_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, node_get_data3(stmt)); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, node_get_data3(stmt)) : map_set(__recv, alias_name, node_get_data3(stmt)); })();
}
  if (((kind === NK_TYPE_ALIAS) && (node_get_data5(stmt) !== 0))) {
  let alias_name = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  let destructor_name = get_interned_str(node_get_data5(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
  (() => { const __recv = bc_destructor_aliases; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, destructor_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, destructor_name) : map_set(__recv, alias_name, destructor_name); })();
  (() => { const __recv = bc_destructor_alias_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, alias_name) : vec_push(__recv, alias_name); })();
}
  if (((kind === NK_EXTERN_TYPE_DECL) && (node_get_data5(stmt) !== 0))) {
  let alias_name = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  let destructor_name = get_interned_str(node_get_data5(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
  (() => { const __recv = bc_destructor_aliases; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, destructor_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, destructor_name) : map_set(__recv, alias_name, destructor_name); })();
  (() => { const __recv = bc_destructor_alias_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, alias_name) : vec_push(__recv, alias_name); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let dlen = (() => { const __recv = bc_destructor_alias_names; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dlen = dlen;
  while ((i < dlen)) {
  let alias_name = (() => { const __recv = bc_destructor_alias_names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  let destructor_name = (() => { const __recv = bc_destructor_aliases; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, alias_name) : map_get(__recv, alias_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.destructor_name = destructor_name;
  let found = false; if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let sk = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.sk = sk;
  if (((sk === NK_FN_DECL) && (() => { const __recv = get_interned_str(node_get_data1(stmt)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(destructor_name); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, destructor_name) : str_eq(__recv, destructor_name); })())) {
  found = true; if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  let valid = true; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
  let params = node_get_data3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  if (((() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() !== 1)) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
} else {
  let p0 = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p0 = p0;
  let pname = get_interned_str((() => { const __recv = p0; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = (() => { const __recv = p0; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if ((!(() => { const __recv = pname; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })())) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
}
  if ((!bc_type_node_is_destructor_receiver(ptype, alias_name))) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
}
}
  if ((!(() => { const __recv = bc_type_name_from_type_node(node_get_data4(stmt)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Void"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Void") : str_eq(__recv, "Void"); })())) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
}
  if ((!valid)) {
  panic_with_code("E_TYPE_DESTRUCTOR_SIGNATURE", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Destructor '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(destructor_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, destructor_name) : str_concat(__recv, destructor_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' must have signature fn "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' must have signature fn ") : str_concat(__recv, "' must have signature fn "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(destructor_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, destructor_name) : str_concat(__recv, destructor_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(this : "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(this : ") : str_concat(__recv, "(this : "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias_name) : str_concat(__recv, alias_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("<...>) : Void"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "<...>) : Void") : str_concat(__recv, "<...>) : Void"); })(), "Destructor signatures must use the alias receiver type (or legacy '*move Alias') and return Void.", "Use exactly one receiver parameter named 'this' with alias type and return Void.");
}
  break;
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  if ((!found)) {
  panic_with_code("E_TYPE_DESTRUCTOR_NOT_FOUND", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Destructor '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(destructor_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, destructor_name) : str_concat(__recv, destructor_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' for alias '"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' for alias '") : str_concat(__recv, "' for alias '"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias_name) : str_concat(__recv, alias_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' was not found"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' was not found") : str_concat(__recv, "' was not found"); })(), "A type declaration referenced a destructor function that does not exist.", "Declare the destructor function before using it in 'type Alias = ... then destructor' or 'extern type Alias then destructor'.");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let copy_alias_count = (() => { const __recv = bc_copy_alias_names; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.copy_alias_count = copy_alias_count;
  while ((i < copy_alias_count)) {
  let alias_name = (() => { const __recv = bc_copy_alias_names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  let alias_type = (() => { const __recv = bc_copy_alias_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, alias_name) : map_get(__recv, alias_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_type = alias_type;
  let visiting = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.visiting = visiting;
  (() => { const __recv = visiting; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, alias_name) : set_add(__recv, alias_name); })();
  if ((!bc_type_node_is_copyable(alias_type, extern_type_names, visiting))) {
  panic_with_code("E_BORROW_INVALID_COPY_ALIAS", (() => { const __recv = (() => { const __recv = "copy type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias_name) : str_concat(__recv, alias_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" must alias a copy-compatible type"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " must alias a copy-compatible type") : str_concat(__recv, " must alias a copy-compatible type"); })(), "A type alias marked 'copy' resolved to a non-copy type under move semantics.", "Only mark aliases as 'copy' when the aliased type is copy-compatible (primitives, pointers, enums, copy structs, or other copy aliases).");
}
  (() => { const __recv = bc_copy_types; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, alias_name) : set_add(__recv, alias_name); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let state = state_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.state = state;
  let env = global_type_by_name; if (typeof __tuff_this !== 'undefined') __tuff_this.env = env;
  bc_global_value_types = global_type_by_name; if (typeof __tuff_this !== 'undefined') __tuff_this.bc_global_value_types = bc_global_value_types;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  check_stmt((() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), state, env, fn_return_types, extern_type_names, global_fn_names);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return program;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.borrowcheck_program_impl = borrowcheck_program_impl;

const __tuff_outer_for_selfhost_borrowcheck_impl_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_borrowcheck_impl_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_borrowcheck_impl_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_borrowcheck_impl_marker = selfhost_borrowcheck_impl_marker;

const __tuff_outer_for_borrowcheck_program = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function borrowcheck_program(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_borrowcheck_program };
  return borrowcheck_program_impl(program);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.borrowcheck_program = borrowcheck_program;

const __tuff_outer_for_selfhost_borrowcheck_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_borrowcheck_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_borrowcheck_marker };
  return selfhost_borrowcheck_impl_marker();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_borrowcheck_marker = selfhost_borrowcheck_marker;

const __tuff_outer_for_js_emit_struct_decl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function js_emit_struct_decl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_js_emit_struct_decl };
  let name_idx = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.name_idx = name_idx;
  let name = get_interned_str(name_idx); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let fields = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "function ");
  sb_append(sb, name);
  sb_append(sb, "(fields = {}) { return { __tag: \"");
  sb_append(sb, name);
  sb_append(sb, "\"");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  let fname = get_interned_str((() => { const __recv = field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  sb_append(sb, ", ");
  sb_append(sb, fname);
  sb_append(sb, ": fields.");
  sb_append(sb, fname);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, " }; }");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.js_emit_struct_decl = js_emit_struct_decl;

const __tuff_outer_for_js_emit_enum_decl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function js_emit_enum_decl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_js_emit_enum_decl };
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let variants = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.variants = variants;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "const ");
  sb_append(sb, name);
  sb_append(sb, " = { ");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = variants; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  if ((i > 0)) {
  sb_append(sb, ", ");
}
  let v = get_interned_str((() => { const __recv = variants; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  sb_append(sb, v);
  sb_append(sb, ": { __tag: \"");
  sb_append(sb, v);
  sb_append(sb, "\" }");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, " }; ");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.js_emit_enum_decl = js_emit_enum_decl;

const __tuff_outer_for_js_emit_object_decl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function js_emit_object_decl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_js_emit_object_decl };
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let inputs = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.inputs = inputs;
  if (((inputs === 0) || ((() => { const __recv = inputs; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 0))) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "const "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = { __tag: \""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = { __tag: \"") : str_concat(__recv, " = { __tag: \""); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\" }; "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\" }; ") : str_concat(__recv, "\" }; "); })();
}
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "const ");
  sb_append(sb, name);
  sb_append(sb, " = (() => { const __cache = new Map(); return (fields = {}) => { const __key = JSON.stringify([");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = inputs; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  if ((i > 0)) {
  sb_append(sb, ", ");
}
  let input_field = (() => { const __recv = inputs; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.input_field = input_field;
  let fname = get_interned_str((() => { const __recv = input_field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  sb_append(sb, "fields.");
  sb_append(sb, fname);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "]); const __cached = __cache.get(__key); if (__cached !== undefined) return __cached; const __value = { __tag: \"");
  sb_append(sb, name);
  sb_append(sb, "\"");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let input_field = (() => { const __recv = inputs; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.input_field = input_field;
  let fname = get_interned_str((() => { const __recv = input_field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  sb_append(sb, ", ");
  sb_append(sb, fname);
  sb_append(sb, ": fields.");
  sb_append(sb, fname);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, " }; __cache.set(__key, __value); return __value; }; })();");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.js_emit_object_decl = js_emit_object_decl;

const __tuff_outer_for_js_emit_contract_decl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function js_emit_contract_decl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_js_emit_contract_decl };
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = "// contract "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.js_emit_contract_decl = js_emit_contract_decl;

const __tuff_outer_for_selfhost_codegen_stmt_decl_emitters_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_codegen_stmt_decl_emitters_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_codegen_stmt_decl_emitters_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_codegen_stmt_decl_emitters_marker = selfhost_codegen_stmt_decl_emitters_marker;

let js_global_dtor_type_map = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.js_global_dtor_type_map = js_global_dtor_type_map;

let js_fn_stack = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.js_fn_stack = js_fn_stack;

const __tuff_outer_for_js_fn_stack_push = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function js_fn_stack_push(has_explicit_this, fn_name) {
  let __tuff_this = { has_explicit_this: has_explicit_this, fn_name: fn_name, this: __tuff_outer_for_js_fn_stack_push };
  let frame = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.frame = frame;
  let _a = (() => { const __recv = frame; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(has_explicit_this); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, has_explicit_this) : vec_push(__recv, has_explicit_this); })(); if (typeof __tuff_this !== 'undefined') __tuff_this._a = _a;
  let _b = (() => { const __recv = frame; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(fn_name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, fn_name) : vec_push(__recv, fn_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this._b = _b;
  let _c = (() => { const __recv = js_fn_stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(frame); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, frame) : vec_push(__recv, frame); })(); if (typeof __tuff_this !== 'undefined') __tuff_this._c = _c;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.js_fn_stack_push = js_fn_stack_push;

const __tuff_outer_for_js_fn_stack_pop = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function js_fn_stack_pop() {
  let __tuff_this = { this: __tuff_outer_for_js_fn_stack_pop };
  let _pop = (() => { const __recv = js_fn_stack; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this._pop = _pop;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.js_fn_stack_pop = js_fn_stack_pop;

const __tuff_outer_for_js_stack_in_synthetic_this = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function js_stack_in_synthetic_this() {
  let __tuff_this = { this: __tuff_outer_for_js_stack_in_synthetic_this };
  let h = (() => { const __recv = js_fn_stack; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.h = h;
  if ((h === 0)) {
  return false;
}
  let frame = (() => { const __recv = js_fn_stack; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop((h - 1)); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, (h - 1)) : vec_get(__recv, (h - 1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.frame = frame;
  return ((() => { const __recv = frame; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })() === 0);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.js_stack_in_synthetic_this = js_stack_in_synthetic_this;

const __tuff_outer_for_js_this_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function js_this_expr() {
  let __tuff_this = { this: __tuff_outer_for_js_this_expr };
  let h = (() => { const __recv = js_fn_stack; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.h = h;
  if ((h === 0)) {
  return "__tuff_this";
}
  let frame = (() => { const __recv = js_fn_stack; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop((h - 1)); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, (h - 1)) : vec_get(__recv, (h - 1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.frame = frame;
  if (((() => { const __recv = frame; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })() === 1)) {
  return "__this_param";
}
  return "__tuff_this";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.js_this_expr = js_this_expr;

const __tuff_outer_for_js_ident_stmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function js_ident_stmt(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_js_ident_stmt };
  if ((() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })()) {
  return js_this_expr();
}
  return name;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.js_ident_stmt = js_ident_stmt;

const __tuff_outer_for_emit_stmt_let_or_assign = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_stmt_let_or_assign(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_stmt_let_or_assign };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LET_DECL)) {
  let name_idx = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.name_idx = name_idx;
  let name = js_ident_stmt(get_interned_str(name_idx)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let value = emit_expr(node_get_data3(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  let decl = (() => { const __recv = (() => { const __recv = (() => { const __recv = "let "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = value; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = value; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })()) : str_concat(__recv, (() => { const __recv = value; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.decl = decl;
  if ((() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("__this_param"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "__this_param") : str_eq(__recv, "__this_param"); })()) {
  return decl;
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = decl; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" if (typeof __tuff_this !== 'undefined') __tuff_this."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " if (typeof __tuff_this !== 'undefined') __tuff_this.") : str_concat(__recv, " if (typeof __tuff_this !== 'undefined') __tuff_this."); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })();
}
  if ((kind === NK_ASSIGN_STMT)) {
  let target_node = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.target_node = target_node;
  let target = emit_expr(target_node); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let value = emit_expr(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  let assign = (() => { const __recv = (() => { const __recv = (() => { const __recv = target; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, value) : str_concat(__recv, value); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.assign = assign;
  if ((node_kind(target_node) === NK_IDENTIFIER)) {
  let name = get_interned_str(node_get_data1(target_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let js_name = js_ident_stmt(name); if (typeof __tuff_this !== 'undefined') __tuff_this.js_name = js_name;
  if ((!(() => { const __recv = js_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("__this_param"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "__this_param") : str_eq(__recv, "__this_param"); })())) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = assign; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" if (typeof __tuff_this !== 'undefined') __tuff_this."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " if (typeof __tuff_this !== 'undefined') __tuff_this.") : str_concat(__recv, " if (typeof __tuff_this !== 'undefined') __tuff_this."); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(js_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, js_name) : str_concat(__recv, js_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(js_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, js_name) : str_concat(__recv, js_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })();
}
}
  if ((node_kind(target_node) === NK_MEMBER_EXPR)) {
  let obj_node = node_get_data1(target_node); if (typeof __tuff_this !== 'undefined') __tuff_this.obj_node = obj_node;
  if ((node_kind(obj_node) === NK_IDENTIFIER)) {
  let obj_name = get_interned_str(node_get_data1(obj_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.obj_name = obj_name;
  if ((() => { const __recv = obj_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })()) {
  let prop = get_interned_str(node_get_data2(target_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "if (typeof __this_param !== 'undefined') { __this_param."; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prop) : str_concat(__recv, prop); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, value) : str_concat(__recv, value); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; } else { "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; } else { ") : str_concat(__recv, "; } else { "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prop) : str_concat(__recv, prop); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, value) : str_concat(__recv, value); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; if (typeof __tuff_this !== 'undefined') __tuff_this."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; if (typeof __tuff_this !== 'undefined') __tuff_this.") : str_concat(__recv, "; if (typeof __tuff_this !== 'undefined') __tuff_this."); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prop) : str_concat(__recv, prop); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prop) : str_concat(__recv, prop); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; }"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; }") : str_concat(__recv, "; }"); })();
}
}
}
  return assign;
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_stmt_let_or_assign = emit_stmt_let_or_assign;

const __tuff_outer_for_emit_stmt_flow = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_stmt_flow(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_stmt_flow };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_IMPORT_DECL)) {
  return "// import placeholder";
}
  if ((kind === NK_EXPR_STMT)) {
  return (() => { const __recv = emit_expr(node_get_data1(n)); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })();
}
  if ((kind === NK_RETURN_STMT)) {
  let value = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  if ((value === 0)) {
  return "return;";
}
  return (() => { const __recv = "return "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = emit_expr(value); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = emit_expr(value); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })()) : str_concat(__recv, (() => { const __recv = emit_expr(value); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })()); })();
}
  if ((kind === NK_IF_STMT)) {
  let cond = emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let then_b = emit_block(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.then_b = then_b;
  let else_b = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.else_b = else_b;
  if ((else_b === 0)) {
  return (() => { const __recv = (() => { const __recv = "if ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond) : str_concat(__recv, cond); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(then_b); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, then_b) : str_concat(__recv, then_b); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(then_b); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, then_b) : str_concat(__recv, then_b); })()) : str_concat(__recv, (() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(then_b); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, then_b) : str_concat(__recv, then_b); })()); })();
}
  return str_concat((() => { const __recv = (() => { const __recv = (() => { const __recv = "if ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond) : str_concat(__recv, cond); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") ") : str_concat(__recv, ") "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(then_b); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, then_b) : str_concat(__recv, then_b); })(), (() => { const __recv = " else "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_stmt_or_block(else_b)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_stmt_or_block(else_b)) : str_concat(__recv, emit_stmt_or_block(else_b)); })());
}
  if ((kind === NK_IF_EXPR)) {
  let cond = emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let then_b = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.then_b = then_b;
  let else_b = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.else_b = else_b;
  let then_str = emit_stmt_or_block(then_b); if (typeof __tuff_this !== 'undefined') __tuff_this.then_str = then_str;
  if ((else_b === 0)) {
  return (() => { const __recv = (() => { const __recv = "if ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond) : str_concat(__recv, cond); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(then_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, then_str) : str_concat(__recv, then_str); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(then_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, then_str) : str_concat(__recv, then_str); })()) : str_concat(__recv, (() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(then_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, then_str) : str_concat(__recv, then_str); })()); })();
}
  return str_concat((() => { const __recv = (() => { const __recv = (() => { const __recv = "if ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond) : str_concat(__recv, cond); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") ") : str_concat(__recv, ") "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(then_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, then_str) : str_concat(__recv, then_str); })(), (() => { const __recv = " else "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_stmt_or_block(else_b)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_stmt_or_block(else_b)) : str_concat(__recv, emit_stmt_or_block(else_b)); })());
}
  if ((kind === NK_WHILE_STMT)) {
  return (() => { const __recv = (() => { const __recv = "while ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_expr(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_expr(node_get_data1(n))) : str_concat(__recv, emit_expr(node_get_data1(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_block(node_get_data2(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_block(node_get_data2(n))) : str_concat(__recv, emit_block(node_get_data2(n))); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_block(node_get_data2(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_block(node_get_data2(n))) : str_concat(__recv, emit_block(node_get_data2(n))); })()) : str_concat(__recv, (() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_block(node_get_data2(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_block(node_get_data2(n))) : str_concat(__recv, emit_block(node_get_data2(n))); })()); })();
}
  if ((kind === NK_FOR_STMT)) {
  let iter = js_ident_stmt(get_interned_str(node_get_data1(n))); if (typeof __tuff_this !== 'undefined') __tuff_this.iter = iter;
  let start = emit_expr(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.start = start;
  let end = emit_expr(node_get_data3(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
  let body = emit_block(node_get_data4(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  return str_concat(str_concat(str_concat(str_concat((() => { const __recv = (() => { const __recv = (() => { const __recv = "for (let "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(iter); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, iter) : str_concat(__recv, iter); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(start); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, start) : str_concat(__recv, start); })(), (() => { const __recv = "; "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(iter); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, iter) : str_concat(__recv, iter); })()), (() => { const __recv = " < "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(end); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, end) : str_concat(__recv, end); })()), (() => { const __recv = "; "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = iter; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("++) "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "++) ") : str_concat(__recv, "++) "); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = iter; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("++) "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "++) ") : str_concat(__recv, "++) "); })()) : str_concat(__recv, (() => { const __recv = iter; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("++) "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "++) ") : str_concat(__recv, "++) "); })()); })()), body);
}
  if ((kind === NK_LOOP_STMT)) {
  return (() => { const __recv = "while (true) "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_block(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_block(node_get_data1(n))) : str_concat(__recv, emit_block(node_get_data1(n))); })();
}
  if ((kind === NK_BREAK_STMT)) {
  return "break;";
}
  if ((kind === NK_CONTINUE_STMT)) {
  return "continue;";
}
  if ((kind === NK_INTO_STMT)) {
  return (() => { const __recv = "// into "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })();
}
  if ((kind === NK_LIFETIME_STMT)) {
  return emit_block(node_get_data2(n));
}
  if ((kind === NK_BLOCK)) {
  return emit_block(n);
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_stmt_flow = emit_stmt_flow;

const __tuff_outer_for_emit_stmt_fn_decl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_stmt_fn_decl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_stmt_fn_decl };
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let params = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let body = node_get_data5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let param_names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.param_names = param_names;
  let has_explicit_this = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.has_explicit_this = has_explicit_this;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let pname = get_interned_str((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  if ((() => { const __recv = pname; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })()) {
  has_explicit_this = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.has_explicit_this = has_explicit_this;
  (() => { const __recv = param_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop("__this_param"); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, "__this_param") : vec_push(__recv, "__this_param"); })();
} else {
  (() => { const __recv = param_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, pname) : vec_push(__recv, pname); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let params_str = (() => { const __recv = param_names; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.params_str = params_str;
  let capture_var = (() => { const __recv = "__tuff_outer_for_"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.capture_var = capture_var;
  let preamble = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.preamble = preamble;
  let init_this = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.init_this = init_this;
  let suffix = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.suffix = suffix;
  if ((has_explicit_this === 1)) {
  init_this = "let __tuff_this = undefined;\n"; if (typeof __tuff_this !== 'undefined') __tuff_this.init_this = init_this;
} else {
  preamble = (() => { const __recv = (() => { const __recv = "const "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(capture_var); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, capture_var) : str_concat(__recv, capture_var); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;\n"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;\n") : str_concat(__recv, " = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;\n"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.preamble = preamble;
  let fields = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < len)) {
  let pname = get_interned_str((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(); const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  if ((!(() => { const __recv = pname; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })())) {
  (() => { const __recv = fields; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = pname; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(": "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ": ") : str_concat(__recv, ": "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, pname) : str_concat(__recv, pname); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = pname; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(": "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ": ") : str_concat(__recv, ": "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, pname) : str_concat(__recv, pname); })()) : vec_push(__recv, (() => { const __recv = (() => { const __recv = pname; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(": "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ": ") : str_concat(__recv, ": "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, pname) : str_concat(__recv, pname); })()); })();
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  (() => { const __recv = fields; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = "this: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(capture_var); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, capture_var) : str_concat(__recv, capture_var); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "this: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(capture_var); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, capture_var) : str_concat(__recv, capture_var); })()) : vec_push(__recv, (() => { const __recv = "this: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(capture_var); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, capture_var) : str_concat(__recv, capture_var); })()); })();
  init_this = (() => { const __recv = (() => { const __recv = "let __tuff_this = { "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = fields; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = fields; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })()) : str_concat(__recv, (() => { const __recv = fields; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" };\n"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " };\n") : str_concat(__recv, " };\n"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.init_this = init_this;
  suffix = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "\nif (typeof __tuff_this !== 'undefined') __tuff_this."; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.suffix = suffix;
}
  if ((node_kind(body) === NK_BLOCK)) {
  return (() => { const __recv = (() => { const __recv = preamble; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = (() => { const __recv = "function "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()) : str_concat(__recv, (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_fn_block_with_init(body, init_this)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_fn_block_with_init(body, init_this)) : str_concat(__recv, emit_fn_block_with_init(body, init_this)); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_fn_block_with_init(body, init_this)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_fn_block_with_init(body, init_this)) : str_concat(__recv, emit_fn_block_with_init(body, init_this)); })()) : str_concat(__recv, (() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_fn_block_with_init(body, init_this)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_fn_block_with_init(body, init_this)) : str_concat(__recv, emit_fn_block_with_init(body, init_this)); })()); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = (() => { const __recv = "function "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()) : str_concat(__recv, (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_fn_block_with_init(body, init_this)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_fn_block_with_init(body, init_this)) : str_concat(__recv, emit_fn_block_with_init(body, init_this)); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_fn_block_with_init(body, init_this)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_fn_block_with_init(body, init_this)) : str_concat(__recv, emit_fn_block_with_init(body, init_this)); })()) : str_concat(__recv, (() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_fn_block_with_init(body, init_this)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_fn_block_with_init(body, init_this)) : str_concat(__recv, emit_fn_block_with_init(body, init_this)); })()); })()) : str_concat(__recv, (() => { const __recv = (() => { const __recv = (() => { const __recv = "function "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()) : str_concat(__recv, (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_fn_block_with_init(body, init_this)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_fn_block_with_init(body, init_this)) : str_concat(__recv, emit_fn_block_with_init(body, init_this)); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_fn_block_with_init(body, init_this)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_fn_block_with_init(body, init_this)) : str_concat(__recv, emit_fn_block_with_init(body, init_this)); })()) : str_concat(__recv, (() => { const __recv = ") "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_fn_block_with_init(body, init_this)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_fn_block_with_init(body, init_this)) : str_concat(__recv, emit_fn_block_with_init(body, init_this)); })()); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(suffix); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, suffix) : str_concat(__recv, suffix); })();
}
  return (() => { const __recv = (() => { const __recv = preamble; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "function "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()) : str_concat(__recv, (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") {\n  "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") {\n  ") : str_concat(__recv, ") {\n  "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(init_this); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, init_this) : str_concat(__recv, init_this); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("  return "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "  return ") : str_concat(__recv, "  return "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_expr(body)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_expr(body)) : str_concat(__recv, emit_expr(body)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";\n}"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";\n}") : str_concat(__recv, ";\n}"); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "function "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()) : str_concat(__recv, (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") {\n  "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") {\n  ") : str_concat(__recv, ") {\n  "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(init_this); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, init_this) : str_concat(__recv, init_this); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("  return "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "  return ") : str_concat(__recv, "  return "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_expr(body)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_expr(body)) : str_concat(__recv, emit_expr(body)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";\n}"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";\n}") : str_concat(__recv, ";\n}"); })()) : str_concat(__recv, (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "function "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()) : str_concat(__recv, (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") {\n  "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") {\n  ") : str_concat(__recv, ") {\n  "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(init_this); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, init_this) : str_concat(__recv, init_this); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("  return "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "  return ") : str_concat(__recv, "  return "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_expr(body)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_expr(body)) : str_concat(__recv, emit_expr(body)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";\n}"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";\n}") : str_concat(__recv, ";\n}"); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(suffix); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, suffix) : str_concat(__recv, suffix); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_stmt_fn_decl = emit_stmt_fn_decl;

const __tuff_outer_for_js_is_extern_fn_decl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function js_is_extern_fn_decl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_js_is_extern_fn_decl };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  return ((kind === NK_FN_DECL) && (node_get_data5(n) === 0));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.js_is_extern_fn_decl = js_is_extern_fn_decl;

const __tuff_outer_for_emit_stmt_decls = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_stmt_decls(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_stmt_decls };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_EXPECT_FN_DECL)) {
  return (() => { const __recv = "// expect fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })();
}
  if (js_is_extern_fn_decl(n)) {
  return (() => { const __recv = "// extern fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })();
}
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  return emit_stmt_fn_decl(n);
}
  if ((kind === NK_STRUCT_DECL)) {
  return js_emit_struct_decl(n);
}
  if ((kind === NK_TYPE_ALIAS)) {
  return (() => { const __recv = (() => { const __recv = "// type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = ..."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ...") : str_concat(__recv, " = ..."); })();
}
  if ((kind === NK_DEP_TYPE_ALIAS)) {
  return (() => { const __recv = (() => { const __recv = "// type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(...) = ..."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(...) = ...") : str_concat(__recv, "(...) = ..."); })();
}
  if ((kind === NK_ENUM_DECL)) {
  return js_emit_enum_decl(n);
}
  if ((kind === NK_OBJECT_DECL)) {
  return js_emit_object_decl(n);
}
  if ((kind === NK_CONTRACT_DECL)) {
  return js_emit_contract_decl(n);
}
  if ((kind === NK_EXTERN_LET_DECL)) {
  return (() => { const __recv = "// extern let "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })();
}
  if ((kind === NK_EXTERN_TYPE_DECL)) {
  return (() => { const __recv = "// extern type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })();
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  let parts = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.parts = parts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let source = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.source = source;
  while ((i < (() => { const __recv = parts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  if ((i > 0)) {
  source = (() => { const __recv = source; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("::"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "::") : str_concat(__recv, "::"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.source = source;
}
  source = (() => { const __recv = source; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str((() => { const __recv = parts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str((() => { const __recv = parts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())) : str_concat(__recv, get_interned_str((() => { const __recv = parts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.source = source;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = "// extern from "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(source); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, source) : str_concat(__recv, source); })();
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_stmt_decls = emit_stmt_decls;

const __tuff_outer_for_emit_stmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_stmt(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_stmt };
  let code = emit_stmt_let_or_assign(n); if (typeof __tuff_this !== 'undefined') __tuff_this.code = code;
  if ((!(() => { const __recv = code; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  return code;
}
  code = emit_stmt_flow(n); if (typeof __tuff_this !== 'undefined') __tuff_this.code = code;
  if ((!(() => { const __recv = code; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  return code;
}
  return emit_stmt_decls(n);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_stmt = emit_stmt;

const __tuff_outer_for_emit_stmt_or_block = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_stmt_or_block(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_stmt_or_block };
  if ((node_kind(n) === NK_BLOCK)) {
  return emit_block(n);
}
  return (() => { const __recv = "{ "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = emit_stmt(n); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" }"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " }") : str_concat(__recv, " }"); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = emit_stmt(n); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" }"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " }") : str_concat(__recv, " }"); })()) : str_concat(__recv, (() => { const __recv = emit_stmt(n); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" }"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " }") : str_concat(__recv, " }"); })()); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_stmt_or_block = emit_stmt_or_block;

const __tuff_outer_for_emit_block = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_block(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_block };
  let stmts = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "{\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  sb_append(sb, "  ");
  sb_append(sb, emit_stmt((() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()));
  sb_append(sb, "\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "}");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_block = emit_block;

const __tuff_outer_for_emit_block_as_iife = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_block_as_iife(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_block_as_iife };
  let stmts = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return "(() => undefined)()";
}
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "(() => {\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let is_last = (i === (len - 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.is_last = is_last;
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((is_last && (kind === NK_EXPR_STMT))) {
  sb_append(sb, "  return ");
  sb_append(sb, emit_expr(node_get_data1(stmt)));
  sb_append(sb, ";\n");
} else { if ((is_last && ((kind === NK_IF_STMT) || (kind === NK_IF_EXPR)))) {
  sb_append(sb, "  return ");
  sb_append(sb, emit_if_as_expr(stmt));
  sb_append(sb, ";\n");
} else {
  sb_append(sb, "  ");
  sb_append(sb, emit_stmt(stmt));
  sb_append(sb, "\n");
} }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "})()");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_block_as_iife = emit_block_as_iife;

const __tuff_outer_for_emit_fn_block_with_init = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_fn_block_with_init(n, init_this) {
  let __tuff_this = { n: n, init_this: init_this, this: __tuff_outer_for_emit_fn_block_with_init };
  let stmts = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "{\n");
  if ((!(() => { const __recv = init_this; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  sb_append(sb, "  ");
  sb_append(sb, init_this);
}
  if ((len === 0)) {
  sb_append(sb, "}");
  return sb_build(sb);
}
  let dtor_type_map = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.dtor_type_map = dtor_type_map;
  let si = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.si = si;
  while ((si < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(si); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, si) : vec_get(__recv, si); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if (((node_kind(stmt) === NK_TYPE_ALIAS) && (node_get_data5(stmt) !== 0))) {
  let alias_name = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  let dtor_name = get_interned_str(node_get_data5(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.dtor_name = dtor_name;
  (() => { const __recv = dtor_type_map; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, dtor_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, dtor_name) : map_set(__recv, alias_name, dtor_name); })();
}
  si = (si + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.si = si;
}
  let dtor_var_names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.dtor_var_names = dtor_var_names;
  let dtor_var_dtors = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.dtor_var_dtors = dtor_var_dtors;
  si = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.si = si;
  while ((si < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(si); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, si) : vec_get(__recv, si); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if ((node_kind(stmt) === NK_LET_DECL)) {
  let type_node = node_get_data2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.type_node = type_node;
  if (((type_node !== 0) && (node_kind(type_node) === 40))) {
  let type_name = get_interned_str(node_get_data1(type_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.type_name = type_name;
  if (((() => { const __recv = dtor_type_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, type_name) : map_has(__recv, type_name); })() || (() => { const __recv = js_global_dtor_type_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, type_name) : map_has(__recv, type_name); })())) {
  (() => { const __recv = dtor_var_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(stmt))); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(stmt))) : vec_push(__recv, get_interned_str(node_get_data1(stmt))); })();
  if ((() => { const __recv = dtor_type_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, type_name) : map_has(__recv, type_name); })()) {
  (() => { const __recv = dtor_var_dtors; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = dtor_type_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, type_name) : map_get(__recv, type_name); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = dtor_type_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, type_name) : map_get(__recv, type_name); })()) : vec_push(__recv, (() => { const __recv = dtor_type_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, type_name) : map_get(__recv, type_name); })()); })();
} else {
  (() => { const __recv = dtor_var_dtors; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = js_global_dtor_type_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, type_name) : map_get(__recv, type_name); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = js_global_dtor_type_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, type_name) : map_get(__recv, type_name); })()) : vec_push(__recv, (() => { const __recv = js_global_dtor_type_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(type_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, type_name) : map_get(__recv, type_name); })()); })();
}
}
}
}
  si = (si + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.si = si;
}
  let dtor_calls = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.dtor_calls = dtor_calls;
  let dtor_count = (() => { const __recv = dtor_var_names; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dtor_count = dtor_count;
  if ((dtor_count > 0)) {
  let di = (dtor_count - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.di = di;
  while ((di >= 0)) {
  let vn = (() => { const __recv = dtor_var_names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(di); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, di) : vec_get(__recv, di); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.vn = vn;
  let dn = (() => { const __recv = dtor_var_dtors; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(di); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, di) : vec_get(__recv, di); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dn = dn;
  dtor_calls = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = dtor_calls; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(dn); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, dn) : str_concat(__recv, dn); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(vn); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, vn) : str_concat(__recv, vn); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(");\n  "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ");\n  ") : str_concat(__recv, ");\n  "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dtor_calls = dtor_calls;
  di = (di - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.di = di;
}
}
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let is_last = (i === (len - 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.is_last = is_last;
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((is_last && (kind === NK_EXPR_STMT))) {
  if ((!(() => { const __recv = dtor_calls; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  sb_append(sb, "  ");
  sb_append(sb, dtor_calls);
}
  sb_append(sb, "  return ");
  sb_append(sb, emit_expr(node_get_data1(stmt)));
  sb_append(sb, ";\n");
} else { if ((is_last && ((kind === NK_IF_STMT) || (kind === NK_IF_EXPR)))) {
  if ((!(() => { const __recv = dtor_calls; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  sb_append(sb, "  ");
  sb_append(sb, dtor_calls);
}
  sb_append(sb, "  return ");
  sb_append(sb, emit_if_as_expr(stmt));
  sb_append(sb, ";\n");
} else {
  sb_append(sb, "  ");
  sb_append(sb, emit_stmt(stmt));
  sb_append(sb, "\n");
} }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "}");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_fn_block_with_init = emit_fn_block_with_init;

const __tuff_outer_for_emit_fn_block_with_preamble = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_fn_block_with_preamble(n, preamble) {
  let __tuff_this = { n: n, preamble: preamble, this: __tuff_outer_for_emit_fn_block_with_preamble };
  let stmts = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  if ((() => { const __recv = preamble; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) {
  return "{\n}";
}
  return (() => { const __recv = (() => { const __recv = "{\n  "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(preamble); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, preamble) : str_concat(__recv, preamble); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\n}"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\n}") : str_concat(__recv, "\n}"); })();
}
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "{\n");
  if ((!(() => { const __recv = preamble; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  sb_append(sb, "  ");
  sb_append(sb, preamble);
  sb_append(sb, "\n");
}
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let is_last = (i === (len - 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.is_last = is_last;
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((is_last && (kind === NK_EXPR_STMT))) {
  sb_append(sb, "  return ");
  sb_append(sb, emit_expr(node_get_data1(stmt)));
  sb_append(sb, ";\n");
} else { if ((is_last && ((kind === NK_IF_STMT) || (kind === NK_IF_EXPR)))) {
  sb_append(sb, "  return ");
  sb_append(sb, emit_if_as_expr(stmt));
  sb_append(sb, ";\n");
} else {
  sb_append(sb, "  ");
  sb_append(sb, emit_stmt(stmt));
  sb_append(sb, "\n");
} }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "}");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_fn_block_with_preamble = emit_fn_block_with_preamble;

const __tuff_outer_for_emit_fn_block = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_fn_block(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_fn_block };
  return emit_fn_block_with_preamble(n, "");
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_fn_block = emit_fn_block;

const __tuff_outer_for_emit_if_as_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_if_as_expr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_if_as_expr };
  let cond = emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let then_branch = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.then_branch = then_branch;
  let else_branch = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.else_branch = else_branch;
  let then_code = emit_branch_as_expr(then_branch); if (typeof __tuff_this !== 'undefined') __tuff_this.then_code = then_code;
  let else_code = "undefined"; if (typeof __tuff_this !== 'undefined') __tuff_this.else_code = else_code;
  if ((else_branch !== 0)) {
  else_code = emit_branch_as_expr(else_branch); if (typeof __tuff_this !== 'undefined') __tuff_this.else_code = else_code;
}
  return str_concat((() => { const __recv = (() => { const __recv = (() => { const __recv = "(("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond) : str_concat(__recv, cond); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") ? "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") ? ") : str_concat(__recv, ") ? "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = then_code; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" : "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " : ") : str_concat(__recv, " : "); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = then_code; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" : "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " : ") : str_concat(__recv, " : "); })()) : str_concat(__recv, (() => { const __recv = then_code; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" : "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " : ") : str_concat(__recv, " : "); })()); })(), (() => { const __recv = else_code; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_if_as_expr = emit_if_as_expr;

const __tuff_outer_for_emit_branch_as_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_branch_as_expr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_branch_as_expr };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_BLOCK)) {
  let stmts = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return "undefined";
}
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "(() => {\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let is_last = (i === (len - 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.is_last = is_last;
  let stmt_kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt_kind = stmt_kind;
  if ((is_last && (stmt_kind === NK_EXPR_STMT))) {
  sb_append(sb, "    return ");
  sb_append(sb, emit_expr(node_get_data1(stmt)));
  sb_append(sb, ";\n");
} else { if ((is_last && ((stmt_kind === NK_IF_STMT) || (stmt_kind === NK_IF_EXPR)))) {
  sb_append(sb, "    return ");
  sb_append(sb, emit_if_as_expr(stmt));
  sb_append(sb, ";\n");
} else {
  sb_append(sb, "    ");
  sb_append(sb, emit_stmt(stmt));
  sb_append(sb, "\n");
} }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "  })()");
  return sb_build(sb);
}
  if (((kind === NK_IF_STMT) || (kind === NK_IF_EXPR))) {
  return emit_if_as_expr(n);
}
  return emit_expr(n);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_branch_as_expr = emit_branch_as_expr;

const __tuff_outer_for_generate_js = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function generate_js(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_generate_js };
  let stmts = node_get_data1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  js_global_dtor_type_map = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.js_global_dtor_type_map = js_global_dtor_type_map;
  let gi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gi = gi;
  let glen = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.glen = glen;
  while ((gi < glen)) {
  let s = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(gi); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, gi) : vec_get(__recv, gi); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  let k = node_kind(s); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((((k === NK_TYPE_ALIAS) || (k === NK_EXTERN_TYPE_DECL)) && (node_get_data5(s) !== 0))) {
  (() => { const __recv = js_global_dtor_type_map; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(s)), get_interned_str(node_get_data5(s))); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(s)), get_interned_str(node_get_data5(s))) : map_set(__recv, get_interned_str(node_get_data1(s)), get_interned_str(node_get_data5(s))); })();
}
  gi = (gi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.gi = gi;
}
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "\"use strict\";\n\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  sb_append(sb, emit_stmt((() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()));
  sb_append(sb, "\n\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.generate_js = generate_js;

const __tuff_outer_for_selfhost_codegen_stmt_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_codegen_stmt_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_codegen_stmt_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_codegen_stmt_marker = selfhost_codegen_stmt_marker;

let cc_temp_counter = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_temp_counter = cc_temp_counter;

let cc_enum_names = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_enum_names = cc_enum_names;

let cc_enum_variant_consts = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_enum_variant_consts = cc_enum_variant_consts;

let cc_struct_fields = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_struct_fields = cc_struct_fields;

let cc_alias_by_variant = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_alias_by_variant = cc_alias_by_variant;

let cc_union_alias_info = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_union_alias_info = cc_union_alias_info;

let cc_covered_extern_fns = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_covered_extern_fns = cc_covered_extern_fns;

let cc_local_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_local_types = cc_local_types;

let cc_inc_stdint = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdint = cc_inc_stdint;

let cc_inc_stddef = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stddef = cc_inc_stddef;

let cc_inc_stdio = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdio = cc_inc_stdio;

let cc_inc_stdlib = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdlib = cc_inc_stdlib;

let cc_inc_string = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_string = cc_inc_string;

let cc_inc_ctype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_ctype = cc_inc_ctype;

let cc_inc_errno = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_errno = cc_inc_errno;

let cc_inc_direct = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_direct = cc_inc_direct;

let cc_inc_sys_stat = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_sys_stat = cc_inc_sys_stat;

let cc_inc_sys_types = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_sys_types = cc_inc_sys_types;

let cc_disable_unicode_escape = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_disable_unicode_escape = cc_disable_unicode_escape;

const __tuff_outer_for_cc_next_temp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_next_temp(prefix) {
  let __tuff_this = { prefix: prefix, this: __tuff_outer_for_cc_next_temp };
  cc_temp_counter = (cc_temp_counter + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_temp_counter = cc_temp_counter;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "__"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prefix); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prefix) : str_concat(__recv, prefix); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "_") : str_concat(__recv, "_"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(cc_temp_counter)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(cc_temp_counter)) : str_concat(__recv, int_to_string(cc_temp_counter)); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_next_temp = cc_next_temp;

const __tuff_outer_for_cc_to_name = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_to_name(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_cc_to_name };
  return (((() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("main"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "main") : str_eq(__recv, "main"); })()) ? (() => {
    return "tuff_main";
  })() : (() => {
    return name;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_to_name = cc_to_name;

const __tuff_outer_for_cc_join_parts = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_join_parts(parts) {
  let __tuff_this = { parts: parts, this: __tuff_outer_for_cc_join_parts };
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = parts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  if ((i > 0)) {
  sb_append(sb, "::");
}
  sb_append(sb, get_interned_str((() => { const __recv = parts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_join_parts = cc_join_parts;

const __tuff_outer_for_cc_mark_header_from_source = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_mark_header_from_source(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_cc_mark_header_from_source };
  if ((() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("stdio"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "stdio") : str_eq(__recv, "stdio"); })()) {
  cc_inc_stdio = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdio = cc_inc_stdio;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("stdlib"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "stdlib") : str_eq(__recv, "stdlib"); })()) {
  cc_inc_stdlib = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdlib = cc_inc_stdlib;
  return 0;
}
  if (((() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("string"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "string") : str_eq(__recv, "string"); })() || (() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("strings"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "strings") : str_eq(__recv, "strings"); })())) {
  cc_inc_string = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_string = cc_inc_string;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("stdint"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "stdint") : str_eq(__recv, "stdint"); })()) {
  cc_inc_stdint = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdint = cc_inc_stdint;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("stddef"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "stddef") : str_eq(__recv, "stddef"); })()) {
  cc_inc_stddef = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stddef = cc_inc_stddef;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("errno"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "errno") : str_eq(__recv, "errno"); })()) {
  cc_inc_errno = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_errno = cc_inc_errno;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("direct"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "direct") : str_eq(__recv, "direct"); })()) {
  cc_inc_direct = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_direct = cc_inc_direct;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("sys::stat"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "sys::stat") : str_eq(__recv, "sys::stat"); })()) {
  cc_inc_sys_stat = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_sys_stat = cc_inc_sys_stat;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("sys::types"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "sys::types") : str_eq(__recv, "sys::types"); })()) {
  cc_inc_sys_types = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_sys_types = cc_inc_sys_types;
  return 0;
}
  if ((((() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("globalThis"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "globalThis") : str_eq(__recv, "globalThis"); })() || (() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("substrate"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "substrate") : str_eq(__recv, "substrate"); })()) || (() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("host_c"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "host_c") : str_eq(__recv, "host_c"); })())) {
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("collections"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "collections") : str_eq(__recv, "collections"); })()) {
  cc_inc_stdlib = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdlib = cc_inc_stdlib;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("io"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "io") : str_eq(__recv, "io"); })()) {
  cc_inc_stdio = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdio = cc_inc_stdio;
  cc_inc_stdlib = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdlib = cc_inc_stdlib;
  cc_inc_string = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_string = cc_inc_string;
  return 0;
}
  return panic_with_code("E_EXTERN_UNKNOWN_SOURCE", (() => { const __recv = (() => { const __recv = "Unknown extern source attribution: '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(source); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, source) : str_concat(__recv, source); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "The C backend only supports a built-in set of extern source aliases for header mapping.", "Use a supported source alias (stdio, stdlib, string/strings, stdint, stddef, errno, direct, sys::stat, sys::types) or one of the runtime buckets (globalThis, substrate, host_c).");
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_mark_header_from_source = cc_mark_header_from_source;

const __tuff_outer_for_cc_require_substrate_headers = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_require_substrate_headers() {
  let __tuff_this = { this: __tuff_outer_for_cc_require_substrate_headers };
  cc_inc_stddef = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stddef = cc_inc_stddef;
  cc_inc_stdio = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdio = cc_inc_stdio;
  cc_inc_stdlib = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdlib = cc_inc_stdlib;
  cc_inc_string = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_string = cc_inc_string;
  cc_inc_ctype = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_ctype = cc_inc_ctype;
  cc_inc_errno = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_errno = cc_inc_errno;
  cc_inc_direct = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_direct = cc_inc_direct;
  cc_inc_sys_stat = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_sys_stat = cc_inc_sys_stat;
  cc_inc_sys_types = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_sys_types = cc_inc_sys_types;
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_require_substrate_headers = cc_require_substrate_headers;

const __tuff_outer_for_cc_emit_minimal_runtime_prelude = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_minimal_runtime_prelude() {
  let __tuff_this = { this: __tuff_outer_for_cc_emit_minimal_runtime_prelude };
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "/* Built-in minimal runtime prelude (substrate-free path) */\n");
  sb_append(sb, "static inline int64_t tuff_to_val(const void* p) { return (int64_t)(intptr_t)p; }\n");
  sb_append(sb, "static inline void* tuff_from_val(int64_t v) { return (void*)(intptr_t)v; }\n");
  sb_append(sb, "static inline const char* tuff_str(int64_t v) { return v == 0 ? NULL : (const char*)(intptr_t)v; }\n");
  sb_append(sb, "static inline const char* tuff_str_or_empty(int64_t v) { const char* s = tuff_str(v); return s ? s : \"\"; }\n");
  sb_append(sb, "typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\n");
  sb_append(sb, "static void tuff_panic(const char* msg) { fprintf(stderr, \"[tuff panic] %s\\n\", msg); abort(); }\n");
  sb_append(sb, "\n/* String runtime function declarations and minimal implementations */\n");
  sb_append(sb, "int64_t str_length(int64_t this) { return (int64_t)strlen(tuff_str_or_empty(this)); }\n");
  sb_append(sb, "int64_t str_char_at(int64_t this, int64_t index) { const char* s = tuff_str(this); if (!s || index < 0 || index >= (int64_t)strlen(s)) return 0; return (int64_t)s[index]; }\n");
  sb_append(sb, "int64_t str_slice(int64_t this, int64_t start, int64_t end) { const char* s = tuff_str(this); if (!s || start < 0 || end < start) return 0; size_t len = strlen(s); if ((size_t)end > len) end = (int64_t)len; size_t n = (size_t)(end - start); char* out = (char*)malloc(n + 1); if (!out) return 0; strncpy(out, s + start, n); out[n] = '\\0'; return (int64_t)(intptr_t)out; }\n");
  sb_append(sb, "int64_t str_concat(int64_t a, int64_t b) { const char* as = tuff_str_or_empty(a); const char* bs = tuff_str_or_empty(b); size_t alen = strlen(as); size_t blen = strlen(bs); char* out = (char*)malloc(alen + blen + 1); if (!out) return 0; strcpy(out, as); strcat(out, bs); return (int64_t)(intptr_t)out; }\n");
  sb_append(sb, "int64_t str_eq(int64_t a, int64_t b) { const char* as = tuff_str_or_empty(a); const char* bs = tuff_str_or_empty(b); return strcmp(as, bs) == 0 ? 1 : 0; }\n");
  sb_append(sb, "int64_t str_from_char_code(int64_t code) { char* out = (char*)malloc(2); if (!out) return 0; out[0] = (char)(code & 0xFF); out[1] = '\\0'; return (int64_t)(intptr_t)out; }\n");
  sb_append(sb, "int64_t str_index_of(int64_t s, int64_t needle) { const char* str = tuff_str(s); const char* ndl = tuff_str(needle); if (!str || !ndl) return -1; const char* found = strstr(str, ndl); if (!found) return -1; return (int64_t)(found - str); }\n");
  sb_append(sb, "int64_t str_trim(int64_t s) { const char* str = tuff_str_or_empty(s); while (isspace(*str)) str++; const char* end = str + strlen(str); while (end > str && isspace(*(end - 1))) end--; size_t len = end - str; if (len == 0) return (int64_t)(intptr_t)\"\"; char* out = (char*)malloc(len + 1); if (!out) return 0; strncpy(out, str, len); out[len] = '\\0'; return (int64_t)(intptr_t)out; }\n");
  sb_append(sb, "int64_t str_replace_all(int64_t s, int64_t from, int64_t to) { const char* str = tuff_str_or_empty(s); const char* f = tuff_str_or_empty(from); const char* t = tuff_str_or_empty(to); if (strlen(f) == 0) return s; size_t buf_size = strlen(str) * 2 + 1; char* out = (char*)malloc(buf_size); if (!out) return 0; char* p = out; const char* q = str; while ((q = strstr(q, f)) != NULL) { strncat(p, str, q - str); strncat(p, t, strlen(t)); str = q + strlen(f); q = str; } strcat(p, str); return (int64_t)(intptr_t)out; }\n");
  sb_append(sb, "int64_t char_code(int64_t ch) { const char* s = tuff_str(ch); return s && *s ? (int64_t)*s : 0; }\n");
  sb_append(sb, "int64_t int_to_string(int64_t n) { char* out = (char*)malloc(32); if (!out) return 0; snprintf(out, 32, \"%lld\", (long long)n); return (int64_t)(intptr_t)out; }\n");
  sb_append(sb, "int64_t parse_int(int64_t s) { const char* str = tuff_str_or_empty(s); return (int64_t)atoll(str); }\n");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_minimal_runtime_prelude = cc_emit_minimal_runtime_prelude;

const __tuff_outer_for_cc_type_to_c = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_type_to_c(type_node) {
  let __tuff_this = { type_node: type_node, this: __tuff_outer_for_cc_type_to_c };
  if ((type_node === 0)) {
  return "int64_t";
}
  let kind = node_kind(type_node); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_POINTER_TYPE)) {
  let inner = node_get_data2(type_node); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  if (((inner !== 0) && (node_kind(inner) === NK_ARRAY_TYPE))) {
  return "TuffVec*";
}
  return "int64_t";
}
  if ((kind === NK_NAMED_TYPE)) {
  let name = get_interned_str(node_get_data1(type_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Void"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Void") : str_eq(__recv, "Void"); })()) {
  return "void";
}
  if ((() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("Alloc"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "Alloc") : str_eq(__recv, "Alloc"); })()) {
  let generics = node_get_data2(type_node); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  if (((generics !== 0) && ((() => { const __recv = generics; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() > 0))) {
  return cc_type_to_c((() => { const __recv = generics; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })());
}
  return "int64_t";
}
  if ((() => { const __recv = cc_union_alias_info; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  return name;
}
  if ((() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  return (() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })();
}
  return "int64_t";
}
  if ((kind === 44)) {
  return cc_type_to_c(node_get_data1(type_node));
}
  if ((kind === 71)) {
  return "int64_t";
}
  return "int64_t";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_type_to_c = cc_type_to_c;

const __tuff_outer_for_cc_infer_expr_ctype = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_infer_expr_ctype(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_cc_infer_expr_ctype };
  if ((n === 0)) {
  return "int64_t";
}
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_STRUCT_INIT)) {
  let vname = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.vname = vname;
  if ((() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(vname); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, vname) : map_has(__recv, vname); })()) {
  return (() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(vname); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, vname) : map_get(__recv, vname); })();
}
  return vname;
}
  if ((kind === NK_CALL_EXPR)) {
  let callee = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  if ((node_kind(callee) === NK_IDENTIFIER)) {
  let cname = get_interned_str(node_get_data1(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
  if (((() => { const __recv = cname; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("malloc"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "malloc") : str_eq(__recv, "malloc"); })() || (() => { const __recv = cname; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("realloc"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "realloc") : str_eq(__recv, "realloc"); })())) {
  return "TuffVec*";
}
}
}
  return "int64_t";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_infer_expr_ctype = cc_infer_expr_ctype;

const __tuff_outer_for_cc_is_stdlib_builtin = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_is_stdlib_builtin(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_cc_is_stdlib_builtin };
  return ((((((((((((((((((((((((((() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("malloc"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "malloc") : str_eq(__recv, "malloc"); })() || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("free"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "free") : str_eq(__recv, "free"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("realloc"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "realloc") : str_eq(__recv, "realloc"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("calloc"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "calloc") : str_eq(__recv, "calloc"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("memcpy"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "memcpy") : str_eq(__recv, "memcpy"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("memmove"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "memmove") : str_eq(__recv, "memmove"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("memset"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "memset") : str_eq(__recv, "memset"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("printf"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "printf") : str_eq(__recv, "printf"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("fprintf"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "fprintf") : str_eq(__recv, "fprintf"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("fopen"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "fopen") : str_eq(__recv, "fopen"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("fclose"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "fclose") : str_eq(__recv, "fclose"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("fwrite"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "fwrite") : str_eq(__recv, "fwrite"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("fread"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "fread") : str_eq(__recv, "fread"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("fseek"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "fseek") : str_eq(__recv, "fseek"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("ftell"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "ftell") : str_eq(__recv, "ftell"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("strlen"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "strlen") : str_eq(__recv, "strlen"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("strdup"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "strdup") : str_eq(__recv, "strdup"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("strcpy"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "strcpy") : str_eq(__recv, "strcpy"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("strcat"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "strcat") : str_eq(__recv, "strcat"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("strncpy"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "strncpy") : str_eq(__recv, "strncpy"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("strncat"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "strncat") : str_eq(__recv, "strncat"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("strcmp"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "strcmp") : str_eq(__recv, "strcmp"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("strstr"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "strstr") : str_eq(__recv, "strstr"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("strrchr"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "strrchr") : str_eq(__recv, "strrchr"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("exit"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "exit") : str_eq(__recv, "exit"); })()) || (() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("abort"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "abort") : str_eq(__recv, "abort"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_is_stdlib_builtin = cc_is_stdlib_builtin;

const __tuff_outer_for_cc_flatten_union_variants = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_flatten_union_variants(type_node, names_vec) {
  let __tuff_this = { type_node: type_node, names_vec: names_vec, this: __tuff_outer_for_cc_flatten_union_variants };
  if ((type_node === 0)) {
  return 0;
}
  let kind = node_kind(type_node); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_NAMED_TYPE)) {
  (() => { const __recv = names_vec; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(type_node))); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(type_node))) : vec_push(__recv, get_interned_str(node_get_data1(type_node))); })();
  return 0;
}
  if ((kind === NK_UNION_TYPE)) {
  cc_flatten_union_variants(node_get_data1(type_node), names_vec);
  cc_flatten_union_variants(node_get_data2(type_node), names_vec);
  return 0;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_flatten_union_variants = cc_flatten_union_variants;

const __tuff_outer_for_cc_init_context = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_init_context(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_cc_init_context };
  let stmts = node_get_data1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let n = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_ENUM_DECL)) {
  let enum_name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.enum_name = enum_name;
  (() => { const __recv = cc_enum_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(enum_name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, enum_name) : set_add(__recv, enum_name); })();
  let variants = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.variants = variants;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let vlen = (() => { const __recv = variants; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.vlen = vlen;
  while ((j < vlen)) {
  let v = get_interned_str((() => { const __recv = variants; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  (() => { const __recv = cc_enum_variant_consts; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(v, (() => { const __recv = (() => { const __recv = enum_name; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "_") : str_concat(__recv, "_"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, v) : str_concat(__recv, v); })()); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, v, (() => { const __recv = (() => { const __recv = enum_name; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "_") : str_concat(__recv, "_"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, v) : str_concat(__recv, v); })()) : map_set(__recv, v, (() => { const __recv = (() => { const __recv = enum_name; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "_") : str_concat(__recv, "_"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, v) : str_concat(__recv, v); })()); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
}
  if ((kind === NK_STRUCT_DECL)) {
  let struct_name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.struct_name = struct_name;
  let fields = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let field_names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.field_names = field_names;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let flen = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.flen = flen;
  while ((j < flen)) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  (() => { const __recv = field_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(get_interned_str((() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })())); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, get_interned_str((() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })())) : vec_push(__recv, get_interned_str((() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })())); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  (() => { const __recv = cc_struct_fields; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(struct_name, field_names); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, struct_name, field_names) : map_set(__recv, struct_name, field_names); })();
}
  if ((kind === NK_TYPE_ALIAS)) {
  let alias_name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  let aliased = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.aliased = aliased;
  if (((aliased !== 0) && (node_kind(aliased) === NK_UNION_TYPE))) {
  let variants = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.variants = variants;
  cc_flatten_union_variants(aliased, variants);
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let vlen = (() => { const __recv = variants; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.vlen = vlen;
  while ((j < vlen)) {
  let v = (() => { const __recv = variants; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  (() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(v, alias_name); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, v, alias_name) : map_set(__recv, v, alias_name); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  (() => { const __recv = cc_union_alias_info; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(alias_name, variants); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, alias_name, variants) : map_set(__recv, alias_name, variants); })();
}
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  let names = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let nlen = (() => { const __recv = names; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.nlen = nlen;
  while ((j < nlen)) {
  (() => { const __recv = cc_covered_extern_fns; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(get_interned_str((() => { const __recv = names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })())); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, get_interned_str((() => { const __recv = names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })())) : set_add(__recv, get_interned_str((() => { const __recv = names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })())); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  cc_mark_header_from_source(cc_join_parts(node_get_data2(n)));
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_init_context = cc_init_context;

const __tuff_outer_for_cc_emit_pattern_guard = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_pattern_guard(target, pat) {
  let __tuff_this = { target: target, pat: pat, this: __tuff_outer_for_cc_emit_pattern_guard };
  let kind = node_kind(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_WILDCARD_PAT)) {
  return "1";
}
  if ((kind === NK_LITERAL_PAT)) {
  let val = get_interned_str(node_get_data1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, target) : str_concat(__recv, target); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" == "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " == ") : str_concat(__recv, " == "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(val); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, val) : str_concat(__recv, val); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  if ((kind === NK_NAME_PAT)) {
  let name = get_interned_str(node_get_data1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = cc_enum_variant_consts; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, target) : str_concat(__recv, target); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" == "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " == ") : str_concat(__recv, " == "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = cc_enum_variant_consts; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = cc_enum_variant_consts; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })()) : str_concat(__recv, (() => { const __recv = cc_enum_variant_consts; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  if ((() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  let alias = (() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias = alias;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, target) : str_concat(__recv, target); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(".__tag == "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".__tag == ") : str_concat(__recv, ".__tag == "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias) : str_concat(__recv, alias); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "_") : str_concat(__recv, "_"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  return "1";
}
  if ((kind === NK_STRUCT_PAT)) {
  let name = get_interned_str(node_get_data1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  let alias = (() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias = alias;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, target) : str_concat(__recv, target); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(".__tag == "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".__tag == ") : str_concat(__recv, ".__tag == "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias) : str_concat(__recv, alias); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "_") : str_concat(__recv, "_"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  return "1";
}
  return "1";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_pattern_guard = cc_emit_pattern_guard;

const __tuff_outer_for_cc_emit_block_to_assign = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_block_to_assign(block_node, tmp_var) {
  let __tuff_this = { block_node: block_node, tmp_var: tmp_var, this: __tuff_outer_for_cc_emit_block_to_assign };
  let stmts = node_get_data1(block_node); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return (() => { const __recv = tmp_var; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = 0;"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = 0;") : str_concat(__recv, " = 0;"); })();
}
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let is_last = (i === (len - 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.is_last = is_last;
  let skind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.skind = skind;
  if ((is_last && (skind === NK_EXPR_STMT))) {
  sb_append(sb, tmp_var);
  sb_append(sb, " = ");
  sb_append(sb, cc_emit_expr(node_get_data1(stmt)));
  sb_append(sb, ";");
} else { if ((is_last && ((skind === NK_IF_STMT) || (skind === NK_IF_EXPR)))) {
  sb_append(sb, tmp_var);
  sb_append(sb, " = ");
  sb_append(sb, cc_emit_if_as_c_expr(stmt));
  sb_append(sb, ";");
} else { if ((is_last && (skind === NK_RETURN_STMT))) {
  let val = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  let val_code = "0"; if (typeof __tuff_this !== 'undefined') __tuff_this.val_code = val_code;
  if ((val !== 0)) {
  val_code = cc_emit_expr(val); if (typeof __tuff_this !== 'undefined') __tuff_this.val_code = val_code;
}
  sb_append(sb, tmp_var);
  sb_append(sb, " = ");
  sb_append(sb, val_code);
  sb_append(sb, ";");
} else {
  sb_append(sb, cc_emit_stmt(stmt));
  sb_append(sb, " ");
} } }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_block_to_assign = cc_emit_block_to_assign;

const __tuff_outer_for_cc_emit_block_as_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_block_as_expr(block_node) {
  let __tuff_this = { block_node: block_node, this: __tuff_outer_for_cc_emit_block_as_expr };
  let tmp = cc_next_temp("blk"); if (typeof __tuff_this !== 'undefined') __tuff_this.tmp = tmp;
  let inner = cc_emit_block_to_assign(block_node, tmp); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "({ int64_t "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(tmp); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, tmp) : str_concat(__recv, tmp); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = 0; "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = 0; ") : str_concat(__recv, " = 0; "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(tmp); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, tmp) : str_concat(__recv, tmp); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; })"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; })") : str_concat(__recv, "; })"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_block_as_expr = cc_emit_block_as_expr;

const __tuff_outer_for_cc_emit_if_as_c_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_if_as_c_expr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_cc_emit_if_as_c_expr };
  let cond = cc_emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let then_b = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.then_b = then_b;
  let else_b = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.else_b = else_b;
  let tmp = cc_next_temp("ifexpr"); if (typeof __tuff_this !== 'undefined') __tuff_this.tmp = tmp;
  let then_body = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.then_body = then_body;
  if ((node_kind(then_b) === NK_BLOCK)) {
  then_body = cc_emit_block_to_assign(then_b, tmp); if (typeof __tuff_this !== 'undefined') __tuff_this.then_body = then_body;
} else { if (((node_kind(then_b) === NK_IF_STMT) || (node_kind(then_b) === NK_IF_EXPR))) {
  then_body = (() => { const __recv = (() => { const __recv = (() => { const __recv = tmp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_if_as_c_expr(then_b)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_if_as_c_expr(then_b)) : str_concat(__recv, cc_emit_if_as_c_expr(then_b)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.then_body = then_body;
} else {
  then_body = (() => { const __recv = (() => { const __recv = (() => { const __recv = tmp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_expr(then_b)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_expr(then_b)) : str_concat(__recv, cc_emit_expr(then_b)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.then_body = then_body;
} }
  let else_body = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.else_body = else_body;
  if ((else_b === 0)) {
  else_body = (() => { const __recv = tmp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = 0;"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = 0;") : str_concat(__recv, " = 0;"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.else_body = else_body;
} else { if ((node_kind(else_b) === NK_BLOCK)) {
  else_body = cc_emit_block_to_assign(else_b, tmp); if (typeof __tuff_this !== 'undefined') __tuff_this.else_body = else_body;
} else { if (((node_kind(else_b) === NK_IF_STMT) || (node_kind(else_b) === NK_IF_EXPR))) {
  else_body = (() => { const __recv = (() => { const __recv = (() => { const __recv = tmp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_if_as_c_expr(else_b)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_if_as_c_expr(else_b)) : str_concat(__recv, cc_emit_if_as_c_expr(else_b)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.else_body = else_body;
} else {
  else_body = (() => { const __recv = (() => { const __recv = (() => { const __recv = tmp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_expr(else_b)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_expr(else_b)) : str_concat(__recv, cc_emit_expr(else_b)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.else_body = else_body;
} } }
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "({ int64_t "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(tmp); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, tmp) : str_concat(__recv, tmp); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = 0; if ("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = 0; if (") : str_concat(__recv, " = 0; if ("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond) : str_concat(__recv, cond); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") { "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") { ") : str_concat(__recv, ") { "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(then_body); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, then_body) : str_concat(__recv, then_body); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" } else { "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " } else { ") : str_concat(__recv, " } else { "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(else_body); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, else_body) : str_concat(__recv, else_body); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" } "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " } ") : str_concat(__recv, " } "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(tmp); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, tmp) : str_concat(__recv, tmp); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; })"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; })") : str_concat(__recv, "; })"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_if_as_c_expr = cc_emit_if_as_c_expr;

const __tuff_outer_for_cc_escape_unicode_in_string = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_escape_unicode_in_string(raw) {
  let __tuff_this = { raw: raw, this: __tuff_outer_for_cc_escape_unicode_in_string };
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = raw; const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0000", "\\000"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0000", "\\000") : str_replace_all(__recv, "\\u0000", "\\000"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0001", "\\001"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0001", "\\001") : str_replace_all(__recv, "\\u0001", "\\001"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0002", "\\002"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0002", "\\002") : str_replace_all(__recv, "\\u0002", "\\002"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0003", "\\003"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0003", "\\003") : str_replace_all(__recv, "\\u0003", "\\003"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0004", "\\004"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0004", "\\004") : str_replace_all(__recv, "\\u0004", "\\004"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0005", "\\005"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0005", "\\005") : str_replace_all(__recv, "\\u0005", "\\005"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0006", "\\006"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0006", "\\006") : str_replace_all(__recv, "\\u0006", "\\006"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0007", "\\007"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0007", "\\007") : str_replace_all(__recv, "\\u0007", "\\007"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0008", "\\010"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0008", "\\010") : str_replace_all(__recv, "\\u0008", "\\010"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0009", "\\011"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0009", "\\011") : str_replace_all(__recv, "\\u0009", "\\011"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u000a", "\\012"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u000a", "\\012") : str_replace_all(__recv, "\\u000a", "\\012"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u000A", "\\012"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u000A", "\\012") : str_replace_all(__recv, "\\u000A", "\\012"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u000b", "\\013"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u000b", "\\013") : str_replace_all(__recv, "\\u000b", "\\013"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u000B", "\\013"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u000B", "\\013") : str_replace_all(__recv, "\\u000B", "\\013"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u000c", "\\014"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u000c", "\\014") : str_replace_all(__recv, "\\u000c", "\\014"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u000C", "\\014"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u000C", "\\014") : str_replace_all(__recv, "\\u000C", "\\014"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u000d", "\\015"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u000d", "\\015") : str_replace_all(__recv, "\\u000d", "\\015"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u000D", "\\015"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u000D", "\\015") : str_replace_all(__recv, "\\u000D", "\\015"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u000e", "\\016"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u000e", "\\016") : str_replace_all(__recv, "\\u000e", "\\016"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u000E", "\\016"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u000E", "\\016") : str_replace_all(__recv, "\\u000E", "\\016"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u000f", "\\017"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u000f", "\\017") : str_replace_all(__recv, "\\u000f", "\\017"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u000F", "\\017"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u000F", "\\017") : str_replace_all(__recv, "\\u000F", "\\017"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0010", "\\020"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0010", "\\020") : str_replace_all(__recv, "\\u0010", "\\020"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0011", "\\021"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0011", "\\021") : str_replace_all(__recv, "\\u0011", "\\021"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0012", "\\022"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0012", "\\022") : str_replace_all(__recv, "\\u0012", "\\022"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0013", "\\023"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0013", "\\023") : str_replace_all(__recv, "\\u0013", "\\023"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0014", "\\024"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0014", "\\024") : str_replace_all(__recv, "\\u0014", "\\024"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0015", "\\025"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0015", "\\025") : str_replace_all(__recv, "\\u0015", "\\025"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0016", "\\026"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0016", "\\026") : str_replace_all(__recv, "\\u0016", "\\026"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0017", "\\027"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0017", "\\027") : str_replace_all(__recv, "\\u0017", "\\027"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0018", "\\030"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0018", "\\030") : str_replace_all(__recv, "\\u0018", "\\030"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u0019", "\\031"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u0019", "\\031") : str_replace_all(__recv, "\\u0019", "\\031"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u001a", "\\032"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u001a", "\\032") : str_replace_all(__recv, "\\u001a", "\\032"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u001A", "\\032"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u001A", "\\032") : str_replace_all(__recv, "\\u001A", "\\032"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u001b", "\\033"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u001b", "\\033") : str_replace_all(__recv, "\\u001b", "\\033"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u001B", "\\033"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u001B", "\\033") : str_replace_all(__recv, "\\u001B", "\\033"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u001c", "\\034"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u001c", "\\034") : str_replace_all(__recv, "\\u001c", "\\034"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u001C", "\\034"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u001C", "\\034") : str_replace_all(__recv, "\\u001C", "\\034"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u001d", "\\035"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u001d", "\\035") : str_replace_all(__recv, "\\u001d", "\\035"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u001D", "\\035"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u001D", "\\035") : str_replace_all(__recv, "\\u001D", "\\035"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u001e", "\\036"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u001e", "\\036") : str_replace_all(__recv, "\\u001e", "\\036"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u001E", "\\036"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u001E", "\\036") : str_replace_all(__recv, "\\u001E", "\\036"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u001f", "\\037"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u001f", "\\037") : str_replace_all(__recv, "\\u001f", "\\037"); })(); const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\u001F", "\\037"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\u001F", "\\037") : str_replace_all(__recv, "\\u001F", "\\037"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_escape_unicode_in_string = cc_escape_unicode_in_string;

const __tuff_outer_for_cc_emit_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_expr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_cc_emit_expr };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_NUMBER_LIT)) {
  return get_interned_str(node_get_data1(n));
}
  if ((kind === NK_BOOL_LIT)) {
  if ((node_get_data1(n) === 1)) {
  return "1";
}
  return "0";
}
  if ((kind === NK_STRING_LIT)) {
  let s = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  let s_c = s; if (typeof __tuff_this !== 'undefined') __tuff_this.s_c = s_c;
  if ((cc_disable_unicode_escape !== 1)) {
  s_c = cc_escape_unicode_in_string(s); if (typeof __tuff_this !== 'undefined') __tuff_this.s_c = s_c;
}
  return (() => { const __recv = (() => { const __recv = "((int64_t)(intptr_t)\""; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(s_c); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, s_c) : str_concat(__recv, s_c); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\")") : str_concat(__recv, "\")"); })();
}
  if ((kind === NK_CHAR_LIT)) {
  let s = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  if (((() => { const __recv = s; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() === 1)) {
  return int_to_string(char_code(s));
}
  if ((() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("\\n"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "\\n") : str_eq(__recv, "\\n"); })()) {
  return "10";
}
  if ((() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("\\r"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "\\r") : str_eq(__recv, "\\r"); })()) {
  return "13";
}
  if ((() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("\\t"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "\\t") : str_eq(__recv, "\\t"); })()) {
  return "9";
}
  if ((() => { const __recv = s; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("\\0"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "\\0") : str_eq(__recv, "\\0"); })()) {
  return "0";
}
  return "0";
}
  if ((kind === NK_IDENTIFIER)) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = cc_enum_variant_consts; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  return (() => { const __recv = cc_enum_variant_consts; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })();
}
  return cc_to_name(name);
}
  if ((kind === NK_UNARY_EXPR)) {
  let op = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&") : str_eq(__recv, "&"); })() || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&mut"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&mut") : str_eq(__recv, "&mut"); })())) {
  return cc_emit_expr(node_get_data2(n));
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, op) : str_concat(__recv, op); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_expr(node_get_data2(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_expr(node_get_data2(n))) : str_concat(__recv, cc_emit_expr(node_get_data2(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  if ((kind === NK_BINARY_EXPR)) {
  let op = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let left = cc_emit_expr(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  let right = cc_emit_expr(node_get_data3(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(left); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, left) : str_concat(__recv, left); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, op) : str_concat(__recv, op); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, right) : str_concat(__recv, right); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  if ((kind === NK_CALL_EXPR)) {
  let callee_node = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.callee_node = callee_node;
  if ((node_kind(callee_node) === NK_IDENTIFIER)) {
  let callee_name = get_interned_str(node_get_data1(callee_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.callee_name = callee_name;
  if ((() => { const __recv = callee_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("drop"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "drop") : str_eq(__recv, "drop"); })()) {
  return "0";
}
  if ((() => { const __recv = callee_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("sizeOf"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "sizeOf") : str_eq(__recv, "sizeOf"); })()) {
  let type_args = node_get_data4(n); if (typeof __tuff_this !== 'undefined') __tuff_this.type_args = type_args;
  if (((() => { const __recv = type_args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() > 0)) {
  let ctype = cc_type_to_c((() => { const __recv = type_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.ctype = ctype;
  return (() => { const __recv = (() => { const __recv = "(int64_t)sizeof("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(ctype); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ctype) : str_concat(__recv, ctype); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  return "0";
}
  if ((() => { const __recv = callee_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("malloc"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "malloc") : str_eq(__recv, "malloc"); })()) {
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() >= 1)) {
  let bytes_str = cc_emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.bytes_str = bytes_str;
  let nbytes = cc_next_temp("malloc_nbytes"); if (typeof __tuff_this !== 'undefined') __tuff_this.nbytes = nbytes;
  let vec = cc_next_temp("malloc_vec"); if (typeof __tuff_this !== 'undefined') __tuff_this.vec = vec;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "({ size_t ");
  sb_append(sb, nbytes);
  sb_append(sb, " = (size_t)(");
  sb_append(sb, bytes_str);
  sb_append(sb, "); TuffVec* ");
  sb_append(sb, vec);
  sb_append(sb, " = (TuffVec*)malloc(sizeof(TuffVec)); if (");
  sb_append(sb, vec);
  sb_append(sb, ") { ");
  sb_append(sb, vec);
  sb_append(sb, "->data = (int64_t*)malloc(");
  sb_append(sb, nbytes);
  sb_append(sb, "); ");
  sb_append(sb, vec);
  sb_append(sb, "->init = 0; ");
  sb_append(sb, vec);
  sb_append(sb, "->length = ");
  sb_append(sb, nbytes);
  sb_append(sb, " / sizeof(int64_t); if (!");
  sb_append(sb, vec);
  sb_append(sb, "->data) { free(");
  sb_append(sb, vec);
  sb_append(sb, "); ");
  sb_append(sb, vec);
  sb_append(sb, " = NULL; } } ");
  sb_append(sb, vec);
  sb_append(sb, "; })");
  return sb_build(sb);
}
  return "0";
}
  if ((() => { const __recv = callee_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("realloc"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "realloc") : str_eq(__recv, "realloc"); })()) {
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() >= 2)) {
  let ptr_str = cc_emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.ptr_str = ptr_str;
  let bytes_str = cc_emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.bytes_str = bytes_str;
  let nbytes = cc_next_temp("realloc_nbytes"); if (typeof __tuff_this !== 'undefined') __tuff_this.nbytes = nbytes;
  let vec = cc_next_temp("realloc_vec"); if (typeof __tuff_this !== 'undefined') __tuff_this.vec = vec;
  let data = cc_next_temp("realloc_data"); if (typeof __tuff_this !== 'undefined') __tuff_this.data = data;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "({ size_t ");
  sb_append(sb, nbytes);
  sb_append(sb, " = (size_t)(");
  sb_append(sb, bytes_str);
  sb_append(sb, "); TuffVec* ");
  sb_append(sb, vec);
  sb_append(sb, " = (TuffVec*)(");
  sb_append(sb, ptr_str);
  sb_append(sb, "); if (");
  sb_append(sb, vec);
  sb_append(sb, ") { int64_t* ");
  sb_append(sb, data);
  sb_append(sb, " = (int64_t*)realloc(");
  sb_append(sb, vec);
  sb_append(sb, "->data, ");
  sb_append(sb, nbytes);
  sb_append(sb, "); if (");
  sb_append(sb, data);
  sb_append(sb, ") { ");
  sb_append(sb, vec);
  sb_append(sb, "->data = ");
  sb_append(sb, data);
  sb_append(sb, "; ");
  sb_append(sb, vec);
  sb_append(sb, "->length = ");
  sb_append(sb, nbytes);
  sb_append(sb, " / sizeof(int64_t); } else { ");
  sb_append(sb, vec);
  sb_append(sb, " = NULL; } } ");
  sb_append(sb, vec);
  sb_append(sb, "; })");
  return sb_build(sb);
}
  return "0";
}
  if ((() => { const __recv = callee_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("free"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "free") : str_eq(__recv, "free"); })()) {
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() >= 1)) {
  let ptr_str = cc_emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.ptr_str = ptr_str;
  let vec = cc_next_temp("free_vec"); if (typeof __tuff_this !== 'undefined') __tuff_this.vec = vec;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "({ TuffVec* "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(vec); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, vec) : str_concat(__recv, vec); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = (TuffVec*)("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = (TuffVec*)(") : str_concat(__recv, " = (TuffVec*)("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(ptr_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ptr_str) : str_concat(__recv, ptr_str); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("); if ("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "); if (") : str_concat(__recv, "); if ("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(vec); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, vec) : str_concat(__recv, vec); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") { free("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") { free(") : str_concat(__recv, ") { free("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(vec); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, vec) : str_concat(__recv, vec); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("->data); free("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "->data); free(") : str_concat(__recv, "->data); free("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(vec); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, vec) : str_concat(__recv, vec); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("); } 0; })"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "); } 0; })") : str_concat(__recv, "); } 0; })"); })();
}
  return "0";
}
}
  let callee = cc_emit_expr(callee_node); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let arg_strs = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.arg_strs = arg_strs;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let alen = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alen = alen;
  while ((i < alen)) {
  (() => { const __recv = arg_strs; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(cc_emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, cc_emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())) : vec_push(__recv, cc_emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let args_str = (() => { const __recv = arg_strs; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.args_str = args_str;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = callee; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(args_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, args_str) : str_concat(__recv, args_str); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  if ((kind === NK_MEMBER_EXPR)) {
  let obj_node = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.obj_node = obj_node;
  let prop = get_interned_str(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  if ((node_kind(obj_node) === NK_IDENTIFIER)) {
  let obj_name = get_interned_str(node_get_data1(obj_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.obj_name = obj_name;
  if ((() => { const __recv = cc_enum_names; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(obj_name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, obj_name) : set_has(__recv, obj_name); })()) {
  return (() => { const __recv = (() => { const __recv = obj_name; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "_") : str_concat(__recv, "_"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prop) : str_concat(__recv, prop); })();
}
  if (((() => { const __recv = cc_local_types; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(obj_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, obj_name) : map_has(__recv, obj_name); })() && (() => { const __recv = (() => { const __recv = cc_local_types; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(obj_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, obj_name) : map_get(__recv, obj_name); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("TuffVec*"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "TuffVec*") : str_eq(__recv, "TuffVec*"); })())) {
  return (() => { const __recv = (() => { const __recv = cc_to_name(obj_name); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("->"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "->") : str_concat(__recv, "->"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prop) : str_concat(__recv, prop); })();
}
}
  let obj = cc_emit_expr(obj_node); if (typeof __tuff_this !== 'undefined') __tuff_this.obj = obj;
  return (() => { const __recv = (() => { const __recv = obj; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prop) : str_concat(__recv, prop); })();
}
  if ((kind === NK_INDEX_EXPR)) {
  let target = cc_emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let idx = cc_emit_expr(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = target; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("["); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "[") : str_concat(__recv, "["); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, idx) : str_concat(__recv, idx); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "]") : str_concat(__recv, "]"); })();
}
  if ((kind === NK_IF_EXPR)) {
  let cond = cc_emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let then_b = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.then_b = then_b;
  let else_b = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.else_b = else_b;
  if (((node_kind(then_b) === NK_BLOCK) || ((else_b !== 0) && (node_kind(else_b) === NK_BLOCK)))) {
  return cc_emit_if_as_c_expr(n);
}
  let then_str = cc_emit_expr(then_b); if (typeof __tuff_this !== 'undefined') __tuff_this.then_str = then_str;
  let else_str = "0"; if (typeof __tuff_this !== 'undefined') __tuff_this.else_str = else_str;
  if ((else_b !== 0)) {
  else_str = cc_emit_expr(else_b); if (typeof __tuff_this !== 'undefined') __tuff_this.else_str = else_str;
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond) : str_concat(__recv, cond); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") ? ("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") ? (") : str_concat(__recv, ") ? ("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(then_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, then_str) : str_concat(__recv, then_str); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") : ("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") : (") : str_concat(__recv, ") : ("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(else_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, else_str) : str_concat(__recv, else_str); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("))"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "))") : str_concat(__recv, "))"); })();
}
  if ((kind === NK_UNWRAP_EXPR)) {
  return cc_emit_expr(node_get_data1(n));
}
  if ((kind === NK_MATCH_EXPR)) {
  return cc_emit_match_expr(n);
}
  if ((kind === NK_IS_EXPR)) {
  let inner = cc_emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let pat = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  if ((node_kind(pat) === NK_NAME_PAT)) {
  let name = get_interned_str(node_get_data1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  let alias = (() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias = alias;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(".__tag == "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".__tag == ") : str_concat(__recv, ".__tag == "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias) : str_concat(__recv, alias); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "_") : str_concat(__recv, "_"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  return (() => { const __recv = (() => { const __recv = "((int64_t)("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, inner) : str_concat(__recv, inner); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") != 0)"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") != 0)") : str_concat(__recv, ") != 0)"); })();
}
  return "0";
}
  if ((kind === NK_STRUCT_INIT)) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, name) : map_has(__recv, name); })()) {
  let alias = (() => { const __recv = cc_alias_by_variant; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, name) : map_get(__recv, name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias = alias;
  let fields = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "((");
  sb_append(sb, alias);
  sb_append(sb, "){ .__tag = ");
  sb_append(sb, alias);
  sb_append(sb, "_");
  sb_append(sb, name);
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let flen = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.flen = flen;
  while ((i < flen)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  let key = get_interned_str((() => { const __recv = field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  let val_str = cc_emit_expr((() => { const __recv = field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.val_str = val_str;
  sb_append(sb, ", .");
  sb_append(sb, key);
  sb_append(sb, " = ");
  sb_append(sb, val_str);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, " })");
  return sb_build(sb);
}
  return (() => { const __recv = (() => { const __recv = "/* struct_init("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") unsupported in C MVP */ 0"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") unsupported in C MVP */ 0") : str_concat(__recv, ") unsupported in C MVP */ 0"); })();
}
  if (((kind === NK_LAMBDA_EXPR) || (kind === NK_FN_EXPR))) {
  return "/* lambda/fn_expr unsupported in C */ 0";
}
  if ((kind === NK_TUPLE_EXPR)) {
  return "/* tuple_expr unsupported in C */ 0";
}
  return "/* unknown_expr */ 0";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_expr = cc_emit_expr;

const __tuff_outer_for_cc_emit_match_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_match_expr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_cc_emit_match_expr };
  let target_str = cc_emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.target_str = target_str;
  let cases = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let chain = "(tuff_panic(\"Non-exhaustive match\"), 0)"; if (typeof __tuff_this !== 'undefined') __tuff_this.chain = chain;
  let i = (len - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i >= 0)) {
  let case_node = (() => { const __recv = cases; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.case_node = case_node;
  let pat = (() => { const __recv = case_node; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  let body = (() => { const __recv = case_node; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let guard = cc_emit_pattern_guard(target_str, pat); if (typeof __tuff_this !== 'undefined') __tuff_this.guard = guard;
  let body_str = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.body_str = body_str;
  if ((node_kind(body) === NK_BLOCK)) {
  body_str = cc_emit_block_as_expr(body); if (typeof __tuff_this !== 'undefined') __tuff_this.body_str = body_str;
} else {
  if (((node_kind(pat) === NK_STRUCT_PAT) && (node_kind(body) === NK_IDENTIFIER))) {
  let pfields = node_get_data2(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.pfields = pfields;
  if (((pfields !== 0) && ((() => { const __recv = pfields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 1))) {
  let pfield = (() => { const __recv = pfields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pfield = pfield;
  let field_name = get_interned_str(pfield); if (typeof __tuff_this !== 'undefined') __tuff_this.field_name = field_name;
  let bind_name = field_name; if (typeof __tuff_this !== 'undefined') __tuff_this.bind_name = bind_name;
  let body_name = get_interned_str(node_get_data1(body)); if (typeof __tuff_this !== 'undefined') __tuff_this.body_name = body_name;
  if ((() => { const __recv = body_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(bind_name); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, bind_name) : str_eq(__recv, bind_name); })()) {
  body_str = (() => { const __recv = (() => { const __recv = target_str; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(field_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, field_name) : str_concat(__recv, field_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.body_str = body_str;
} else {
  body_str = cc_emit_expr(body); if (typeof __tuff_this !== 'undefined') __tuff_this.body_str = body_str;
}
} else {
  body_str = cc_emit_expr(body); if (typeof __tuff_this !== 'undefined') __tuff_this.body_str = body_str;
}
} else {
  body_str = cc_emit_expr(body); if (typeof __tuff_this !== 'undefined') __tuff_this.body_str = body_str;
}
}
  chain = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(guard); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, guard) : str_concat(__recv, guard); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") ? ("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") ? (") : str_concat(__recv, ") ? ("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(body_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, body_str) : str_concat(__recv, body_str); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") : ("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") : (") : str_concat(__recv, ") : ("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(chain); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, chain) : str_concat(__recv, chain); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("))"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "))") : str_concat(__recv, "))"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.chain = chain;
  i = (i - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return chain;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_match_expr = cc_emit_match_expr;

const __tuff_outer_for_cc_emit_block = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_block(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_cc_emit_block };
  let stmts = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "{\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  sb_append(sb, "  ");
  sb_append(sb, cc_emit_stmt((() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()));
  sb_append(sb, "\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "}");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_block = cc_emit_block;

const __tuff_outer_for_cc_emit_stmt_or_block = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_stmt_or_block(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_cc_emit_stmt_or_block };
  if ((node_kind(n) === NK_BLOCK)) {
  return cc_emit_block(n);
}
  return (() => { const __recv = (() => { const __recv = "{ "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_stmt(n)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_stmt(n)) : str_concat(__recv, cc_emit_stmt(n)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" }"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " }") : str_concat(__recv, " }"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_stmt_or_block = cc_emit_stmt_or_block;

const __tuff_outer_for_cc_emit_fn_block = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_fn_block(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_cc_emit_fn_block };
  cc_local_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_local_types = cc_local_types;
  let stmts = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return "{\n  return 0;\n}";
}
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "{\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let is_last = (i === (len - 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.is_last = is_last;
  let skind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.skind = skind;
  if ((is_last && (skind === NK_EXPR_STMT))) {
  sb_append(sb, "  return ");
  sb_append(sb, cc_emit_expr(node_get_data1(stmt)));
  sb_append(sb, ";\n");
} else { if ((is_last && ((skind === NK_IF_STMT) || (skind === NK_IF_EXPR)))) {
  sb_append(sb, "  return ");
  sb_append(sb, cc_emit_if_as_c_expr(stmt));
  sb_append(sb, ";\n");
} else {
  sb_append(sb, "  ");
  sb_append(sb, cc_emit_stmt(stmt));
  sb_append(sb, "\n");
} }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "}");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_fn_block = cc_emit_fn_block;

const __tuff_outer_for_cc_emit_param_list = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_param_list(params) {
  let __tuff_this = { params: params, this: __tuff_outer_for_cc_emit_param_list };
  let parts = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.parts = parts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let param = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  let pname = get_interned_str((() => { const __recv = param; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = (() => { const __recv = param; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  let ptype_str = cc_type_to_c(ptype); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype_str = ptype_str;
  (() => { const __recv = parts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = ptype_str; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, pname) : str_concat(__recv, pname); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = ptype_str; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, pname) : str_concat(__recv, pname); })()) : vec_push(__recv, (() => { const __recv = (() => { const __recv = ptype_str; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, pname) : str_concat(__recv, pname); })()); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = parts; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_param_list = cc_emit_param_list;

const __tuff_outer_for_cc_emit_prototype = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_prototype(ret_type, name, params) {
  let __tuff_this = { ret_type: ret_type, name: name, params: params, this: __tuff_outer_for_cc_emit_prototype };
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = ret_type; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params) : str_concat(__recv, params); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(");"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ");") : str_concat(__recv, ");"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_prototype = cc_emit_prototype;

const __tuff_outer_for_cc_emit_type_alias = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_type_alias(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_cc_emit_type_alias };
  let alias_name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.alias_name = alias_name;
  let aliased = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.aliased = aliased;
  if (((aliased === 0) || (node_kind(aliased) !== NK_UNION_TYPE))) {
  return (() => { const __recv = (() => { const __recv = "/* type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias_name) : str_concat(__recv, alias_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = ... */"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ... */") : str_concat(__recv, " = ... */"); })();
}
  if ((!(() => { const __recv = cc_union_alias_info; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, alias_name) : map_has(__recv, alias_name); })())) {
  return (() => { const __recv = (() => { const __recv = "/* union "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, alias_name) : str_concat(__recv, alias_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" not in context */"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " not in context */") : str_concat(__recv, " not in context */"); })();
}
  let variants = (() => { const __recv = cc_union_alias_info; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(alias_name); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, alias_name) : map_get(__recv, alias_name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.variants = variants;
  let vlen = (() => { const __recv = variants; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.vlen = vlen;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "typedef enum ");
  sb_append(sb, alias_name);
  sb_append(sb, "_Tag { ");
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < vlen)) {
  if ((j > 0)) {
  sb_append(sb, ", ");
}
  sb_append(sb, alias_name);
  sb_append(sb, "_");
  sb_append(sb, (() => { const __recv = variants; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })());
  sb_append(sb, " = ");
  sb_append(sb, int_to_string((j + 1)));
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  sb_append(sb, " } ");
  sb_append(sb, alias_name);
  sb_append(sb, "_Tag;\n");
  let all_field_names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.all_field_names = all_field_names;
  let seen_fields = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.seen_fields = seen_fields;
  j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < vlen)) {
  let v = (() => { const __recv = variants; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  if ((() => { const __recv = cc_struct_fields; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, v) : map_has(__recv, v); })()) {
  let fields = (() => { const __recv = cc_struct_fields; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, v) : map_get(__recv, v); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let m = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.m = m;
  let flen = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.flen = flen;
  while ((m < flen)) {
  let fname = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(m); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, m) : vec_get(__recv, m); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if ((!(() => { const __recv = seen_fields; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, fname) : set_has(__recv, fname); })())) {
  (() => { const __recv = seen_fields; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, fname) : set_add(__recv, fname); })();
  (() => { const __recv = all_field_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, fname) : vec_push(__recv, fname); })();
}
  m = (m + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.m = m;
}
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  sb_append(sb, "typedef struct ");
  sb_append(sb, alias_name);
  sb_append(sb, " { int32_t __tag;");
  let m = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.m = m;
  let flen = (() => { const __recv = all_field_names; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.flen = flen;
  while ((m < flen)) {
  sb_append(sb, " int64_t ");
  sb_append(sb, (() => { const __recv = all_field_names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(m); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, m) : vec_get(__recv, m); })());
  sb_append(sb, ";");
  m = (m + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.m = m;
}
  sb_append(sb, " } ");
  sb_append(sb, alias_name);
  sb_append(sb, ";\n");
  j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < vlen)) {
  let v = (() => { const __recv = variants; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  let vfields = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.vfields = vfields;
  if ((() => { const __recv = cc_struct_fields; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, v) : map_has(__recv, v); })()) {
  vfields = (() => { const __recv = cc_struct_fields; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, v) : map_get(__recv, v); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.vfields = vfields;
}
  let params_sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.params_sb = params_sb;
  let assigns_sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.assigns_sb = assigns_sb;
  let k = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  let klen = (() => { const __recv = vfields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.klen = klen;
  while ((k < klen)) {
  let fname = (() => { const __recv = vfields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, k) : vec_get(__recv, k); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if ((k > 0)) {
  sb_append(params_sb, ", ");
}
  sb_append(params_sb, "int64_t ");
  sb_append(params_sb, fname);
  sb_append(assigns_sb, " out.");
  sb_append(assigns_sb, fname);
  sb_append(assigns_sb, " = ");
  sb_append(assigns_sb, fname);
  sb_append(assigns_sb, ";");
  k = (k + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
}
  sb_append(sb, "static inline ");
  sb_append(sb, alias_name);
  sb_append(sb, " ");
  sb_append(sb, alias_name);
  sb_append(sb, "_make_");
  sb_append(sb, v);
  sb_append(sb, "(");
  sb_append(sb, sb_build(params_sb));
  sb_append(sb, ") { ");
  sb_append(sb, alias_name);
  sb_append(sb, " out = {0}; out.__tag = ");
  sb_append(sb, alias_name);
  sb_append(sb, "_");
  sb_append(sb, v);
  sb_append(sb, ";");
  sb_append(sb, sb_build(assigns_sb));
  sb_append(sb, " return out; }\n");
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_type_alias = cc_emit_type_alias;

const __tuff_outer_for_cc_is_extern_fn_decl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_is_extern_fn_decl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_cc_is_extern_fn_decl };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  return ((kind === NK_FN_DECL) && (node_get_data5(n) === 0));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_is_extern_fn_decl = cc_is_extern_fn_decl;

const __tuff_outer_for_cc_emit_stmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cc_emit_stmt(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_cc_emit_stmt };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LET_DECL)) {
  let name = cc_to_name(get_interned_str(node_get_data1(n))); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let val_node = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.val_node = val_node;
  let ctype = cc_infer_expr_ctype(val_node); if (typeof __tuff_this !== 'undefined') __tuff_this.ctype = ctype;
  let value = cc_emit_expr(val_node); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  (() => { const __recv = cc_local_types; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(name, ctype); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, name, ctype) : map_set(__recv, name, ctype); })();
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = ctype; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, value) : str_concat(__recv, value); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })();
}
  if ((kind === NK_IMPORT_DECL)) {
  return "/* import placeholder */";
}
  if ((kind === NK_EXPR_STMT)) {
  return (() => { const __recv = cc_emit_expr(node_get_data1(n)); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })();
}
  if ((kind === NK_ASSIGN_STMT)) {
  let target = cc_emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let value = cc_emit_expr(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = target; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, value) : str_concat(__recv, value); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })();
}
  if ((kind === NK_RETURN_STMT)) {
  let val = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  if ((val === 0)) {
  return "return 0;";
}
  return (() => { const __recv = (() => { const __recv = "return "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_expr(val)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_expr(val)) : str_concat(__recv, cc_emit_expr(val)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })();
}
  if (((kind === NK_IF_STMT) || (kind === NK_IF_EXPR))) {
  let cond = cc_emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let then_b = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.then_b = then_b;
  let else_b = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.else_b = else_b;
  let then_str = cc_emit_stmt_or_block(then_b); if (typeof __tuff_this !== 'undefined') __tuff_this.then_str = then_str;
  if ((else_b === 0)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "if ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond) : str_concat(__recv, cond); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") ") : str_concat(__recv, ") "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(then_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, then_str) : str_concat(__recv, then_str); })();
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "if ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond) : str_concat(__recv, cond); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") ") : str_concat(__recv, ") "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(then_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, then_str) : str_concat(__recv, then_str); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" else "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " else ") : str_concat(__recv, " else "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_stmt_or_block(else_b)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_stmt_or_block(else_b)) : str_concat(__recv, cc_emit_stmt_or_block(else_b)); })();
}
  if ((kind === NK_WHILE_STMT)) {
  let cond = cc_emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let body = cc_emit_block(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "while ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond) : str_concat(__recv, cond); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") ") : str_concat(__recv, ") "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(body); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, body) : str_concat(__recv, body); })();
}
  if ((kind === NK_FOR_STMT)) {
  let iter = cc_to_name(get_interned_str(node_get_data1(n))); if (typeof __tuff_this !== 'undefined') __tuff_this.iter = iter;
  let start = cc_emit_expr(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.start = start;
  let end = cc_emit_expr(node_get_data3(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
  let body = cc_emit_block(node_get_data4(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "for (int64_t "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(iter); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, iter) : str_concat(__recv, iter); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(start); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, start) : str_concat(__recv, start); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; ") : str_concat(__recv, "; "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(iter); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, iter) : str_concat(__recv, iter); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" < "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " < ") : str_concat(__recv, " < "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(end); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, end) : str_concat(__recv, end); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; ") : str_concat(__recv, "; "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(iter); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, iter) : str_concat(__recv, iter); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("++) "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "++) ") : str_concat(__recv, "++) "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(body); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, body) : str_concat(__recv, body); })();
}
  if ((kind === NK_LOOP_STMT)) {
  let body = cc_emit_block(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  return (() => { const __recv = "while (1) "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(body); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, body) : str_concat(__recv, body); })();
}
  if ((kind === NK_BREAK_STMT)) {
  return "break;";
}
  if ((kind === NK_CONTINUE_STMT)) {
  return "continue;";
}
  if ((kind === NK_INTO_STMT)) {
  return (() => { const __recv = (() => { const __recv = "/* into "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" */"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " */") : str_concat(__recv, " */"); })();
}
  if ((kind === NK_LIFETIME_STMT)) {
  return cc_emit_block(node_get_data2(n));
}
  if ((kind === NK_BLOCK)) {
  return cc_emit_block(n);
}
  if ((kind === NK_EXPECT_FN_DECL)) {
  return (() => { const __recv = (() => { const __recv = "/* expect fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" */"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " */") : str_concat(__recv, " */"); })();
}
  if (cc_is_extern_fn_decl(n)) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if (cc_is_stdlib_builtin(name)) {
  return (() => { const __recv = (() => { const __recv = "/* extern "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("  declared via C stdlib headers */"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "  declared via C stdlib headers */") : str_concat(__recv, "  declared via C stdlib headers */"); })();
}
  let params = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let ret_type = cc_type_to_c(node_get_data4(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.ret_type = ret_type;
  let params_str = cc_emit_param_list(params); if (typeof __tuff_this !== 'undefined') __tuff_this.params_str = params_str;
  return cc_emit_prototype((() => { const __recv = "extern "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(ret_type); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ret_type) : str_concat(__recv, ret_type); })(), name, params_str);
}
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  let source_name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.source_name = source_name;
  let name = cc_to_name(source_name); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let params = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let ret_type = cc_type_to_c(node_get_data4(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.ret_type = ret_type;
  let body = node_get_data5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let params_str = cc_emit_param_list(params); if (typeof __tuff_this !== 'undefined') __tuff_this.params_str = params_str;
  if ((body === 0)) {
  return (() => { const __recv = (() => { const __recv = "/* fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" has no body */"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " has no body */") : str_concat(__recv, " has no body */"); })();
}
  let prev_disable_escape = cc_disable_unicode_escape; if (typeof __tuff_this !== 'undefined') __tuff_this.prev_disable_escape = prev_disable_escape;
  if ((() => { const __recv = source_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("cc_escape_unicode_in_string"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "cc_escape_unicode_in_string") : str_eq(__recv, "cc_escape_unicode_in_string"); })()) {
  cc_disable_unicode_escape = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_disable_unicode_escape = cc_disable_unicode_escape;
}
  let emitted = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.emitted = emitted;
  if ((node_kind(body) === NK_BLOCK)) {
  emitted = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = ret_type; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") ") : str_concat(__recv, ") "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_fn_block(body)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_fn_block(body)) : str_concat(__recv, cc_emit_fn_block(body)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.emitted = emitted;
} else {
  emitted = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = ret_type; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(params_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, params_str) : str_concat(__recv, params_str); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") { return "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") { return ") : str_concat(__recv, ") { return "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_expr(body)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_expr(body)) : str_concat(__recv, cc_emit_expr(body)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; }"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; }") : str_concat(__recv, "; }"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.emitted = emitted;
}
  cc_disable_unicode_escape = prev_disable_escape; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_disable_unicode_escape = cc_disable_unicode_escape;
  return emitted;
}
  if ((kind === NK_STRUCT_DECL)) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = (() => { const __recv = "/* struct "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" lowered via union aliases when applicable */"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " lowered via union aliases when applicable */") : str_concat(__recv, " lowered via union aliases when applicable */"); })();
}
  if ((kind === NK_TYPE_ALIAS)) {
  return cc_emit_type_alias(n);
}
  if ((kind === NK_DEP_TYPE_ALIAS)) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = (() => { const __recv = "/* type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(...) = ... */"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(...) = ... */") : str_concat(__recv, "(...) = ... */"); })();
}
  if ((kind === NK_ENUM_DECL)) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let variants = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.variants = variants;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "typedef enum ");
  sb_append(sb, name);
  sb_append(sb, " { ");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let vlen = (() => { const __recv = variants; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.vlen = vlen;
  while ((i < vlen)) {
  if ((i > 0)) {
  sb_append(sb, ", ");
}
  sb_append(sb, name);
  sb_append(sb, "_");
  sb_append(sb, get_interned_str((() => { const __recv = variants; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()));
  sb_append(sb, " = ");
  sb_append(sb, int_to_string(i));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, " } ");
  sb_append(sb, name);
  sb_append(sb, ";");
  return sb_build(sb);
}
  if ((kind === NK_OBJECT_DECL)) {
  return (() => { const __recv = (() => { const __recv = "/* object "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" */"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " */") : str_concat(__recv, " */"); })();
}
  if ((kind === NK_CONTRACT_DECL)) {
  return (() => { const __recv = (() => { const __recv = "/* contract "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" */"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " */") : str_concat(__recv, " */"); })();
}
  if ((kind === NK_EXTERN_LET_DECL)) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = (() => { const __recv = "/* extern let "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" */"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " */") : str_concat(__recv, " */"); })();
}
  if ((kind === NK_EXTERN_TYPE_DECL)) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = (() => { const __recv = "/* extern type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" */"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " */") : str_concat(__recv, " */"); })();
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  return "";
}
  if ((kind === NK_STMT_LIST)) {
  return "";
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cc_emit_stmt = cc_emit_stmt;

const __tuff_outer_for_generate_c_impl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function generate_c_impl(typed, substrate) {
  let __tuff_this = { typed: typed, substrate: substrate, this: __tuff_outer_for_generate_c_impl };
  cc_temp_counter = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_temp_counter = cc_temp_counter;
  cc_disable_unicode_escape = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_disable_unicode_escape = cc_disable_unicode_escape;
  cc_enum_names = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_enum_names = cc_enum_names;
  cc_enum_variant_consts = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_enum_variant_consts = cc_enum_variant_consts;
  cc_struct_fields = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_struct_fields = cc_struct_fields;
  cc_alias_by_variant = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_alias_by_variant = cc_alias_by_variant;
  cc_union_alias_info = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_union_alias_info = cc_union_alias_info;
  cc_covered_extern_fns = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_covered_extern_fns = cc_covered_extern_fns;
  cc_local_types = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cc_local_types = cc_local_types;
  cc_inc_stdint = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdint = cc_inc_stdint;
  cc_inc_stddef = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stddef = cc_inc_stddef;
  cc_inc_stdio = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdio = cc_inc_stdio;
  cc_inc_stdlib = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdlib = cc_inc_stdlib;
  cc_inc_string = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_string = cc_inc_string;
  cc_inc_ctype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_ctype = cc_inc_ctype;
  cc_inc_errno = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_errno = cc_inc_errno;
  cc_inc_direct = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_direct = cc_inc_direct;
  cc_inc_sys_stat = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_sys_stat = cc_inc_sys_stat;
  cc_inc_sys_types = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_sys_types = cc_inc_sys_types;
  cc_init_context(typed);
  if ((!(() => { const __recv = substrate; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  cc_require_substrate_headers();
} else {
  cc_inc_stddef = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stddef = cc_inc_stddef;
  cc_inc_stdio = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdio = cc_inc_stdio;
  cc_inc_stdlib = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_stdlib = cc_inc_stdlib;
  cc_inc_string = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_string = cc_inc_string;
  cc_inc_ctype = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cc_inc_ctype = cc_inc_ctype;
}
  let stmts = node_get_data1(typed); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let cvi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cvi = cvi;
  while ((cvi < len)) {
  let cvn = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(cvi); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, cvi) : vec_get(__recv, cvi); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cvn = cvn;
  if (cc_is_extern_fn_decl(cvn)) {
  let fname = get_interned_str(node_get_data1(cvn)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if ((!(() => { const __recv = cc_covered_extern_fns; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, fname) : set_has(__recv, fname); })())) {
  panic_with_code("E_EXTERN_NO_SOURCE", (() => { const __recv = (() => { const __recv = "extern fn '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fname) : str_concat(__recv, fname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' has no source attribution"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' has no source attribution") : str_concat(__recv, "' has no source attribution"); })(), "C codegen requires each extern function to be attributed to a source via extern let destructuring.", (() => { const __recv = (() => { const __recv = "Add 'extern let { "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fname) : str_concat(__recv, fname); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" } = <header>;' before the declaration."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " } = <header>;' before the declaration.") : str_concat(__recv, " } = <header>;' before the declaration."); })());
}
}
  cvi = (cvi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cvi = cvi;
}
  let fn_nodes = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_nodes = fn_nodes;
  let init_rows = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.init_rows = init_rows;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  if ((cc_inc_stdint === 1)) {
  sb_append(sb, "#include <stdint.h>\n");
}
  if ((cc_inc_stddef === 1)) {
  sb_append(sb, "#include <stddef.h>\n");
}
  if ((cc_inc_stdio === 1)) {
  sb_append(sb, "#include <stdio.h>\n");
}
  if ((cc_inc_stdlib === 1)) {
  sb_append(sb, "#include <stdlib.h>\n");
}
  if ((cc_inc_string === 1)) {
  sb_append(sb, "#include <string.h>\n");
}
  if ((cc_inc_ctype === 1)) {
  sb_append(sb, "#include <ctype.h>\n");
}
  if ((cc_inc_errno === 1)) {
  sb_append(sb, "#include <errno.h>\n");
}
  sb_append(sb, "#ifdef _WIN32\n");
  if ((cc_inc_direct === 1)) {
  sb_append(sb, "#include <direct.h>\n");
}
  sb_append(sb, "#else\n");
  if ((cc_inc_sys_stat === 1)) {
  sb_append(sb, "#include <sys/stat.h>\n");
}
  if ((cc_inc_sys_types === 1)) {
  sb_append(sb, "#include <sys/types.h>\n");
}
  sb_append(sb, "#endif\n\n");
  sb_append(sb, "/* Generated by Tuff selfhost C backend. */\n\n");
  if ((!(() => { const __recv = substrate; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  sb_append(sb, "/* Embedded C substrate support */\n");
  sb_append(sb, substrate);
} else {
  sb_append(sb, cc_emit_minimal_runtime_prelude());
}
  sb_append(sb, "\n\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let node = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  let kind = node_kind(node); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  (() => { const __recv = fn_nodes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node) : vec_push(__recv, node); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((kind === NK_EXPECT_FN_DECL)) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((kind === NK_LET_DECL)) {
  let name = cc_to_name(get_interned_str(node_get_data1(node))); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  sb_append(sb, "int64_t ");
  sb_append(sb, name);
  sb_append(sb, ";\n");
  (() => { const __recv = init_rows; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = (() => { const __recv = name; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_expr(node_get_data3(node))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_expr(node_get_data3(node))) : str_concat(__recv, cc_emit_expr(node_get_data3(node))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = (() => { const __recv = name; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_expr(node_get_data3(node))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_expr(node_get_data3(node))) : str_concat(__recv, cc_emit_expr(node_get_data3(node))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })()) : vec_push(__recv, (() => { const __recv = (() => { const __recv = (() => { const __recv = name; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cc_emit_expr(node_get_data3(node))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cc_emit_expr(node_get_data3(node))) : str_concat(__recv, cc_emit_expr(node_get_data3(node))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ";") : str_concat(__recv, ";"); })()); })();
  sb_append(sb, "\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  let stmt_str = cc_emit_stmt(node); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt_str = stmt_str;
  if ((!(() => { const __recv = stmt_str; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  sb_append(sb, stmt_str);
  sb_append(sb, "\n");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "\n");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let fn_len = (() => { const __recv = fn_nodes; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_len = fn_len;
  while ((i < fn_len)) {
  let fn_node = (() => { const __recv = fn_nodes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_node = fn_node;
  let fn_name = cc_to_name(get_interned_str(node_get_data1(fn_node))); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_name = fn_name;
  let params_str = cc_emit_param_list(node_get_data3(fn_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.params_str = params_str;
  let ret_type = cc_type_to_c(node_get_data4(fn_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.ret_type = ret_type;
  sb_append(sb, cc_emit_prototype(ret_type, fn_name, params_str));
  sb_append(sb, "\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "\n");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < fn_len)) {
  let fn_node = (() => { const __recv = fn_nodes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_node = fn_node;
  sb_append(sb, cc_emit_stmt(fn_node));
  sb_append(sb, "\n\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "static void tuff_init_globals(void) {\n");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let init_len = (() => { const __recv = init_rows; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.init_len = init_len;
  while ((i < init_len)) {
  sb_append(sb, "  ");
  sb_append(sb, (() => { const __recv = init_rows; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })());
  sb_append(sb, "\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "}\n\n");
  sb_append(sb, "int main(void) {\n");
  sb_append(sb, "  tuff_init_globals();\n");
  sb_append(sb, "  return (int)tuff_main();\n");
  sb_append(sb, "}\n");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.generate_c_impl = generate_c_impl;

const __tuff_outer_for_selfhost_codegen_c_impl_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_codegen_c_impl_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_codegen_c_impl_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_codegen_c_impl_marker = selfhost_codegen_c_impl_marker;

const __tuff_outer_for_generate_c = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function generate_c(typed, substrate) {
  let __tuff_this = { typed: typed, substrate: substrate, this: __tuff_outer_for_generate_c };
  return generate_c_impl(typed, substrate);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.generate_c = generate_c;

const __tuff_outer_for_selfhost_codegen_c_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_codegen_c_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_codegen_c_marker };
  return selfhost_codegen_c_impl_marker();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_codegen_c_marker = selfhost_codegen_c_marker;

const __tuff_outer_for_ensure_trailing_newline = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ensure_trailing_newline(text) {
  let __tuff_this = { text: text, this: __tuff_outer_for_ensure_trailing_newline };
  if (((() => { const __recv = text; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() === 0)) {
  return "\n";
}
  if (((() => { const __recv = text; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(((() => { const __recv = text; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() - 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, ((() => { const __recv = text; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() - 1)) : str_char_at(__recv, ((() => { const __recv = text; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() - 1)); })() === 10)) {
  return text;
}
  return (() => { const __recv = text; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\n") : str_concat(__recv, "\n"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ensure_trailing_newline = ensure_trailing_newline;

const __tuff_outer_for_emit_tuff_from_typed_impl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_tuff_from_typed_impl(typed, source, trivia_payload) {
  let __tuff_this = { typed: typed, source: source, trivia_payload: trivia_payload, this: __tuff_outer_for_emit_tuff_from_typed_impl };
  let _typed_guard = typed; if (typeof __tuff_this !== 'undefined') __tuff_this._typed_guard = _typed_guard;
  let _trivia_guard = (() => { const __recv = trivia_payload; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this._trivia_guard = _trivia_guard;
  let _source_guard = (() => { const __recv = source; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this._source_guard = _source_guard;
  return ensure_trailing_newline(source);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_tuff_from_typed_impl = emit_tuff_from_typed_impl;

const __tuff_outer_for_selfhost_tuff_printer_impl_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_tuff_printer_impl_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_tuff_printer_impl_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_tuff_printer_impl_marker = selfhost_tuff_printer_impl_marker;

const __tuff_outer_for_emit_tuff_from_typed = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_tuff_from_typed(typed, source, trivia_payload) {
  let __tuff_this = { typed: typed, source: source, trivia_payload: trivia_payload, this: __tuff_outer_for_emit_tuff_from_typed };
  return emit_tuff_from_typed_impl(typed, source, trivia_payload);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_tuff_from_typed = emit_tuff_from_typed;

const __tuff_outer_for_selfhost_tuff_printer_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_tuff_printer_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_tuff_printer_marker };
  return selfhost_tuff_printer_impl_marker();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_tuff_printer_marker = selfhost_tuff_printer_marker;

let sm_paths = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sm_paths = sm_paths;

let sm_start_lines = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sm_start_lines = sm_start_lines;

const __tuff_outer_for_sourcemap_init = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function sourcemap_init() {
  let __tuff_this = { this: __tuff_outer_for_sourcemap_init };
  while (((() => { const __recv = sm_paths; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() > 0)) {
  (() => { const __recv = sm_paths; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  (() => { const __recv = sm_start_lines; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.sourcemap_init = sourcemap_init;

const __tuff_outer_for_sourcemap_add = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function sourcemap_add(path, start_line) {
  let __tuff_this = { path: path, start_line: start_line, this: __tuff_outer_for_sourcemap_add };
  (() => { const __recv = sm_paths; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(path); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, path) : vec_push(__recv, path); })();
  (() => { const __recv = sm_start_lines; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(start_line); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, start_line) : vec_push(__recv, start_line); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.sourcemap_add = sourcemap_add;

const __tuff_outer_for_sourcemap_count_lines = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function sourcemap_count_lines(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_sourcemap_count_lines };
  let count = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  let found = (() => { const __recv = s; const __prop = __recv?.["str_index_of"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.str_index_of; return __dyn ? __dyn(__recv.ref, "\n") : str_index_of(__recv, "\n"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  while ((found >= 0)) {
  count = (count + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  s = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((found + 1), (() => { const __recv = s; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (found + 1), (() => { const __recv = s; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()) : str_slice(__recv, (found + 1), (() => { const __recv = s; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  found = (() => { const __recv = s; const __prop = __recv?.["str_index_of"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.str_index_of; return __dyn ? __dyn(__recv.ref, "\n") : str_index_of(__recv, "\n"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
}
  return count;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.sourcemap_count_lines = sourcemap_count_lines;

const __tuff_outer_for_sourcemap_lookup = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function sourcemap_lookup(merged_line) {
  let __tuff_this = { merged_line: merged_line, this: __tuff_outer_for_sourcemap_lookup };
  let len = (() => { const __recv = sm_paths; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return "<unknown>";
}
  let best_i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.best_i = best_i;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  if (((() => { const __recv = sm_start_lines; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })() <= merged_line)) {
  best_i = i; if (typeof __tuff_this !== 'undefined') __tuff_this.best_i = best_i;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let path = (() => { const __recv = sm_paths; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(best_i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, best_i) : vec_get(__recv, best_i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.path = path;
  let start = (() => { const __recv = sm_start_lines; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(best_i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, best_i) : vec_get(__recv, best_i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.start = start;
  let local_line = ((merged_line - start) + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.local_line = local_line;
  return (() => { const __recv = (() => { const __recv = path; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":L"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":L") : str_concat(__recv, ":L"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(local_line)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(local_line)) : str_concat(__recv, int_to_string(local_line)); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.sourcemap_lookup = sourcemap_lookup;

const __tuff_outer_for_selfhost_module_sourcemap_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_module_sourcemap_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_module_sourcemap_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_module_sourcemap_marker = selfhost_module_sourcemap_marker;

let lint_issue_records = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.lint_issue_records = lint_issue_records;

const __tuff_outer_for_lint_issue_sep_field = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_issue_sep_field() {
  let __tuff_this = { this: __tuff_outer_for_lint_issue_sep_field };
  return "\u001f";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_issue_sep_field = lint_issue_sep_field;

const __tuff_outer_for_lint_issue_sep_record = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_issue_sep_record() {
  let __tuff_this = { this: __tuff_outer_for_lint_issue_sep_record };
  return "\u001e";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_issue_sep_record = lint_issue_sep_record;

const __tuff_outer_for_lint_issue_encode = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_issue_encode(code, message, reason, fix) {
  let __tuff_this = { code: code, message: message, reason: reason, fix: fix, this: __tuff_outer_for_lint_issue_encode };
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = code; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_issue_sep_field()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_issue_sep_field()) : str_concat(__recv, lint_issue_sep_field()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(message); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, message) : str_concat(__recv, message); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_issue_sep_field()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_issue_sep_field()) : str_concat(__recv, lint_issue_sep_field()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(reason); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, reason) : str_concat(__recv, reason); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_issue_sep_field()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_issue_sep_field()) : str_concat(__recv, lint_issue_sep_field()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fix); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fix) : str_concat(__recv, fix); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_issue_encode = lint_issue_encode;

const __tuff_outer_for_lint_add_issue = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_add_issue(code, message, reason, fix) {
  let __tuff_this = { code: code, message: message, reason: reason, fix: fix, this: __tuff_outer_for_lint_add_issue };
  (() => { const __recv = lint_issue_records; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(lint_issue_encode(code, message, reason, fix)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, lint_issue_encode(code, message, reason, fix)) : vec_push(__recv, lint_issue_encode(code, message, reason, fix)); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_add_issue = lint_add_issue;

const __tuff_outer_for_lint_reset = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_reset() {
  let __tuff_this = { this: __tuff_outer_for_lint_reset };
  (() => { const __recv = lint_issue_records; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_reset = lint_reset;

const __tuff_outer_for_lint_take_issues = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_take_issues() {
  let __tuff_this = { this: __tuff_outer_for_lint_take_issues };
  let s = (() => { const __recv = lint_issue_records; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(lint_issue_sep_record()); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, lint_issue_sep_record()) : vec_join(__recv, lint_issue_sep_record()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  (() => { const __recv = lint_issue_records; const __prop = __recv?.["vec_clear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_clear; return __dyn ? __dyn(__recv.ref) : vec_clear(__recv); })();
  return s;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_take_issues = lint_take_issues;

const __tuff_outer_for_lint_check_file_length = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_check_file_length(file_path, max_effective_lines) {
  let __tuff_this = { file_path: file_path, max_effective_lines: max_effective_lines, this: __tuff_outer_for_lint_check_file_length };
  let count = lint_effective_line_count(); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  if ((count > max_effective_lines)) {
  lint_add_issue("E_LINT_FILE_TOO_LONG", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "File '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(file_path); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, file_path) : str_concat(__recv, file_path); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' exceeds "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' exceeds ") : str_concat(__recv, "' exceeds "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(max_effective_lines)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(max_effective_lines)) : str_concat(__recv, int_to_string(max_effective_lines)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" effective lines ("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " effective lines (") : str_concat(__recv, " effective lines ("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(count)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(count)) : str_concat(__recv, int_to_string(count)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(), "Large files are harder to review and maintain; this file exceeds the maximum effective line budget after excluding comments and blank lines.", (() => { const __recv = (() => { const __recv = "Split this file into smaller modules so each file has at most "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(max_effective_lines)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(max_effective_lines)) : str_concat(__recv, int_to_string(max_effective_lines)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" non-comment, non-whitespace lines."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " non-comment, non-whitespace lines.") : str_concat(__recv, " non-comment, non-whitespace lines."); })());
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_check_file_length = lint_check_file_length;

const __tuff_outer_for_lint_check_current_file_length = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_check_current_file_length(file_path, max_effective_lines) {
  let __tuff_this = { file_path: file_path, max_effective_lines: max_effective_lines, this: __tuff_outer_for_lint_check_current_file_length };
  return lint_check_file_length(file_path, max_effective_lines);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_check_current_file_length = lint_check_current_file_length;

const __tuff_outer_for_lint_is_extern_fn_decl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_is_extern_fn_decl(stmt) {
  let __tuff_this = { stmt: stmt, this: __tuff_outer_for_lint_is_extern_fn_decl };
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  return ((kind === NK_FN_DECL) && (node_get_data5(stmt) === 0));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_is_extern_fn_decl = lint_is_extern_fn_decl;

const __tuff_outer_for_lint_mark_line = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_mark_line(lines, line) {
  let __tuff_this = { lines: lines, line: line, this: __tuff_outer_for_lint_mark_line };
  let key = int_to_string(line); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  if ((!(() => { const __recv = lines; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(key); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, key) : set_has(__recv, key); })())) {
  (() => { const __recv = lines; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(key); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, key) : set_add(__recv, key); })();
  return 1;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_mark_line = lint_mark_line;

const __tuff_outer_for_lint_collect_effective_lines_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_collect_effective_lines_expr(expr, lines) {
  let __tuff_this = { expr: expr, lines: lines, this: __tuff_outer_for_lint_collect_effective_lines_expr };
  if ((expr === 0)) {
  return 0;
}
  let added = lint_mark_line(lines, node_get_line(expr)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  let kind = node_kind(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if (((kind === NK_UNARY_EXPR) || (kind === NK_UNWRAP_EXPR))) {
  added = (added + lint_collect_effective_lines_expr(node_get_data2(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  if ((kind === NK_UNWRAP_EXPR)) {
  added = (added + lint_collect_effective_lines_expr(node_get_data1(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
}
  return added;
}
  if ((kind === NK_BINARY_EXPR)) {
  added = (added + lint_collect_effective_lines_expr(node_get_data2(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lint_collect_effective_lines_expr(node_get_data3(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_CALL_EXPR)) {
  added = (added + lint_collect_effective_lines_expr(node_get_data1(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  let args = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  added = (added + lint_collect_effective_lines_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return added;
}
  if ((kind === NK_MEMBER_EXPR)) {
  return (added + lint_collect_effective_lines_expr(node_get_data1(expr), lines));
}
  if ((kind === NK_INDEX_EXPR)) {
  added = (added + lint_collect_effective_lines_expr(node_get_data1(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lint_collect_effective_lines_expr(node_get_data2(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_STRUCT_INIT)) {
  let fields = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  added = (added + lint_collect_effective_lines_expr((() => { const __recv = field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return added;
}
  if ((kind === NK_IF_EXPR)) {
  added = (added + lint_collect_effective_lines_expr(node_get_data1(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lint_collect_effective_lines_stmt(node_get_data2(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  if ((node_get_data3(expr) !== 0)) {
  added = (added + lint_collect_effective_lines_stmt(node_get_data3(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
}
  return added;
}
  if ((kind === NK_MATCH_EXPR)) {
  added = (added + lint_collect_effective_lines_expr(node_get_data1(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  let cases = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = cases; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let c = (() => { const __recv = cases; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.c = c;
  added = (added + lint_collect_effective_lines_stmt((() => { const __recv = c; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return added;
}
  if ((kind === NK_IS_EXPR)) {
  return (added + lint_collect_effective_lines_expr(node_get_data1(expr), lines));
}
  if ((kind === NK_FN_EXPR)) {
  return (added + lint_collect_effective_lines_stmt(node_get_data5(expr), lines));
}
  if ((kind === NK_LAMBDA_EXPR)) {
  return (added + lint_collect_effective_lines_stmt(node_get_data2(expr), lines));
}
  if ((kind === NK_TUPLE_EXPR)) {
  let items = node_get_data1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = items; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  added = (added + lint_collect_effective_lines_expr((() => { const __recv = items; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return added;
}
  return added;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_collect_effective_lines_expr = lint_collect_effective_lines_expr;

const __tuff_outer_for_lint_collect_effective_lines_stmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_collect_effective_lines_stmt(stmt, lines) {
  let __tuff_this = { stmt: stmt, lines: lines, this: __tuff_outer_for_lint_collect_effective_lines_stmt };
  if ((stmt === 0)) {
  return 0;
}
  let added = lint_mark_line(lines, node_get_line(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LET_DECL)) {
  added = (added + lint_collect_effective_lines_expr(node_get_data2(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lint_collect_effective_lines_expr(node_get_data3(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_BLOCK)) {
  let stmts = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  added = (added + lint_collect_effective_lines_stmt((() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return added;
}
  if ((kind === NK_EXPR_STMT)) {
  return (added + lint_collect_effective_lines_expr(node_get_data1(stmt), lines));
}
  if ((kind === NK_ASSIGN_STMT)) {
  added = (added + lint_collect_effective_lines_expr(node_get_data1(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lint_collect_effective_lines_expr(node_get_data2(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_RETURN_STMT)) {
  return (added + lint_collect_effective_lines_expr(node_get_data1(stmt), lines));
}
  if ((kind === NK_IF_STMT)) {
  added = (added + lint_collect_effective_lines_expr(node_get_data1(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lint_collect_effective_lines_stmt(node_get_data2(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lint_collect_effective_lines_stmt(node_get_data3(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_FOR_STMT)) {
  added = (added + lint_collect_effective_lines_expr(node_get_data2(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lint_collect_effective_lines_expr(node_get_data3(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lint_collect_effective_lines_stmt(node_get_data4(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_WHILE_STMT)) {
  added = (added + lint_collect_effective_lines_expr(node_get_data1(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lint_collect_effective_lines_stmt(node_get_data2(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_LOOP_STMT)) {
  return (added + lint_collect_effective_lines_stmt(node_get_data1(stmt), lines));
}
  if ((kind === NK_LIFETIME_STMT)) {
  return (added + lint_collect_effective_lines_stmt(node_get_data2(stmt), lines));
}
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  added = (added + lint_collect_effective_lines_expr(node_get_data4(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lint_collect_effective_lines_stmt(node_get_data5(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_STMT_LIST)) {
  let items = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = items; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  added = (added + lint_collect_effective_lines_stmt((() => { const __recv = items; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return added;
}
  if ((((((((kind === NK_INTO_STMT) || (kind === NK_BREAK_STMT)) || (kind === NK_CONTINUE_STMT)) || (kind === NK_EXTERN_IMPORT_DECL)) || lint_is_extern_fn_decl(stmt)) || (kind === NK_EXTERN_LET_DECL)) || (kind === NK_EXTERN_TYPE_DECL))) {
  return added;
}
  return (added + lint_collect_effective_lines_expr(stmt, lines));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_collect_effective_lines_stmt = lint_collect_effective_lines_stmt;

const __tuff_outer_for_lint_check_function_length = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_check_function_length(stmt, max_effective_lines) {
  let __tuff_this = { stmt: stmt, max_effective_lines: max_effective_lines, this: __tuff_outer_for_lint_check_function_length };
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((!(((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL)))) {
  return 0;
}
  let body = node_get_data5(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if ((body === 0)) {
  return 0;
}
  let lines = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.lines = lines;
  let count = lint_mark_line(lines, node_get_line(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  count = (count + lint_collect_effective_lines_stmt(body, lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  if ((count >= max_effective_lines)) {
  let fn_name = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.fn_name = fn_name;
  lint_add_issue("E_LINT_FUNCTION_TOO_LONG", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Function '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fn_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fn_name) : str_concat(__recv, fn_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' has "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' has ") : str_concat(__recv, "' has "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(max_effective_lines)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(max_effective_lines)) : str_concat(__recv, int_to_string(max_effective_lines)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" or more effective lines ("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " or more effective lines (") : str_concat(__recv, " or more effective lines ("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(count)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(count)) : str_concat(__recv, int_to_string(count)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(), (() => { const __recv = (() => { const __recv = "This function has at least "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(max_effective_lines)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(max_effective_lines)) : str_concat(__recv, int_to_string(max_effective_lines)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" non-comment, non-whitespace lines, which increases complexity and reduces readability."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " non-comment, non-whitespace lines, which increases complexity and reduces readability.") : str_concat(__recv, " non-comment, non-whitespace lines, which increases complexity and reduces readability."); })(), (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Split function '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(fn_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, fn_name) : str_concat(__recv, fn_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' into smaller helper functions so each function stays below "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' into smaller helper functions so each function stays below ") : str_concat(__recv, "' into smaller helper functions so each function stays below "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(max_effective_lines)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(max_effective_lines)) : str_concat(__recv, int_to_string(max_effective_lines)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" effective lines."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " effective lines.") : str_concat(__recv, " effective lines."); })());
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_check_function_length = lint_check_function_length;

const __tuff_outer_for_lint_collect_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_collect_expr(expr, receiver_extern_fns, reads) {
  let __tuff_this = { expr: expr, receiver_extern_fns: receiver_extern_fns, reads: reads, this: __tuff_outer_for_lint_collect_expr };
  if ((expr === 0)) {
  return 0;
}
  let kind = node_kind(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_IDENTIFIER)) {
  (() => { const __recv = reads; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(expr))); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(expr))) : set_add(__recv, get_interned_str(node_get_data1(expr))); })();
  return 0;
}
  if (((kind === NK_UNARY_EXPR) || (kind === NK_UNWRAP_EXPR))) {
  lint_collect_expr(node_get_data2(expr), receiver_extern_fns, reads);
  if ((kind === NK_UNWRAP_EXPR)) {
  lint_collect_expr(node_get_data1(expr), receiver_extern_fns, reads);
}
  return 0;
}
  if ((kind === NK_BINARY_EXPR)) {
  lint_collect_expr(node_get_data2(expr), receiver_extern_fns, reads);
  lint_collect_expr(node_get_data3(expr), receiver_extern_fns, reads);
  return 0;
}
  if ((kind === NK_CALL_EXPR)) {
  let callee = node_get_data1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  let args = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((node_kind(callee) === NK_IDENTIFIER) && ((() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() > 0))) {
  let name = get_interned_str(node_get_data1(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let call_style = node_get_data3(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.call_style = call_style;
  if (((() => { const __recv = receiver_extern_fns; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })() && (call_style !== 1))) {
  lint_add_issue("E_LINT_PREFER_RECEIVER_CALL", (() => { const __recv = (() => { const __recv = "Prefer receiver-call syntax for '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "This extern function declares a receiver as its first 'this' parameter, so calling it as a free function is less idiomatic.", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Rewrite '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(x, ...)' as 'x."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(x, ...)' as 'x.") : str_concat(__recv, "(x, ...)' as 'x."); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(...)'."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(...)'.") : str_concat(__recv, "(...)'."); })());
}
}
  lint_collect_expr(callee, receiver_extern_fns, reads);
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  lint_collect_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), receiver_extern_fns, reads);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_MEMBER_EXPR)) {
  lint_collect_expr(node_get_data1(expr), receiver_extern_fns, reads);
  return 0;
}
  if ((kind === NK_INDEX_EXPR)) {
  lint_collect_expr(node_get_data1(expr), receiver_extern_fns, reads);
  lint_collect_expr(node_get_data2(expr), receiver_extern_fns, reads);
  return 0;
}
  if ((kind === NK_STRUCT_INIT)) {
  let fields = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  lint_collect_expr((() => { const __recv = field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), receiver_extern_fns, reads);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_IF_EXPR)) {
  let cond = node_get_data1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  if ((node_kind(cond) === NK_BOOL_LIT)) {
  lint_add_issue("E_LINT_CONSTANT_CONDITION", "Constant condition in if-expression/statement", "A constant condition means one branch is unreachable, which usually indicates dead or unintended code.", "Use a non-constant condition, or simplify by keeping only the branch that will execute.");
}
  lint_collect_expr(cond, receiver_extern_fns, reads);
  lint_collect_stmt(node_get_data2(expr), receiver_extern_fns, reads, set_new(), vec_new());
  if ((node_get_data3(expr) !== 0)) {
  lint_collect_stmt(node_get_data3(expr), receiver_extern_fns, reads, set_new(), vec_new());
}
  return 0;
}
  if ((kind === NK_MATCH_EXPR)) {
  lint_collect_expr(node_get_data1(expr), receiver_extern_fns, reads);
  let cases = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let c = (() => { const __recv = cases; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.c = c;
  lint_collect_stmt((() => { const __recv = c; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), receiver_extern_fns, reads, set_new(), vec_new());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_IS_EXPR)) {
  lint_collect_expr(node_get_data1(expr), receiver_extern_fns, reads);
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_collect_expr = lint_collect_expr;

const __tuff_outer_for_lint_collect_stmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_collect_stmt(stmt, receiver_extern_fns, reads, declared_set, declared_names) {
  let __tuff_this = { stmt: stmt, receiver_extern_fns: receiver_extern_fns, reads: reads, declared_set: declared_set, declared_names: declared_names, this: __tuff_outer_for_lint_collect_stmt };
  if ((stmt === 0)) {
  return 0;
}
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LET_DECL)) {
  let name = get_interned_str(node_get_data1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((!(() => { const __recv = declared_set; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })())) {
  (() => { const __recv = declared_set; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, name) : set_add(__recv, name); })();
  (() => { const __recv = declared_names; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, name) : vec_push(__recv, name); })();
}
  lint_collect_expr(node_get_data3(stmt), receiver_extern_fns, reads);
  return 0;
}
  if ((kind === NK_BLOCK)) {
  let stmts = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  if (((() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 0)) {
  lint_add_issue("E_LINT_EMPTY_BLOCK", "Empty block has no effect", "An empty block executes no statements, which is often accidental and can hide incomplete logic.", "Add the intended statements to the block, or remove the block if it is unnecessary.");
}
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  lint_collect_stmt((() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), receiver_extern_fns, reads, declared_set, declared_names);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_EXPR_STMT)) {
  lint_collect_expr(node_get_data1(stmt), receiver_extern_fns, reads);
  return 0;
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  return 0;
}
  if ((kind === NK_ASSIGN_STMT)) {
  lint_collect_expr(node_get_data1(stmt), receiver_extern_fns, reads);
  lint_collect_expr(node_get_data2(stmt), receiver_extern_fns, reads);
  return 0;
}
  if ((kind === NK_RETURN_STMT)) {
  lint_collect_expr(node_get_data1(stmt), receiver_extern_fns, reads);
  return 0;
}
  if ((kind === NK_IF_STMT)) {
  let cond = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  if ((node_kind(cond) === NK_BOOL_LIT)) {
  lint_add_issue("E_LINT_CONSTANT_CONDITION", "Constant condition in if-expression/statement", "A constant condition means one branch is unreachable, which usually indicates dead or unintended code.", "Use a non-constant condition, or simplify by keeping only the branch that will execute.");
}
  lint_collect_expr(cond, receiver_extern_fns, reads);
  lint_collect_stmt(node_get_data2(stmt), receiver_extern_fns, reads, declared_set, declared_names);
  lint_collect_stmt(node_get_data3(stmt), receiver_extern_fns, reads, declared_set, declared_names);
  return 0;
}
  if ((kind === NK_FOR_STMT)) {
  lint_collect_expr(node_get_data2(stmt), receiver_extern_fns, reads);
  lint_collect_expr(node_get_data3(stmt), receiver_extern_fns, reads);
  lint_collect_stmt(node_get_data4(stmt), receiver_extern_fns, reads, declared_set, declared_names);
  return 0;
}
  if ((kind === NK_WHILE_STMT)) {
  lint_collect_expr(node_get_data1(stmt), receiver_extern_fns, reads);
  lint_collect_stmt(node_get_data2(stmt), receiver_extern_fns, reads, declared_set, declared_names);
  return 0;
}
  if (((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL))) {
  lint_collect_stmt(node_get_data5(stmt), receiver_extern_fns, reads, declared_set, declared_names);
  return 0;
}
  lint_collect_expr(stmt, receiver_extern_fns, reads);
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_collect_stmt = lint_collect_stmt;

const __tuff_outer_for_lint_add_circular_import_issue = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_add_circular_import_issue(cycle_text) {
  let __tuff_this = { cycle_text: cycle_text, this: __tuff_outer_for_lint_add_circular_import_issue };
  return lint_add_issue("E_LINT_CIRCULAR_IMPORT", (() => { const __recv = "Circular import detected: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cycle_text); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cycle_text) : str_concat(__recv, cycle_text); })(), "Circular dependencies between modules make dependency flow harder to understand and maintain.", "Refactor shared declarations into a third module and have each side import that shared module instead.");
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_add_circular_import_issue = lint_add_circular_import_issue;

const __tuff_outer_for_lint_astdup_kind_name = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_kind_name(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_lint_astdup_kind_name };
  if ((kind === NK_BLOCK)) {
  return "block";
}
  if ((kind === NK_IF_STMT)) {
  return "if-stmt";
}
  if ((kind === NK_WHILE_STMT)) {
  return "while-stmt";
}
  if ((kind === NK_FOR_STMT)) {
  return "for-stmt";
}
  if ((kind === NK_LOOP_STMT)) {
  return "loop-stmt";
}
  if ((kind === NK_ASSIGN_STMT)) {
  return "assign-stmt";
}
  if ((kind === NK_RETURN_STMT)) {
  return "return-stmt";
}
  if ((kind === NK_BINARY_EXPR)) {
  return "binary-expr";
}
  if ((kind === NK_CALL_EXPR)) {
  return "call-expr";
}
  if ((kind === NK_IF_EXPR)) {
  return "if-expr";
}
  if ((kind === NK_MATCH_EXPR)) {
  return "match-expr";
}
  if ((kind === NK_STRUCT_INIT)) {
  return "struct-init";
}
  if ((kind === NK_LAMBDA_EXPR)) {
  return "lambda-expr";
}
  return (() => { const __recv = "node-kind-"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(kind)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(kind)) : str_concat(__recv, int_to_string(kind)); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_kind_name = lint_astdup_kind_name;

const __tuff_outer_for_lint_astdup_loc = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_loc(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_lint_astdup_loc };
  return (() => { const __recv = (() => { const __recv = sourcemap_lookup(node_get_line(n)); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_col(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_col(n))) : str_concat(__recv, int_to_string(node_get_col(n))); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_loc = lint_astdup_loc;

const __tuff_outer_for_lint_astdup_preview = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_preview(fp) {
  let __tuff_this = { fp: fp, this: __tuff_outer_for_lint_astdup_preview };
  let max_len = 120; if (typeof __tuff_this !== 'undefined') __tuff_this.max_len = max_len;
  if (((() => { const __recv = fp; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() <= max_len)) {
  return fp;
}
  return (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, max_len); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, max_len) : str_slice(__recv, 0, max_len); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("..."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "...") : str_concat(__recv, "..."); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_preview = lint_astdup_preview;

const __tuff_outer_for_lint_astdup_reportable_kind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_reportable_kind(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_lint_astdup_reportable_kind };
  return (((((((((((((((((((((kind === NK_BLOCK) || (kind === NK_IF_STMT)) || (kind === NK_WHILE_STMT)) || (kind === NK_FOR_STMT)) || (kind === NK_LOOP_STMT)) || (kind === NK_ASSIGN_STMT)) || (kind === NK_EXPR_STMT)) || (kind === NK_RETURN_STMT)) || (kind === NK_BINARY_EXPR)) || (kind === NK_UNARY_EXPR)) || (kind === NK_CALL_EXPR)) || (kind === NK_MEMBER_EXPR)) || (kind === NK_INDEX_EXPR)) || (kind === NK_STRUCT_INIT)) || (kind === NK_IF_EXPR)) || (kind === NK_MATCH_EXPR)) || (kind === NK_IS_EXPR)) || (kind === NK_UNWRAP_EXPR)) || (kind === NK_TUPLE_EXPR)) || (kind === NK_LAMBDA_EXPR)) || (kind === NK_FN_EXPR));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_reportable_kind = lint_astdup_reportable_kind;

const __tuff_outer_for_lint_astdup_vec_fp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_vec_fp(vec_nodes, fp_cache, size_cache, seen_nodes) {
  let __tuff_this = { vec_nodes: vec_nodes, fp_cache: fp_cache, size_cache: size_cache, seen_nodes: seen_nodes, this: __tuff_outer_for_lint_astdup_vec_fp };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let acc = "["; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  while ((i < (() => { const __recv = vec_nodes; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp((() => { const __recv = vec_nodes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp((() => { const __recv = vec_nodes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp((() => { const __recv = vec_nodes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), fp_cache, size_cache, seen_nodes)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((i + 1) < (() => { const __recv = vec_nodes; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ",") : str_concat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "]") : str_concat(__recv, "]"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_vec_fp = lint_astdup_vec_fp;

const __tuff_outer_for_lint_astdup_vec_size = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_vec_size(vec_nodes, size_cache) {
  let __tuff_this = { vec_nodes: vec_nodes, size_cache: size_cache, this: __tuff_outer_for_lint_astdup_vec_size };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  while ((i < (() => { const __recv = vec_nodes; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let node = (() => { const __recv = vec_nodes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (((node !== 0) && (() => { const __recv = size_cache; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(node); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, node) : map_has(__recv, node); })())) {
  total = (total + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node) : map_get(__recv, node); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return total;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_vec_size = lint_astdup_vec_size;

const __tuff_outer_for_lint_astdup_params_fp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_params_fp(params, fp_cache, size_cache, seen_nodes) {
  let __tuff_this = { params: params, fp_cache: fp_cache, size_cache: size_cache, seen_nodes: seen_nodes, this: __tuff_outer_for_lint_astdup_params_fp };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let acc = "("; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  while ((i < (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let p = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let ptype = (() => { const __recv = p; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  acc = (() => { const __recv = (() => { const __recv = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("{p:ID:t:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "{p:ID:t:") : str_concat(__recv, "{p:ID:t:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(ptype, fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(ptype, fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(ptype, fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "}") : str_concat(__recv, "}"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((i + 1) < (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ",") : str_concat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_params_fp = lint_astdup_params_fp;

const __tuff_outer_for_lint_astdup_params_size = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_params_size(params, size_cache) {
  let __tuff_this = { params: params, size_cache: size_cache, this: __tuff_outer_for_lint_astdup_params_size };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  while ((i < (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let p = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let ptype = (() => { const __recv = p; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (((ptype !== 0) && (() => { const __recv = size_cache; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, ptype) : map_has(__recv, ptype); })())) {
  total = (total + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, ptype) : map_get(__recv, ptype); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return total;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_params_size = lint_astdup_params_size;

const __tuff_outer_for_lint_astdup_named_type_fields_fp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_named_type_fields_fp(fields, fp_cache, size_cache, seen_nodes) {
  let __tuff_this = { fields: fields, fp_cache: fp_cache, size_cache: size_cache, seen_nodes: seen_nodes, this: __tuff_outer_for_lint_astdup_named_type_fields_fp };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let acc = "{"; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  while ((i < (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  acc = (() => { const __recv = (() => { const __recv = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("{n:ID:t:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "{n:ID:t:") : str_concat(__recv, "{n:ID:t:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp((() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp((() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp((() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "}") : str_concat(__recv, "}"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((i + 1) < (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ",") : str_concat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "}") : str_concat(__recv, "}"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_named_type_fields_fp = lint_astdup_named_type_fields_fp;

const __tuff_outer_for_lint_astdup_named_type_fields_size = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_named_type_fields_size(fields, size_cache) {
  let __tuff_this = { fields: fields, size_cache: size_cache, this: __tuff_outer_for_lint_astdup_named_type_fields_size };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  while ((i < (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  let t = (() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  if (((t !== 0) && (() => { const __recv = size_cache; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(t); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, t) : map_has(__recv, t); })())) {
  total = (total + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(t); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, t) : map_get(__recv, t); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return total;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_named_type_fields_size = lint_astdup_named_type_fields_size;

const __tuff_outer_for_lint_astdup_struct_init_fields_fp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_struct_init_fields_fp(fields, fp_cache, size_cache, seen_nodes) {
  let __tuff_this = { fields: fields, fp_cache: fp_cache, size_cache: size_cache, seen_nodes: seen_nodes, this: __tuff_outer_for_lint_astdup_struct_init_fields_fp };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let acc = "{"; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  while ((i < (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  acc = (() => { const __recv = (() => { const __recv = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("{n:ID:v:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "{n:ID:v:") : str_concat(__recv, "{n:ID:v:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp((() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp((() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp((() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "}") : str_concat(__recv, "}"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((i + 1) < (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ",") : str_concat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "}") : str_concat(__recv, "}"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_struct_init_fields_fp = lint_astdup_struct_init_fields_fp;

const __tuff_outer_for_lint_astdup_struct_init_fields_size = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_struct_init_fields_size(fields, size_cache) {
  let __tuff_this = { fields: fields, size_cache: size_cache, this: __tuff_outer_for_lint_astdup_struct_init_fields_size };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  while ((i < (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  let v = (() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  if (((v !== 0) && (() => { const __recv = size_cache; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, v) : map_has(__recv, v); })())) {
  total = (total + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, v) : map_get(__recv, v); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return total;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_struct_init_fields_size = lint_astdup_struct_init_fields_size;

const __tuff_outer_for_lint_astdup_cases_fp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_cases_fp(cases, fp_cache, size_cache, seen_nodes) {
  let __tuff_this = { cases: cases, fp_cache: fp_cache, size_cache: size_cache, seen_nodes: seen_nodes, this: __tuff_outer_for_lint_astdup_cases_fp };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let acc = "["; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  while ((i < (() => { const __recv = cases; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let c = (() => { const __recv = cases; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.c = c;
  acc = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("{p:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "{p:") : str_concat(__recv, "{p:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp((() => { const __recv = c; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp((() => { const __recv = c; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp((() => { const __recv = c; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":b:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":b:") : str_concat(__recv, ":b:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp((() => { const __recv = c; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp((() => { const __recv = c; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp((() => { const __recv = c; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "}") : str_concat(__recv, "}"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((i + 1) < (() => { const __recv = cases; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ",") : str_concat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "]") : str_concat(__recv, "]"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_cases_fp = lint_astdup_cases_fp;

const __tuff_outer_for_lint_astdup_cases_size = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_cases_size(cases, size_cache) {
  let __tuff_this = { cases: cases, size_cache: size_cache, this: __tuff_outer_for_lint_astdup_cases_size };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  while ((i < (() => { const __recv = cases; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let c = (() => { const __recv = cases; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.c = c;
  let p = (() => { const __recv = c; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let b = (() => { const __recv = c; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.b = b;
  if (((p !== 0) && (() => { const __recv = size_cache; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(p); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, p) : map_has(__recv, p); })())) {
  total = (total + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(p); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, p) : map_get(__recv, p); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  if (((b !== 0) && (() => { const __recv = size_cache; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(b); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, b) : map_has(__recv, b); })())) {
  total = (total + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(b); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, b) : map_get(__recv, b); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return total;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_cases_size = lint_astdup_cases_size;

const __tuff_outer_for_lint_astdup_contract_methods_fp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_contract_methods_fp(methods, fp_cache, size_cache, seen_nodes) {
  let __tuff_this = { methods: methods, fp_cache: fp_cache, size_cache: size_cache, seen_nodes: seen_nodes, this: __tuff_outer_for_lint_astdup_contract_methods_fp };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let acc = "["; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  while ((i < (() => { const __recv = methods; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let m = (() => { const __recv = methods; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.m = m;
  acc = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("{m:ID:g:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "{m:ID:g:") : str_concat(__recv, "{m:ID:g:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((() => { const __recv = (() => { const __recv = m; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((() => { const __recv = (() => { const __recv = m; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) : str_concat(__recv, int_to_string((() => { const __recv = (() => { const __recv = m; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":p:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":p:") : str_concat(__recv, ":p:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_params_fp((() => { const __recv = m; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 2) : vec_get(__recv, 2); })(), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_params_fp((() => { const __recv = m; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 2) : vec_get(__recv, 2); })(), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_params_fp((() => { const __recv = m; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 2) : vec_get(__recv, 2); })(), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":r:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":r:") : str_concat(__recv, ":r:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp((() => { const __recv = m; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(3); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 3) : vec_get(__recv, 3); })(), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp((() => { const __recv = m; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(3); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 3) : vec_get(__recv, 3); })(), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp((() => { const __recv = m; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(3); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 3) : vec_get(__recv, 3); })(), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "}") : str_concat(__recv, "}"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((i + 1) < (() => { const __recv = methods; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ",") : str_concat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "]") : str_concat(__recv, "]"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_contract_methods_fp = lint_astdup_contract_methods_fp;

const __tuff_outer_for_lint_astdup_contract_methods_size = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_contract_methods_size(methods, size_cache) {
  let __tuff_this = { methods: methods, size_cache: size_cache, this: __tuff_outer_for_lint_astdup_contract_methods_size };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  while ((i < (() => { const __recv = methods; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let m = (() => { const __recv = methods; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.m = m;
  total = (total + lint_astdup_params_size((() => { const __recv = m; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 2) : vec_get(__recv, 2); })(), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  let ret = (() => { const __recv = m; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(3); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 3) : vec_get(__recv, 3); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
  if (((ret !== 0) && (() => { const __recv = size_cache; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(ret); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, ret) : map_has(__recv, ret); })())) {
  total = (total + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(ret); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, ret) : map_get(__recv, ret); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return total;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_contract_methods_size = lint_astdup_contract_methods_size;

const __tuff_outer_for_lint_astdup_fp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_fp(n, fp_cache, size_cache, seen_nodes) {
  let __tuff_this = { n: n, fp_cache: fp_cache, size_cache: size_cache, seen_nodes: seen_nodes, this: __tuff_outer_for_lint_astdup_fp };
  if ((n === 0)) {
  return "0";
}
  if ((() => { const __recv = fp_cache; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, n) : map_has(__recv, n); })()) {
  return (() => { const __recv = fp_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, n) : map_get(__recv, n); })();
}
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  let fp = (() => { const __recv = "K"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(kind)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(kind)) : str_concat(__recv, int_to_string(kind)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  let size = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  if ((((kind === NK_IDENTIFIER) || (kind === NK_NAME_PAT)) || (kind === NK_NAMED_TYPE))) {
  fp = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(ID)"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(ID)") : str_concat(__recv, "(ID)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if (((((kind === NK_NUMBER_LIT) || (kind === NK_STRING_LIT)) || (kind === NK_CHAR_LIT)) || (kind === NK_LITERAL_PAT))) {
  fp = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(LIT)"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(LIT)") : str_concat(__recv, "(LIT)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if ((kind === NK_BOOL_LIT)) {
  fp = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(BOOL)"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(BOOL)") : str_concat(__recv, "(BOOL)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if ((((kind === NK_WILDCARD_PAT) || (kind === NK_BREAK_STMT)) || (kind === NK_CONTINUE_STMT))) {
  fp = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("()"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "()") : str_concat(__recv, "()"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if ((kind === NK_UNARY_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_UNWRAP_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : map_get(__recv, node_get_data1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_BINARY_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(n))) : str_concat(__recv, get_interned_str(node_get_data1(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = ((size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()) + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data3(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data3(n)) : map_get(__recv, node_get_data3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_CALL_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(callee:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(callee:") : str_concat(__recv, "(callee:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":args:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":args:") : str_concat(__recv, ":args:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_vec_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_vec_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_vec_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":style:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":style:") : str_concat(__recv, ":style:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_data3(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_data3(n))) : str_concat(__recv, int_to_string(node_get_data3(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":targs:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":targs:") : str_concat(__recv, ":targs:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_vec_fp(node_get_data4(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_vec_fp(node_get_data4(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_vec_fp(node_get_data4(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : map_get(__recv, node_get_data1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + lint_astdup_vec_size(node_get_data2(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + lint_astdup_vec_size(node_get_data4(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_MEMBER_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(obj:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(obj:") : str_concat(__recv, "(obj:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":member:ID)"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":member:ID)") : str_concat(__recv, ":member:ID)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : map_get(__recv, node_get_data1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_INDEX_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(target:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(target:") : str_concat(__recv, "(target:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":index:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":index:") : str_concat(__recv, ":index:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = ((size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : map_get(__recv, node_get_data1(n)); })()) + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_STRUCT_INIT)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:fields:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:fields:") : str_concat(__recv, "(name:ID:fields:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_struct_init_fields_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_struct_init_fields_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_struct_init_fields_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":targs:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":targs:") : str_concat(__recv, ":targs:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_vec_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_vec_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_vec_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lint_astdup_struct_init_fields_size(node_get_data2(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + lint_astdup_vec_size(node_get_data3(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if (((kind === NK_IF_EXPR) || (kind === NK_IF_STMT))) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(c:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(c:") : str_concat(__recv, "(c:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":t:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":t:") : str_concat(__recv, ":t:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":e:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":e:") : str_concat(__recv, ":e:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : map_get(__recv, node_get_data1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  if ((node_get_data3(n) !== 0)) {
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data3(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data3(n)) : map_get(__recv, node_get_data3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
} else { if ((kind === NK_MATCH_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(target:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(target:") : str_concat(__recv, "(target:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":cases:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":cases:") : str_concat(__recv, ":cases:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_cases_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_cases_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_cases_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : map_get(__recv, node_get_data1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + lint_astdup_cases_size(node_get_data2(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_IS_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(subject:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(subject:") : str_concat(__recv, "(subject:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":pat:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":pat:") : str_concat(__recv, ":pat:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = ((size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : map_get(__recv, node_get_data1(n)); })()) + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((((((kind === NK_TUPLE_EXPR) || (kind === NK_TUPLE_TYPE)) || (kind === NK_BLOCK)) || (kind === NK_STMT_LIST)) || (kind === NK_PROGRAM))) {
  fp = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_vec_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_vec_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_vec_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lint_astdup_vec_size(node_get_data1(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_FN_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:g:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:g:") : str_concat(__recv, "(name:ID:g:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) : str_concat(__recv, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":p:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":p:") : str_concat(__recv, ":p:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_params_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_params_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_params_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":r:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":r:") : str_concat(__recv, ":r:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data4(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data4(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data4(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":b:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":b:") : str_concat(__recv, ":b:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data5(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data5(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data5(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lint_astdup_params_size(node_get_data3(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  if ((node_get_data4(n) !== 0)) {
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data4(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data4(n)) : map_get(__recv, node_get_data4(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data5(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data5(n)) : map_get(__recv, node_get_data5(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_LAMBDA_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(p:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(p:") : str_concat(__recv, "(p:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_params_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_params_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_params_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":b:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":b:") : str_concat(__recv, ":b:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lint_astdup_params_size(node_get_data1(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if (((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL)) || (kind === NK_EXPECT_FN_DECL))) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:g:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:g:") : str_concat(__recv, "(name:ID:g:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) : str_concat(__recv, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":p:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":p:") : str_concat(__recv, ":p:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_params_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_params_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_params_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":r:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":r:") : str_concat(__recv, ":r:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data4(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data4(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data4(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":b:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":b:") : str_concat(__recv, ":b:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data5(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data5(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data5(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lint_astdup_params_size(node_get_data3(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  if ((node_get_data4(n) !== 0)) {
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data4(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data4(n)) : map_get(__recv, node_get_data4(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
  if ((node_get_data5(n) !== 0)) {
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data5(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data5(n)) : map_get(__recv, node_get_data5(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
} else { if (((kind === NK_LET_DECL) || (kind === NK_EXTERN_LET_DECL))) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:t:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:t:") : str_concat(__recv, "(name:ID:t:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":v:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":v:") : str_concat(__recv, ":v:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  if ((node_get_data2(n) !== 0)) {
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
  if ((node_get_data3(n) !== 0)) {
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data3(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data3(n)) : map_get(__recv, node_get_data3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
} else { if ((kind === NK_FOR_STMT)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(iter:ID:s:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(iter:ID:s:") : str_concat(__recv, "(iter:ID:s:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":e:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":e:") : str_concat(__recv, ":e:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":b:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":b:") : str_concat(__recv, ":b:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data4(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data4(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data4(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data3(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data3(n)) : map_get(__recv, node_get_data3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data4(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data4(n)) : map_get(__recv, node_get_data4(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if (((((kind === NK_WHILE_STMT) || (kind === NK_LOOP_STMT)) || (kind === NK_RETURN_STMT)) || (kind === NK_EXPR_STMT))) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  if ((node_get_data1(n) !== 0)) {
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : map_get(__recv, node_get_data1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
} else { if ((kind === NK_ASSIGN_STMT)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(t:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(t:") : str_concat(__recv, "(t:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":v:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":v:") : str_concat(__recv, ":v:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = ((size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : map_get(__recv, node_get_data1(n)); })()) + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_LIFETIME_STMT)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(names:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(names:") : str_concat(__recv, "(names:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((() => { const __recv = node_get_data1(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((() => { const __recv = node_get_data1(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) : str_concat(__recv, int_to_string((() => { const __recv = node_get_data1(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":b:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":b:") : str_concat(__recv, ":b:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_POINTER_TYPE)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(mut:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(mut:") : str_concat(__recv, "(mut:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_data1(n))) : str_concat(__recv, int_to_string(node_get_data1(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":inner:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":inner:") : str_concat(__recv, ":inner:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":move:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":move:") : str_concat(__recv, ":move:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_data3(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_data3(n))) : str_concat(__recv, int_to_string(node_get_data3(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":life:ID)"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":life:ID)") : str_concat(__recv, ":life:ID)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_ARRAY_TYPE)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(e:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(e:") : str_concat(__recv, "(e:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":i:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":i:") : str_concat(__recv, ":i:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":t:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":t:") : str_concat(__recv, ":t:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : map_get(__recv, node_get_data1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  if ((node_get_data2(n) !== 0)) {
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
  if ((node_get_data3(n) !== 0)) {
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data3(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data3(n)) : map_get(__recv, node_get_data3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
} else { if ((kind === NK_REFINEMENT_TYPE)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(b:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(b:") : str_concat(__recv, "(b:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":op:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":op:") : str_concat(__recv, ":op:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data2(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data2(n))) : str_concat(__recv, get_interned_str(node_get_data2(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":v:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":v:") : str_concat(__recv, ":v:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : map_get(__recv, node_get_data1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data3(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data3(n)) : map_get(__recv, node_get_data3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_UNION_TYPE)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(l:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(l:") : str_concat(__recv, "(l:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":r:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":r:") : str_concat(__recv, ":r:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":x:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":x:") : str_concat(__recv, ":x:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_data3(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_data3(n))) : str_concat(__recv, int_to_string(node_get_data3(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = ((size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : map_get(__recv, node_get_data1(n)); })()) + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_FUNCTION_TYPE)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(p:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(p:") : str_concat(__recv, "(p:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_vec_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_vec_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_vec_fp(node_get_data1(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":r:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":r:") : str_concat(__recv, ":r:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lint_astdup_vec_size(node_get_data1(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : map_get(__recv, node_get_data2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_APPLIED_TYPE)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:args:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:args:") : str_concat(__recv, "(name:ID:args:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_vec_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_vec_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_vec_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lint_astdup_vec_size(node_get_data2(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if (((kind === NK_IMPORT_DECL) || (kind === NK_EXTERN_IMPORT_DECL))) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(names:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(names:") : str_concat(__recv, "(names:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((() => { const __recv = node_get_data1(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((() => { const __recv = node_get_data1(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) : str_concat(__recv, int_to_string((() => { const __recv = node_get_data1(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":parts:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":parts:") : str_concat(__recv, ":parts:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) : str_concat(__recv, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if ((kind === NK_STRUCT_DECL)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:g:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:g:") : str_concat(__recv, "(name:ID:g:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) : str_concat(__recv, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":f:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":f:") : str_concat(__recv, ":f:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_named_type_fields_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_named_type_fields_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_named_type_fields_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":copy:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":copy:") : str_concat(__recv, ":copy:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_data4(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_data4(n))) : str_concat(__recv, int_to_string(node_get_data4(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lint_astdup_named_type_fields_size(node_get_data3(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_OBJECT_DECL)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:g:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:g:") : str_concat(__recv, "(name:ID:g:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) : str_concat(__recv, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":in:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":in:") : str_concat(__recv, ":in:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_named_type_fields_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_named_type_fields_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_named_type_fields_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lint_astdup_named_type_fields_size(node_get_data3(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_CONTRACT_DECL)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:m:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:m:") : str_concat(__recv, "(name:ID:m:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_contract_methods_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_contract_methods_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_contract_methods_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lint_astdup_contract_methods_size(node_get_data2(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_ENUM_DECL)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:v:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:v:") : str_concat(__recv, "(name:ID:v:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) : str_concat(__recv, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if ((kind === NK_TYPE_ALIAS)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:g:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:g:") : str_concat(__recv, "(name:ID:g:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) : str_concat(__recv, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":a:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":a:") : str_concat(__recv, ":a:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":copy:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":copy:") : str_concat(__recv, ":copy:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_data4(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_data4(n))) : str_concat(__recv, int_to_string(node_get_data4(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":d:ID)"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":d:ID)") : str_concat(__recv, ":d:ID)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data3(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data3(n)) : map_get(__recv, node_get_data3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_DEP_TYPE_ALIAS)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:p:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:p:") : str_concat(__recv, "(name:ID:p:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_params_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_params_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_params_fp(node_get_data2(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":a:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":a:") : str_concat(__recv, ":a:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)) : str_concat(__recv, lint_astdup_fp(node_get_data3(n), fp_cache, size_cache, seen_nodes)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":copy:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":copy:") : str_concat(__recv, ":copy:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_data4(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_data4(n))) : str_concat(__recv, int_to_string(node_get_data4(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":d:ID)"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":d:ID)") : str_concat(__recv, ":d:ID)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lint_astdup_params_size(node_get_data2(n), size_cache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(node_get_data3(n)); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, node_get_data3(n)) : map_get(__recv, node_get_data3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_EXTERN_TYPE_DECL)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:g:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:g:") : str_concat(__recv, "(name:ID:g:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) : str_concat(__recv, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":d:ID)"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":d:ID)") : str_concat(__recv, ":d:ID)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if ((kind === NK_STRUCT_PAT)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(name:ID:fields:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(name:ID:fields:") : str_concat(__recv, "(name:ID:fields:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) : str_concat(__recv, int_to_string((() => { const __recv = node_get_data2(n); const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("(d1:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(d1:") : str_concat(__recv, "(d1:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_data1(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_data1(n))) : str_concat(__recv, int_to_string(node_get_data1(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":d2:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":d2:") : str_concat(__recv, ":d2:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_data2(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_data2(n))) : str_concat(__recv, int_to_string(node_get_data2(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":d3:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":d3:") : str_concat(__recv, ":d3:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_data3(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_data3(n))) : str_concat(__recv, int_to_string(node_get_data3(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":d4:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":d4:") : str_concat(__recv, ":d4:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_data4(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_data4(n))) : str_concat(__recv, int_to_string(node_get_data4(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":d5:"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":d5:") : str_concat(__recv, ":d5:"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(node_get_data5(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(node_get_data5(n))) : str_concat(__recv, int_to_string(node_get_data5(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
  (() => { const __recv = fp_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(n, fp); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, n, fp) : map_set(__recv, n, fp); })();
  (() => { const __recv = size_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(n, size); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, n, size) : map_set(__recv, n, size); })();
  (() => { const __recv = seen_nodes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, n) : vec_push(__recv, n); })();
  return fp;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_fp = lint_astdup_fp;

const __tuff_outer_for_lint_astdup_norm_leaf_kind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_norm_leaf_kind(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_lint_astdup_norm_leaf_kind };
  if ((((kind === NK_IDENTIFIER) || (kind === NK_NAME_PAT)) || (kind === NK_NAMED_TYPE))) {
  return "ID";
}
  if (((((kind === NK_NUMBER_LIT) || (kind === NK_STRING_LIT)) || (kind === NK_CHAR_LIT)) || (kind === NK_LITERAL_PAT))) {
  return "LIT";
}
  if ((kind === NK_BOOL_LIT)) {
  return "BOOL";
}
  return int_to_string(kind);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_norm_leaf_kind = lint_astdup_norm_leaf_kind;

const __tuff_outer_for_lint_astdup_fallback_binary = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_astdup_fallback_binary(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_lint_astdup_fallback_binary };
  let body = node_get_data1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let stack = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.stack = stack;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = body; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()) : vec_push(__recv, (() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let keys = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.keys = keys;
  let counts = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.counts = counts;
  let first_nodes = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.first_nodes = first_nodes;
  let second_nodes = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.second_nodes = second_nodes;
  while (((() => { const __recv = stack; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() > 0)) {
  let n = (() => { const __recv = stack; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(((() => { const __recv = stack; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() - 1)); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, ((() => { const __recv = stack; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() - 1)) : vec_get(__recv, ((() => { const __recv = stack; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() - 1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  (() => { const __recv = stack; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  if ((n === 0)) {
  continue;
}
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_BINARY_EXPR)) {
  let op = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let left_kind = lint_astdup_norm_leaf_kind(node_kind(node_get_data2(n))); if (typeof __tuff_this !== 'undefined') __tuff_this.left_kind = left_kind;
  let right_kind = lint_astdup_norm_leaf_kind(node_kind(node_get_data3(n))); if (typeof __tuff_this !== 'undefined') __tuff_this.right_kind = right_kind;
  let key = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = op; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(left_kind); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, left_kind) : str_concat(__recv, left_kind); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ":") : str_concat(__recv, ":"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(right_kind); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, right_kind) : str_concat(__recv, right_kind); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  let found = (-1); if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  let k = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  while ((k < (() => { const __recv = keys; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  if ((() => { const __recv = (() => { const __recv = keys; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, k) : vec_get(__recv, k); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(key); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, key) : str_eq(__recv, key); })()) {
  found = k; if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  break;
}
  k = (k + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
}
  if ((found === (-1))) {
  (() => { const __recv = keys; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(key); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, key) : vec_push(__recv, key); })();
  (() => { const __recv = counts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 1) : vec_push(__recv, 1); })();
  (() => { const __recv = first_nodes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, n) : vec_push(__recv, n); })();
  (() => { const __recv = second_nodes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
} else {
  let next_count = ((() => { const __recv = counts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(found); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, found) : vec_get(__recv, found); })() + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.next_count = next_count;
  (() => { const __recv = counts; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(found, next_count); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, found, next_count) : vec_set(__recv, found, next_count); })();
  if (((() => { const __recv = second_nodes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(found); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, found) : vec_get(__recv, found); })() === 0)) {
  (() => { const __recv = second_nodes; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(found, n); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, found, n) : vec_set(__recv, found, n); })();
}
}
}
  if ((((((kind === NK_PROGRAM) || (kind === NK_BLOCK)) || (kind === NK_STMT_LIST)) || (kind === NK_TUPLE_EXPR)) || (kind === NK_TUPLE_TYPE))) {
  let items = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < (() => { const __recv = items; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = items; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = items; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()) : vec_push(__recv, (() => { const __recv = items; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  continue;
}
  if ((((((kind === NK_LET_DECL) || (kind === NK_ASSIGN_STMT)) || (kind === NK_BINARY_EXPR)) || (kind === NK_INDEX_EXPR)) || (kind === NK_IS_EXPR))) {
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : vec_push(__recv, node_get_data1(n)); })();
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : vec_push(__recv, node_get_data2(n)); })();
  if (((kind === NK_LET_DECL) || (kind === NK_BINARY_EXPR))) {
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node_get_data3(n)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node_get_data3(n)) : vec_push(__recv, node_get_data3(n)); })();
}
  continue;
}
  if ((((((((kind === NK_EXPR_STMT) || (kind === NK_RETURN_STMT)) || (kind === NK_WHILE_STMT)) || (kind === NK_LOOP_STMT)) || (kind === NK_UNARY_EXPR)) || (kind === NK_UNWRAP_EXPR)) || (kind === NK_MEMBER_EXPR))) {
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : vec_push(__recv, node_get_data1(n)); })();
  if (((kind === NK_UNARY_EXPR) || (kind === NK_UNWRAP_EXPR))) {
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : vec_push(__recv, node_get_data2(n)); })();
}
  continue;
}
  if (((kind === NK_IF_STMT) || (kind === NK_IF_EXPR))) {
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : vec_push(__recv, node_get_data1(n)); })();
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : vec_push(__recv, node_get_data2(n)); })();
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node_get_data3(n)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node_get_data3(n)) : vec_push(__recv, node_get_data3(n)); })();
  continue;
}
  if ((kind === NK_FOR_STMT)) {
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node_get_data2(n)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node_get_data2(n)) : vec_push(__recv, node_get_data2(n)); })();
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node_get_data3(n)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node_get_data3(n)) : vec_push(__recv, node_get_data3(n)); })();
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node_get_data4(n)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node_get_data4(n)) : vec_push(__recv, node_get_data4(n)); })();
  continue;
}
  if ((kind === NK_CALL_EXPR)) {
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(node_get_data1(n)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, node_get_data1(n)) : vec_push(__recv, node_get_data1(n)); })();
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let a = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.a = a;
  while ((a < (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  (() => { const __recv = stack; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(a); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, a) : vec_get(__recv, a); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(a); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, a) : vec_get(__recv, a); })()) : vec_push(__recv, (() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(a); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, a) : vec_get(__recv, a); })()); })();
  a = (a + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.a = a;
}
}
}
  let emitted = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.emitted = emitted;
  let k = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  while (((k < (() => { const __recv = keys; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })()) && (emitted < 5))) {
  let count = (() => { const __recv = counts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, k) : vec_get(__recv, k); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  if ((count >= 3)) {
  let key = (() => { const __recv = keys; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, k) : vec_get(__recv, k); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  let first = (() => { const __recv = first_nodes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, k) : vec_get(__recv, k); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.first = first;
  let second = (() => { const __recv = second_nodes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, k) : vec_get(__recv, k); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.second = second;
  let first_loc = lint_astdup_loc(first); if (typeof __tuff_this !== 'undefined') __tuff_this.first_loc = first_loc;
  let second_loc = "unknown"; if (typeof __tuff_this !== 'undefined') __tuff_this.second_loc = second_loc;
  if ((second !== 0)) {
  second_loc = lint_astdup_loc(second); if (typeof __tuff_this !== 'undefined') __tuff_this.second_loc = second_loc;
}
  lint_add_issue("E_LINT_AST_DUPLICATE_SUBTREE", (() => { const __recv = (() => { const __recv = "Duplicate AST subtree detected (binary-expr) with "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(count)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(count)) : str_concat(__recv, int_to_string(count)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" occurrences"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " occurrences") : str_concat(__recv, " occurrences"); })(), (() => { const __recv = (() => { const __recv = "Normalized shape '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(key); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, key) : str_concat(__recv, key); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' repeats (identifier/literal values normalized), indicating copy-paste structure that is likely extractable."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' repeats (identifier/literal values normalized), indicating copy-paste structure that is likely extractable.") : str_concat(__recv, "' repeats (identifier/literal values normalized), indicating copy-paste structure that is likely extractable."); })(), (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Consider extracting the repeated expression shape into a helper/local binding. Example locations: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(first_loc); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, first_loc) : str_concat(__recv, first_loc); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" and "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " and ") : str_concat(__recv, " and "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(second_loc); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, second_loc) : str_concat(__recv, second_loc); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })());
  emitted = (emitted + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.emitted = emitted;
}
  k = (k + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_astdup_fallback_binary = lint_astdup_fallback_binary;

const __tuff_outer_for_lint_check_ast_duplicates = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_check_ast_duplicates(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_lint_check_ast_duplicates };
  let fp_cache = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp_cache = fp_cache;
  let size_cache = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.size_cache = size_cache;
  let seen_nodes = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.seen_nodes = seen_nodes;
  let body = node_get_data1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let scan_i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.scan_i = scan_i;
  while ((scan_i < (() => { const __recv = body; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  lint_astdup_fp((() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(scan_i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, scan_i) : vec_get(__recv, scan_i); })(), fp_cache, size_cache, seen_nodes);
  scan_i = (scan_i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.scan_i = scan_i;
}
  let keys = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.keys = keys;
  let buckets = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.buckets = buckets;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = seen_nodes; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let n = (() => { const __recv = seen_nodes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  let size = (() => { const __recv = size_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, n) : map_get(__recv, n); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  if (((size >= 6) && lint_astdup_reportable_kind(kind))) {
  let fp = (() => { const __recv = fp_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, n) : map_get(__recv, n); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  let found = (-1); if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < (() => { const __recv = keys; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  if ((() => { const __recv = (() => { const __recv = keys; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(fp); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, fp) : str_eq(__recv, fp); })()) {
  found = j; if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  break;
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  if ((found === (-1))) {
  (() => { const __recv = keys; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(fp); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, fp) : vec_push(__recv, fp); })();
  let bucket = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.bucket = bucket;
  (() => { const __recv = bucket; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, n) : vec_push(__recv, n); })();
  (() => { const __recv = buckets; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(bucket); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, bucket) : vec_push(__recv, bucket); })();
} else {
  let bucket = (() => { const __recv = buckets; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(found); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, found) : vec_get(__recv, found); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.bucket = bucket;
  (() => { const __recv = bucket; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, n) : vec_push(__recv, n); })();
  (() => { const __recv = buckets; const __prop = __recv?.["vec_set"]; if (typeof __prop === "function") return __prop(found, bucket); const __dyn = __recv?.table?.vec_set; return __dyn ? __dyn(__recv.ref, found, bucket) : vec_set(__recv, found, bucket); })();
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = keys; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let fp = (() => { const __recv = keys; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  let bucket = (() => { const __recv = buckets; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.bucket = bucket;
  if (((() => { const __recv = bucket; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() > 1)) {
  let first = (() => { const __recv = bucket; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.first = first;
  let second = (() => { const __recv = bucket; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.second = second;
  let kind_name = lint_astdup_kind_name(node_kind(first)); if (typeof __tuff_this !== 'undefined') __tuff_this.kind_name = kind_name;
  let count = (() => { const __recv = bucket; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  let first_loc = lint_astdup_loc(first); if (typeof __tuff_this !== 'undefined') __tuff_this.first_loc = first_loc;
  let second_loc = lint_astdup_loc(second); if (typeof __tuff_this !== 'undefined') __tuff_this.second_loc = second_loc;
  let shape = lint_astdup_preview(fp); if (typeof __tuff_this !== 'undefined') __tuff_this.shape = shape;
  lint_add_issue("E_LINT_AST_DUPLICATE_SUBTREE", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Duplicate AST subtree detected ("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(kind_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, kind_name) : str_concat(__recv, kind_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") with "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") with ") : str_concat(__recv, ") with "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(int_to_string(count)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, int_to_string(count)) : str_concat(__recv, int_to_string(count)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" occurrences"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " occurrences") : str_concat(__recv, " occurrences"); })(), (() => { const __recv = (() => { const __recv = "A structurally identical subtree appears multiple times (identifier/literal values normalized). Shape preview: '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(shape); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, shape) : str_concat(__recv, shape); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'.") : str_concat(__recv, "'."); })(), (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Extract shared logic into a helper function. Example locations: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(first_loc); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, first_loc) : str_concat(__recv, first_loc); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" and "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " and ") : str_concat(__recv, " and "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(second_loc); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, second_loc) : str_concat(__recv, second_loc); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })());
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  lint_astdup_fallback_binary(program);
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_check_ast_duplicates = lint_check_ast_duplicates;

const __tuff_outer_for_lint_program = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lint_program(program, file_path, max_effective_lines, enforce_file_length) {
  let __tuff_this = { program: program, file_path: file_path, max_effective_lines: max_effective_lines, enforce_file_length: enforce_file_length, this: __tuff_outer_for_lint_program };
  if ((enforce_file_length === 1)) {
  lint_check_file_length(file_path, max_effective_lines);
}
  let receiver_extern_fns = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.receiver_extern_fns = receiver_extern_fns;
  let reads = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.reads = reads;
  let declared_set = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.declared_set = declared_set;
  let declared_names = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.declared_names = declared_names;
  let body = node_get_data1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = body; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if (lint_is_extern_fn_decl(stmt)) {
  let params = node_get_data3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  if (((() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() > 0)) {
  let p0 = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p0 = p0;
  let p0name = get_interned_str((() => { const __recv = p0; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.p0name = p0name;
  if ((() => { const __recv = p0name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })()) {
  (() => { const __recv = receiver_extern_fns; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(stmt))); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(stmt))) : set_add(__recv, get_interned_str(node_get_data1(stmt))); })();
}
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  lint_check_function_length(stmt, 100);
  lint_collect_stmt(stmt, receiver_extern_fns, reads, declared_set, declared_names);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let dlen = (() => { const __recv = declared_names; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dlen = dlen;
  while ((i < dlen)) {
  let name = (() => { const __recv = declared_names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if (((!(() => { const __recv = name; const __prop = __recv?.["str_starts_with"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.str_starts_with; return __dyn ? __dyn(__recv.ref, "_") : str_starts_with(__recv, "_"); })()) && (!(() => { const __recv = reads; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })()))) {
  lint_add_issue("E_LINT_UNUSED_BINDING", (() => { const __recv = (() => { const __recv = "Unused binding '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "Unused bindings increase cognitive load and can indicate leftover or incomplete code paths.", "Remove the binding if unused, use it intentionally, or rename it to start with '_' to mark it as intentionally unused.");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  lint_check_ast_duplicates(program);
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lint_program = lint_program;

const __tuff_outer_for_selfhost_linter_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_linter_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_linter_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_linter_marker = selfhost_linter_marker;

const __tuff_outer_for_module_loader_sanitize_max_effective_lines = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_loader_sanitize_max_effective_lines(max_effective_lines) {
  let __tuff_this = { max_effective_lines: max_effective_lines, this: __tuff_outer_for_module_loader_sanitize_max_effective_lines };
  return (((max_effective_lines <= 0)) ? (() => {
    return 500;
  })() : (() => {
    return max_effective_lines;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_loader_sanitize_max_effective_lines = module_loader_sanitize_max_effective_lines;

const __tuff_outer_for_module_loader_normalize_flag = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_loader_normalize_flag(value) {
  let __tuff_this = { value: value, this: __tuff_outer_for_module_loader_normalize_flag };
  return (((value === 0)) ? (() => {
    return 0;
  })() : (() => {
    return 1;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_loader_normalize_flag = module_loader_normalize_flag;

const __tuff_outer_for_module_parts_to_relative_path = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_parts_to_relative_path(parts) {
  let __tuff_this = { parts: parts, this: __tuff_outer_for_module_parts_to_relative_path };
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = parts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  if ((i > 0)) {
  sb_append(sb, "/");
}
  sb_append(sb, get_interned_str((() => { const __recv = parts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, ".tuff");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_parts_to_relative_path = module_parts_to_relative_path;

const __tuff_outer_for_module_normalize_path = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_normalize_path(p) {
  let __tuff_this = { p: p, this: __tuff_outer_for_module_normalize_path };
  return (() => { const __recv = p; const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("\\", "/"); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "\\", "/") : str_replace_all(__recv, "\\", "/"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_normalize_path = module_normalize_path;

const __tuff_outer_for_join_sources = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function join_sources(sources) {
  let __tuff_this = { sources: sources, this: __tuff_outer_for_join_sources };
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = sources; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  if ((i > 0)) {
  sb_append(sb, "\n\n");
}
  sb_append(sb, (() => { const __recv = sources; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.join_sources = join_sources;

const __tuff_outer_for_module_with_c_runtime_prelude = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_with_c_runtime_prelude(source, target) {
  let __tuff_this = { source: source, target: target, this: __tuff_outer_for_module_with_c_runtime_prelude };
  if ((!(() => { const __recv = target; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("c"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "c") : str_eq(__recv, "c"); })())) {
  return source;
}
  if ((() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop("fn tuff_runtime_panic("); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, "fn tuff_runtime_panic(") : str_includes(__recv, "fn tuff_runtime_panic("); })()) {
  return source;
}
  let prelude = __host_get_c_runtime_prelude_source(); if (typeof __tuff_this !== 'undefined') __tuff_this.prelude = prelude;
  if ((() => { const __recv = prelude; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) {
  return source;
}
  return (() => { const __recv = (() => { const __recv = source; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\n\n"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\n\n") : str_concat(__recv, "\n\n"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prelude); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prelude) : str_concat(__recv, prelude); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_with_c_runtime_prelude = module_with_c_runtime_prelude;

const __tuff_outer_for_selfhost_module_loader_utils_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_module_loader_utils_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_module_loader_utils_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_module_loader_utils_marker = selfhost_module_loader_utils_marker;

const __tuff_outer_for_module_emit_target_output = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_emit_target_output(typed, merged_source, target) {
  let __tuff_this = { typed: typed, merged_source: merged_source, target: target, this: __tuff_outer_for_module_emit_target_output };
  if ((() => { const __recv = target; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("js"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "js") : str_eq(__recv, "js"); })()) {
  return generate_js(typed);
}
  if ((() => { const __recv = target; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("c"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "c") : str_eq(__recv, "c"); })()) {
  return generate_c(typed, __host_get_c_substrate());
}
  if ((() => { const __recv = target; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("tuff"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "tuff") : str_eq(__recv, "tuff"); })()) {
  return emit_tuff_from_typed(typed, merged_source, lex_take_trivia());
}
  panic_with_code("E_UNSUPPORTED_TARGET", (() => { const __recv = "Unsupported codegen target: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, target) : str_concat(__recv, target); })(), "The compiler was asked to emit code for a target that is not implemented.", "Use target 'js', target 'c', or target 'tuff'.");
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_emit_target_output = module_emit_target_output;

let gather_prof_modules = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_modules = gather_prof_modules;

let gather_prof_import_edges = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_import_edges = gather_prof_import_edges;

let gather_prof_read_file_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_read_file_ms = gather_prof_read_file_ms;

let gather_prof_lex_parse_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_lex_parse_ms = gather_prof_lex_parse_ms;

let gather_prof_decl_collect_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_decl_collect_ms = gather_prof_decl_collect_ms;

let gather_prof_import_snapshot_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_import_snapshot_ms = gather_prof_import_snapshot_ms;

let gather_prof_import_walk_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_import_walk_ms = gather_prof_import_walk_ms;

let gather_prof_import_recurse_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_import_recurse_ms = gather_prof_import_recurse_ms;

let gather_prof_implicit_check_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_implicit_check_ms = gather_prof_implicit_check_ms;

const __tuff_outer_for_gather_prof_reset = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function gather_prof_reset() {
  let __tuff_this = { this: __tuff_outer_for_gather_prof_reset };
  gather_prof_modules = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_modules = gather_prof_modules;
  gather_prof_import_edges = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_import_edges = gather_prof_import_edges;
  gather_prof_read_file_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_read_file_ms = gather_prof_read_file_ms;
  gather_prof_lex_parse_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_lex_parse_ms = gather_prof_lex_parse_ms;
  gather_prof_decl_collect_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_decl_collect_ms = gather_prof_decl_collect_ms;
  gather_prof_import_snapshot_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_import_snapshot_ms = gather_prof_import_snapshot_ms;
  gather_prof_import_walk_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_import_walk_ms = gather_prof_import_walk_ms;
  gather_prof_import_recurse_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_import_recurse_ms = gather_prof_import_recurse_ms;
  gather_prof_implicit_check_ms = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_implicit_check_ms = gather_prof_implicit_check_ms;
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_reset = gather_prof_reset;

const __tuff_outer_for_strip_import_decls = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function strip_import_decls(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_strip_import_decls };
  let stmts = node_get_data1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let filtered = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.filtered = filtered;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if ((node_kind(stmt) !== 6)) {
  (() => { const __recv = filtered; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(stmt); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, stmt) : vec_push(__recv, stmt); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  node_set_data1(program, filtered);
  return program;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.strip_import_decls = strip_import_decls;

const __tuff_outer_for_is_module_decl_kind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function is_module_decl_kind(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_is_module_decl_kind };
  return ((((((((((kind === 2) || (kind === 16)) || (kind === 3)) || (kind === 60)) || (kind === 63)) || (kind === 65)) || (kind === 4)) || (kind === 5)) || (kind === 18)) || (kind === 19));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.is_module_decl_kind = is_module_decl_kind;

const __tuff_outer_for_module_is_extern_decl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_is_extern_decl(stmt) {
  let __tuff_this = { stmt: stmt, this: __tuff_outer_for_module_is_extern_decl };
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  return ((((kind === 2) && (node_get_data5(stmt) === 0)) || (kind === 18)) || (kind === 19));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_is_extern_decl = module_is_extern_decl;

const __tuff_outer_for_collect_module_declarations = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function collect_module_declarations(stmts) {
  let __tuff_this = { stmts: stmts, this: __tuff_outer_for_collect_module_declarations };
  let declared = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.declared = declared;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let kind = node_kind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if (is_module_decl_kind(kind)) {
  (() => { const __recv = declared; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(get_interned_str(node_get_data1(stmt))); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, get_interned_str(node_get_data1(stmt))) : set_add(__recv, get_interned_str(node_get_data1(stmt))); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return declared;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.collect_module_declarations = collect_module_declarations;

const __tuff_outer_for_module_scope_define = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_scope_define(scopes, depth, name) {
  let __tuff_this = { scopes: scopes, depth: depth, name: name, this: __tuff_outer_for_module_scope_define };
  let scope = (() => { const __recv = scopes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(depth); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, depth) : vec_get(__recv, depth); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.scope = scope;
  (() => { const __recv = scope; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, name) : set_add(__recv, name); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_scope_define = module_scope_define;

const __tuff_outer_for_module_scope_has = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_scope_has(scopes, depth, name) {
  let __tuff_this = { scopes: scopes, depth: depth, name: name, this: __tuff_outer_for_module_scope_has };
  let i = depth; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i >= 0)) {
  if ((() => { const __recv = (() => { const __recv = scopes; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })()) {
  return true;
}
  i = (i - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_scope_has = module_scope_has;

const __tuff_outer_for_module_check_expr_call_like = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_check_expr_call_like(n, declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set) {
  let __tuff_this = { n: n, declared: declared, imported: imported, scopes: scopes, depth: depth, implicit_candidates: implicit_candidates, implicit_candidate_set: implicit_candidate_set, this: __tuff_outer_for_module_check_expr_call_like };
  if ((node_kind(n) === 27)) {
  module_check_expr_implicit_imports(node_get_data1(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  module_check_expr_implicit_imports((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 1;
}
  if ((node_kind(n) === 28)) {
  module_check_expr_implicit_imports(node_get_data1(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  return 1;
}
  if ((node_kind(n) === 29)) {
  module_check_expr_implicit_imports(node_get_data1(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  module_check_expr_implicit_imports(node_get_data2(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  return 1;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_check_expr_call_like = module_check_expr_call_like;

const __tuff_outer_for_module_check_expr_composites = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_check_expr_composites(n, declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set) {
  let __tuff_this = { n: n, declared: declared, imported: imported, scopes: scopes, depth: depth, implicit_candidates: implicit_candidates, implicit_candidate_set: implicit_candidate_set, this: __tuff_outer_for_module_check_expr_composites };
  if ((node_kind(n) === 30)) {
  let fields = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  module_check_expr_implicit_imports((() => { const __recv = f; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 1;
}
  if ((node_kind(n) === 33)) {
  module_check_expr_implicit_imports(node_get_data1(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  return 1;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_check_expr_composites = module_check_expr_composites;

const __tuff_outer_for_module_check_expr_match = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_check_expr_match(n, declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set) {
  let __tuff_this = { n: n, declared: declared, imported: imported, scopes: scopes, depth: depth, implicit_candidates: implicit_candidates, implicit_candidate_set: implicit_candidate_set, this: __tuff_outer_for_module_check_expr_match };
  if ((node_kind(n) !== 32)) {
  return 0;
}
  module_check_expr_implicit_imports(node_get_data1(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  let cases = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let case_node = (() => { const __recv = cases; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.case_node = case_node;
  let pat = (() => { const __recv = case_node; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  let body = (() => { const __recv = case_node; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let next_depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.next_depth = next_depth;
  (() => { const __recv = scopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  if ((node_kind(pat) === 53)) {
  let fields = node_get_data2(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let fLen = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fLen = fLen;
  while ((j < fLen)) {
  module_scope_define(scopes, next_depth, get_interned_str((() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()));
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
} else { if ((node_kind(pat) === 52)) {
  let pat_name = get_interned_str(node_get_data1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.pat_name = pat_name;
  if (((!(() => { const __recv = declared; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(pat_name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, pat_name) : set_has(__recv, pat_name); })()) && (!(() => { const __recv = imported; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(pat_name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, pat_name) : set_has(__recv, pat_name); })()))) {
  module_scope_define(scopes, next_depth, pat_name);
}
} }
  module_check_stmt_implicit_imports(body, declared, imported, scopes, next_depth, implicit_candidates, implicit_candidate_set);
  (() => { const __recv = scopes; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 1;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_check_expr_match = module_check_expr_match;

const __tuff_outer_for_module_collect_declared_sets = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_collect_declared_sets(source, program, module_declared_map, module_exported_map, filePath, all_declared_names, all_exported_declared_names, all_extern_declared_names) {
  let __tuff_this = { source: source, program: program, module_declared_map: module_declared_map, module_exported_map: module_exported_map, filePath: filePath, all_declared_names: all_declared_names, all_exported_declared_names: all_exported_declared_names, all_extern_declared_names: all_extern_declared_names, this: __tuff_outer_for_module_collect_declared_sets };
  let stmts = node_get_data1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let declared = collect_module_declarations(stmts); if (typeof __tuff_this !== 'undefined') __tuff_this.declared = declared;
  let exported = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.exported = exported;
  (() => { const __recv = module_declared_map; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(filePath, declared); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, filePath, declared) : map_set(__recv, filePath, declared); })();
  (() => { const __recv = module_exported_map; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(filePath, exported); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, filePath, exported) : map_set(__recv, filePath, exported); })();
  let di = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.di = di;
  let dlen = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dlen = dlen;
  while ((di < dlen)) {
  let dstmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(di); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, di) : vec_get(__recv, di); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dstmt = dstmt;
  let dkind = node_kind(dstmt); if (typeof __tuff_this !== 'undefined') __tuff_this.dkind = dkind;
  if (is_module_decl_kind(dkind)) {
  let dname = get_interned_str(node_get_data1(dstmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.dname = dname;
  (() => { const __recv = all_declared_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(dname); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, dname) : set_add(__recv, dname); })();
  if (module_is_extern_decl(dstmt)) {
  (() => { const __recv = all_extern_declared_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(dname); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, dname) : set_add(__recv, dname); })();
}
  if (module_has_out_export(source, dname)) {
  (() => { const __recv = exported; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(dname); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, dname) : set_add(__recv, dname); })();
  (() => { const __recv = all_exported_declared_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(dname); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, dname) : set_add(__recv, dname); })();
}
}
  di = (di + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.di = di;
}
  return declared;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_collect_declared_sets = module_collect_declared_sets;

const __tuff_outer_for_module_snapshot_import_specs = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_snapshot_import_specs(stmts, moduleBasePath, import_path_cache) {
  let __tuff_this = { stmts: stmts, moduleBasePath: moduleBasePath, import_path_cache: import_path_cache, this: __tuff_outer_for_module_snapshot_import_specs };
  let t0 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t0 = t0;
  let imports = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.imports = imports;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if ((node_kind(stmt) === 6)) {
  let parts = node_get_data2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.parts = parts;
  let rel = module_parts_to_relative_path(parts); if (typeof __tuff_this !== 'undefined') __tuff_this.rel = rel;
  let depPath = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.depPath = depPath;
  if ((() => { const __recv = import_path_cache; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(rel); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, rel) : map_has(__recv, rel); })()) {
  depPath = (() => { const __recv = import_path_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(rel); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, rel) : map_get(__recv, rel); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.depPath = depPath;
} else {
  depPath = module_normalize_path(path_join(moduleBasePath, rel)); if (typeof __tuff_this !== 'undefined') __tuff_this.depPath = depPath;
  (() => { const __recv = import_path_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(rel, depPath); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, rel, depPath) : map_set(__recv, rel, depPath); })();
}
  let importNamesRaw = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.importNamesRaw = importNamesRaw;
  let importNames = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.importNames = importNames;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let jLen = (() => { const __recv = importNamesRaw; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.jLen = jLen;
  while ((j < jLen)) {
  (() => { const __recv = importNames; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(get_interned_str((() => { const __recv = importNamesRaw; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })())); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, get_interned_str((() => { const __recv = importNamesRaw; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })())) : vec_push(__recv, get_interned_str((() => { const __recv = importNamesRaw; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })())); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  let importSpec = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.importSpec = importSpec;
  (() => { const __recv = importSpec; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(depPath); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, depPath) : vec_push(__recv, depPath); })();
  (() => { const __recv = importSpec; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(importNames); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, importNames) : vec_push(__recv, importNames); })();
  (() => { const __recv = imports; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(importSpec); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, importSpec) : vec_push(__recv, importSpec); })();
  gather_prof_import_edges = (gather_prof_import_edges + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_import_edges = gather_prof_import_edges;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  gather_prof_import_snapshot_ms = (gather_prof_import_snapshot_ms + (perf_now_out() - t0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_import_snapshot_ms = gather_prof_import_snapshot_ms;
  return imports;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_snapshot_import_specs = module_snapshot_import_specs;

const __tuff_outer_for_module_walk_imports = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_walk_imports(imports, moduleBasePath, seen, visiting, sources, module_paths, module_declared_map, module_exported_map, module_source_cache, import_path_cache, all_declared_names, all_exported_declared_names, all_extern_declared_names, lint_enabled, max_effective_lines, module_cycles, recursion_depth) {
  let __tuff_this = { imports: imports, moduleBasePath: moduleBasePath, seen: seen, visiting: visiting, sources: sources, module_paths: module_paths, module_declared_map: module_declared_map, module_exported_map: module_exported_map, module_source_cache: module_source_cache, import_path_cache: import_path_cache, all_declared_names: all_declared_names, all_exported_declared_names: all_exported_declared_names, all_extern_declared_names: all_extern_declared_names, lint_enabled: lint_enabled, max_effective_lines: max_effective_lines, module_cycles: module_cycles, recursion_depth: recursion_depth, this: __tuff_outer_for_module_walk_imports };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = imports; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let spec = (() => { const __recv = imports; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.spec = spec;
  let depPath = (() => { const __recv = spec; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.depPath = depPath;
  let importNames = (() => { const __recv = spec; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.importNames = importNames;
  if ((!(() => { const __recv = seen; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(depPath); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, depPath) : set_has(__recv, depPath); })())) {
  let t_recurse_0 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t_recurse_0 = t_recurse_0;
  gather_module_sources(depPath, moduleBasePath, seen, visiting, sources, module_paths, module_declared_map, module_exported_map, module_source_cache, import_path_cache, all_declared_names, all_exported_declared_names, all_extern_declared_names, lint_enabled, max_effective_lines, module_cycles, (recursion_depth + 1));
  if ((recursion_depth === 0)) {
  gather_prof_import_recurse_ms = (gather_prof_import_recurse_ms + (perf_now_out() - t_recurse_0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_import_recurse_ms = gather_prof_import_recurse_ms;
}
}
  let t_walk_local_0 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t_walk_local_0 = t_walk_local_0;
  let depDeclared = (() => { const __recv = module_declared_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(depPath); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, depPath) : map_get(__recv, depPath); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.depDeclared = depDeclared;
  let depExported = (() => { const __recv = module_exported_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(depPath); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, depPath) : map_get(__recv, depPath); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.depExported = depExported;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let jLen = (() => { const __recv = importNames; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.jLen = jLen;
  while ((j < jLen)) {
  let importedName = (() => { const __recv = importNames; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.importedName = importedName;
  if ((!(() => { const __recv = depExported; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(importedName); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, importedName) : set_has(__recv, importedName); })())) {
  if ((() => { const __recv = depDeclared; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(importedName); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, importedName) : set_has(__recv, importedName); })()) {
  panic_with_code("E_MODULE_PRIVATE_IMPORT", (() => { const __recv = (() => { const __recv = "Cannot import '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(importedName); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, importedName) : str_concat(__recv, importedName); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' from module: symbol is not exported with 'out'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' from module: symbol is not exported with 'out'") : str_concat(__recv, "' from module: symbol is not exported with 'out'"); })(), "A module import referenced a declaration that exists but is not visible outside its module.", "Mark the declaration with 'out' in the target module, or remove it from the import list.");
}
  panic_with_code("E_MODULE_UNKNOWN_EXPORT", (() => { const __recv = (() => { const __recv = "Cannot import '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(importedName); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, importedName) : str_concat(__recv, importedName); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("' from module: exported symbol not found"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "' from module: exported symbol not found") : str_concat(__recv, "' from module: exported symbol not found"); })(), "A module import requested a symbol that is not exported by the target module.", "Check the import list and add a matching 'out' declaration in the target module.");
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  gather_prof_import_walk_ms = (gather_prof_import_walk_ms + (perf_now_out() - t_walk_local_0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_import_walk_ms = gather_prof_import_walk_ms;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_walk_imports = module_walk_imports;

const __tuff_outer_for_module_collect_imported_names = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_collect_imported_names(imports) {
  let __tuff_this = { imports: imports, this: __tuff_outer_for_module_collect_imported_names };
  let imported_names = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.imported_names = imported_names;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = imports; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let spec = (() => { const __recv = imports; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.spec = spec;
  let importNames = (() => { const __recv = spec; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.importNames = importNames;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let jLen = (() => { const __recv = importNames; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.jLen = jLen;
  while ((j < jLen)) {
  (() => { const __recv = imported_names; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop((() => { const __recv = importNames; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, (() => { const __recv = importNames; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()) : set_add(__recv, (() => { const __recv = importNames; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, j) : vec_get(__recv, j); })()); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return imported_names;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_collect_imported_names = module_collect_imported_names;

const __tuff_outer_for_module_check_expr_implicit_imports = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_check_expr_implicit_imports(n, declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set) {
  let __tuff_this = { n: n, declared: declared, imported: imported, scopes: scopes, depth: depth, implicit_candidates: implicit_candidates, implicit_candidate_set: implicit_candidate_set, this: __tuff_outer_for_module_check_expr_implicit_imports };
  if ((n === 0)) {
  return 0;
}
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === 24)) {
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((((!module_scope_has(scopes, depth, name)) && (!(() => { const __recv = declared; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })())) && (!(() => { const __recv = imported; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })()))) {
  if ((!(() => { const __recv = implicit_candidate_set; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })())) {
  (() => { const __recv = implicit_candidate_set; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, name) : set_add(__recv, name); })();
  (() => { const __recv = implicit_candidates; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, name) : vec_push(__recv, name); })();
}
}
  return 0;
}
  if ((kind === 25)) {
  module_check_expr_implicit_imports(node_get_data2(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  module_check_expr_implicit_imports(node_get_data3(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  return 0;
}
  if (((kind === 26) || (kind === 34))) {
  module_check_expr_implicit_imports(node_get_data2(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  if ((kind === 34)) {
  module_check_expr_implicit_imports(node_get_data1(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
}
  return 0;
}
  if ((module_check_expr_call_like(n, declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set) === 1)) {
  return 0;
}
  if ((module_check_expr_composites(n, declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set) === 1)) {
  return 0;
}
  if ((kind === 31)) {
  module_check_expr_implicit_imports(node_get_data1(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  module_check_stmt_implicit_imports(node_get_data2(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  if ((node_get_data3(n) !== 0)) {
  module_check_stmt_implicit_imports(node_get_data3(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
}
  return 0;
}
  if ((module_check_expr_match(n, declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set) === 1)) {
  return 0;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_check_expr_implicit_imports = module_check_expr_implicit_imports;

const __tuff_outer_for_module_check_stmt_implicit_imports = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_check_stmt_implicit_imports(n, declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set) {
  let __tuff_this = { n: n, declared: declared, imported: imported, scopes: scopes, depth: depth, implicit_candidates: implicit_candidates, implicit_candidate_set: implicit_candidate_set, this: __tuff_outer_for_module_check_stmt_implicit_imports };
  if ((n === 0)) {
  return 0;
}
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === 12)) {
  let next_depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.next_depth = next_depth;
  (() => { const __recv = scopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  let stmts = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  module_check_stmt_implicit_imports((() => { const __recv = stmts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), declared, imported, scopes, next_depth, implicit_candidates, implicit_candidate_set);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  (() => { const __recv = scopes; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  return 0;
}
  if (((kind === 2) || (kind === 16))) {
  let fnScopes = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnScopes = fnScopes;
  (() => { const __recv = fnScopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  let params = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let p = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  module_scope_define(fnScopes, 0, get_interned_str((() => { const __recv = p; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  module_check_stmt_implicit_imports(node_get_data5(n), declared, imported, fnScopes, 0, implicit_candidates, implicit_candidate_set);
  return 0;
}
  if ((kind === 5)) {
  module_check_expr_implicit_imports(node_get_data3(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  module_scope_define(scopes, depth, get_interned_str(node_get_data1(n)));
  return 0;
}
  if ((kind === 6)) {
  let names = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = names; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  module_scope_define(scopes, depth, get_interned_str((() => { const __recv = names; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === 7)) {
  module_check_expr_implicit_imports(node_get_data1(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  return 0;
}
  if ((kind === 13)) {
  module_check_expr_implicit_imports(node_get_data1(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  module_check_expr_implicit_imports(node_get_data2(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  return 0;
}
  if ((kind === 8)) {
  module_check_expr_implicit_imports(node_get_data1(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  return 0;
}
  if ((kind === 9)) {
  module_check_expr_implicit_imports(node_get_data1(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  module_check_stmt_implicit_imports(node_get_data2(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  if ((node_get_data3(n) !== 0)) {
  module_check_stmt_implicit_imports(node_get_data3(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
}
  return 0;
}
  if ((kind === 11)) {
  let next_depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.next_depth = next_depth;
  (() => { const __recv = scopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  module_scope_define(scopes, next_depth, get_interned_str(node_get_data1(n)));
  module_check_expr_implicit_imports(node_get_data2(n), declared, imported, scopes, next_depth, implicit_candidates, implicit_candidate_set);
  module_check_expr_implicit_imports(node_get_data3(n), declared, imported, scopes, next_depth, implicit_candidates, implicit_candidate_set);
  module_check_stmt_implicit_imports(node_get_data4(n), declared, imported, scopes, next_depth, implicit_candidates, implicit_candidate_set);
  (() => { const __recv = scopes; const __prop = __recv?.["vec_pop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_pop; return __dyn ? __dyn(__recv.ref) : vec_pop(__recv); })();
  return 0;
}
  if ((kind === 10)) {
  module_check_expr_implicit_imports(node_get_data1(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  module_check_stmt_implicit_imports(node_get_data2(n), declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  return 0;
}
  module_check_expr_implicit_imports(n, declared, imported, scopes, depth, implicit_candidates, implicit_candidate_set);
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_check_stmt_implicit_imports = module_check_stmt_implicit_imports;

const __tuff_outer_for_module_collect_implicit_import_candidates = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_collect_implicit_import_candidates(program, declared, imported) {
  let __tuff_this = { program: program, declared: declared, imported: imported, this: __tuff_outer_for_module_collect_implicit_import_candidates };
  let implicit_candidates = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.implicit_candidates = implicit_candidates;
  let implicit_candidate_set = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.implicit_candidate_set = implicit_candidate_set;
  let topScopes = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.topScopes = topScopes;
  (() => { const __recv = topScopes; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(set_new()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, set_new()) : vec_push(__recv, set_new()); })();
  let body = node_get_data1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = body; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  module_check_stmt_implicit_imports((() => { const __recv = body; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(), declared, imported, topScopes, 0, implicit_candidates, implicit_candidate_set);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return implicit_candidates;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_collect_implicit_import_candidates = module_collect_implicit_import_candidates;

const __tuff_outer_for_module_assert_no_implicit_imports = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_assert_no_implicit_imports(implicit_candidates, all_exported_declared, all_extern_declared) {
  let __tuff_this = { implicit_candidates: implicit_candidates, all_exported_declared: all_exported_declared, all_extern_declared: all_extern_declared, this: __tuff_outer_for_module_assert_no_implicit_imports };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = implicit_candidates; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let name = (() => { const __recv = implicit_candidates; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if (((() => { const __recv = all_exported_declared; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })() && (!(() => { const __recv = all_extern_declared; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, name) : set_has(__recv, name); })()))) {
  panic_with_code("E_MODULE_IMPLICIT_IMPORT", (() => { const __recv = (() => { const __recv = "Strict module imports require explicit import for symbol '"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(), "A module referenced a symbol declared in another module without importing it explicitly.", "Add the symbol to the module import list (for example: let { symbol } = moduleName;).");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_assert_no_implicit_imports = module_assert_no_implicit_imports;

const __tuff_outer_for_module_has_out_export = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function module_has_out_export(source, name) {
  let __tuff_this = { source: source, name: name, this: __tuff_outer_for_module_has_out_export };
  return (((((((((((((() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "out extern fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "out extern fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "out extern fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })() || (() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "extern out fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "extern out fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "extern out fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })()) || (() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "out fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "out fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "out fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })()) || (() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "out struct "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "out struct "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "out struct "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })()) || (() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "out copy struct "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "out copy struct "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "out copy struct "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })()) || (() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "copy out struct "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "copy out struct "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "copy out struct "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })()) || (() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "out enum "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "out enum "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "out enum "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })()) || (() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "out object "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "out object "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "out object "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })()) || (() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "out contract "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "out contract "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "out contract "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })()) || (() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "out type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "out type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "out type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })()) || (() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "out copy type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "out copy type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "out copy type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })()) || (() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "copy out type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "copy out type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "copy out type "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })()) || (() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop((() => { const __recv = "out class fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "out class fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()) : str_includes(__recv, (() => { const __recv = "out class fn "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })()); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.module_has_out_export = module_has_out_export;

const __tuff_outer_for_gather_module_sources = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function gather_module_sources(filePath, moduleBasePath, seen, visiting, sources, module_paths, module_declared_map, module_exported_map, module_source_cache, import_path_cache, all_declared_names, all_exported_declared_names, all_extern_declared_names, lint_enabled, max_effective_lines, module_cycles, recursion_depth) {
  let __tuff_this = { filePath: filePath, moduleBasePath: moduleBasePath, seen: seen, visiting: visiting, sources: sources, module_paths: module_paths, module_declared_map: module_declared_map, module_exported_map: module_exported_map, module_source_cache: module_source_cache, import_path_cache: import_path_cache, all_declared_names: all_declared_names, all_exported_declared_names: all_exported_declared_names, all_extern_declared_names: all_extern_declared_names, lint_enabled: lint_enabled, max_effective_lines: max_effective_lines, module_cycles: module_cycles, recursion_depth: recursion_depth, this: __tuff_outer_for_gather_module_sources };
  filePath = module_normalize_path(filePath); if (typeof __tuff_this !== 'undefined') __tuff_this.filePath = filePath;
  moduleBasePath = module_normalize_path(moduleBasePath); if (typeof __tuff_this !== 'undefined') __tuff_this.moduleBasePath = moduleBasePath;
  if ((() => { const __recv = seen; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, filePath) : set_has(__recv, filePath); })()) {
  return 0;
}
  if ((() => { const __recv = visiting; const __prop = __recv?.["set_has"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.set_has; return __dyn ? __dyn(__recv.ref, filePath) : set_has(__recv, filePath); })()) {
  if ((lint_enabled === 1)) {
  (() => { const __recv = module_cycles; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, filePath) : vec_push(__recv, filePath); })();
  return 0;
}
  panic_with_code("E_MODULE_CYCLE", (() => { const __recv = "Module import cycle detected at "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, filePath) : str_concat(__recv, filePath); })(), "A module was revisited while still being loaded, which means the import graph contains a cycle.", "Break the cycle by extracting shared declarations into a third module imported by both sides.");
}
  (() => { const __recv = visiting; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, filePath) : set_add(__recv, filePath); })();
  let module_t0 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.module_t0 = module_t0;
  gather_prof_modules = (gather_prof_modules + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_modules = gather_prof_modules;
  let source = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.source = source;
  if ((() => { const __recv = module_source_cache; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, filePath) : map_has(__recv, filePath); })()) {
  source = (() => { const __recv = module_source_cache; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, filePath) : map_get(__recv, filePath); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.source = source;
} else {
  let t_read_0 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t_read_0 = t_read_0;
  source = read_file(filePath); if (typeof __tuff_this !== 'undefined') __tuff_this.source = source;
  gather_prof_read_file_ms = (gather_prof_read_file_ms + (perf_now_out() - t_read_0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_read_file_ms = gather_prof_read_file_ms;
  (() => { const __recv = module_source_cache; const __prop = __recv?.["map_set"]; if (typeof __prop === "function") return __prop(filePath, source); const __dyn = __recv?.table?.map_set; return __dyn ? __dyn(__recv.ref, filePath, source) : map_set(__recv, filePath, source); })();
}
  let t_parse_0 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t_parse_0 = t_parse_0;
  lex_init(source);
  lex_all();
  if ((lint_enabled === 1)) {
  lint_check_current_file_length(filePath, max_effective_lines);
}
  parse_init();
  let program = p_parse_program(); if (typeof __tuff_this !== 'undefined') __tuff_this.program = program;
  gather_prof_lex_parse_ms = (gather_prof_lex_parse_ms + (perf_now_out() - t_parse_0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_lex_parse_ms = gather_prof_lex_parse_ms;
  let stmts = node_get_data1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let t_decl_0 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t_decl_0 = t_decl_0;
  let declared = module_collect_declared_sets(source, program, module_declared_map, module_exported_map, filePath, all_declared_names, all_exported_declared_names, all_extern_declared_names); if (typeof __tuff_this !== 'undefined') __tuff_this.declared = declared;
  gather_prof_decl_collect_ms = (gather_prof_decl_collect_ms + (perf_now_out() - t_decl_0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_decl_collect_ms = gather_prof_decl_collect_ms;
  let imports = module_snapshot_import_specs(stmts, moduleBasePath, import_path_cache); if (typeof __tuff_this !== 'undefined') __tuff_this.imports = imports;
  let imported_names = module_collect_imported_names(imports); if (typeof __tuff_this !== 'undefined') __tuff_this.imported_names = imported_names;
  let implicit_candidates = module_collect_implicit_import_candidates(program, declared, imported_names); if (typeof __tuff_this !== 'undefined') __tuff_this.implicit_candidates = implicit_candidates;
  module_walk_imports(imports, moduleBasePath, seen, visiting, sources, module_paths, module_declared_map, module_exported_map, module_source_cache, import_path_cache, all_declared_names, all_exported_declared_names, all_extern_declared_names, lint_enabled, max_effective_lines, module_cycles, recursion_depth);
  let t_implicit_0 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t_implicit_0 = t_implicit_0;
  module_assert_no_implicit_imports(implicit_candidates, all_exported_declared_names, all_extern_declared_names);
  gather_prof_implicit_check_ms = (gather_prof_implicit_check_ms + (perf_now_out() - t_implicit_0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gather_prof_implicit_check_ms = gather_prof_implicit_check_ms;
  (() => { const __recv = visiting; const __prop = __recv?.["set_delete"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.set_delete; return __dyn ? __dyn(__recv.ref, filePath) : set_delete(__recv, filePath); })();
  (() => { const __recv = seen; const __prop = __recv?.["set_add"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.set_add; return __dyn ? __dyn(__recv.ref, filePath) : set_add(__recv, filePath); })();
  (() => { const __recv = sources; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(source); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, source) : vec_push(__recv, source); })();
  (() => { const __recv = module_paths; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, filePath) : vec_push(__recv, filePath); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.gather_module_sources = gather_module_sources;

const __tuff_outer_for_compile_file = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function compile_file(inputPath, outputPath) {
  let __tuff_this = { inputPath: inputPath, outputPath: outputPath, this: __tuff_outer_for_compile_file };
  return compile_file_with_options(inputPath, outputPath, 0, 500, 1, "js");
}
if (typeof __tuff_this !== 'undefined') __tuff_this.compile_file = compile_file;

const __tuff_outer_for_compile_file_with_options = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function compile_file_with_options(inputPath, outputPath, lint_enabled, max_effective_lines, borrow_enabled, target) {
  let __tuff_this = { inputPath: inputPath, outputPath: outputPath, lint_enabled: lint_enabled, max_effective_lines: max_effective_lines, borrow_enabled: borrow_enabled, target: target, this: __tuff_outer_for_compile_file_with_options };
  let max_lines = module_loader_sanitize_max_effective_lines(max_effective_lines); if (typeof __tuff_this !== 'undefined') __tuff_this.max_lines = max_lines;
  let lint = module_loader_normalize_flag(lint_enabled); if (typeof __tuff_this !== 'undefined') __tuff_this.lint = lint;
  let borrow = module_loader_normalize_flag(borrow_enabled); if (typeof __tuff_this !== 'undefined') __tuff_this.borrow = borrow;
  inputPath = module_normalize_path(inputPath); if (typeof __tuff_this !== 'undefined') __tuff_this.inputPath = inputPath;
  let moduleBasePath = module_normalize_path(path_dirname(inputPath)); if (typeof __tuff_this !== 'undefined') __tuff_this.moduleBasePath = moduleBasePath;
  let seen = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.seen = seen;
  let visiting = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.visiting = visiting;
  let sources = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sources = sources;
  let module_paths = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.module_paths = module_paths;
  let module_declared_map = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.module_declared_map = module_declared_map;
  let module_exported_map = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.module_exported_map = module_exported_map;
  let module_source_cache = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.module_source_cache = module_source_cache;
  let import_path_cache = map_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.import_path_cache = import_path_cache;
  let all_declared_names = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.all_declared_names = all_declared_names;
  let all_exported_declared_names = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.all_exported_declared_names = all_exported_declared_names;
  let all_extern_declared_names = set_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.all_extern_declared_names = all_extern_declared_names;
  let module_cycles = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.module_cycles = module_cycles;
  gather_prof_reset();
  lint_reset();
  sourcemap_init();
  let t0 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t0 = t0;
  gather_module_sources(inputPath, moduleBasePath, seen, visiting, sources, module_paths, module_declared_map, module_exported_map, module_source_cache, import_path_cache, all_declared_names, all_exported_declared_names, all_extern_declared_names, lint, max_lines, module_cycles, 0);
  let t1 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t1 = t1;
  let sm_i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.sm_i = sm_i;
  let sm_line = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.sm_line = sm_line;
  while ((sm_i < (() => { const __recv = module_paths; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  let sm_path = (() => { const __recv = module_paths; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(sm_i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, sm_i) : vec_get(__recv, sm_i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.sm_path = sm_path;
  let sm_src = (() => { const __recv = sources; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(sm_i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, sm_i) : vec_get(__recv, sm_i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.sm_src = sm_src;
  sourcemap_add(sm_path, sm_line);
  sm_line = ((sm_line + sourcemap_count_lines(sm_src)) + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.sm_line = sm_line;
  sm_i = (sm_i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.sm_i = sm_i;
}
  let joined = join_sources(sources); if (typeof __tuff_this !== 'undefined') __tuff_this.joined = joined;
  let merged = module_with_c_runtime_prelude(joined, target); if (typeof __tuff_this !== 'undefined') __tuff_this.merged = merged;
  let t2 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2 = t2;
  lex_init(merged);
  lex_all();
  parse_init();
  let program = p_parse_program(); if (typeof __tuff_this !== 'undefined') __tuff_this.program = program;
  program = strip_import_decls(program); if (typeof __tuff_this !== 'undefined') __tuff_this.program = program;
  let t3 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t3 = t3;
  let desugared = desugar(program); if (typeof __tuff_this !== 'undefined') __tuff_this.desugared = desugared;
  let resolved = resolve_names(desugared); if (typeof __tuff_this !== 'undefined') __tuff_this.resolved = resolved;
  let t4 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t4 = t4;
  let typed = typecheck_program_with_options(resolved); if (typeof __tuff_this !== 'undefined') __tuff_this.typed = typed;
  let t5 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t5 = t5;
  if ((borrow === 1)) {
  borrowcheck_program(typed);
}
  let t6 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t6 = t6;
  if ((lint === 1)) {
  lint_program(typed, inputPath, max_lines, 0);
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = module_cycles; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  lint_add_circular_import_issue((() => { const __recv = module_cycles; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
}
  let t7 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t7 = t7;
  let emitted = module_emit_target_output(typed, merged, target); if (typeof __tuff_this !== 'undefined') __tuff_this.emitted = emitted;
  let t8 = perf_now_out(); if (typeof __tuff_this !== 'undefined') __tuff_this.t8 = t8;
  return write_file(outputPath, emitted);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.compile_file_with_options = compile_file_with_options;

const __tuff_outer_for_p_has_generic_call_suffix = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_has_generic_call_suffix() {
  let __tuff_this = { this: __tuff_outer_for_p_has_generic_call_suffix };
  if ((!p_at(TK_SYMBOL, "<"))) {
  return false;
}
  if ((!p_can_start_type_tok_at(1))) {
  return false;
}
  let cursor = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cursor = cursor;
  let depth = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.depth = depth;
  while (true) {
  if ((cursor > 200000)) {
  p_error_with_token_context("Parser watchdog: generic-call suffix scan exceeded 200000 tokens");
}
  let ti = p_peek(cursor); if (typeof __tuff_this !== 'undefined') __tuff_this.ti = ti;
  let tk = tok_kind(ti); if (typeof __tuff_this !== 'undefined') __tuff_this.tk = tk;
  if ((tk === TK_EOF)) {
  return false;
}
  if ((tk === TK_SYMBOL)) {
  let sym = get_interned_str(tok_value(ti)); if (typeof __tuff_this !== 'undefined') __tuff_this.sym = sym;
  if ((() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<") : str_eq(__recv, "<"); })()) {
  depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.depth = depth;
} else { if ((() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(">"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ">") : str_eq(__recv, ">"); })()) {
  depth = (depth - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.depth = depth;
  if ((depth === 0)) {
  let next = p_peek((cursor + 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((tok_kind(next) === TK_SYMBOL)) {
  let next_sym = get_interned_str(tok_value(next)); if (typeof __tuff_this !== 'undefined') __tuff_this.next_sym = next_sym;
  return (() => { const __recv = next_sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "(") : str_eq(__recv, "("); })();
}
  return false;
}
} }
}
  cursor = (cursor + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cursor = cursor;
}
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_has_generic_call_suffix = p_has_generic_call_suffix;

const __tuff_outer_for_p_has_generic_struct_init_suffix = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_has_generic_struct_init_suffix() {
  let __tuff_this = { this: __tuff_outer_for_p_has_generic_struct_init_suffix };
  if ((!p_at(TK_SYMBOL, "<"))) {
  return false;
}
  if ((!p_can_start_type_tok_at(1))) {
  return false;
}
  let cursor = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cursor = cursor;
  let depth = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.depth = depth;
  while (true) {
  if ((cursor > 200000)) {
  p_error_with_token_context("Parser watchdog: generic-struct-init suffix scan exceeded 200000 tokens");
}
  let ti = p_peek(cursor); if (typeof __tuff_this !== 'undefined') __tuff_this.ti = ti;
  let tk = tok_kind(ti); if (typeof __tuff_this !== 'undefined') __tuff_this.tk = tk;
  if ((tk === TK_EOF)) {
  return false;
}
  if ((tk === TK_SYMBOL)) {
  let sym = get_interned_str(tok_value(ti)); if (typeof __tuff_this !== 'undefined') __tuff_this.sym = sym;
  if ((() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<") : str_eq(__recv, "<"); })()) {
  depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.depth = depth;
} else { if ((() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(">"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ">") : str_eq(__recv, ">"); })()) {
  depth = (depth - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.depth = depth;
  if ((depth === 0)) {
  let next = p_peek((cursor + 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((tok_kind(next) === TK_SYMBOL)) {
  let next_sym = get_interned_str(tok_value(next)); if (typeof __tuff_this !== 'undefined') __tuff_this.next_sym = next_sym;
  return (() => { const __recv = next_sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("{"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "{") : str_eq(__recv, "{"); })();
}
  return false;
}
} }
}
  cursor = (cursor + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cursor = cursor;
}
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_has_generic_struct_init_suffix = p_has_generic_struct_init_suffix;

const __tuff_outer_for_p_has_generic_value_suffix = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_has_generic_value_suffix() {
  let __tuff_this = { this: __tuff_outer_for_p_has_generic_value_suffix };
  if ((!p_at(TK_SYMBOL, "<"))) {
  return false;
}
  if ((!p_can_start_type_tok_at(1))) {
  return false;
}
  let cursor = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cursor = cursor;
  let depth = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.depth = depth;
  while (true) {
  if ((cursor > 200000)) {
  p_error_with_token_context("Parser watchdog: generic-value suffix scan exceeded 200000 tokens");
}
  let ti = p_peek(cursor); if (typeof __tuff_this !== 'undefined') __tuff_this.ti = ti;
  let tk = tok_kind(ti); if (typeof __tuff_this !== 'undefined') __tuff_this.tk = tk;
  if ((tk === TK_EOF)) {
  return false;
}
  if ((tk === TK_SYMBOL)) {
  let sym = get_interned_str(tok_value(ti)); if (typeof __tuff_this !== 'undefined') __tuff_this.sym = sym;
  if ((() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "<") : str_eq(__recv, "<"); })()) {
  depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.depth = depth;
} else { if ((() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(">"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ">") : str_eq(__recv, ">"); })()) {
  depth = (depth - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.depth = depth;
  if ((depth === 0)) {
  let next = p_peek((cursor + 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((tok_kind(next) === TK_SYMBOL)) {
  let next_sym = get_interned_str(tok_value(next)); if (typeof __tuff_this !== 'undefined') __tuff_this.next_sym = next_sym;
  if ((() => { const __recv = next_sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "(") : str_eq(__recv, "("); })()) {
  return false;
}
}
  return true;
}
} }
}
  cursor = (cursor + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cursor = cursor;
}
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_has_generic_value_suffix = p_has_generic_value_suffix;

const __tuff_outer_for_p_parse_generic_arg_value_or_type = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_generic_arg_value_or_type() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_generic_arg_value_or_type };
  let t0 = p_peek(0); if (typeof __tuff_this !== 'undefined') __tuff_this.t0 = t0;
  if (((tok_kind(t0) === TK_IDENTIFIER) && (tok_kind(p_peek(1)) === TK_SYMBOL))) {
  let s1 = get_interned_str(tok_value(p_peek(1))); if (typeof __tuff_this !== 'undefined') __tuff_this.s1 = s1;
  if ((() => { const __recv = s1; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ".") : str_eq(__recv, "."); })()) {
  return p_parse_expression(5);
}
}
  let cursor = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cursor = cursor;
  let paren_depth = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.paren_depth = paren_depth;
  let bracket_depth = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.bracket_depth = bracket_depth;
  while (true) {
  if ((cursor > 200000)) {
  p_error_with_token_context("Parser watchdog: generic-arg scan exceeded 200000 tokens");
}
  let ti = p_peek(cursor); if (typeof __tuff_this !== 'undefined') __tuff_this.ti = ti;
  let tk = tok_kind(ti); if (typeof __tuff_this !== 'undefined') __tuff_this.tk = tk;
  if ((tk === TK_EOF)) {
  break;
}
  if ((tk === TK_SYMBOL)) {
  let sym = get_interned_str(tok_value(ti)); if (typeof __tuff_this !== 'undefined') __tuff_this.sym = sym;
  if ((() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "(") : str_eq(__recv, "("); })()) {
  paren_depth = (paren_depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.paren_depth = paren_depth;
} else { if ((() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ")") : str_eq(__recv, ")"); })()) {
  if ((paren_depth > 0)) {
  paren_depth = (paren_depth - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.paren_depth = paren_depth;
}
} else { if ((() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("["); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "[") : str_eq(__recv, "["); })()) {
  bracket_depth = (bracket_depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.bracket_depth = bracket_depth;
} else { if ((() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "]") : str_eq(__recv, "]"); })()) {
  if ((bracket_depth > 0)) {
  bracket_depth = (bracket_depth - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.bracket_depth = bracket_depth;
}
} else { if ((((paren_depth === 0) && (bracket_depth === 0)) && ((() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ",") : str_eq(__recv, ","); })() || (() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(">"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ">") : str_eq(__recv, ">"); })()))) {
  break;
} else { if ((((paren_depth === 0) && (bracket_depth === 0)) && (((((((cursor > 0) && (() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, ".") : str_eq(__recv, "."); })()) || ((cursor > 0) && (() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("+"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "+") : str_eq(__recv, "+"); })())) || ((cursor > 0) && (() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "-") : str_eq(__recv, "-"); })())) || ((cursor > 0) && (() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "*") : str_eq(__recv, "*"); })())) || ((cursor > 0) && (() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("/"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "/") : str_eq(__recv, "/"); })())) || ((cursor > 0) && (() => { const __recv = sym; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("%"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "%") : str_eq(__recv, "%"); })())))) {
  return p_parse_expression(5);
} } } } } }
}
  cursor = (cursor + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cursor = cursor;
}
  return p_parse_type();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_generic_arg_value_or_type = p_parse_generic_arg_value_or_type;

const __tuff_outer_for_p_try_parse_into_generic_value_call = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_try_parse_into_generic_value_call(expr) {
  let __tuff_this = { expr: expr, this: __tuff_outer_for_p_try_parse_into_generic_value_call };
  if ((!((((node_kind(expr) === NK_MEMBER_EXPR) && (() => { const __recv = get_interned_str(node_get_data2(expr)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "into") : str_eq(__recv, "into"); })()) && p_at(TK_SYMBOL, "<")) && p_has_generic_value_suffix()))) {
  return 0;
}
  p_eat();
  let type_args = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.type_args = type_args;
  if ((!p_at(TK_SYMBOL, ">"))) {
  (() => { const __recv = type_args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_generic_arg_value_or_type()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_generic_arg_value_or_type()) : vec_push(__recv, p_parse_generic_arg_value_or_type()); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = type_args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_generic_arg_value_or_type()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_generic_arg_value_or_type()) : vec_push(__recv, p_parse_generic_arg_value_or_type()); })();
}
}
  p_expect(TK_SYMBOL, ">", "Expected '>' after into type args");
  let recv = node_get_data1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.recv = recv;
  let prop = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  let args = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  (() => { const __recv = args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(recv); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, recv) : vec_push(__recv, recv); })();
  let callee = node_new(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  node_set_data1(callee, prop);
  let into_value = node_new(NK_CALL_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.into_value = into_value;
  node_set_data1(into_value, callee);
  node_set_data2(into_value, args);
  node_set_data3(into_value, 1);
  node_set_data4(into_value, type_args);
  node_set_data5(into_value, 1);
  return into_value;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_try_parse_into_generic_value_call = p_try_parse_into_generic_value_call;

const __tuff_outer_for_p_parse_call_args = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_call_args() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_call_args };
  let args = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if ((!p_at(TK_SYMBOL, ")"))) {
  (() => { const __recv = args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_expression(0)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_expression(0)) : vec_push(__recv, p_parse_expression(0)); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_expression(0)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_expression(0)) : vec_push(__recv, p_parse_expression(0)); })();
}
}
  return args;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_call_args = p_parse_call_args;

const __tuff_outer_for_p_lower_member_call = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_lower_member_call(expr, args, type_args, has_type_args) {
  let __tuff_this = { expr: expr, args: args, type_args: type_args, has_type_args: has_type_args, this: __tuff_outer_for_p_lower_member_call };
  let recv = node_get_data1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.recv = recv;
  let prop = node_get_data2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  let lowered_args = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.lowered_args = lowered_args;
  (() => { const __recv = lowered_args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(recv); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, recv) : vec_push(__recv, recv); })();
  let ai = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ai = ai;
  let alen = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alen = alen;
  while ((ai < alen)) {
  (() => { const __recv = lowered_args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(ai); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, ai) : vec_get(__recv, ai); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(ai); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, ai) : vec_get(__recv, ai); })()) : vec_push(__recv, (() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(ai); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, ai) : vec_get(__recv, ai); })()); })();
  ai = (ai + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.ai = ai;
}
  let callee = node_new(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  node_set_data1(callee, prop);
  let call = node_new(NK_CALL_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.call = call;
  node_set_data1(call, callee);
  node_set_data2(call, lowered_args);
  node_set_data3(call, 1);
  if ((has_type_args === 1)) {
  node_set_data4(call, type_args);
}
  return call;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_lower_member_call = p_lower_member_call;

const __tuff_outer_for_p_try_parse_generic_call = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_try_parse_generic_call(expr) {
  let __tuff_this = { expr: expr, this: __tuff_outer_for_p_try_parse_generic_call };
  if ((!(p_at(TK_SYMBOL, "<") && p_has_generic_call_suffix()))) {
  return 0;
}
  p_eat();
  let type_args = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.type_args = type_args;
  if ((!p_at(TK_SYMBOL, ">"))) {
  (() => { const __recv = type_args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_generic_arg_value_or_type()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_generic_arg_value_or_type()) : vec_push(__recv, p_parse_generic_arg_value_or_type()); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = type_args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_generic_arg_value_or_type()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_generic_arg_value_or_type()) : vec_push(__recv, p_parse_generic_arg_value_or_type()); })();
}
}
  p_expect(TK_SYMBOL, ">", "Expected '>' after generic call type args");
  p_expect(TK_SYMBOL, "(", "Expected '(' after generic call type args");
  let args = p_parse_call_args(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  p_expect(TK_SYMBOL, ")", "Expected ')' after call args");
  if ((node_kind(expr) === NK_MEMBER_EXPR)) {
  return p_lower_member_call(expr, args, type_args, 1);
}
  let call = node_new(NK_CALL_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.call = call;
  node_set_data1(call, expr);
  node_set_data2(call, args);
  node_set_data3(call, 0);
  node_set_data4(call, type_args);
  return call;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_try_parse_generic_call = p_try_parse_generic_call;

const __tuff_outer_for_p_try_parse_call = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_try_parse_call(expr) {
  let __tuff_this = { expr: expr, this: __tuff_outer_for_p_try_parse_call };
  if ((!p_at(TK_SYMBOL, "("))) {
  return 0;
}
  p_eat();
  let args = p_parse_call_args(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  p_expect(TK_SYMBOL, ")", "Expected ')'");
  if ((node_kind(expr) === NK_MEMBER_EXPR)) {
  return p_lower_member_call(expr, args, vec_new(), 0);
}
  let call = node_new(NK_CALL_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.call = call;
  node_set_data1(call, expr);
  node_set_data2(call, args);
  node_set_data3(call, 0);
  return call;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_try_parse_call = p_try_parse_call;

const __tuff_outer_for_p_try_parse_member = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_try_parse_member(expr) {
  let __tuff_this = { expr: expr, this: __tuff_outer_for_p_try_parse_member };
  if ((!p_at(TK_SYMBOL, "."))) {
  return 0;
}
  p_eat();
  let prop = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  if (p_at_kind(TK_IDENTIFIER)) {
  prop = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
} else { if (p_at_kind(TK_KEYWORD)) {
  prop = tok_value(p_eat()); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
} else {
  p_error_with_token_context("Expected member name after '.'");
} }
  let member = node_new(NK_MEMBER_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.member = member;
  node_set_data1(member, expr);
  node_set_data2(member, prop);
  return member;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_try_parse_member = p_try_parse_member;

const __tuff_outer_for_p_try_parse_index_or_unwrap = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_try_parse_index_or_unwrap(expr) {
  let __tuff_this = { expr: expr, this: __tuff_outer_for_p_try_parse_index_or_unwrap };
  if (p_at(TK_SYMBOL, "[")) {
  p_eat();
  let idx_expr = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.idx_expr = idx_expr;
  p_expect(TK_SYMBOL, "]", "Expected ']'");
  let idx_node = node_new(NK_INDEX_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.idx_node = idx_node;
  node_set_data1(idx_node, expr);
  node_set_data2(idx_node, idx_expr);
  return idx_node;
}
  if (p_at(TK_SYMBOL, "?")) {
  p_eat();
  let unwrap = node_new(NK_UNWRAP_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.unwrap = unwrap;
  node_set_data1(unwrap, expr);
  return unwrap;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_try_parse_index_or_unwrap = p_try_parse_index_or_unwrap;

const __tuff_outer_for_p_parse_postfix = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_postfix(exprIn) {
  let __tuff_this = { exprIn: exprIn, this: __tuff_outer_for_p_parse_postfix };
  let expr = exprIn; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  let postfix_watchdog = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.postfix_watchdog = postfix_watchdog;
  while (true) {
  postfix_watchdog = (postfix_watchdog + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.postfix_watchdog = postfix_watchdog;
  if ((postfix_watchdog > 10000)) {
  p_error_with_token_context("Parser watchdog: postfix loop exceeded 10000 iterations");
}
  let next = p_try_parse_into_generic_value_call(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((next !== 0)) {
  expr = next; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  continue;
}
  next = p_try_parse_generic_call(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((next !== 0)) {
  expr = next; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  continue;
}
  next = p_try_parse_call(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((next !== 0)) {
  expr = next; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  continue;
}
  next = p_try_parse_member(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((next !== 0)) {
  expr = next; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  continue;
}
  next = p_try_parse_index_or_unwrap(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((next !== 0)) {
  expr = next; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  continue;
}
  break;
}
  return expr;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_postfix = p_parse_postfix;

const __tuff_outer_for_selfhost_parser_expr_postfix_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_parser_expr_postfix_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_parser_expr_postfix_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_parser_expr_postfix_marker = selfhost_parser_expr_postfix_marker;

const __tuff_outer_for_p_parse_primary_array = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_primary_array() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_primary_array };
  p_eat();
  let items = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  if ((!p_at(TK_SYMBOL, "]"))) {
  (() => { const __recv = items; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_expression(0)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_expression(0)) : vec_push(__recv, p_parse_expression(0)); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  if (p_at(TK_SYMBOL, "]")) {
  break;
}
  (() => { const __recv = items; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_expression(0)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_expression(0)) : vec_push(__recv, p_parse_expression(0)); })();
}
}
  p_expect(TK_SYMBOL, "]", "Expected ']' in array literal");
  let node = node_new(NK_TUPLE_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, items);
  return p_parse_postfix(node);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_primary_array = p_parse_primary_array;

const __tuff_outer_for_p_parse_primary_basic_literal = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_primary_basic_literal(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_p_parse_primary_basic_literal };
  let t = p_eat(); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let node = node_new(kind); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, tok_value(t));
  return p_parse_postfix(node);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_primary_basic_literal = p_parse_primary_basic_literal;

const __tuff_outer_for_p_try_parse_paren_lambda = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_try_parse_paren_lambda() {
  let __tuff_this = { this: __tuff_outer_for_p_try_parse_paren_lambda };
  if ((!p_at(TK_SYMBOL, "("))) {
  return 0;
}
  let mark = p_mark(); if (typeof __tuff_this !== 'undefined') __tuff_this.mark = mark;
  p_eat();
  let params = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let valid = true; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
  if ((!p_at(TK_SYMBOL, ")"))) {
  while (true) {
  if ((!p_at_kind(TK_IDENTIFIER))) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
  break;
}
  let pname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  ptype = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
  let param = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, pname) : vec_push(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, ptype) : vec_push(__recv, ptype); })();
  (() => { const __recv = params; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, param) : vec_push(__recv, param); })();
  if (p_at(TK_SYMBOL, ",")) {
  p_eat();
  continue;
}
  break;
}
}
  if ((valid && p_at(TK_SYMBOL, ")"))) {
  p_eat();
  if (p_at(TK_SYMBOL, "=>")) {
  p_eat();
  let body = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if (p_at(TK_SYMBOL, "{")) {
  body = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
} else {
  body = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
}
  let lam = node_new(NK_LAMBDA_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.lam = lam;
  node_set_data1(lam, params);
  node_set_data2(lam, body);
  return p_parse_postfix(lam);
}
}
  p_restore(mark);
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_try_parse_paren_lambda = p_try_parse_paren_lambda;

const __tuff_outer_for_p_parse_primary_fn_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_primary_fn_expr() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_primary_fn_expr };
  p_eat();
  let fname = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if (p_at_kind(TK_IDENTIFIER)) {
  fname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
}
  let generics = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  if (p_at(TK_SYMBOL, "<")) {
  p_eat();
  if ((!p_at(TK_SYMBOL, ">"))) {
  while (true) {
  (() => { const __recv = generics; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_identifier()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_identifier()) : vec_push(__recv, p_parse_identifier()); })();
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  p_parse_type();
}
  if ((!p_at(TK_SYMBOL, ","))) {
  break;
}
  p_eat();
}
}
  p_expect(TK_SYMBOL, ">", "Expected '>'");
}
  p_expect(TK_SYMBOL, "(", "Expected '(' in function expression");
  let params = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  if ((!p_at(TK_SYMBOL, ")"))) {
  while (true) {
  let pname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  ptype = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
  let param = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, pname) : vec_push(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, ptype) : vec_push(__recv, ptype); })();
  (() => { const __recv = params; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, param) : vec_push(__recv, param); })();
  if ((!p_at(TK_SYMBOL, ","))) {
  break;
}
  p_eat();
}
}
  p_expect(TK_SYMBOL, ")", "Expected ')' after params");
  let ret = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
  if (p_at(TK_SYMBOL, ":")) {
  p_eat();
  ret = p_parse_type(); if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
}
  p_expect(TK_SYMBOL, "=>", "Expected '=>' in function expression");
  let body = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if (p_at(TK_SYMBOL, "{")) {
  body = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
} else {
  body = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
}
  let fnexpr = node_new(NK_FN_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.fnexpr = fnexpr;
  node_set_data1(fnexpr, fname);
  node_set_data2(fnexpr, generics);
  node_set_data3(fnexpr, params);
  node_set_data4(fnexpr, ret);
  node_set_data5(fnexpr, body);
  return p_parse_postfix(fnexpr);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_primary_fn_expr = p_parse_primary_fn_expr;

const __tuff_outer_for_p_try_parse_identifier_lambda = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_try_parse_identifier_lambda() {
  let __tuff_this = { this: __tuff_outer_for_p_try_parse_identifier_lambda };
  if ((!((p_at_kind(TK_IDENTIFIER) && (tok_kind(p_peek(1)) === TK_SYMBOL)) && (() => { const __recv = get_interned_str(tok_value(p_peek(1))); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("=>"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "=>") : str_eq(__recv, "=>"); })()))) {
  return 0;
}
  let pname = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  p_expect(TK_SYMBOL, "=>", "Expected '=>' in lambda expression");
  let param = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, pname) : vec_push(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, 0) : vec_push(__recv, 0); })();
  let params = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  (() => { const __recv = params; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, param) : vec_push(__recv, param); })();
  let body = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if (p_at(TK_SYMBOL, "{")) {
  body = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
} else {
  body = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
}
  let lam = node_new(NK_LAMBDA_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.lam = lam;
  node_set_data1(lam, params);
  node_set_data2(lam, body);
  return p_parse_postfix(lam);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_try_parse_identifier_lambda = p_try_parse_identifier_lambda;

const __tuff_outer_for_p_parse_primary_paren_or_tuple = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_primary_paren_or_tuple() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_primary_paren_or_tuple };
  p_eat();
  let first = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.first = first;
  if (p_at(TK_SYMBOL, ",")) {
  let items = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  (() => { const __recv = items; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(first); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, first) : vec_push(__recv, first); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = items; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_expression(0)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_expression(0)) : vec_push(__recv, p_parse_expression(0)); })();
}
  p_expect(TK_SYMBOL, ")", "Expected ')' after tuple expression");
  let tuple = node_new(NK_TUPLE_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.tuple = tuple;
  node_set_data1(tuple, items);
  return p_parse_postfix(tuple);
}
  p_expect(TK_SYMBOL, ")", "Expected ')'");
  return p_parse_postfix(first);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_primary_paren_or_tuple = p_parse_primary_paren_or_tuple;

const __tuff_outer_for_p_parse_primary_if_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_primary_if_expr() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_primary_if_expr };
  p_eat();
  p_expect(TK_SYMBOL, "(", "Expected '(' after if");
  let cond = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  p_expect(TK_SYMBOL, ")", "Expected ')' after condition");
  let then_branch = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.then_branch = then_branch;
  if (p_at(TK_SYMBOL, "{")) {
  then_branch = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.then_branch = then_branch;
} else {
  then_branch = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.then_branch = then_branch;
}
  let else_branch = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.else_branch = else_branch;
  if (p_at(TK_KEYWORD, "else")) {
  p_eat();
  if (p_at(TK_SYMBOL, "{")) {
  else_branch = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.else_branch = else_branch;
} else {
  else_branch = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.else_branch = else_branch;
}
}
  let node = node_new(NK_IF_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, cond);
  node_set_data2(node, then_branch);
  node_set_data3(node, else_branch);
  return p_parse_postfix(node);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_primary_if_expr = p_parse_primary_if_expr;

const __tuff_outer_for_p_parse_primary_match_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_primary_match_expr() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_primary_match_expr };
  p_eat();
  p_expect(TK_SYMBOL, "(", "Expected '(' after match");
  let target = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  p_expect(TK_SYMBOL, ")", "Expected ')' after match target");
  p_expect(TK_SYMBOL, "{", "Expected '{'");
  let cases = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  while ((!p_at(TK_SYMBOL, "}"))) {
  p_expect(TK_KEYWORD, "case", "Expected 'case'");
  let pat = p_parse_pattern(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  p_expect(TK_SYMBOL, "=", "Expected '='");
  let body = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if (p_at(TK_SYMBOL, "{")) {
  body = p_parse_block(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
} else {
  body = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
}
  p_expect(TK_SYMBOL, ";", "Expected ';' after case");
  let case_node = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.case_node = case_node;
  (() => { const __recv = case_node; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(pat); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, pat) : vec_push(__recv, pat); })();
  (() => { const __recv = case_node; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(body); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, body) : vec_push(__recv, body); })();
  (() => { const __recv = cases; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(case_node); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, case_node) : vec_push(__recv, case_node); })();
}
  p_expect(TK_SYMBOL, "}", "Expected '}'");
  let node = node_new(NK_MATCH_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, target);
  node_set_data2(node, cases);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_primary_match_expr = p_parse_primary_match_expr;

const __tuff_outer_for_p_parse_primary_identifier_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_primary_identifier_expr() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_primary_identifier_expr };
  let name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let expr = node_new(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  node_set_data1(expr, name);
  let generic_args = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.generic_args = generic_args;
  let is_type_like = false; if (typeof __tuff_this !== 'undefined') __tuff_this.is_type_like = is_type_like;
  let name_text = get_interned_str(name); if (typeof __tuff_this !== 'undefined') __tuff_this.name_text = name_text;
  if (((() => { const __recv = name_text; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() > 0)) {
  let c0 = (() => { const __recv = name_text; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, 0) : str_char_at(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.c0 = c0;
  if (((c0 >= 65) && (c0 <= 90))) {
  is_type_like = true; if (typeof __tuff_this !== 'undefined') __tuff_this.is_type_like = is_type_like;
}
}
  if (((is_type_like && p_at(TK_SYMBOL, "<")) && (p_has_generic_struct_init_suffix() || p_has_generic_value_suffix()))) {
  p_eat();
  if ((!p_at(TK_SYMBOL, ">"))) {
  (() => { const __recv = generic_args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_generic_arg_value_or_type()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_generic_arg_value_or_type()) : vec_push(__recv, p_parse_generic_arg_value_or_type()); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = generic_args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_generic_arg_value_or_type()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_generic_arg_value_or_type()) : vec_push(__recv, p_parse_generic_arg_value_or_type()); })();
}
}
  p_expect(TK_SYMBOL, ">", "Expected '>' in generic struct initializer");
  node_set_data2(expr, generic_args);
}
  if (p_at(TK_SYMBOL, "{")) {
  p_eat();
  let fields = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  if ((!p_at(TK_SYMBOL, "}"))) {
  let key = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  p_expect(TK_SYMBOL, ":", "Expected ':' in struct init");
  let val = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  let field = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  (() => { const __recv = field; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(key); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, key) : vec_push(__recv, key); })();
  (() => { const __recv = field; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(val); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, val) : vec_push(__recv, val); })();
  (() => { const __recv = fields; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(field); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, field) : vec_push(__recv, field); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  let key2 = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.key2 = key2;
  p_expect(TK_SYMBOL, ":", "Expected ':'");
  let val2 = p_parse_expression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.val2 = val2;
  let field2 = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.field2 = field2;
  (() => { const __recv = field2; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(key2); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, key2) : vec_push(__recv, key2); })();
  (() => { const __recv = field2; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(val2); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, val2) : vec_push(__recv, val2); })();
  (() => { const __recv = fields; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(field2); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, field2) : vec_push(__recv, field2); })();
}
}
  p_expect(TK_SYMBOL, "}", "Expected '}'");
  let init_node = node_new(NK_STRUCT_INIT); if (typeof __tuff_this !== 'undefined') __tuff_this.init_node = init_node;
  node_set_data1(init_node, name);
  node_set_data2(init_node, fields);
  node_set_data3(init_node, generic_args);
  expr = init_node; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
}
  return p_parse_postfix(expr);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_primary_identifier_expr = p_parse_primary_identifier_expr;

const __tuff_outer_for_p_parse_primary = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_primary() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_primary };
  if (p_at(TK_SYMBOL, "[")) {
  return p_parse_primary_array();
}
  if (p_at_kind(TK_NUMBER)) {
  return p_parse_primary_basic_literal(NK_NUMBER_LIT);
}
  if (p_at_kind(TK_BOOL)) {
  return p_parse_primary_basic_literal(NK_BOOL_LIT);
}
  if (p_at_kind(TK_STRING)) {
  return p_parse_primary_basic_literal(NK_STRING_LIT);
}
  if (p_at_kind(TK_CHAR)) {
  return p_parse_primary_basic_literal(NK_CHAR_LIT);
}
  let paren_lambda = p_try_parse_paren_lambda(); if (typeof __tuff_this !== 'undefined') __tuff_this.paren_lambda = paren_lambda;
  if ((paren_lambda !== 0)) {
  return paren_lambda;
}
  if (p_at(TK_KEYWORD, "fn")) {
  return p_parse_primary_fn_expr();
}
  let id_lambda = p_try_parse_identifier_lambda(); if (typeof __tuff_this !== 'undefined') __tuff_this.id_lambda = id_lambda;
  if ((id_lambda !== 0)) {
  return id_lambda;
}
  if (p_at(TK_SYMBOL, "(")) {
  return p_parse_primary_paren_or_tuple();
}
  if (p_at(TK_KEYWORD, "if")) {
  return p_parse_primary_if_expr();
}
  if (p_at(TK_KEYWORD, "match")) {
  return p_parse_primary_match_expr();
}
  if (p_at_kind(TK_IDENTIFIER)) {
  return p_parse_primary_identifier_expr();
}
  p_error_with_token_context("Expected expression start (identifier, literal, '(', '[', 'if', 'match', or 'fn')");
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_primary = p_parse_primary;

const __tuff_outer_for_selfhost_parser_expr_primary_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_parser_expr_primary_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_parser_expr_primary_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_parser_expr_primary_marker = selfhost_parser_expr_primary_marker;

const __tuff_outer_for_p_parse_unary = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_unary() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_unary };
  if (((p_at(TK_SYMBOL, "!") || p_at(TK_SYMBOL, "-")) || p_at(TK_SYMBOL, "&"))) {
  let t = p_eat(); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let op = tok_value(t); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((() => { const __recv = get_interned_str(op); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&") : str_eq(__recv, "&"); })() && p_at(TK_KEYWORD, "mut"))) {
  p_eat();
  op = intern("&mut"); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
}
  let inner = p_parse_unary(); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let node = node_new(NK_UNARY_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, op);
  node_set_data2(node, inner);
  return node;
}
  return p_parse_primary();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_unary = p_parse_unary;

const __tuff_outer_for_p_get_precedence = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_get_precedence(op) {
  let __tuff_this = { op: op, this: __tuff_outer_for_p_get_precedence };
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("||"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "||") : map_has(__recv, "||"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("||"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "||") : map_get(__recv, "||"); })()))) {
  return 1;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("&&"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "&&") : map_has(__recv, "&&"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("&&"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "&&") : map_get(__recv, "&&"); })()))) {
  return 2;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("=="); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "==") : map_has(__recv, "=="); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("=="); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "==") : map_get(__recv, "=="); })()))) {
  return 3;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "!=") : map_has(__recv, "!="); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "!=") : map_get(__recv, "!="); })()))) {
  return 3;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "<") : map_has(__recv, "<"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "<") : map_get(__recv, "<"); })()))) {
  return 4;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "<=") : map_has(__recv, "<="); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "<=") : map_get(__recv, "<="); })()))) {
  return 4;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(">"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, ">") : map_has(__recv, ">"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(">"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, ">") : map_get(__recv, ">"); })()))) {
  return 4;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(">="); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, ">=") : map_has(__recv, ">="); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(">="); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, ">=") : map_get(__recv, ">="); })()))) {
  return 4;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop(".."); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "..") : map_has(__recv, ".."); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop(".."); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "..") : map_get(__recv, ".."); })()))) {
  return 4;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("+"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "+") : map_has(__recv, "+"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("+"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "+") : map_get(__recv, "+"); })()))) {
  return 5;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "-") : map_has(__recv, "-"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "-") : map_get(__recv, "-"); })()))) {
  return 5;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "*") : map_has(__recv, "*"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "*") : map_get(__recv, "*"); })()))) {
  return 6;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("/"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "/") : map_has(__recv, "/"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("/"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "/") : map_get(__recv, "/"); })()))) {
  return 6;
}
  if (((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("%"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "%") : map_has(__recv, "%"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("%"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "%") : map_get(__recv, "%"); })()))) {
  return 6;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_get_precedence = p_get_precedence;

const __tuff_outer_for_p_is_binary_op = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_is_binary_op() {
  let __tuff_this = { this: __tuff_outer_for_p_is_binary_op };
  if (p_at(TK_SYMBOL, "+")) {
  return true;
}
  if (p_at(TK_SYMBOL, "-")) {
  return true;
}
  if (p_at(TK_SYMBOL, "*")) {
  return true;
}
  if (p_at(TK_SYMBOL, "/")) {
  return true;
}
  if (p_at(TK_SYMBOL, "%")) {
  return true;
}
  if (p_at(TK_SYMBOL, "==")) {
  return true;
}
  if (p_at(TK_SYMBOL, "!=")) {
  return true;
}
  if (p_at(TK_SYMBOL, "<")) {
  return true;
}
  if (p_at(TK_SYMBOL, "<=")) {
  return true;
}
  if (p_at(TK_SYMBOL, ">")) {
  return true;
}
  if (p_at(TK_SYMBOL, ">=")) {
  return true;
}
  if (p_at(TK_SYMBOL, "..")) {
  return true;
}
  if (p_at(TK_SYMBOL, "&&")) {
  return true;
}
  if (p_at(TK_SYMBOL, "||")) {
  return true;
}
  if (p_at(TK_KEYWORD, "is")) {
  return true;
}
  if (p_at(TK_KEYWORD, "into")) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_is_binary_op = p_is_binary_op;

const __tuff_outer_for_p_parse_expression = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_expression(minPrec) {
  let __tuff_this = { minPrec: minPrec, this: __tuff_outer_for_p_parse_expression };
  let left = p_parse_unary(); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  let watchdog = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.watchdog = watchdog;
  while (p_is_binary_op()) {
  watchdog = (watchdog + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.watchdog = watchdog;
  if ((watchdog > 200000)) {
  p_error_with_token_context("Parser watchdog: binary-expression loop exceeded 200000 iterations");
}
  if (((minPrec <= 0) && p_at(TK_KEYWORD, "into"))) {
  p_eat();
  let contract_name = p_parse_identifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.contract_name = contract_name;
  let type_args = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.type_args = type_args;
  let contract_type = node_new(NK_NAMED_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.contract_type = contract_type;
  node_set_data1(contract_type, contract_name);
  node_set_data2(contract_type, vec_new());
  (() => { const __recv = type_args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(contract_type); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, contract_type) : vec_push(__recv, contract_type); })();
  let args = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  (() => { const __recv = args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(left); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, left) : vec_push(__recv, left); })();
  if (p_at(TK_SYMBOL, "(")) {
  p_eat();
  if ((!p_at(TK_SYMBOL, ")"))) {
  (() => { const __recv = args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_expression(0)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_expression(0)) : vec_push(__recv, p_parse_expression(0)); })();
  while (p_at(TK_SYMBOL, ",")) {
  p_eat();
  (() => { const __recv = args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(p_parse_expression(0)); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, p_parse_expression(0)) : vec_push(__recv, p_parse_expression(0)); })();
}
}
  p_expect(TK_SYMBOL, ")", "Expected ')' after into arguments");
}
  let call = node_new(NK_CALL_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.call = call;
  let callee = node_new(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  node_set_data1(callee, intern("into"));
  node_set_data1(call, callee);
  node_set_data2(call, args);
  node_set_data3(call, 1);
  node_set_data4(call, type_args);
  left = call; if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  continue;
}
  let op = tok_value(p_peek(0)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let prec = p_get_precedence(op); if (typeof __tuff_this !== 'undefined') __tuff_this.prec = prec;
  if (p_at(TK_KEYWORD, "is")) {
  p_eat();
  let pat = p_parse_pattern(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  let is_node = node_new(NK_IS_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.is_node = is_node;
  node_set_data1(is_node, left);
  node_set_data2(is_node, pat);
  left = is_node; if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  continue;
}
  if ((prec < minPrec)) {
  break;
}
  if ((((((((((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("+"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "+") : map_has(__recv, "+"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("+"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "+") : map_get(__recv, "+"); })())) || ((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "-") : map_has(__recv, "-"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "-") : map_get(__recv, "-"); })()))) || ((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "*") : map_has(__recv, "*"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "*") : map_get(__recv, "*"); })()))) || ((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("/"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "/") : map_has(__recv, "/"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("/"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "/") : map_get(__recv, "/"); })()))) || ((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("%"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "%") : map_has(__recv, "%"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("%"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "%") : map_get(__recv, "%"); })()))) || ((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "&") : map_has(__recv, "&"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "&") : map_get(__recv, "&"); })()))) || ((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "|") : map_has(__recv, "|"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "|") : map_get(__recv, "|"); })()))) || ((() => { const __recv = intern_map; const __prop = __recv?.["map_has"]; if (typeof __prop === "function") return __prop("^"); const __dyn = __recv?.table?.map_has; return __dyn ? __dyn(__recv.ref, "^") : map_has(__recv, "^"); })() && (op === (() => { const __recv = intern_map; const __prop = __recv?.["map_get"]; if (typeof __prop === "function") return __prop("^"); const __dyn = __recv?.table?.map_get; return __dyn ? __dyn(__recv.ref, "^") : map_get(__recv, "^"); })())))) {
  let next = p_peek(1); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if (((tok_kind(next) === TK_SYMBOL) && (() => { const __recv = get_interned_str(tok_value(next)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "=") : str_eq(__recv, "="); })())) {
  break;
}
}
  p_eat();
  let right = p_parse_expression((prec + 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let bin = node_new(NK_BINARY_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.bin = bin;
  node_set_data1(bin, op);
  node_set_data2(bin, left);
  node_set_data3(bin, right);
  left = bin; if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
}
  return left;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_expression = p_parse_expression;

const __tuff_outer_for_p_parse_block = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function p_parse_block() {
  let __tuff_this = { this: __tuff_outer_for_p_parse_block };
  p_expect(TK_SYMBOL, "{", "Expected '{'");
  let stmts = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  while (((!p_at(TK_SYMBOL, "}")) && (!p_at_kind(TK_EOF)))) {
  let before = p_mark(); if (typeof __tuff_this !== 'undefined') __tuff_this.before = before;
  let stmt = p_parse_statement(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let after = p_mark(); if (typeof __tuff_this !== 'undefined') __tuff_this.after = after;
  if ((after === before)) {
  p_error_with_token_context("Parser made no progress while parsing block statement");
}
  if ((node_kind(stmt) === NK_STMT_LIST)) {
  let inner = node_get_data1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = inner; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })())) {
  (() => { const __recv = stmts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop((() => { const __recv = inner; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, (() => { const __recv = inner; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()) : vec_push(__recv, (() => { const __recv = inner; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })()); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
} else {
  (() => { const __recv = stmts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(stmt); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, stmt) : vec_push(__recv, stmt); })();
}
}
  p_expect(TK_SYMBOL, "}", "Expected '}'");
  let node = node_new(NK_BLOCK); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  node_set_data1(node, stmts);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.p_parse_block = p_parse_block;

const __tuff_outer_for_selfhost_parser_expr_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_parser_expr_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_parser_expr_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_parser_expr_marker = selfhost_parser_expr_marker;

const __tuff_outer_for_js_ident_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function js_ident_expr(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_js_ident_expr };
  if ((() => { const __recv = name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "this") : str_eq(__recv, "this"); })()) {
  return "(typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this))";
}
  return name;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.js_ident_expr = js_ident_expr;

const __tuff_outer_for_cg_strip_num_suffix = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cg_strip_num_suffix(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_cg_strip_num_suffix };
  let n = (() => { const __recv = s; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  if (((n > 5) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((n - 5), n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (n - 5), n) : str_slice(__recv, (n - 5), n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "USize") : str_eq(__recv, "USize"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (n - 5)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (n - 5)) : str_slice(__recv, 0, (n - 5)); })();
}
  if (((n > 5) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((n - 5), n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (n - 5), n) : str_slice(__recv, (n - 5), n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("ISize"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "ISize") : str_eq(__recv, "ISize"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (n - 5)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (n - 5)) : str_slice(__recv, 0, (n - 5)); })();
}
  if (((n > 4) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((n - 4), n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (n - 4), n) : str_slice(__recv, (n - 4), n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U128"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U128") : str_eq(__recv, "U128"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (n - 4)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (n - 4)) : str_slice(__recv, 0, (n - 4)); })();
}
  if (((n > 4) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((n - 4), n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (n - 4), n) : str_slice(__recv, (n - 4), n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I128"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I128") : str_eq(__recv, "I128"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (n - 4)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (n - 4)) : str_slice(__recv, 0, (n - 4)); })();
}
  if (((n > 3) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((n - 3), n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (n - 3), n) : str_slice(__recv, (n - 3), n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U64"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U64") : str_eq(__recv, "U64"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (n - 3)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (n - 3)) : str_slice(__recv, 0, (n - 3)); })();
}
  if (((n > 3) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((n - 3), n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (n - 3), n) : str_slice(__recv, (n - 3), n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I64"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I64") : str_eq(__recv, "I64"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (n - 3)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (n - 3)) : str_slice(__recv, 0, (n - 3)); })();
}
  if (((n > 3) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((n - 3), n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (n - 3), n) : str_slice(__recv, (n - 3), n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U32") : str_eq(__recv, "U32"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (n - 3)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (n - 3)) : str_slice(__recv, 0, (n - 3)); })();
}
  if (((n > 3) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((n - 3), n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (n - 3), n) : str_slice(__recv, (n - 3), n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I32") : str_eq(__recv, "I32"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (n - 3)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (n - 3)) : str_slice(__recv, 0, (n - 3)); })();
}
  if (((n > 3) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((n - 3), n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (n - 3), n) : str_slice(__recv, (n - 3), n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U16") : str_eq(__recv, "U16"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (n - 3)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (n - 3)) : str_slice(__recv, 0, (n - 3)); })();
}
  if (((n > 3) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((n - 3), n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (n - 3), n) : str_slice(__recv, (n - 3), n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I16"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I16") : str_eq(__recv, "I16"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (n - 3)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (n - 3)) : str_slice(__recv, 0, (n - 3)); })();
}
  if (((n > 2) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((n - 2), n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (n - 2), n) : str_slice(__recv, (n - 2), n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "U8") : str_eq(__recv, "U8"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (n - 2)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (n - 2)) : str_slice(__recv, 0, (n - 2)); })();
}
  if (((n > 2) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop((n - 2), n); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, (n - 2), n) : str_slice(__recv, (n - 2), n); })(); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("I8"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "I8") : str_eq(__recv, "I8"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, (n - 2)); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, (n - 2)) : str_slice(__recv, 0, (n - 2)); })();
}
  return s;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cg_strip_num_suffix = cg_strip_num_suffix;

const __tuff_outer_for_emit_expr_call_into = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_expr_call_into(n, callee_node) {
  let __tuff_this = { n: n, callee_node: callee_node, this: __tuff_outer_for_emit_expr_call_into };
  let callee_name = get_interned_str(node_get_data1(callee_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.callee_name = callee_name;
  if ((!((() => { const __recv = callee_name; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "into") : str_eq(__recv, "into"); })() && (node_get_data3(n) === 1)))) {
  return "";
}
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() < 1)) {
  return "undefined";
}
  let type_args = node_get_data4(n); if (typeof __tuff_this !== 'undefined') __tuff_this.type_args = type_args;
  let contract_name = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.contract_name = contract_name;
  if ((((() => { const __recv = type_args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() === 1) && (node_kind((() => { const __recv = type_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()) === NK_NAMED_TYPE))) {
  contract_name = get_interned_str(node_get_data1((() => { const __recv = type_args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })())); if (typeof __tuff_this !== 'undefined') __tuff_this.contract_name = contract_name;
}
  let src_node = (() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.src_node = src_node;
  let src = emit_expr(src_node); if (typeof __tuff_this !== 'undefined') __tuff_this.src = src;
  let consume_source = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.consume_source = consume_source;
  let contract_label = contract_name; if (typeof __tuff_this !== 'undefined') __tuff_this.contract_label = contract_label;
  if ((() => { const __recv = contract_label; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) {
  contract_label = "<unknown>"; if (typeof __tuff_this !== 'undefined') __tuff_this.contract_label = contract_label;
}
  if ((node_kind(src_node) === NK_IDENTIFIER)) {
  consume_source = (() => { const __recv = get_interned_str(node_get_data1(src_node)); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = undefined;"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = undefined;") : str_concat(__recv, " = undefined;"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.consume_source = consume_source;
}
  if ((node_get_data5(n) === 1)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(() => { const __src = "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(src); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, src) : str_concat(__recv, src); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; const __conv = __src?.__into?.["); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; const __conv = __src?.__into?.[") : str_concat(__recv, "; const __conv = __src?.__into?.["); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"") : str_concat(__recv, "\""); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(contract_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, contract_name) : str_concat(__recv, contract_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"") : str_concat(__recv, "\""); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("]; if (!__conv) { throw new Error(\"Missing into converter for "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "]; if (!__conv) { throw new Error(\"Missing into converter for ") : str_concat(__recv, "]; if (!__conv) { throw new Error(\"Missing into converter for "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(contract_label); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, contract_label) : str_concat(__recv, contract_label); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\"); } "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"); } ") : str_concat(__recv, "\"); } "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(consume_source); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, consume_source) : str_concat(__recv, consume_source); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" let __used = false; return (...__intoArgs) => { if (__used) { throw new Error(\"Into converter already consumed for "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " let __used = false; return (...__intoArgs) => { if (__used) { throw new Error(\"Into converter already consumed for ") : str_concat(__recv, " let __used = false; return (...__intoArgs) => { if (__used) { throw new Error(\"Into converter already consumed for "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(contract_label); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, contract_label) : str_concat(__recv, contract_label); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\"); } __used = true; return __conv(...__intoArgs); }; })()"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"); } __used = true; return __conv(...__intoArgs); }; })()") : str_concat(__recv, "\"); } __used = true; return __conv(...__intoArgs); }; })()"); })();
}
  let arg_strs = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.arg_strs = arg_strs;
  let i = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = arg_strs; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())) : vec_push(__recv, emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let rest_args = (() => { const __recv = arg_strs; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.rest_args = rest_args;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(() => { const __src = "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(src); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, src) : str_concat(__recv, src); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; const __conv = __src?.__into?.["); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; const __conv = __src?.__into?.[") : str_concat(__recv, "; const __conv = __src?.__into?.["); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"") : str_concat(__recv, "\""); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(contract_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, contract_name) : str_concat(__recv, contract_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"") : str_concat(__recv, "\""); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("]; if (!__conv) { throw new Error(\"Missing into converter for "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "]; if (!__conv) { throw new Error(\"Missing into converter for ") : str_concat(__recv, "]; if (!__conv) { throw new Error(\"Missing into converter for "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(contract_label); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, contract_label) : str_concat(__recv, contract_label); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\"); } const __out = __conv("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"); } const __out = __conv(") : str_concat(__recv, "\"); } const __out = __conv("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(rest_args); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, rest_args) : str_concat(__recv, rest_args); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("); "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "); ") : str_concat(__recv, "); "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(consume_source); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, consume_source) : str_concat(__recv, consume_source); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" return __out; })()"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " return __out; })()") : str_concat(__recv, " return __out; })()"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_expr_call_into = emit_expr_call_into;

const __tuff_outer_for_emit_expr_call_method = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_expr_call_method(n, callee_node) {
  let __tuff_this = { n: n, callee_node: callee_node, this: __tuff_outer_for_emit_expr_call_method };
  if ((!((node_get_data3(n) === 1) && (node_kind(callee_node) === NK_IDENTIFIER)))) {
  return "";
}
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })() < 1)) {
  return "";
}
  let callee_name = get_interned_str(node_get_data1(callee_node)); if (typeof __tuff_this !== 'undefined') __tuff_this.callee_name = callee_name;
  let receiver = emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.receiver = receiver;
  let rest_args = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.rest_args = rest_args;
  let i = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = rest_args; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())) : vec_push(__recv, emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let rest_str = (() => { const __recv = rest_args; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.rest_str = rest_str;
  let dyn_args = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.dyn_args = dyn_args;
  if ((() => { const __recv = rest_str; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) {
  dyn_args = "__recv.ref"; if (typeof __tuff_this !== 'undefined') __tuff_this.dyn_args = dyn_args;
} else {
  dyn_args = (() => { const __recv = "__recv.ref, "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(rest_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, rest_str) : str_concat(__recv, rest_str); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dyn_args = dyn_args;
}
  let static_args = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.static_args = static_args;
  if ((() => { const __recv = rest_str; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) {
  static_args = "__recv"; if (typeof __tuff_this !== 'undefined') __tuff_this.static_args = static_args;
} else {
  static_args = (() => { const __recv = "__recv, "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(rest_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, rest_str) : str_concat(__recv, rest_str); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.static_args = static_args;
}
  let method_key = (() => { const __recv = (() => { const __recv = "\""; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(callee_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, callee_name) : str_concat(__recv, callee_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"") : str_concat(__recv, "\""); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.method_key = method_key;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(() => { const __recv = "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(receiver); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, receiver) : str_concat(__recv, receiver); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; const __prop = __recv?.["); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; const __prop = __recv?.[") : str_concat(__recv, "; const __prop = __recv?.["); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(method_key); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, method_key) : str_concat(__recv, method_key); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("]; if (typeof __prop === \"function\") return __prop("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "]; if (typeof __prop === \"function\") return __prop(") : str_concat(__recv, "]; if (typeof __prop === \"function\") return __prop("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(rest_str); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, rest_str) : str_concat(__recv, rest_str); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("); const __dyn = __recv?.table?."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "); const __dyn = __recv?.table?.") : str_concat(__recv, "); const __dyn = __recv?.table?."); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(callee_name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, callee_name) : str_concat(__recv, callee_name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; return __dyn ? __dyn("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; return __dyn ? __dyn(") : str_concat(__recv, "; return __dyn ? __dyn("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(dyn_args); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, dyn_args) : str_concat(__recv, dyn_args); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") : "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") : ") : str_concat(__recv, ") : "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_expr(callee_node)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_expr(callee_node)) : str_concat(__recv, emit_expr(callee_node)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(static_args); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, static_args) : str_concat(__recv, static_args); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("); })()"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "); })()") : str_concat(__recv, "); })()"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_expr_call_method = emit_expr_call_method;

const __tuff_outer_for_emit_expr_call_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_expr_call_expr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_expr_call_expr };
  let callee_node = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.callee_node = callee_node;
  if (((node_kind(callee_node) === NK_IDENTIFIER) && (() => { const __recv = get_interned_str(node_get_data1(callee_node)); const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("drop"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "drop") : str_eq(__recv, "drop"); })())) {
  return "undefined";
}
  let into_call = emit_expr_call_into(n, callee_node); if (typeof __tuff_this !== 'undefined') __tuff_this.into_call = into_call;
  if ((!(() => { const __recv = into_call; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  return into_call;
}
  let method = emit_expr_call_method(n, callee_node); if (typeof __tuff_this !== 'undefined') __tuff_this.method = method;
  if ((!(() => { const __recv = method; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  return method;
}
  let callee = emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  let args = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let arg_strs = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.arg_strs = arg_strs;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = arg_strs; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())) : vec_push(__recv, emit_expr((() => { const __recv = args; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let args_str = (() => { const __recv = arg_strs; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.args_str = args_str;
  return (() => { const __recv = (() => { const __recv = callee; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = args_str; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = args_str; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })()) : str_concat(__recv, (() => { const __recv = args_str; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })()); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_expr_call_expr = emit_expr_call_expr;

const __tuff_outer_for_emit_expr_struct_init = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_expr_struct_init(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_expr_struct_init };
  let name = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let fields = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "((typeof ");
  sb_append(sb, name);
  sb_append(sb, " === \"function\") ? ");
  sb_append(sb, name);
  sb_append(sb, "({");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  if ((i > 0)) {
  sb_append(sb, ", ");
}
  sb_append(sb, get_interned_str((() => { const __recv = field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()));
  sb_append(sb, ": ");
  sb_append(sb, emit_expr((() => { const __recv = field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })()));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "}) : ({ __tag: ");
  sb_append(sb, (() => { const __recv = (() => { const __recv = "\""; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"") : str_concat(__recv, "\""); })());
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  sb_append(sb, ", ");
  sb_append(sb, get_interned_str((() => { const __recv = field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()));
  sb_append(sb, ": ");
  sb_append(sb, emit_expr((() => { const __recv = field; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })()));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, " }))");
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_expr_struct_init = emit_expr_struct_init;

const __tuff_outer_for_emit_expr_complex = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_expr_complex(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_expr_complex };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_IF_EXPR)) {
  let cond = emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let then_b = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.then_b = then_b;
  let else_b = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.else_b = else_b;
  let then_str = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.then_str = then_str;
  if ((node_kind(then_b) === NK_BLOCK)) {
  then_str = emit_block_as_iife(then_b); if (typeof __tuff_this !== 'undefined') __tuff_this.then_str = then_str;
} else {
  then_str = emit_expr(then_b); if (typeof __tuff_this !== 'undefined') __tuff_this.then_str = then_str;
}
  let else_str = "undefined"; if (typeof __tuff_this !== 'undefined') __tuff_this.else_str = else_str;
  if ((else_b !== 0)) {
  if ((node_kind(else_b) === NK_BLOCK)) {
  else_str = emit_block_as_iife(else_b); if (typeof __tuff_this !== 'undefined') __tuff_this.else_str = else_str;
} else {
  else_str = emit_expr(else_b); if (typeof __tuff_this !== 'undefined') __tuff_this.else_str = else_str;
}
}
  return str_concat((() => { const __recv = (() => { const __recv = (() => { const __recv = "(("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, cond) : str_concat(__recv, cond); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") ? "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") ? ") : str_concat(__recv, ") ? "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = then_str; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" : "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " : ") : str_concat(__recv, " : "); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = then_str; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" : "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " : ") : str_concat(__recv, " : "); })()) : str_concat(__recv, (() => { const __recv = then_str; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" : "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " : ") : str_concat(__recv, " : "); })()); })(), (() => { const __recv = else_str; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })());
}
  if ((kind === NK_MATCH_EXPR)) {
  let target = emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let cases = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sb_append(sb, "(() => { const __m = ");
  sb_append(sb, target);
  sb_append(sb, "; ");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let case_node = (() => { const __recv = cases; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.case_node = case_node;
  let pat = (() => { const __recv = case_node; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  let body = (() => { const __recv = case_node; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let guard = emit_pattern_guard("__m", pat); if (typeof __tuff_this !== 'undefined') __tuff_this.guard = guard;
  if ((i === 0)) {
  sb_append(sb, "if (");
} else {
  sb_append(sb, "else if (");
}
  sb_append(sb, guard);
  sb_append(sb, ") { ");
  sb_append(sb, emit_pattern_bindings("__m", pat));
  sb_append(sb, "return ");
  let body_js = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.body_js = body_js;
  if ((node_kind(body) === NK_BLOCK)) {
  body_js = emit_block(body); if (typeof __tuff_this !== 'undefined') __tuff_this.body_js = body_js;
} else {
  body_js = emit_expr(body); if (typeof __tuff_this !== 'undefined') __tuff_this.body_js = body_js;
}
  sb_append(sb, body_js);
  sb_append(sb, "; } ");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sb_append(sb, "else { throw new Error(\"Non-exhaustive match\"); } })()");
  return sb_build(sb);
}
  if ((kind === NK_IS_EXPR)) {
  return (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_pattern_guard(emit_expr(node_get_data1(n)), node_get_data2(n))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_pattern_guard(emit_expr(node_get_data1(n)), node_get_data2(n))) : str_concat(__recv, emit_pattern_guard(emit_expr(node_get_data1(n)), node_get_data2(n))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  if ((kind === NK_UNWRAP_EXPR)) {
  return emit_expr(node_get_data1(n));
}
  if ((kind === NK_LAMBDA_EXPR)) {
  let params = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let body = node_get_data2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let pnames = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.pnames = pnames;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = pnames; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(js_ident_expr(get_interned_str((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, js_ident_expr(get_interned_str((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))) : vec_push(__recv, js_ident_expr(get_interned_str((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let args = (() => { const __recv = pnames; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if ((node_kind(body) === NK_BLOCK)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(args); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, args) : str_concat(__recv, args); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") => "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") => ") : str_concat(__recv, ") => "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_fn_block(body)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_fn_block(body)) : str_concat(__recv, emit_fn_block(body)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(args); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, args) : str_concat(__recv, args); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") => "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") => ") : str_concat(__recv, ") => "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_expr(body)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_expr(body)) : str_concat(__recv, emit_expr(body)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  if ((kind === NK_FN_EXPR)) {
  let fname_idx = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fname_idx = fname_idx;
  let params = node_get_data3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let body = node_get_data5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let pnames = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.pnames = pnames;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = pnames; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(js_ident_expr(get_interned_str((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, js_ident_expr(get_interned_str((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))) : vec_push(__recv, js_ident_expr(get_interned_str((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })()))); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let args = (() => { const __recv = pnames; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let namePart = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.namePart = namePart;
  if ((fname_idx !== 0)) {
  namePart = (() => { const __recv = " "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(get_interned_str(fname_idx)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, get_interned_str(fname_idx)) : str_concat(__recv, get_interned_str(fname_idx)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.namePart = namePart;
}
  if ((node_kind(body) === NK_BLOCK)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(function"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(namePart); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, namePart) : str_concat(__recv, namePart); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(args); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, args) : str_concat(__recv, args); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") ") : str_concat(__recv, ") "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_fn_block(body)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_fn_block(body)) : str_concat(__recv, emit_fn_block(body)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })();
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(function"; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(namePart); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, namePart) : str_concat(__recv, namePart); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "(") : str_concat(__recv, "("); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(args); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, args) : str_concat(__recv, args); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(") { return "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ") { return ") : str_concat(__recv, ") { return "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(emit_expr(body)); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, emit_expr(body)) : str_concat(__recv, emit_expr(body)); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; })"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; })") : str_concat(__recv, "; })"); })();
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_expr_complex = emit_expr_complex;

const __tuff_outer_for_emit_expr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_expr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emit_expr };
  let kind = node_kind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_NUMBER_LIT)) {
  let val = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  return cg_strip_num_suffix(get_interned_str(val));
}
  if ((kind === NK_BOOL_LIT)) {
  let val = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  if ((val === 1)) {
  return "true";
}
  return "false";
}
  if ((kind === NK_STRING_LIT)) {
  let val = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  let s = get_interned_str(val); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  return (() => { const __recv = (() => { const __recv = "\""; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(s); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, s) : str_concat(__recv, s); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"") : str_concat(__recv, "\""); })();
}
  if ((kind === NK_CHAR_LIT)) {
  let val = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  let s = get_interned_str(val); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  return (() => { const __recv = (() => { const __recv = "\""; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(s); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, s) : str_concat(__recv, s); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"") : str_concat(__recv, "\""); })();
}
  if ((kind === NK_IDENTIFIER)) {
  let name_idx = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.name_idx = name_idx;
  return js_ident_expr(get_interned_str(name_idx));
}
  if ((kind === NK_UNARY_EXPR)) {
  let op = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&") : str_eq(__recv, "&"); })() || (() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("&mut"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "&mut") : str_eq(__recv, "&mut"); })())) {
  return emit_expr(node_get_data2(n));
}
  let inner = emit_expr(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  return (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, op) : str_concat(__recv, op); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = inner; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = inner; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })()) : str_concat(__recv, (() => { const __recv = inner; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ")") : str_concat(__recv, ")"); })()); })();
}
  if ((kind === NK_BINARY_EXPR)) {
  let op = get_interned_str(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("=="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "==") : str_eq(__recv, "=="); })()) {
  op = "==="; if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
}
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "!=") : str_eq(__recv, "!="); })()) {
  op = "!=="; if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
}
  let left = emit_expr(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  let right = emit_expr(node_get_data3(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  if ((() => { const __recv = op; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(".."); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "..") : str_eq(__recv, ".."); })()) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(function() { let __cur = "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(left); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, left) : str_concat(__recv, left); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(", __hi = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ", __hi = ") : str_concat(__recv, ", __hi = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, right) : str_concat(__recv, right); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; return function() { if (__cur > __hi) return [true, __hi]; let __val = __cur++; return [false, __val]; }; })()"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; return function() { if (__cur > __hi) return [true, __hi]; let __val = __cur++; return [false, __val]; }; })()") : str_concat(__recv, "; return function() { if (__cur > __hi) return [true, __hi]; let __val = __cur++; return [false, __val]; }; })()"); })();
}
  return str_concat((() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(left); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, left) : str_concat(__recv, left); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = " "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, op) : str_concat(__recv, op); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = " "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, op) : str_concat(__recv, op); })()) : str_concat(__recv, (() => { const __recv = " "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, op) : str_concat(__recv, op); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = " "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, right) : str_concat(__recv, right); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = " "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, right) : str_concat(__recv, right); })()) : str_concat(__recv, (() => { const __recv = " "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, right) : str_concat(__recv, right); })()); })(), ")");
}
  if ((kind === NK_CALL_EXPR)) {
  return emit_expr_call_expr(n);
}
  if ((kind === NK_MEMBER_EXPR)) {
  let obj = emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.obj = obj;
  let prop = get_interned_str(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  if ((() => { const __recv = prop; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("init"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "init") : str_eq(__recv, "init"); })()) {
  return (() => { const __recv = obj; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(".length"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".length") : str_concat(__recv, ".length"); })();
}
  return (() => { const __recv = (() => { const __recv = obj; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".") : str_concat(__recv, "."); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prop) : str_concat(__recv, prop); })();
}
  if ((kind === NK_INDEX_EXPR)) {
  let target = emit_expr(node_get_data1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let idx_expr = emit_expr(node_get_data2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.idx_expr = idx_expr;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = target; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("["); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "[") : str_concat(__recv, "["); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(idx_expr); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, idx_expr) : str_concat(__recv, idx_expr); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "]") : str_concat(__recv, "]"); })();
}
  if ((kind === NK_STRUCT_INIT)) {
  return emit_expr_struct_init(n);
}
  if ((kind === NK_TUPLE_EXPR)) {
  let items = node_get_data1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let parts = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.parts = parts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = items; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = parts; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(emit_expr((() => { const __recv = items; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, emit_expr((() => { const __recv = items; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())) : vec_push(__recv, emit_expr((() => { const __recv = items; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })())); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = (() => { const __recv = "["; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = parts; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = parts; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })()) : str_concat(__recv, (() => { const __recv = parts; const __prop = __recv?.["vec_join"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vec_join; return __dyn ? __dyn(__recv.ref, ", ") : vec_join(__recv, ", "); })()); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "]") : str_concat(__recv, "]"); })();
}
  let complex = emit_expr_complex(n); if (typeof __tuff_this !== 'undefined') __tuff_this.complex = complex;
  if ((!(() => { const __recv = complex; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })())) {
  return complex;
}
  return "undefined";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_expr = emit_expr;

const __tuff_outer_for_emit_pattern_guard = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_pattern_guard(value_expr, pat) {
  let __tuff_this = { value_expr: value_expr, pat: pat, this: __tuff_outer_for_emit_pattern_guard };
  let kind = node_kind(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_WILDCARD_PAT)) {
  return "true";
}
  if ((kind === NK_LITERAL_PAT)) {
  let val = get_interned_str(node_get_data1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = value_expr; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" === "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " === ") : str_concat(__recv, " === "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(val); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, val) : str_concat(__recv, val); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "") : str_concat(__recv, ""); })();
}
  if ((kind === NK_NAME_PAT)) {
  let name = get_interned_str(node_get_data1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return str_concat((() => { const __recv = (() => { const __recv = (() => { const __recv = value_expr; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" && "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " && ") : str_concat(__recv, " && "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(value_expr); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, value_expr) : str_concat(__recv, value_expr); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(".__tag === \""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".__tag === \"") : str_concat(__recv, ".__tag === \""); })(), (() => { const __recv = name; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"") : str_concat(__recv, "\""); })());
}
  if ((kind === NK_STRUCT_PAT)) {
  let name = get_interned_str(node_get_data1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return str_concat((() => { const __recv = (() => { const __recv = (() => { const __recv = value_expr; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" && "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " && ") : str_concat(__recv, " && "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(value_expr); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, value_expr) : str_concat(__recv, value_expr); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(".__tag === \""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ".__tag === \"") : str_concat(__recv, ".__tag === \""); })(), (() => { const __recv = name; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"") : str_concat(__recv, "\""); })());
}
  return "false";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_pattern_guard = emit_pattern_guard;

const __tuff_outer_for_emit_pattern_bindings = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_pattern_bindings(value_expr, pat) {
  let __tuff_this = { value_expr: value_expr, pat: pat, this: __tuff_outer_for_emit_pattern_bindings };
  let kind = node_kind(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_STRUCT_PAT)) {
  let fields = node_get_data2(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vec_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vec_length; return __dyn ? __dyn(__recv.ref) : vec_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let fname_idx = (() => { const __recv = fields; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, i) : vec_get(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fname_idx = fname_idx;
  let fname = get_interned_str(fname_idx); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  sb_append(sb, "const ");
  sb_append(sb, fname);
  sb_append(sb, " = ");
  sb_append(sb, value_expr);
  sb_append(sb, ".");
  sb_append(sb, fname);
  sb_append(sb, "; ");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sb_build(sb);
}
  if ((kind === NK_NAME_PAT)) {
  let name = get_interned_str(node_get_data1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "const "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, name) : str_concat(__recv, name); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = value_expr; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; ") : str_concat(__recv, "; "); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = value_expr; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; ") : str_concat(__recv, "; "); })()) : str_concat(__recv, (() => { const __recv = value_expr; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("; "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "; ") : str_concat(__recv, "; "); })()); })();
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_pattern_bindings = emit_pattern_bindings;

const __tuff_outer_for_selfhost_codegen_expr_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_codegen_expr_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_codegen_expr_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_codegen_expr_marker = selfhost_codegen_expr_marker;

const __tuff_outer_for_fmt_spaces = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_spaces(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_fmt_spaces };
  let sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < n)) {
  sb_append_char(sb, 32);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sb_build(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_spaces = fmt_spaces;

const __tuff_outer_for_fmt_trim_right = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_trim_right(line) {
  let __tuff_this = { line: line, this: __tuff_outer_for_fmt_trim_right };
  let end = (() => { const __recv = line; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
  while ((end > 0)) {
  let ch = (() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((end - 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (end - 1)) : str_char_at(__recv, (end - 1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((((ch === 32) || (ch === 9)) || (ch === 13))) {
  end = (end - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
} else {
  return (() => { const __recv = line; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, end); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, end) : str_slice(__recv, 0, end); })();
}
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_trim_right = fmt_trim_right;

const __tuff_outer_for_fmt_count_leading_closes = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_count_leading_closes(line) {
  let __tuff_this = { line: line, this: __tuff_outer_for_fmt_count_leading_closes };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = line; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while (((i < len) && ((() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })() === 125))) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return i;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_count_leading_closes = fmt_count_leading_closes;

const __tuff_outer_for_fmt_count_char = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_count_char(line, target) {
  let __tuff_this = { line: line, target: target, this: __tuff_outer_for_fmt_count_char };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = line; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let count = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  while ((i < len)) {
  if (((() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })() === target)) {
  count = (count + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return count;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_count_char = fmt_count_char;

const __tuff_outer_for_fmt_count_structural_braces = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_count_structural_braces(line) {
  let __tuff_this = { line: line, this: __tuff_outer_for_fmt_count_structural_braces };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = line; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let opens = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.opens = opens;
  let closes = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.closes = closes;
  let in_string = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_string = in_string;
  let in_char = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_char = in_char;
  while ((i < len)) {
  let ch = (() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((in_string === 1)) {
  if (((ch === 92) && ((i + 1) < len))) {
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 34)) {
  in_string = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_string = in_string;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((in_char === 1)) {
  if (((ch === 92) && ((i + 1) < len))) {
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 39)) {
  in_char = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_char = in_char;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((((ch === 47) && ((i + 1) < len)) && ((() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })() === 47))) {
  break;
}
  if ((ch === 34)) {
  in_string = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.in_string = in_string;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 39)) {
  in_char = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.in_char = in_char;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 123)) {
  opens = (opens + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.opens = opens;
}
  if ((ch === 125)) {
  closes = (closes + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.closes = closes;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let r = vec_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.r = r;
  (() => { const __recv = r; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(opens); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, opens) : vec_push(__recv, opens); })();
  (() => { const __recv = r; const __prop = __recv?.["vec_push"]; if (typeof __prop === "function") return __prop(closes); const __dyn = __recv?.table?.vec_push; return __dyn ? __dyn(__recv.ref, closes) : vec_push(__recv, closes); })();
  return r;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_count_structural_braces = fmt_count_structural_braces;

const __tuff_outer_for_fmt_is_space = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_is_space(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_fmt_is_space };
  return ((ch === 32) || (ch === 9));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_is_space = fmt_is_space;

const __tuff_outer_for_fmt_is_ident_char = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_is_ident_char(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_fmt_is_ident_char };
  return (((((ch >= 65) && (ch <= 90)) || ((ch >= 97) && (ch <= 122))) || ((ch >= 48) && (ch <= 57))) || (ch === 95));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_is_ident_char = fmt_is_ident_char;

const __tuff_outer_for_fmt_prev_non_space_char = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_prev_non_space_char(text) {
  let __tuff_this = { text: text, this: __tuff_outer_for_fmt_prev_non_space_char };
  let i = ((() => { const __recv = text; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i >= 0)) {
  let ch = (() => { const __recv = text; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((!fmt_is_space((0 + ch)))) {
  return (0 + ch);
}
  i = (i - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_prev_non_space_char = fmt_prev_non_space_char;

const __tuff_outer_for_fmt_next_non_space_char = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_next_non_space_char(text, start) {
  let __tuff_this = { text: text, start: start, this: __tuff_outer_for_fmt_next_non_space_char };
  let i = start; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = text; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let ch = (() => { const __recv = text; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((!fmt_is_space((0 + ch)))) {
  return (0 + ch);
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_next_non_space_char = fmt_next_non_space_char;

const __tuff_outer_for_fmt_trim_right_spaces_text = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_trim_right_spaces_text(text) {
  let __tuff_this = { text: text, this: __tuff_outer_for_fmt_trim_right_spaces_text };
  let end = (() => { const __recv = text; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
  while (((end > 0) && fmt_is_space((0 + (() => { const __recv = text; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((end - 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (end - 1)) : str_char_at(__recv, (end - 1)); })())))) {
  end = (end - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
}
  return (() => { const __recv = text; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(0, end); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, 0, end) : str_slice(__recv, 0, end); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_trim_right_spaces_text = fmt_trim_right_spaces_text;

const __tuff_outer_for_fmt_normalize_line_spacing = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_normalize_line_spacing(line) {
  let __tuff_this = { line: line, this: __tuff_outer_for_fmt_normalize_line_spacing };
  let acc = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = line; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let in_string = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_string = in_string;
  let in_char = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_char = in_char;
  while ((i < len)) {
  let ch = (() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((in_string === 1)) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(str_from_char_code((0 + ch))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, str_from_char_code((0 + ch))) : str_concat(__recv, str_from_char_code((0 + ch))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((ch === 92) && ((i + 1) < len))) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(str_from_char_code((0 + (() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })()))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, str_from_char_code((0 + (() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })()))) : str_concat(__recv, str_from_char_code((0 + (() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })()))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 34)) {
  in_string = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_string = in_string;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((in_char === 1)) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(str_from_char_code((0 + ch))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, str_from_char_code((0 + ch))) : str_concat(__recv, str_from_char_code((0 + ch))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((ch === 92) && ((i + 1) < len))) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(str_from_char_code((0 + (() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })()))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, str_from_char_code((0 + (() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })()))) : str_concat(__recv, str_from_char_code((0 + (() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })()))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 39)) {
  in_char = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_char = in_char;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((((ch === 47) && ((i + 1) < len)) && ((() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })() === 47))) {
  acc = (() => { const __recv = (() => { const __recv = fmt_trim_right_spaces_text(acc); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop((() => { const __recv = line; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(i, len); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, i, len) : str_slice(__recv, i, len); })()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = line; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(i, len); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, i, len) : str_slice(__recv, i, len); })()) : str_concat(__recv, (() => { const __recv = line; const __prop = __recv?.["str_slice"]; if (typeof __prop === "function") return __prop(i, len); const __dyn = __recv?.table?.str_slice; return __dyn ? __dyn(__recv.ref, i, len) : str_slice(__recv, i, len); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  break;
}
  if ((ch === 34)) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\"") : str_concat(__recv, "\""); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  in_string = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.in_string = in_string;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 39)) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "'") : str_concat(__recv, "'"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  in_char = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.in_char = in_char;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 44)) {
  acc = (() => { const __recv = fmt_trim_right_spaces_text(acc); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ",") : str_concat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  let next = fmt_next_non_space_char(line, (i + 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if (((((next !== 0) && (next !== 41)) && (next !== 93)) && (next !== 125))) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 123)) {
  let prev = fmt_prev_non_space_char(acc); if (typeof __tuff_this !== 'undefined') __tuff_this.prev = prev;
  acc = fmt_trim_right_spaces_text(acc); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((((prev !== 0) && (prev !== 123)) && (prev !== 40)) && (prev !== 91))) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("{"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "{") : str_concat(__recv, "{"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((((ch === 61) && (!(((i + 1) < len) && (((() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })() === 61) || ((() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })() === 62))))) && (!((i > 0) && ((((() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i - 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i - 1)) : str_char_at(__recv, (i - 1)); })() === 33) || ((() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i - 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i - 1)) : str_char_at(__recv, (i - 1)); })() === 60)) || ((() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i - 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i - 1)) : str_char_at(__recv, (i - 1)); })() === 62)))))) {
  acc = (() => { const __recv = fmt_trim_right_spaces_text(acc); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " = ") : str_concat(__recv, " = "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while (((i < len) && fmt_is_space((0 + (() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })())))) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  continue;
}
  if (((((ch === 43) || (ch === 45)) || (ch === 47)) || (ch === 37))) {
  let prev = fmt_prev_non_space_char(acc); if (typeof __tuff_this !== 'undefined') __tuff_this.prev = prev;
  let next = fmt_next_non_space_char(line, (i + 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  let binary = ((((((fmt_is_ident_char(prev) || (prev === 41)) || (prev === 93)) || (prev === 125)) || (prev === 34)) || (prev === 39)) && ((((fmt_is_ident_char(next) || (next === 40)) || (next === 91)) || (next === 34)) || (next === 39))); if (typeof __tuff_this !== 'undefined') __tuff_this.binary = binary;
  if (binary) {
  acc = (() => { const __recv = (() => { const __recv = (() => { const __recv = fmt_trim_right_spaces_text(acc); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(str_from_char_code((0 + ch))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, str_from_char_code((0 + ch))) : str_concat(__recv, str_from_char_code((0 + ch))); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while (((i < len) && fmt_is_space((0 + (() => { const __recv = line; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })())))) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  continue;
}
}
  if (fmt_is_space((0 + ch))) {
  if ((((() => { const __recv = acc; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() > 0) && (!fmt_is_space((0 + (() => { const __recv = acc; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(((() => { const __recv = acc; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() - 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, ((() => { const __recv = acc; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() - 1)) : str_char_at(__recv, ((() => { const __recv = acc; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() - 1)); })()))))) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " ") : str_concat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(str_from_char_code((0 + ch))); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, str_from_char_code((0 + ch))) : str_concat(__recv, str_from_char_code((0 + ch))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  acc = fmt_trim_right_spaces_text(acc); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("if (", "if ("); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "if (", "if (") : str_replace_all(__recv, "if (", "if ("); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("while (", "while ("); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "while (", "while (") : str_replace_all(__recv, "while (", "while ("); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("match (", "match ("); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "match (", "match (") : str_replace_all(__recv, "match (", "match ("); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("for (", "for ("); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "for (", "for (") : str_replace_all(__recv, "for (", "for ("); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  acc = (() => { const __recv = acc; const __prop = __recv?.["str_replace_all"]; if (typeof __prop === "function") return __prop("return (", "return ("); const __dyn = __recv?.table?.str_replace_all; return __dyn ? __dyn(__recv.ref, "return (", "return (") : str_replace_all(__recv, "return (", "return ("); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  return acc;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_normalize_line_spacing = fmt_normalize_line_spacing;

const __tuff_outer_for_fmt_emit_processed_line = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_emit_processed_line(sink, raw, indent) {
  let __tuff_this = { sink: sink, raw: raw, indent: indent, this: __tuff_outer_for_fmt_emit_processed_line };
  let trimmed = (() => { const __recv = fmt_trim_right(raw); const __prop = __recv?.["str_trim"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_trim; return __dyn ? __dyn(__recv.ref) : str_trim(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.trimmed = trimmed;
  if ((() => { const __recv = trimmed; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) {
  return indent;
}
  let normalized = fmt_normalize_line_spacing(trimmed); if (typeof __tuff_this !== 'undefined') __tuff_this.normalized = normalized;
  let leading_closes = fmt_count_leading_closes(normalized); if (typeof __tuff_this !== 'undefined') __tuff_this.leading_closes = leading_closes;
  let effective_indent = indent; if (typeof __tuff_this !== 'undefined') __tuff_this.effective_indent = effective_indent;
  if (((effective_indent > 0) && (leading_closes > 0))) {
  let k = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  while (((k < leading_closes) && (effective_indent > 0))) {
  effective_indent = (effective_indent - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.effective_indent = effective_indent;
  k = (k + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
}
}
  let line = (() => { const __recv = fmt_spaces((effective_indent * 4)); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(normalized); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, normalized) : str_concat(__recv, normalized); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.line = line;
  (() => { const __recv = sink; const __prop = __recv?.["sb_append"]; if (typeof __prop === "function") return __prop(line); const __dyn = __recv?.table?.sb_append; return __dyn ? __dyn(__recv.ref, line) : sb_append(__recv, line); })();
  (() => { const __recv = sink; const __prop = __recv?.["sb_append"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.sb_append; return __dyn ? __dyn(__recv.ref, "\n") : sb_append(__recv, "\n"); })();
  let brace_counts = fmt_count_structural_braces(normalized); if (typeof __tuff_this !== 'undefined') __tuff_this.brace_counts = brace_counts;
  let opens = (() => { const __recv = brace_counts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 0) : vec_get(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.opens = opens;
  let closes = (() => { const __recv = brace_counts; const __prop = __recv?.["vec_get"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vec_get; return __dyn ? __dyn(__recv.ref, 1) : vec_get(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.closes = closes;
  let closes_after_prefix = (closes - leading_closes); if (typeof __tuff_this !== 'undefined') __tuff_this.closes_after_prefix = closes_after_prefix;
  if ((closes_after_prefix < 0)) {
  closes_after_prefix = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.closes_after_prefix = closes_after_prefix;
}
  let next_indent = ((effective_indent + opens) - closes_after_prefix); if (typeof __tuff_this !== 'undefined') __tuff_this.next_indent = next_indent;
  if ((next_indent < 0)) {
  next_indent = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.next_indent = next_indent;
}
  return next_indent;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_emit_processed_line = fmt_emit_processed_line;

const __tuff_outer_for_fmt_stage1_split = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmt_stage1_split(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_fmt_stage1_split };
  let sink = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sink = sink;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = source; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let in_line_comment = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_line_comment = in_line_comment;
  let in_block_comment = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_block_comment = in_block_comment;
  let in_string = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_string = in_string;
  let in_char = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_char = in_char;
  while ((i < len)) {
  let ch = (() => { const __recv = source; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((in_line_comment === 1)) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sb_append_char(__recv, (0 + ch)); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((ch === 10)) {
  in_line_comment = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_line_comment = in_line_comment;
}
  continue;
}
  if ((in_block_comment === 1)) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sb_append_char(__recv, (0 + ch)); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((((ch === 42) && (i < len)) && ((() => { const __recv = source; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })() === 47))) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop(47); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, 47) : sb_append_char(__recv, 47); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  in_block_comment = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_block_comment = in_block_comment;
}
  continue;
}
  if ((in_string === 1)) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sb_append_char(__recv, (0 + ch)); })();
  if (((ch === 92) && ((i + 1) < len))) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + (() => { const __recv = source; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })())); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + (() => { const __recv = source; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })())) : sb_append_char(__recv, (0 + (() => { const __recv = source; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })())); })();
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((ch === 34)) {
  in_string = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_string = in_string;
}
  continue;
}
  if ((in_char === 1)) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sb_append_char(__recv, (0 + ch)); })();
  if (((ch === 92) && ((i + 1) < len))) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + (() => { const __recv = source; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })())); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + (() => { const __recv = source; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })())) : sb_append_char(__recv, (0 + (() => { const __recv = source; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })())); })();
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((ch === 39)) {
  in_char = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.in_char = in_char;
}
  continue;
}
  if ((((ch === 47) && ((i + 1) < len)) && ((() => { const __recv = source; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })() === 47))) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append"]; if (typeof __prop === "function") return __prop("//"); const __dyn = __recv?.table?.sb_append; return __dyn ? __dyn(__recv.ref, "//") : sb_append(__recv, "//"); })();
  in_line_comment = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.in_line_comment = in_line_comment;
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((((ch === 47) && ((i + 1) < len)) && ((() => { const __recv = source; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, (i + 1)) : str_char_at(__recv, (i + 1)); })() === 42))) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append"]; if (typeof __prop === "function") return __prop("/*"); const __dyn = __recv?.table?.sb_append; return __dyn ? __dyn(__recv.ref, "/*") : sb_append(__recv, "/*"); })();
  in_block_comment = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.in_block_comment = in_block_comment;
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 34)) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sb_append_char(__recv, (0 + ch)); })();
  in_string = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.in_string = in_string;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 39)) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sb_append_char(__recv, (0 + ch)); })();
  in_char = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.in_char = in_char;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 13)) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 59)) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sb_append_char(__recv, (0 + ch)); })();
  (() => { const __recv = sink; const __prop = __recv?.["sb_append"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.sb_append; return __dyn ? __dyn(__recv.ref, "\n") : sb_append(__recv, "\n"); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 123)) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sb_append_char(__recv, (0 + ch)); })();
  (() => { const __recv = sink; const __prop = __recv?.["sb_append"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.sb_append; return __dyn ? __dyn(__recv.ref, "\n") : sb_append(__recv, "\n"); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 125)) {
  (() => { const __recv = sink; const __prop = __recv?.["sb_append"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.sb_append; return __dyn ? __dyn(__recv.ref, "\n") : sb_append(__recv, "\n"); })();
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sb_append_char(__recv, (0 + ch)); })();
  (() => { const __recv = sink; const __prop = __recv?.["sb_append"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.sb_append; return __dyn ? __dyn(__recv.ref, "\n") : sb_append(__recv, "\n"); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  (() => { const __recv = sink; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sb_append_char(__recv, (0 + ch)); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = sink; const __prop = __recv?.["sb_build"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.sb_build; return __dyn ? __dyn(__recv.ref) : sb_build(__recv); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmt_stage1_split = fmt_stage1_split;

const __tuff_outer_for_format_tuff_source_impl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function format_tuff_source_impl(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_format_tuff_source_impl };
  let stage1 = fmt_stage1_split(source); if (typeof __tuff_this !== 'undefined') __tuff_this.stage1 = stage1;
  let sink = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.sink = sink;
  let line_sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.line_sb = line_sb;
  let indent = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.indent = indent;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stage1; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let ch = (() => { const __recv = stage1; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, i) : str_char_at(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((ch === 13)) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 10)) {
  let line = (() => { const __recv = line_sb; const __prop = __recv?.["sb_build"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.sb_build; return __dyn ? __dyn(__recv.ref) : sb_build(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.line = line;
  line_sb = sb_new(); if (typeof __tuff_this !== 'undefined') __tuff_this.line_sb = line_sb;
  indent = fmt_emit_processed_line(sink, line, indent); if (typeof __tuff_this !== 'undefined') __tuff_this.indent = indent;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  (() => { const __recv = line_sb; const __prop = __recv?.["sb_append_char"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sb_append_char; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sb_append_char(__recv, (0 + ch)); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let tail = (() => { const __recv = line_sb; const __prop = __recv?.["sb_build"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.sb_build; return __dyn ? __dyn(__recv.ref) : sb_build(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tail = tail;
  fmt_emit_processed_line(sink, tail, indent);
  let result = (() => { const __recv = sink; const __prop = __recv?.["sb_build"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.sb_build; return __dyn ? __dyn(__recv.ref) : sb_build(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  if ((((() => { const __recv = result; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() > 0) && ((() => { const __recv = result; const __prop = __recv?.["str_char_at"]; if (typeof __prop === "function") return __prop(((() => { const __recv = result; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() - 1)); const __dyn = __recv?.table?.str_char_at; return __dyn ? __dyn(__recv.ref, ((() => { const __recv = result; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() - 1)) : str_char_at(__recv, ((() => { const __recv = result; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() - 1)); })() === 10))) {
  return result;
}
  return (() => { const __recv = result; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\n") : str_concat(__recv, "\n"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.format_tuff_source_impl = format_tuff_source_impl;

const __tuff_outer_for_selfhost_formatter_impl_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_formatter_impl_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_formatter_impl_marker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_formatter_impl_marker = selfhost_formatter_impl_marker;

const __tuff_outer_for_format_tuff_source = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function format_tuff_source(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_format_tuff_source };
  return format_tuff_source_impl(source);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.format_tuff_source = format_tuff_source;

const __tuff_outer_for_selfhost_formatter_marker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhost_formatter_marker() {
  let __tuff_this = { this: __tuff_outer_for_selfhost_formatter_marker };
  return selfhost_formatter_impl_marker();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhost_formatter_marker = selfhost_formatter_marker;

// extern from globalThis

// extern from globalThis

// extern from globalThis

// extern fn __host_get_c_substrate

// extern fn __host_get_c_runtime_prelude_source

// extern fn __host_emit_target_from_source

const __tuff_outer_for_sanitize_max_effective_lines = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function sanitize_max_effective_lines(max_effective_lines) {
  let __tuff_this = { max_effective_lines: max_effective_lines, this: __tuff_outer_for_sanitize_max_effective_lines };
  return (((max_effective_lines <= 0)) ? (() => {
    return 500;
  })() : (() => {
    return max_effective_lines;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.sanitize_max_effective_lines = sanitize_max_effective_lines;

const __tuff_outer_for_normalize_flag = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function normalize_flag(value) {
  let __tuff_this = { value: value, this: __tuff_outer_for_normalize_flag };
  return (((value === 0)) ? (() => {
    return 0;
  })() : (() => {
    return 1;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.normalize_flag = normalize_flag;

const __tuff_outer_for_with_c_runtime_prelude = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function with_c_runtime_prelude(source, target) {
  let __tuff_this = { source: source, target: target, this: __tuff_outer_for_with_c_runtime_prelude };
  if ((!(() => { const __recv = target; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("c"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "c") : str_eq(__recv, "c"); })())) {
  return source;
}
  if ((() => { const __recv = source; const __prop = __recv?.["str_includes"]; if (typeof __prop === "function") return __prop("fn tuff_runtime_panic("); const __dyn = __recv?.table?.str_includes; return __dyn ? __dyn(__recv.ref, "fn tuff_runtime_panic(") : str_includes(__recv, "fn tuff_runtime_panic("); })()) {
  return source;
}
  let prelude = __host_get_c_runtime_prelude_source(); if (typeof __tuff_this !== 'undefined') __tuff_this.prelude = prelude;
  if ((() => { const __recv = prelude; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) {
  return source;
}
  return (() => { const __recv = (() => { const __recv = source; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop("\n\n"); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, "\n\n") : str_concat(__recv, "\n\n"); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(prelude); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, prelude) : str_concat(__recv, prelude); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.with_c_runtime_prelude = with_c_runtime_prelude;

const __tuff_outer_for_emit_target_output = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emit_target_output(typed, source, target) {
  let __tuff_this = { typed: typed, source: source, target: target, this: __tuff_outer_for_emit_target_output };
  if ((() => { const __recv = target; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("js"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "js") : str_eq(__recv, "js"); })()) {
  return generate_js(typed);
}
  if ((() => { const __recv = target; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("c"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "c") : str_eq(__recv, "c"); })()) {
  return generate_c(typed, __host_get_c_substrate());
}
  if ((() => { const __recv = target; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("tuff"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "tuff") : str_eq(__recv, "tuff"); })()) {
  return emit_tuff_from_typed(typed, source, lex_take_trivia());
}
  panic_with_code("E_UNSUPPORTED_TARGET", (() => { const __recv = "Unsupported codegen target: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, target) : str_concat(__recv, target); })(), "The compiler was asked to emit code for a target that is not implemented.", "Use target 'js', target 'c', or target 'tuff'.");
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emit_target_output = emit_target_output;

const __tuff_outer_for_compile_source_with_options = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function compile_source_with_options(source, lint_enabled, max_effective_lines, borrow_enabled, target) {
  let __tuff_this = { source: source, lint_enabled: lint_enabled, max_effective_lines: max_effective_lines, borrow_enabled: borrow_enabled, target: target, this: __tuff_outer_for_compile_source_with_options };
  let t_start = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t_start = t_start;
  let effective_source = with_c_runtime_prelude(source, target); if (typeof __tuff_this !== 'undefined') __tuff_this.effective_source = effective_source;
  let max_lines = sanitize_max_effective_lines(max_effective_lines); if (typeof __tuff_this !== 'undefined') __tuff_this.max_lines = max_lines;
  let lint = normalize_flag(lint_enabled); if (typeof __tuff_this !== 'undefined') __tuff_this.lint = lint;
  let borrow = normalize_flag(borrow_enabled); if (typeof __tuff_this !== 'undefined') __tuff_this.borrow = borrow;
  lint_reset();
  let t0 = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t0 = t0;
  lex_init(effective_source);
  lex_all();
  let t1 = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t1 = t1;
  profile_mark("lex", (t1 - t0));
  let t1_parse = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t1_parse = t1_parse;
  parse_init();
  let program = p_parse_program(); if (typeof __tuff_this !== 'undefined') __tuff_this.program = program;
  let t2_parse = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2_parse = t2_parse;
  profile_mark("parse", (t2_parse - t1_parse));
  let t2_desugar = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2_desugar = t2_desugar;
  let desugared = desugar(program); if (typeof __tuff_this !== 'undefined') __tuff_this.desugared = desugared;
  let t3_desugar = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t3_desugar = t3_desugar;
  profile_mark("desugar", (t3_desugar - t2_desugar));
  let t3_resolve = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t3_resolve = t3_resolve;
  let resolved = resolve_names(desugared); if (typeof __tuff_this !== 'undefined') __tuff_this.resolved = resolved;
  let t4_resolve = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t4_resolve = t4_resolve;
  profile_mark("resolve", (t4_resolve - t3_resolve));
  let t4_typecheck = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t4_typecheck = t4_typecheck;
  let typed = typecheck_program_with_options(resolved); if (typeof __tuff_this !== 'undefined') __tuff_this.typed = typed;
  let t5_typecheck = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t5_typecheck = t5_typecheck;
  profile_mark("typecheck", (t5_typecheck - t4_typecheck));
  let t5_borrow = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t5_borrow = t5_borrow;
  if ((borrow === 1)) {
  borrowcheck_program(typed);
}
  let t6_borrow = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t6_borrow = t6_borrow;
  profile_mark("borrowcheck", (t6_borrow - t5_borrow));
  if ((lint === 1)) {
  lint_program(typed, "<memory>", max_lines, 1);
}
  let t6_emit = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t6_emit = t6_emit;
  let output = emit_target_output(typed, effective_source, target); if (typeof __tuff_this !== 'undefined') __tuff_this.output = output;
  let t7_emit = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t7_emit = t7_emit;
  profile_mark("emit", (t7_emit - t6_emit));
  let t_end = perf_now(); if (typeof __tuff_this !== 'undefined') __tuff_this.t_end = t_end;
  profile_mark("total", (t_end - t_start));
  return output;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.compile_source_with_options = compile_source_with_options;

const __tuff_outer_for_take_lint_issues = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function take_lint_issues() {
  let __tuff_this = { this: __tuff_outer_for_take_lint_issues };
  return lint_take_issues();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.take_lint_issues = take_lint_issues;

const __tuff_outer_for_format_source_tuff = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function format_source_tuff(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_format_source_tuff };
  return format_tuff_source(source);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.format_source_tuff = format_source_tuff;

const __tuff_outer_for_cpd_lex_init = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpd_lex_init(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_cpd_lex_init };
  return lex_init(source);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpd_lex_init = cpd_lex_init;

const __tuff_outer_for_cpd_lex_all = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpd_lex_all() {
  let __tuff_this = { this: __tuff_outer_for_cpd_lex_all };
  return lex_all();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpd_lex_all = cpd_lex_all;

const __tuff_outer_for_cpd_tok_kind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpd_tok_kind(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_cpd_tok_kind };
  return tok_kind(idx);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpd_tok_kind = cpd_tok_kind;

const __tuff_outer_for_cpd_tok_value = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpd_tok_value(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_cpd_tok_value };
  return tok_value(idx);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpd_tok_value = cpd_tok_value;

const __tuff_outer_for_cpd_tok_line = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpd_tok_line(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_cpd_tok_line };
  return tok_line(idx);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpd_tok_line = cpd_tok_line;

const __tuff_outer_for_cpd_tok_col = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpd_tok_col(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_cpd_tok_col };
  return tok_col(idx);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpd_tok_col = cpd_tok_col;

const __tuff_outer_for_cpd_get_interned_str = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpd_get_interned_str(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_cpd_get_interned_str };
  return get_interned_str(idx);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpd_get_interned_str = cpd_get_interned_str;

const __tuff_outer_for_compile_source = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function compile_source(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_compile_source };
  return compile_source_with_options(source, 0, 500, 1, "js");
}
if (typeof __tuff_this !== 'undefined') __tuff_this.compile_source = compile_source;

const __tuff_outer_for_main = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function main() {
  let __tuff_this = { this: __tuff_outer_for_main };
  let argc = get_argc(); if (typeof __tuff_this !== 'undefined') __tuff_this.argc = argc;
  if ((argc < 2)) {
  print_error("Usage: tuffc <input.tuff> -o <output> [--target <js|c|tuff>] [--module-base <dir> (legacy)]");
  return 1;
}
  let first_arg = get_argv(1); if (typeof __tuff_this !== 'undefined') __tuff_this.first_arg = first_arg;
  if ((() => { const __recv = first_arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("--version"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "--version") : str_eq(__recv, "--version"); })()) {
  print("tuffc (stage3 native)");
  return 0;
}
  if (((() => { const __recv = first_arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("-h"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "-h") : str_eq(__recv, "-h"); })() || (() => { const __recv = first_arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("--help"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "--help") : str_eq(__recv, "--help"); })())) {
  print("Usage: tuffc <input.tuff> -o <output> [--target <js|c|tuff>] [--module-base <dir> (legacy)] [--version]");
  return 0;
}
  let input_file = first_arg; if (typeof __tuff_this !== 'undefined') __tuff_this.input_file = input_file;
  let output_file = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.output_file = output_file;
  let target = "js"; if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let lint_enabled = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.lint_enabled = lint_enabled;
  let lint_strict = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.lint_strict = lint_strict;
  let borrow_enabled = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.borrow_enabled = borrow_enabled;
  let profile_enabled = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.profile_enabled = profile_enabled;
  let i = 2; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let had_error = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.had_error = had_error;
  while ((i < argc)) {
  let arg = get_argv(i); if (typeof __tuff_this !== 'undefined') __tuff_this.arg = arg;
  if (((() => { const __recv = arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("-o"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "-o") : str_eq(__recv, "-o"); })() || (() => { const __recv = arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("--out"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "--out") : str_eq(__recv, "--out"); })())) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((i < argc)) {
  output_file = get_argv(i); if (typeof __tuff_this !== 'undefined') __tuff_this.output_file = output_file;
} else {
  print_error("Missing value for -o/--out");
  had_error = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.had_error = had_error;
}
} else { if ((() => { const __recv = arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("--target"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "--target") : str_eq(__recv, "--target"); })()) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((i < argc)) {
  target = get_argv(i); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
} else {
  print_error("Missing value for --target");
  had_error = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.had_error = had_error;
}
} else { if ((() => { const __recv = arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("--lint"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "--lint") : str_eq(__recv, "--lint"); })()) {
  lint_enabled = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lint_enabled = lint_enabled;
} else { if ((() => { const __recv = arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("--lint-strict"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "--lint-strict") : str_eq(__recv, "--lint-strict"); })()) {
  lint_enabled = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lint_enabled = lint_enabled;
  lint_strict = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lint_strict = lint_strict;
} else { if ((() => { const __recv = arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("--profile"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "--profile") : str_eq(__recv, "--profile"); })()) {
  profile_enabled = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.profile_enabled = profile_enabled;
} else { if ((() => { const __recv = arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("--no-borrowcheck"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "--no-borrowcheck") : str_eq(__recv, "--no-borrowcheck"); })()) {
  borrow_enabled = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.borrow_enabled = borrow_enabled;
} else { if (((() => { const __recv = arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("--modules"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "--modules") : str_eq(__recv, "--modules"); })() || (() => { const __recv = arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("--no-modules"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "--no-modules") : str_eq(__recv, "--no-modules"); })())) {
  print_error((() => { const __recv = (() => { const __recv = "Legacy option: "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(arg); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, arg) : str_concat(__recv, arg); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(". Module graph loading is always enabled for file compilation; remove this option."); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, ". Module graph loading is always enabled for file compilation; remove this option.") : str_concat(__recv, ". Module graph loading is always enabled for file compilation; remove this option."); })());
  had_error = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.had_error = had_error;
} else { if ((() => { const __recv = arg; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop("--module-base"); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "--module-base") : str_eq(__recv, "--module-base"); })()) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((i >= argc)) {
  print_error("Missing value for --module-base");
  had_error = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.had_error = had_error;
}
} } } } } } } }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  if ((had_error === 1)) {
  return 1;
}
  if ((() => { const __recv = output_file; const __prop = __recv?.["str_eq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.str_eq; return __dyn ? __dyn(__recv.ref, "") : str_eq(__recv, ""); })()) {
  print_error("Missing required -o/--out <output_file>. Native selfhost CLI writes compiled output to a file.");
  return 1;
}
  let result_code = compile_file_with_options(input_file, output_file, lint_enabled, 500, borrow_enabled, target); if (typeof __tuff_this !== 'undefined') __tuff_this.result_code = result_code;
  if ((result_code === 0)) {
  print((() => { const __recv = (() => { const __recv = (() => { const __recv = "Compiled "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(input_file); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, input_file) : str_concat(__recv, input_file); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(" -> "); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, " -> ") : str_concat(__recv, " -> "); })(); const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(output_file); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, output_file) : str_concat(__recv, output_file); })());
}
  if ((lint_enabled === 1)) {
  let issues = take_lint_issues(); if (typeof __tuff_this !== 'undefined') __tuff_this.issues = issues;
  if (((() => { const __recv = issues; const __prop = __recv?.["str_length"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.str_length; return __dyn ? __dyn(__recv.ref) : str_length(__recv); })() > 0)) {
  print_error((() => { const __recv = "[lint] "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(issues); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, issues) : str_concat(__recv, issues); })());
  if ((lint_strict === 1)) {
  result_code = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.result_code = result_code;
}
}
}
  if ((profile_enabled === 1)) {
  print_error((() => { const __recv = "[profile] "; const __prop = __recv?.["str_concat"]; if (typeof __prop === "function") return __prop(profile_take_json()); const __dyn = __recv?.table?.str_concat; return __dyn ? __dyn(__recv.ref, profile_take_json()) : str_concat(__recv, profile_take_json()); })());
}
  return result_code;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.main = main;

