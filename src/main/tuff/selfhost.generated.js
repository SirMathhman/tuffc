"use strict";





















// type StrIndex(...) = ...





{
  
}











function strIndexOf(__this_param, needle) {
  let __tuff_this = undefined;
  return __str_index_of((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)), needle);
}

function strIncludes(__this_param, needle) {
  let __tuff_this = undefined;
  return ((() => { const __recv = (typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)); const __prop = __recv?.["strIndexOf"]; if (typeof __prop === "function") return __prop(needle); const __dyn = __recv?.table?.strIndexOf; return __dyn ? __dyn(__recv.ref, needle) : strIndexOf(__recv, needle); })() >= 0);
}

function strStartsWith(__this_param, prefix) {
  let __tuff_this = undefined;
  let plen = (() => { const __recv = prefix; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.plen = plen;
  return ((((() => { const __recv = (typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)); const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() < plen)) ? (() => {
    return false;
  })() : (() => {
    return (() => { const __recv = (() => { const __recv = (typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)); const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(0, plen); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, 0, plen) : strSlice(__recv, 0, plen); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(prefix); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, prefix) : strEq(__recv, prefix); })();
  })());
}









const __tuff_outer_for_intToString = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function intToString(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_intToString };
  return __int_to_string(n);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.intToString = intToString;





















const __tuff_outer_for_vecNew = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function vecNew() {
  let __tuff_this = { this: __tuff_outer_for_vecNew };
  return __vec_new();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.vecNew = vecNew;

function vecPush(__this_param, item) {
  let __tuff_this = undefined;
  return __vec_push((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)), item);
}

function vecPop(__this_param) {
  let __tuff_this = undefined;
  return __vec_pop((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)));
}



function vecGet(__this_param, i) {
  let __tuff_this = undefined;
  return __vec_get((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)), i);
}

















function vecSet(__this_param, i, v) {
  let __tuff_this = undefined;
  return __vec_set((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)), i, v);
}

function vecLength(__this_param) {
  let __tuff_this = undefined;
  return (0 + __vec_length((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this))));
}

function vecInit(__this_param) {
  let __tuff_this = undefined;
  return __vec_init((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)));
}

function vecCapacity(__this_param) {
  let __tuff_this = undefined;
  return __vec_capacity((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)));
}

function vecClear(__this_param) {
  let __tuff_this = undefined;
  return __vec_clear((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)));
}

function vecClone(__this_param) {
  let __tuff_this = undefined;
  return __vec_clone((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)));
}

function vecJoin(__this_param, sep) {
  let __tuff_this = undefined;
  return __vec_join((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)), sep);
}

function vecIncludes(__this_param, item) {
  let __tuff_this = undefined;
  return __vec_includes((typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this)), item);
}

















const __tuff_outer_for_mapNew = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function mapNew() {
  let __tuff_this = { this: __tuff_outer_for_mapNew };
  return __map_new();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.mapNew = mapNew;













const __tuff_outer_for_setNew = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function setNew() {
  let __tuff_this = { this: __tuff_outer_for_setNew };
  return __set_new();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.setNew = setNew;













const __tuff_outer_for_printError = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function printError(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_printError };
  return __print_error(s);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.printError = printError;













const __tuff_outer_for_perfNow = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function perfNow() {
  let __tuff_this = { this: __tuff_outer_for_perfNow };
  return __perf_now();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.perfNow = perfNow;





const __tuff_outer_for_profileTakeJson = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function profileTakeJson() {
  let __tuff_this = { this: __tuff_outer_for_profileTakeJson };
  return __profile_take_json();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.profileTakeJson = profileTakeJson;

let TK_EOF = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_EOF = TK_EOF;

let TK_KEYWORD = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_KEYWORD = TK_KEYWORD;

let TK_IDENTIFIER = 2; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_IDENTIFIER = TK_IDENTIFIER;

let TK_NUMBER = 3; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_NUMBER = TK_NUMBER;

let TK_STRING = 4; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_STRING = TK_STRING;

let TK_BOOL = 5; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_BOOL = TK_BOOL;

let TK_SYMBOL = 6; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_SYMBOL = TK_SYMBOL;

let TK_CHAR = 7; if (typeof __tuff_this !== 'undefined') __tuff_this.TK_CHAR = TK_CHAR;

let tokens = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tokens = tokens;

let tokCount = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.tokCount = tokCount;

const __tuff_outer_for_triviaSepField = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function triviaSepField() {
  let __tuff_this = { this: __tuff_outer_for_triviaSepField };
  return "\u001f";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.triviaSepField = triviaSepField;

const __tuff_outer_for_triviaSepRecord = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function triviaSepRecord() {
  let __tuff_this = { this: __tuff_outer_for_triviaSepRecord };
  return "\u001e";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.triviaSepRecord = triviaSepRecord;

let triviaData = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.triviaData = triviaData;

const __tuff_outer_for_triviaAdd = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function triviaAdd(kind, text, line, col) {
  let __tuff_this = { kind: kind, text: text, line: line, col: col, this: __tuff_outer_for_triviaAdd };
  (() => { const __recv = triviaData; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(kind); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, kind) : vecPush(__recv, kind); })();
  (() => { const __recv = triviaData; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(text); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, text) : vecPush(__recv, text); })();
  (() => { const __recv = triviaData; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(line); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, line) : vecPush(__recv, line); })();
  (() => { const __recv = triviaData; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(col); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, col) : vecPush(__recv, col); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.triviaAdd = triviaAdd;

const __tuff_outer_for_lexTakeTrivia = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexTakeTrivia() {
  let __tuff_this = { this: __tuff_outer_for_lexTakeTrivia };
  let len = (() => { const __recv = triviaData; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return "";
}
  let sep = triviaSepField(); if (typeof __tuff_this !== 'undefined') __tuff_this.sep = sep;
  let rsep = triviaSepRecord(); if (typeof __tuff_this !== 'undefined') __tuff_this.rsep = rsep;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let result = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  while ((i < len)) {
  if ((i > 0)) {
  result = (() => { const __recv = result; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(rsep); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, rsep) : strConcat(__recv, rsep); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
}
  result = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = result; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = triviaData; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = triviaData; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()) : strConcat(__recv, (() => { const __recv = triviaData; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(sep); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, sep) : strConcat(__recv, sep); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = triviaData; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (i + 1)) : vecGet(__recv, (i + 1)); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = triviaData; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (i + 1)) : vecGet(__recv, (i + 1)); })()) : strConcat(__recv, (() => { const __recv = triviaData; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (i + 1)) : vecGet(__recv, (i + 1)); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(sep); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, sep) : strConcat(__recv, sep); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = triviaData; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((i + 2)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (i + 2)) : vecGet(__recv, (i + 2)); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = triviaData; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((i + 2)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (i + 2)) : vecGet(__recv, (i + 2)); })())) : strConcat(__recv, intToString((() => { const __recv = triviaData; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((i + 2)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (i + 2)) : vecGet(__recv, (i + 2)); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(sep); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, sep) : strConcat(__recv, sep); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = triviaData; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((i + 3)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (i + 3)) : vecGet(__recv, (i + 3)); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = triviaData; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((i + 3)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (i + 3)) : vecGet(__recv, (i + 3)); })())) : strConcat(__recv, intToString((() => { const __recv = triviaData; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((i + 3)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (i + 3)) : vecGet(__recv, (i + 3)); })())); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  i = (i + 4); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  (() => { const __recv = triviaData; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  return result;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexTakeTrivia = lexTakeTrivia;

const __tuff_outer_for_tokAdd = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tokAdd(kind, value, line, col) {
  let __tuff_this = { kind: kind, value: value, line: line, col: col, this: __tuff_outer_for_tokAdd };
  let idx = tokCount; if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  (() => { const __recv = tokens; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(kind); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, kind) : vecPush(__recv, kind); })();
  (() => { const __recv = tokens; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, value) : vecPush(__recv, value); })();
  (() => { const __recv = tokens; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(line); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, line) : vecPush(__recv, line); })();
  (() => { const __recv = tokens; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(col); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, col) : vecPush(__recv, col); })();
  tokCount = (tokCount + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.tokCount = tokCount;
  return idx;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tokAdd = tokAdd;

const __tuff_outer_for_tokKind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tokKind(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_tokKind };
  return (() => { const __recv = tokens; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((idx * 4)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (idx * 4)) : vecGet(__recv, (idx * 4)); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tokKind = tokKind;

const __tuff_outer_for_tokValue = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tokValue(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_tokValue };
  return (() => { const __recv = tokens; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(((idx * 4) + 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, ((idx * 4) + 1)) : vecGet(__recv, ((idx * 4) + 1)); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tokValue = tokValue;

const __tuff_outer_for_tokLine = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tokLine(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_tokLine };
  return (() => { const __recv = tokens; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(((idx * 4) + 2)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, ((idx * 4) + 2)) : vecGet(__recv, ((idx * 4) + 2)); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tokLine = tokLine;

const __tuff_outer_for_tokCol = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tokCol(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_tokCol };
  return (() => { const __recv = tokens; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(((idx * 4) + 3)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, ((idx * 4) + 3)) : vecGet(__recv, ((idx * 4) + 3)); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tokCol = tokCol;

let internTable = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.internTable = internTable;

let internMap = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.internMap = internMap;

const __tuff_outer_for_intern = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function intern(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_intern };
  let existing = (() => { const __recv = internMap; const __prop = __recv?.["mapGetOrDefault"]; if (typeof __prop === "function") return __prop(s, (-1)); const __dyn = __recv?.table?.mapGetOrDefault; return __dyn ? __dyn(__recv.ref, s, (-1)) : mapGetOrDefault(__recv, s, (-1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.existing = existing;
  return (((existing !== (-1))) ? (() => {
    return existing;
  })() : (() => {
    let idx = (() => { const __recv = internTable; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
    (() => { const __recv = internTable; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(s); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, s) : vecPush(__recv, s); })();
    (() => { const __recv = internMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(s, idx); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, s, idx) : mapSet(__recv, s, idx); })();
    return idx;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.intern = intern;

const __tuff_outer_for_internStr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function internStr(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_internStr };
  return intern(s);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.internStr = internStr;

const __tuff_outer_for_getIntern = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function getIntern(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_getIntern };
  return (() => { const __recv = internTable; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, idx) : vecGet(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.getIntern = getIntern;

const __tuff_outer_for_getInternedStr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function getInternedStr(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_getInternedStr };
  return getIntern(idx);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.getInternedStr = getInternedStr;

let keywords = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.keywords = keywords;

const __tuff_outer_for_initKeywords = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function initKeywords() {
  let __tuff_this = { this: __tuff_outer_for_initKeywords };
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("fn"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "fn") : setAdd(__recv, "fn"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("let"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "let") : setAdd(__recv, "let"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("struct"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "struct") : setAdd(__recv, "struct"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("enum"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "enum") : setAdd(__recv, "enum"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("type"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "type") : setAdd(__recv, "type"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("match"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "match") : setAdd(__recv, "match"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("case"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "case") : setAdd(__recv, "case"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("if"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "if") : setAdd(__recv, "if"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("else"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "else") : setAdd(__recv, "else"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("for"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "for") : setAdd(__recv, "for"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("while"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "while") : setAdd(__recv, "while"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("loop"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "loop") : setAdd(__recv, "loop"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("in"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "in") : setAdd(__recv, "in"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("return"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "return") : setAdd(__recv, "return"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("break"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "break") : setAdd(__recv, "break"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("continue"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "continue") : setAdd(__recv, "continue"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("is"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "is") : setAdd(__recv, "is"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("class"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "class") : setAdd(__recv, "class"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("object"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "object") : setAdd(__recv, "object"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("contract"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "contract") : setAdd(__recv, "contract"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("impl"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "impl") : setAdd(__recv, "impl"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "into") : setAdd(__recv, "into"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("with"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "with") : setAdd(__recv, "with"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("out"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "out") : setAdd(__recv, "out"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("module"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "module") : setAdd(__recv, "module"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("extern"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "extern") : setAdd(__recv, "extern"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("copy"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "copy") : setAdd(__recv, "copy"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("async"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "async") : setAdd(__recv, "async"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("mut"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "mut") : setAdd(__recv, "mut"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("move"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "move") : setAdd(__recv, "move"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("then"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "then") : setAdd(__recv, "then"); })();
  (() => { const __recv = keywords; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("lifetime"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "lifetime") : setAdd(__recv, "lifetime"); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.initKeywords = initKeywords;

const __tuff_outer_for_isKeyword = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isKeyword(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_isKeyword };
  return (() => { const __recv = keywords; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(s); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, s) : setHas(__recv, s); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isKeyword = isKeyword;

let lexSource = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.lexSource = lexSource;

let lexPos = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.lexPos = lexPos;

let lexLine = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lexLine = lexLine;

let lexCol = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lexCol = lexCol;

let lexLen = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.lexLen = lexLen;

const __tuff_outer_for_lexInit = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexInit(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_lexInit };
  let sourceLen = (() => { const __recv = source; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.sourceLen = sourceLen;
  lexSource = source; if (typeof __tuff_this !== 'undefined') __tuff_this.lexSource = lexSource;
  lexPos = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.lexPos = lexPos;
  lexLine = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lexLine = lexLine;
  lexCol = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lexCol = lexCol;
  lexLen = sourceLen; if (typeof __tuff_this !== 'undefined') __tuff_this.lexLen = lexLen;
  (() => { const __recv = tokens; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  (() => { const __recv = triviaData; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  tokCount = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.tokCount = tokCount;
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexInit = lexInit;

const __tuff_outer_for_lexPeek = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexPeek(offset) {
  let __tuff_this = { offset: offset, this: __tuff_outer_for_lexPeek };
  let p = (lexPos + offset); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  return ((((p >= 0) && (p < lexLen))) ? (() => {
    return (() => { const __recv = lexSource; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(p); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, p) : strCharAt(__recv, p); })();
  })() : (() => {
    return 0;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexPeek = lexPeek;

const __tuff_outer_for_lexAdvance = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexAdvance() {
  let __tuff_this = { this: __tuff_outer_for_lexAdvance };
  let ch = lexPeek(0); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  lexPos = (lexPos + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.lexPos = lexPos;
  return (((ch === 10)) ? (() => {
    lexLine = (lexLine + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.lexLine = lexLine;
    lexCol = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lexCol = lexCol;
    return ch;
  })() : (() => {
    lexCol = (lexCol + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.lexCol = lexCol;
    return ch;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexAdvance = lexAdvance;

const __tuff_outer_for_isAlpha = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isAlpha(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_isAlpha };
  return ((((ch >= 65) && (ch <= 90))) ? (() => {
    return true;
  })() : ((((ch >= 97) && (ch <= 122))) ? (() => {
    return true;
  })() : (((ch === 95)) ? (() => {
    return true;
  })() : (() => {
    return false;
  })())));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isAlpha = isAlpha;

const __tuff_outer_for_isDigit = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isDigit(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_isDigit };
  return ((ch >= 48) && (ch <= 57));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isDigit = isDigit;

const __tuff_outer_for_isAlnum = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isAlnum(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_isAlnum };
  return (isAlpha(ch) || isDigit(ch));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isAlnum = isAlnum;

const __tuff_outer_for_isWhitespace = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isWhitespace(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_isWhitespace };
  return ((((ch === 32) || (ch === 9)) || (ch === 13)) || (ch === 10));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isWhitespace = isWhitespace;

const __tuff_outer_for_lexReadIdent = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexReadIdent() {
  let __tuff_this = { this: __tuff_outer_for_lexReadIdent };
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  while (isAlnum(lexPeek(0))) {
  sbAppendChar(sb, lexAdvance());
}
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexReadIdent = lexReadIdent;

const __tuff_outer_for_lexReadNumber = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexReadNumber() {
  let __tuff_this = { this: __tuff_outer_for_lexReadNumber };
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  if ((lexPeek(0) === 48)) {
  let next = lexPeek(1); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((((next === 120) || (next === 98)) || (next === 111))) {
  sbAppendChar(sb, lexAdvance());
  sbAppendChar(sb, lexAdvance());
  while ((isAlnum(lexPeek(0)) || (lexPeek(0) === 95))) {
  let ch = lexAdvance(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((ch !== 95)) {
  sbAppendChar(sb, ch);
}
}
  return sbBuild(sb);
}
}
  while ((isDigit(lexPeek(0)) || (lexPeek(0) === 95))) {
  let ch = lexAdvance(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((ch !== 95)) {
  sbAppendChar(sb, ch);
}
}
  if (((lexPeek(0) === 46) && isDigit(lexPeek(1)))) {
  sbAppendChar(sb, lexAdvance());
  while ((isDigit(lexPeek(0)) || (lexPeek(0) === 95))) {
  let ch = lexAdvance(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((ch !== 95)) {
  sbAppendChar(sb, ch);
}
}
}
  while ((isAlnum(lexPeek(0)) || (lexPeek(0) === 95))) {
  let ch = lexAdvance(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((ch !== 95)) {
  sbAppendChar(sb, ch);
}
}
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexReadNumber = lexReadNumber;

const __tuff_outer_for_lexReadString = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexReadString() {
  let __tuff_this = { this: __tuff_outer_for_lexReadString };
  lexAdvance();
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  while (((lexPos < lexLen) && (lexPeek(0) !== 34))) {
  if ((lexPeek(0) === 92)) {
  sbAppendChar(sb, lexAdvance());
  sbAppendChar(sb, lexAdvance());
} else {
  sbAppendChar(sb, lexAdvance());
}
}
  if ((lexPeek(0) !== 34)) {
  panicWithCode("E_LEX_UNTERMINATED_STRING", (() => { const __recv = (() => { const __recv = (() => { const __recv = "Unterminated string literal at "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(lexLine)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(lexLine)) : strConcat(__recv, intToString(lexLine)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(lexCol)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(lexCol)) : strConcat(__recv, intToString(lexCol)); })(), "The lexer reached end-of-line or end-of-file before finding the closing quote delimiter for this string.", "Close the string with a matching quote delimiter, or escape embedded quotes.");
}
  lexAdvance();
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexReadString = lexReadString;

const __tuff_outer_for_lexReadChar = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexReadChar() {
  let __tuff_this = { this: __tuff_outer_for_lexReadChar };
  lexAdvance();
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  while (((lexPos < lexLen) && (lexPeek(0) !== 39))) {
  sbAppendChar(sb, lexAdvance());
}
  if ((lexPeek(0) !== 39)) {
  panicWithCode("E_LEX_UNTERMINATED_CHAR", (() => { const __recv = (() => { const __recv = (() => { const __recv = "Unterminated char literal at "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(lexLine)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(lexLine)) : strConcat(__recv, intToString(lexLine)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(lexCol)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(lexCol)) : strConcat(__recv, intToString(lexCol)); })(), "The lexer reached end-of-line or end-of-file before finding the closing apostrophe delimiter for this char literal.", "Close the char literal with a matching apostrophe and ensure only one character (or valid escape) is inside.");
}
  lexAdvance();
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexReadChar = lexReadChar;

const __tuff_outer_for_lexCheckTwo = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexCheckTwo(a, b) {
  let __tuff_this = { a: a, b: b, this: __tuff_outer_for_lexCheckTwo };
  return ((lexPeek(0) === a) && (lexPeek(1) === b));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexCheckTwo = lexCheckTwo;

const __tuff_outer_for_lexTryConsumeBom = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexTryConsumeBom(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_lexTryConsumeBom };
  if (((((lexPos === 0) && (ch === 239)) && (lexPeek(1) === 187)) && (lexPeek(2) === 191))) {
  lexAdvance();
  lexAdvance();
  lexAdvance();
  return true;
}
  if (((lexPos === 0) && ((ch === 65279) || (ch === 65534)))) {
  lexAdvance();
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexTryConsumeBom = lexTryConsumeBom;

const __tuff_outer_for_lexTrySkipWhitespaceOrComment = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexTrySkipWhitespaceOrComment(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_lexTrySkipWhitespaceOrComment };
  if (isWhitespace(ch)) {
  lexAdvance();
  return true;
}
  if (((ch === 47) && (lexPeek(1) === 47))) {
  let startLine = lexLine; if (typeof __tuff_this !== 'undefined') __tuff_this.startLine = startLine;
  let startCol = lexCol; if (typeof __tuff_this !== 'undefined') __tuff_this.startCol = startCol;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  while (((lexPos < lexLen) && (lexPeek(0) !== 10))) {
  sbAppendChar(sb, lexAdvance());
}
  triviaAdd("line_comment", sbBuild(sb), startLine, startCol);
  return true;
}
  if (((ch === 47) && (lexPeek(1) === 42))) {
  let startLine = lexLine; if (typeof __tuff_this !== 'undefined') __tuff_this.startLine = startLine;
  let startCol = lexCol; if (typeof __tuff_this !== 'undefined') __tuff_this.startCol = startCol;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppendChar(sb, lexAdvance());
  sbAppendChar(sb, lexAdvance());
  while (((lexPos < lexLen) && (!((lexPeek(0) === 42) && (lexPeek(1) === 47))))) {
  sbAppendChar(sb, lexAdvance());
}
  if ((lexPos >= lexLen)) {
  panicWithCode("E_LEX_UNTERMINATED_BLOCK_COMMENT", (() => { const __recv = (() => { const __recv = (() => { const __recv = "Unterminated block comment near "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(lexLine)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(lexLine)) : strConcat(__recv, intToString(lexLine)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(lexCol)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(lexCol)) : strConcat(__recv, intToString(lexCol)); })(), "A block comment started with '/*' but the lexer did not find a matching '*/' before end-of-file.", "Add a closing '*/' for this comment, or remove the unmatched opening '/*'.");
}
  sbAppendChar(sb, lexAdvance());
  sbAppendChar(sb, lexAdvance());
  triviaAdd("block_comment", sbBuild(sb), startLine, startCol);
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexTrySkipWhitespaceOrComment = lexTrySkipWhitespaceOrComment;

const __tuff_outer_for_lexTryEmitThreeCharSymbol = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexTryEmitThreeCharSymbol(startLine, startCol) {
  let __tuff_this = { startLine: startLine, startCol: startCol, this: __tuff_outer_for_lexTryEmitThreeCharSymbol };
  if ((((lexPeek(0) === 46) && (lexPeek(1) === 46)) && (lexPeek(2) === 46))) {
  lexAdvance();
  lexAdvance();
  lexAdvance();
  tokAdd(TK_SYMBOL, intern("..."), startLine, startCol);
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexTryEmitThreeCharSymbol = lexTryEmitThreeCharSymbol;

const __tuff_outer_for_lexTryEmitTwoCharSymbol = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexTryEmitTwoCharSymbol(startLine, startCol) {
  let __tuff_this = { startLine: startLine, startCol: startCol, this: __tuff_outer_for_lexTryEmitTwoCharSymbol };
  if (lexCheckTwo(61, 62)) {
  lexAdvance();
  lexAdvance();
  tokAdd(TK_SYMBOL, intern("=>"), startLine, startCol);
  return true;
}
  if (lexCheckTwo(61, 61)) {
  lexAdvance();
  lexAdvance();
  tokAdd(TK_SYMBOL, intern("=="), startLine, startCol);
  return true;
}
  if (lexCheckTwo(33, 61)) {
  lexAdvance();
  lexAdvance();
  tokAdd(TK_SYMBOL, intern("!="), startLine, startCol);
  return true;
}
  if (lexCheckTwo(60, 61)) {
  lexAdvance();
  lexAdvance();
  tokAdd(TK_SYMBOL, intern("<="), startLine, startCol);
  return true;
}
  if (lexCheckTwo(62, 61)) {
  lexAdvance();
  lexAdvance();
  tokAdd(TK_SYMBOL, intern(">="), startLine, startCol);
  return true;
}
  if (lexCheckTwo(38, 38)) {
  lexAdvance();
  lexAdvance();
  tokAdd(TK_SYMBOL, intern("&&"), startLine, startCol);
  return true;
}
  if (lexCheckTwo(124, 124)) {
  lexAdvance();
  lexAdvance();
  tokAdd(TK_SYMBOL, intern("||"), startLine, startCol);
  return true;
}
  if (lexCheckTwo(58, 58)) {
  lexAdvance();
  lexAdvance();
  tokAdd(TK_SYMBOL, intern("::"), startLine, startCol);
  return true;
}
  if (lexCheckTwo(46, 46)) {
  lexAdvance();
  lexAdvance();
  tokAdd(TK_SYMBOL, intern(".."), startLine, startCol);
  return true;
}
  if (lexCheckTwo(124, 62)) {
  lexAdvance();
  lexAdvance();
  tokAdd(TK_SYMBOL, intern("|>"), startLine, startCol);
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexTryEmitTwoCharSymbol = lexTryEmitTwoCharSymbol;

const __tuff_outer_for_lexAll = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lexAll() {
  let __tuff_this = { this: __tuff_outer_for_lexAll };
  initKeywords();
  while ((lexPos < lexLen)) {
  let ch = lexPeek(0); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((lexTryConsumeBom(ch) || lexTrySkipWhitespaceOrComment(ch))) {
  continue;
}
  let startLine = lexLine; if (typeof __tuff_this !== 'undefined') __tuff_this.startLine = startLine;
  let startCol = lexCol; if (typeof __tuff_this !== 'undefined') __tuff_this.startCol = startCol;
  if ((lexTryEmitThreeCharSymbol(startLine, startCol) || lexTryEmitTwoCharSymbol(startLine, startCol))) {
  continue;
}
  if (isAlpha(ch)) {
  let text = lexReadIdent(); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  if ((() => { const __recv = text; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("true"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "true") : strEq(__recv, "true"); })()) {
  tokAdd(TK_BOOL, 1, startLine, startCol);
} else { if ((() => { const __recv = text; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("false"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "false") : strEq(__recv, "false"); })()) {
  tokAdd(TK_BOOL, 0, startLine, startCol);
} else { if (isKeyword(text)) {
  tokAdd(TK_KEYWORD, intern(text), startLine, startCol);
} else {
  tokAdd(TK_IDENTIFIER, intern(text), startLine, startCol);
} } }
  continue;
}
  if (isDigit(ch)) {
  let text = lexReadNumber(); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  tokAdd(TK_NUMBER, intern(text), startLine, startCol);
  continue;
}
  if ((ch === 34)) {
  let text = lexReadString(); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  tokAdd(TK_STRING, intern(text), startLine, startCol);
  continue;
}
  if ((ch === 39)) {
  let text = lexReadChar(); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  tokAdd(TK_CHAR, intern(text), startLine, startCol);
  continue;
}
  let symText = strFromCharCode(ch); if (typeof __tuff_this !== 'undefined') __tuff_this.symText = symText;
  if ((((() => { const __recv = symText; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() === 1) && (() => { const __recv = "(){}[],:;+-*/%<>=.!?|&"; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop(symText); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, symText) : strIncludes(__recv, symText); })())) {
  lexAdvance();
  tokAdd(TK_SYMBOL, intern(symText), startLine, startCol);
  continue;
}
  let displayChar = symText; if (typeof __tuff_this !== 'undefined') __tuff_this.displayChar = displayChar;
  if (((() => { const __recv = displayChar; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() === 0)) {
  displayChar = "<non-printable>"; if (typeof __tuff_this !== 'undefined') __tuff_this.displayChar = displayChar;
}
  panicWithCode("E_LEX_UNEXPECTED_CHARACTER", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Unexpected character '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(displayChar); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, displayChar) : strConcat(__recv, displayChar); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' (code "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' (code ") : strConcat(__recv, "' (code "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(ch)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(ch)) : strConcat(__recv, intToString(ch)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") at "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") at ") : strConcat(__recv, ") at "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(startLine)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(startLine)) : strConcat(__recv, intToString(startLine)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(startCol)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(startCol)) : strConcat(__recv, intToString(startCol)); })(), "This character is not valid in the current lexical context and cannot be tokenized as part of Tuff syntax.", "Remove/replace the character, save source as UTF-8 without BOM, and use only supported symbols/identifiers in source text.");
}
  tokAdd(TK_EOF, intern("<eof>"), lexLine, lexCol);
  return tokCount;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lexAll = lexAll;

const __tuff_outer_for_countEffectiveTokenLines = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function countEffectiveTokenLines() {
  let __tuff_this = { this: __tuff_outer_for_countEffectiveTokenLines };
  let seen = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.seen = seen;
  let count = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < tokCount)) {
  if ((tokKind(i) !== TK_EOF)) {
  let line = tokLine(i); if (typeof __tuff_this !== 'undefined') __tuff_this.line = line;
  if ((!(() => { const __recv = seen; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(line); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, line) : mapHas(__recv, line); })())) {
  (() => { const __recv = seen; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(line, 1); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, line, 1) : mapSet(__recv, line, 1); })();
  count = (count + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return count;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.countEffectiveTokenLines = countEffectiveTokenLines;

const __tuff_outer_for_lintEffectiveLineCount = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintEffectiveLineCount() {
  let __tuff_this = { this: __tuff_outer_for_lintEffectiveLineCount };
  return countEffectiveTokenLines();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintEffectiveLineCount = lintEffectiveLineCount;

const __tuff_outer_for_lintAssertFileLength = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAssertFileLength(filePath, maxEffectiveLines) {
  let __tuff_this = { filePath: filePath, maxEffectiveLines: maxEffectiveLines, this: __tuff_outer_for_lintAssertFileLength };
  let count = countEffectiveTokenLines(); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  if ((count > maxEffectiveLines)) {
  panicWithCode("E_LINT_FILE_TOO_LONG", (() => { const __recv = (() => { const __recv = "File exceeds "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(maxEffectiveLines)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(maxEffectiveLines)) : strConcat(__recv, intToString(maxEffectiveLines)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = " effective lines ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(count)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(count)) : strConcat(__recv, intToString(count)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = " effective lines ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(count)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(count)) : strConcat(__recv, intToString(count)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })()) : strConcat(__recv, (() => { const __recv = (() => { const __recv = " effective lines ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(count)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(count)) : strConcat(__recv, intToString(count)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })()); })(), "Large files are harder to review and maintain; this file exceeds the maximum effective line budget after excluding comments and blank lines.", (() => { const __recv = (() => { const __recv = "Split this file into smaller modules so each file has at most "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(maxEffectiveLines)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(maxEffectiveLines)) : strConcat(__recv, intToString(maxEffectiveLines)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" non-comment, non-whitespace lines."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " non-comment, non-whitespace lines.") : strConcat(__recv, " non-comment, non-whitespace lines."); })());
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAssertFileLength = lintAssertFileLength;

const __tuff_outer_for_selfhostRuntimeLexerMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostRuntimeLexerMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostRuntimeLexerMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostRuntimeLexerMarker = selfhostRuntimeLexerMarker;

function Ok(fields = {}) { return { __tag: "Ok", value: fields.value }; }

function Err(fields = {}) { return { __tag: "Err", error: fields.error }; }

// type Result = ...

function ResolveError(fields = {}) { return { __tag: "ResolveError", code: fields.code, message: fields.message, reason: fields.reason, fix: fields.fix, line: fields.line, col: fields.col }; }

let NK_PROGRAM = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_PROGRAM = NK_PROGRAM;

let NK_FN_DECL = 2; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_FN_DECL = NK_FN_DECL;

let NK_STRUCT_DECL = 3; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_STRUCT_DECL = NK_STRUCT_DECL;

let NK_TYPE_ALIAS = 4; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_TYPE_ALIAS = NK_TYPE_ALIAS;

let NK_LET_DECL = 5; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_LET_DECL = NK_LET_DECL;

let NK_IMPORT_DECL = 6; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_IMPORT_DECL = NK_IMPORT_DECL;

let NK_EXPR_STMT = 7; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_EXPR_STMT = NK_EXPR_STMT;

let NK_RETURN_STMT = 8; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_RETURN_STMT = NK_RETURN_STMT;

let NK_IF_STMT = 9; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_IF_STMT = NK_IF_STMT;

let NK_WHILE_STMT = 10; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_WHILE_STMT = NK_WHILE_STMT;

let NK_FOR_STMT = 11; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_FOR_STMT = NK_FOR_STMT;

let NK_BLOCK = 12; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_BLOCK = NK_BLOCK;

let NK_ASSIGN_STMT = 13; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_ASSIGN_STMT = NK_ASSIGN_STMT;

let NK_BREAK_STMT = 14; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_BREAK_STMT = NK_BREAK_STMT;

let NK_CONTINUE_STMT = 15; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_CONTINUE_STMT = NK_CONTINUE_STMT;

let NK_CLASS_FN_DECL = 16; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_CLASS_FN_DECL = NK_CLASS_FN_DECL;

let NK_EXTERN_LET_DECL = 18; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_EXTERN_LET_DECL = NK_EXTERN_LET_DECL;

let NK_EXTERN_TYPE_DECL = 19; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_EXTERN_TYPE_DECL = NK_EXTERN_TYPE_DECL;

let NK_EXPECT_FN_DECL = 61; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_EXPECT_FN_DECL = NK_EXPECT_FN_DECL;

let NK_ACTUAL_FN_DECL = 62; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_ACTUAL_FN_DECL = NK_ACTUAL_FN_DECL;

let NK_OBJECT_DECL = 63; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_OBJECT_DECL = NK_OBJECT_DECL;

let NK_LOOP_STMT = 64; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_LOOP_STMT = NK_LOOP_STMT;

let NK_CONTRACT_DECL = 65; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_CONTRACT_DECL = NK_CONTRACT_DECL;

let NK_INTO_STMT = 66; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_INTO_STMT = NK_INTO_STMT;

let NK_LIFETIME_STMT = 67; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_LIFETIME_STMT = NK_LIFETIME_STMT;

let NK_STMT_LIST = 68; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_STMT_LIST = NK_STMT_LIST;

let NK_EXTERN_IMPORT_DECL = 69; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_EXTERN_IMPORT_DECL = NK_EXTERN_IMPORT_DECL;

let NK_ENUM_DECL = 60; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_ENUM_DECL = NK_ENUM_DECL;

let NK_DEP_TYPE_ALIAS = 70; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_DEP_TYPE_ALIAS = NK_DEP_TYPE_ALIAS;

let NK_APPLIED_TYPE = 71; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_APPLIED_TYPE = NK_APPLIED_TYPE;

let NK_NUMBER_LIT = 20; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_NUMBER_LIT = NK_NUMBER_LIT;

let NK_BOOL_LIT = 21; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_BOOL_LIT = NK_BOOL_LIT;

let NK_STRING_LIT = 22; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_STRING_LIT = NK_STRING_LIT;

let NK_CHAR_LIT = 23; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_CHAR_LIT = NK_CHAR_LIT;

let NK_IDENTIFIER = 24; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_IDENTIFIER = NK_IDENTIFIER;

let NK_BINARY_EXPR = 25; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_BINARY_EXPR = NK_BINARY_EXPR;

let NK_UNARY_EXPR = 26; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_UNARY_EXPR = NK_UNARY_EXPR;

let NK_CALL_EXPR = 27; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_CALL_EXPR = NK_CALL_EXPR;

let NK_MEMBER_EXPR = 28; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_MEMBER_EXPR = NK_MEMBER_EXPR;

let NK_INDEX_EXPR = 29; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_INDEX_EXPR = NK_INDEX_EXPR;

let NK_STRUCT_INIT = 30; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_STRUCT_INIT = NK_STRUCT_INIT;

let NK_IF_EXPR = 31; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_IF_EXPR = NK_IF_EXPR;

let NK_MATCH_EXPR = 32; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_MATCH_EXPR = NK_MATCH_EXPR;

let NK_IS_EXPR = 33; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_IS_EXPR = NK_IS_EXPR;

let NK_UNWRAP_EXPR = 34; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_UNWRAP_EXPR = NK_UNWRAP_EXPR;

let NK_LAMBDA_EXPR = 35; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_LAMBDA_EXPR = NK_LAMBDA_EXPR;

let NK_FN_EXPR = 36; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_FN_EXPR = NK_FN_EXPR;

let NK_TUPLE_EXPR = 37; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_TUPLE_EXPR = NK_TUPLE_EXPR;

let NK_NAMED_TYPE = 40; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_NAMED_TYPE = NK_NAMED_TYPE;

let NK_POINTER_TYPE = 41; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_POINTER_TYPE = NK_POINTER_TYPE;

let NK_ARRAY_TYPE = 42; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_ARRAY_TYPE = NK_ARRAY_TYPE;

let NK_TUPLE_TYPE = 43; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_TUPLE_TYPE = NK_TUPLE_TYPE;

let NK_REFINEMENT_TYPE = 44; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_REFINEMENT_TYPE = NK_REFINEMENT_TYPE;

let NK_UNION_TYPE = 45; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_UNION_TYPE = NK_UNION_TYPE;

let NK_FUNCTION_TYPE = 46; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_FUNCTION_TYPE = NK_FUNCTION_TYPE;

let NK_WILDCARD_PAT = 50; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_WILDCARD_PAT = NK_WILDCARD_PAT;

let NK_LITERAL_PAT = 51; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_LITERAL_PAT = NK_LITERAL_PAT;

let NK_NAME_PAT = 52; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_NAME_PAT = NK_NAME_PAT;

let NK_STRUCT_PAT = 53; if (typeof __tuff_this !== 'undefined') __tuff_this.NK_STRUCT_PAT = NK_STRUCT_PAT;

const __tuff_outer_for_selfhostParserKindsMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostParserKindsMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostParserKindsMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostParserKindsMarker = selfhostParserKindsMarker;

function ParseError(fields = {}) { return { __tag: "ParseError", code: fields.code, message: fields.message, reason: fields.reason, fix: fields.fix, line: fields.line, col: fields.col }; }

let nodeKinds = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.nodeKinds = nodeKinds;

let nodeData1 = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.nodeData1 = nodeData1;

let nodeData2 = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.nodeData2 = nodeData2;

let nodeData3 = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.nodeData3 = nodeData3;

let nodeData4 = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.nodeData4 = nodeData4;

let nodeData5 = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.nodeData5 = nodeData5;

let nodeToks = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.nodeToks = nodeToks;

let nodeCount = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.nodeCount = nodeCount;

const __tuff_outer_for_nodeNew = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeNew(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_nodeNew };
  let idx = nodeCount; if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  (() => { const __recv = nodeKinds; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(kind); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, kind) : vecPush(__recv, kind); })();
  (() => { const __recv = nodeData1; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  (() => { const __recv = nodeData2; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  (() => { const __recv = nodeData3; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  (() => { const __recv = nodeData4; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  (() => { const __recv = nodeData5; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  (() => { const __recv = nodeToks; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(parsePos); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, parsePos) : vecPush(__recv, parsePos); })();
  nodeCount = (nodeCount + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nodeCount = nodeCount;
  return idx;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeNew = nodeNew;

const __tuff_outer_for_nodeKind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeKind(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_nodeKind };
  return (() => { const __recv = nodeKinds; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, idx) : vecGet(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeKind = nodeKind;

const __tuff_outer_for_nodeSetData1 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeSetData1(idx, v) {
  let __tuff_this = { idx: idx, v: v, this: __tuff_outer_for_nodeSetData1 };
  (() => { const __recv = nodeData1; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(idx, v); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, idx, v) : vecSet(__recv, idx, v); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeSetData1 = nodeSetData1;

const __tuff_outer_for_nodeSetData2 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeSetData2(idx, v) {
  let __tuff_this = { idx: idx, v: v, this: __tuff_outer_for_nodeSetData2 };
  (() => { const __recv = nodeData2; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(idx, v); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, idx, v) : vecSet(__recv, idx, v); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeSetData2 = nodeSetData2;

const __tuff_outer_for_nodeSetData3 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeSetData3(idx, v) {
  let __tuff_this = { idx: idx, v: v, this: __tuff_outer_for_nodeSetData3 };
  (() => { const __recv = nodeData3; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(idx, v); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, idx, v) : vecSet(__recv, idx, v); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeSetData3 = nodeSetData3;

const __tuff_outer_for_nodeSetData4 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeSetData4(idx, v) {
  let __tuff_this = { idx: idx, v: v, this: __tuff_outer_for_nodeSetData4 };
  (() => { const __recv = nodeData4; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(idx, v); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, idx, v) : vecSet(__recv, idx, v); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeSetData4 = nodeSetData4;

const __tuff_outer_for_nodeSetData5 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeSetData5(idx, v) {
  let __tuff_this = { idx: idx, v: v, this: __tuff_outer_for_nodeSetData5 };
  (() => { const __recv = nodeData5; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(idx, v); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, idx, v) : vecSet(__recv, idx, v); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeSetData5 = nodeSetData5;

const __tuff_outer_for_nodeGetData1 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeGetData1(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_nodeGetData1 };
  return (() => { const __recv = nodeData1; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, idx) : vecGet(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeGetData1 = nodeGetData1;

const __tuff_outer_for_nodeGetData2 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeGetData2(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_nodeGetData2 };
  return (() => { const __recv = nodeData2; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, idx) : vecGet(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeGetData2 = nodeGetData2;

const __tuff_outer_for_nodeGetData3 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeGetData3(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_nodeGetData3 };
  return (() => { const __recv = nodeData3; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, idx) : vecGet(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeGetData3 = nodeGetData3;

const __tuff_outer_for_nodeGetData4 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeGetData4(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_nodeGetData4 };
  return (() => { const __recv = nodeData4; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, idx) : vecGet(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeGetData4 = nodeGetData4;

const __tuff_outer_for_nodeGetData5 = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeGetData5(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_nodeGetData5 };
  return (() => { const __recv = nodeData5; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, idx) : vecGet(__recv, idx); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeGetData5 = nodeGetData5;

const __tuff_outer_for_nodeGetLine = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeGetLine(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_nodeGetLine };
  return tokLine((() => { const __recv = nodeToks; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, idx) : vecGet(__recv, idx); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeGetLine = nodeGetLine;

const __tuff_outer_for_nodeGetCol = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function nodeGetCol(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_nodeGetCol };
  return tokCol((() => { const __recv = nodeToks; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, idx) : vecGet(__recv, idx); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.nodeGetCol = nodeGetCol;

let parsePos = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.parsePos = parsePos;

let parseExports = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.parseExports = parseExports;

let PC_SYM_STAR = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.PC_SYM_STAR = PC_SYM_STAR;

let PC_SYM_LBRACKET = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.PC_SYM_LBRACKET = PC_SYM_LBRACKET;

let PC_SYM_LPAREN = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.PC_SYM_LPAREN = PC_SYM_LPAREN;

const __tuff_outer_for_pcInitSymbolCache = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pcInitSymbolCache() {
  let __tuff_this = { this: __tuff_outer_for_pcInitSymbolCache };
  if ((PC_SYM_STAR === 0)) {
  PC_SYM_STAR = internStr("*"); if (typeof __tuff_this !== 'undefined') __tuff_this.PC_SYM_STAR = PC_SYM_STAR;
  PC_SYM_LBRACKET = internStr("["); if (typeof __tuff_this !== 'undefined') __tuff_this.PC_SYM_LBRACKET = PC_SYM_LBRACKET;
  PC_SYM_LPAREN = internStr("("); if (typeof __tuff_this !== 'undefined') __tuff_this.PC_SYM_LPAREN = PC_SYM_LPAREN;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pcInitSymbolCache = pcInitSymbolCache;

const __tuff_outer_for_getParseExports = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function getParseExports() {
  let __tuff_this = { this: __tuff_outer_for_getParseExports };
  return parseExports;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.getParseExports = getParseExports;

const __tuff_outer_for_parseInit = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function parseInit() {
  let __tuff_this = { this: __tuff_outer_for_parseInit };
  parsePos = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.parsePos = parsePos;
  parseExports = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.parseExports = parseExports;
  (() => { const __recv = nodeKinds; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  (() => { const __recv = nodeData1; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  (() => { const __recv = nodeData2; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  (() => { const __recv = nodeData3; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  (() => { const __recv = nodeData4; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  (() => { const __recv = nodeData5; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  (() => { const __recv = nodeToks; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  (() => { const __recv = nodeKinds; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  (() => { const __recv = nodeData1; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  (() => { const __recv = nodeData2; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  (() => { const __recv = nodeData3; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  (() => { const __recv = nodeData4; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  (() => { const __recv = nodeData5; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  (() => { const __recv = nodeToks; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  nodeCount = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.nodeCount = nodeCount;
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.parseInit = parseInit;

const __tuff_outer_for_pPeek = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pPeek(offset) {
  let __tuff_this = { offset: offset, this: __tuff_outer_for_pPeek };
  let idx = (parsePos + offset); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  return (((idx >= tokCount)) ? (() => {
    return (tokCount - 1);
  })() : (() => {
    return idx;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pPeek = pPeek;

const __tuff_outer_for_pMark = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pMark() {
  let __tuff_this = { this: __tuff_outer_for_pMark };
  return parsePos;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pMark = pMark;

const __tuff_outer_for_pRestore = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pRestore(mark) {
  let __tuff_this = { mark: mark, this: __tuff_outer_for_pRestore };
  parsePos = mark; if (typeof __tuff_this !== 'undefined') __tuff_this.parsePos = parsePos;
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pRestore = pRestore;

const __tuff_outer_for_pAtKind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pAtKind(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_pAtKind };
  return (tokKind(pPeek(0)) === kind);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pAtKind = pAtKind;

const __tuff_outer_for_pAtValue = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pAtValue(val) {
  let __tuff_this = { val: val, this: __tuff_outer_for_pAtValue };
  let v = tokValue(pPeek(0)); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  return ((() => { const __recv = internMap; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(val); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, val) : mapHas(__recv, val); })() && ((() => { const __recv = internMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(val); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, val) : mapGet(__recv, val); })() === v));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pAtValue = pAtValue;

const __tuff_outer_for_pAt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pAt(kind, val) {
  let __tuff_this = { kind: kind, val: val, this: __tuff_outer_for_pAt };
  return (pAtKind(kind) && pAtValue(val));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pAt = pAt;

const __tuff_outer_for_pEat = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pEat() {
  let __tuff_this = { this: __tuff_outer_for_pEat };
  let t = pPeek(0); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  parsePos = (parsePos + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.parsePos = parsePos;
  return t;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pEat = pEat;

const __tuff_outer_for_pTokenKindName = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTokenKindName(knd) {
  let __tuff_this = { knd: knd, this: __tuff_outer_for_pTokenKindName };
  if ((knd === TK_EOF)) {
  return "eof";
}
  if ((knd === TK_KEYWORD)) {
  return "keyword";
}
  if ((knd === TK_IDENTIFIER)) {
  return "identifier";
}
  if ((knd === TK_NUMBER)) {
  return "number";
}
  if ((knd === TK_STRING)) {
  return "string";
}
  if ((knd === TK_BOOL)) {
  return "bool";
}
  if ((knd === TK_SYMBOL)) {
  return "symbol";
}
  if ((knd === TK_CHAR)) {
  return "char";
}
  return "token";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTokenKindName = pTokenKindName;

const __tuff_outer_for_pTokenValueForError = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTokenValueForError(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_pTokenValueForError };
  let knd = tokKind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.knd = knd;
  if ((knd === TK_BOOL)) {
  if ((tokValue(t) === 0)) {
  return "false";
}
  return "true";
}
  if ((((((((knd === TK_KEYWORD) || (knd === TK_IDENTIFIER)) || (knd === TK_NUMBER)) || (knd === TK_STRING)) || (knd === TK_SYMBOL)) || (knd === TK_CHAR)) || (knd === TK_EOF))) {
  let raw = getIntern(tokValue(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.raw = raw;
  if (((knd === TK_SYMBOL) && ((() => { const __recv = raw; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() === 0))) {
  return "<empty-symbol>";
}
  return raw;
}
  return "<unknown>";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTokenValueForError = pTokenValueForError;

const __tuff_outer_for_pTokenDebugAt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTokenDebugAt(i) {
  let __tuff_this = { i: i, this: __tuff_outer_for_pTokenDebugAt };
  if (((i < 0) || (i >= tokCount))) {
  return "<none>";
}
  let kname = pTokenKindName(tokKind(i)); if (typeof __tuff_this !== 'undefined') __tuff_this.kname = kname;
  let val = pTokenValueForError(i); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  let line = intToString(tokLine(i)); if (typeof __tuff_this !== 'undefined') __tuff_this.line = line;
  let col = intToString(tokCol(i)); if (typeof __tuff_this !== 'undefined') __tuff_this.col = col;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = kname; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(val); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, val) : strConcat(__recv, val); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" @"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " @") : strConcat(__recv, " @"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(line); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, line) : strConcat(__recv, line); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(col); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, col) : strConcat(__recv, col); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTokenDebugAt = pTokenDebugAt;

const __tuff_outer_for_pErrorWithTokenContext = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pErrorWithTokenContext(msg) {
  let __tuff_this = { msg: msg, this: __tuff_outer_for_pErrorWithTokenContext };
  let t = pPeek(0); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let curIdx = t; if (typeof __tuff_this !== 'undefined') __tuff_this.curIdx = curIdx;
  let prevIdx = (parsePos - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.prevIdx = prevIdx;
  let nextIdx = (parsePos + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nextIdx = nextIdx;
  let foundKind = pTokenKindName(tokKind(curIdx)); if (typeof __tuff_this !== 'undefined') __tuff_this.foundKind = foundKind;
  let value = pTokenValueForError(curIdx); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  let line = intToString(tokLine(curIdx)); if (typeof __tuff_this !== 'undefined') __tuff_this.line = line;
  let col = intToString(tokCol(curIdx)); if (typeof __tuff_this !== 'undefined') __tuff_this.col = col;
  let prevTok = pTokenDebugAt(prevIdx); if (typeof __tuff_this !== 'undefined') __tuff_this.prevTok = prevTok;
  let curTok = pTokenDebugAt(curIdx); if (typeof __tuff_this !== 'undefined') __tuff_this.curTok = curTok;
  let nextTok = pTokenDebugAt(nextIdx); if (typeof __tuff_this !== 'undefined') __tuff_this.nextTok = nextTok;
  panic((() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = msg; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" (found "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " (found ") : strConcat(__recv, " (found "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(foundKind); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, foundKind) : strConcat(__recv, foundKind); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, value) : strConcat(__recv, value); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" at "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " at ") : strConcat(__recv, " at "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(line); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, line) : strConcat(__recv, line); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(col); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, col) : strConcat(__recv, col); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; context: [prev="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; context: [prev=") : strConcat(__recv, "; context: [prev="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prevTok); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prevTok) : strConcat(__recv, prevTok); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(", current="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ", current=") : strConcat(__recv, ", current="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(curTok); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, curTok) : strConcat(__recv, curTok); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(", next="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ", next=") : strConcat(__recv, ", next="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(nextTok); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, nextTok) : strConcat(__recv, nextTok); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "]") : strConcat(__recv, "]"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })());
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pErrorWithTokenContext = pErrorWithTokenContext;

const __tuff_outer_for_pPanicLoc = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pPanicLoc(code, message, reason, fix) {
  let __tuff_this = { code: code, message: message, reason: reason, fix: fix, this: __tuff_outer_for_pPanicLoc };
  let t = pPeek(0); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  panicWithCodeLoc(code, message, reason, fix, tokLine(t), tokCol(t));
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pPanicLoc = pPanicLoc;

const __tuff_outer_for_pResultError = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pResultError(code, message, reason, fix) {
  let __tuff_this = { code: code, message: message, reason: reason, fix: fix, this: __tuff_outer_for_pResultError };
  let t = pPeek(0); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let err = ((typeof ParseError === "function") ? ParseError({code: code, message: message, reason: reason, fix: fix, line: tokLine(t), col: tokCol(t)}) : ({ __tag: "ParseError", code: code, message: message, reason: reason, fix: fix, line: tokLine(t), col: tokCol(t) })); if (typeof __tuff_this !== 'undefined') __tuff_this.err = err;
  return ((typeof Err === "function") ? Err({error: err}) : ({ __tag: "Err", error: err }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pResultError = pResultError;

const __tuff_outer_for_pExpectKind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pExpectKind(kind, msg) {
  let __tuff_this = { kind: kind, msg: msg, this: __tuff_outer_for_pExpectKind };
  if ((!pAtKind(kind))) {
  pErrorWithTokenContext(msg);
}
  return pEat();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pExpectKind = pExpectKind;

const __tuff_outer_for_pExpect = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pExpect(kind, val, msg) {
  let __tuff_this = { kind: kind, val: val, msg: msg, this: __tuff_outer_for_pExpect };
  if ((!pAt(kind, val))) {
  pErrorWithTokenContext(msg);
}
  return pEat();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pExpect = pExpect;

const __tuff_outer_for_pParseIdentifier = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseIdentifier() {
  let __tuff_this = { this: __tuff_outer_for_pParseIdentifier };
  let t = pExpectKind(TK_IDENTIFIER, "Expected identifier"); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  return tokValue(t);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseIdentifier = pParseIdentifier;

const __tuff_outer_for_pCanStartTypeTok = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pCanStartTypeTok() {
  let __tuff_this = { this: __tuff_outer_for_pCanStartTypeTok };
  if (pAtKind(TK_IDENTIFIER)) {
  return true;
}
  if (pAt(TK_SYMBOL, "*")) {
  return true;
}
  if (pAt(TK_SYMBOL, "[")) {
  return true;
}
  if (pAt(TK_SYMBOL, "(")) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pCanStartTypeTok = pCanStartTypeTok;

const __tuff_outer_for_pCanStartTypeTokAt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pCanStartTypeTokAt(offset) {
  let __tuff_this = { offset: offset, this: __tuff_outer_for_pCanStartTypeTokAt };
  pcInitSymbolCache();
  let idx = pPeek(offset); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  let k = tokKind(idx); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === TK_IDENTIFIER)) {
  return true;
}
  if ((k === TK_SYMBOL)) {
  let v = tokValue(idx); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  if ((((v === PC_SYM_STAR) || (v === PC_SYM_LBRACKET)) || (v === PC_SYM_LPAREN))) {
  return true;
}
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pCanStartTypeTokAt = pCanStartTypeTokAt;

const __tuff_outer_for_pCanStartTypeAfterLifetimeTokAt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pCanStartTypeAfterLifetimeTokAt(offset) {
  let __tuff_this = { offset: offset, this: __tuff_outer_for_pCanStartTypeAfterLifetimeTokAt };
  pcInitSymbolCache();
  let idx = pPeek(offset); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  let k = tokKind(idx); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === TK_IDENTIFIER)) {
  return true;
}
  if ((k === TK_SYMBOL)) {
  let v = tokValue(idx); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  if ((((v === PC_SYM_STAR) || (v === PC_SYM_LBRACKET)) || (v === PC_SYM_LPAREN))) {
  return true;
}
}
  if ((k === TK_KEYWORD)) {
  let kw = getIntern(tokValue(idx)); if (typeof __tuff_this !== 'undefined') __tuff_this.kw = kw;
  if (((((() => { const __recv = kw; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("mut"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "mut") : strEq(__recv, "mut"); })() || (() => { const __recv = kw; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("move"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "move") : strEq(__recv, "move"); })()) || (() => { const __recv = kw; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("out"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "out") : strEq(__recv, "out"); })()) || (() => { const __recv = kw; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("uninit"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "uninit") : strEq(__recv, "uninit"); })())) {
  return true;
}
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pCanStartTypeAfterLifetimeTokAt = pCanStartTypeAfterLifetimeTokAt;

const __tuff_outer_for_pCanStartRefinementExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pCanStartRefinementExpr() {
  let __tuff_this = { this: __tuff_outer_for_pCanStartRefinementExpr };
  if (pAtKind(TK_NUMBER)) {
  return true;
}
  if (pAtKind(TK_IDENTIFIER)) {
  return true;
}
  if (pAtKind(TK_BOOL)) {
  return true;
}
  if (pAtKind(TK_STRING)) {
  return true;
}
  if (pAt(TK_SYMBOL, "(")) {
  return true;
}
  if (pAt(TK_SYMBOL, "-")) {
  return true;
}
  if (pAt(TK_SYMBOL, "!")) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pCanStartRefinementExpr = pCanStartRefinementExpr;

const __tuff_outer_for_pCanStartRefinementExprAt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pCanStartRefinementExprAt(offset) {
  let __tuff_this = { offset: offset, this: __tuff_outer_for_pCanStartRefinementExprAt };
  let idx = pPeek(offset); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  let k = tokKind(idx); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((((((k === TK_NUMBER) || (k === TK_IDENTIFIER)) || (k === TK_BOOL)) || (k === TK_STRING)) || (k === TK_CHAR))) {
  return true;
}
  if ((k === TK_SYMBOL)) {
  let s = getIntern(tokValue(idx)); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  if ((((() => { const __recv = s; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "(") : strEq(__recv, "("); })() || (() => { const __recv = s; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "-") : strEq(__recv, "-"); })()) || (() => { const __recv = s; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("!"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "!") : strEq(__recv, "!"); })())) {
  return true;
}
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pCanStartRefinementExprAt = pCanStartRefinementExprAt;

const __tuff_outer_for_pParseTypePrimaryPointer = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseTypePrimaryPointer() {
  let __tuff_this = { this: __tuff_outer_for_pParseTypePrimaryPointer };
  pEat();
  let mutable = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.mutable = mutable;
  let movePtr = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.movePtr = movePtr;
  let lifeName = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.lifeName = lifeName;
  let progressed = true; if (typeof __tuff_this !== 'undefined') __tuff_this.progressed = progressed;
  while (progressed) {
  progressed = false; if (typeof __tuff_this !== 'undefined') __tuff_this.progressed = progressed;
  if (((mutable === 0) && pAt(TK_KEYWORD, "mut"))) {
  pEat();
  mutable = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.mutable = mutable;
  progressed = true; if (typeof __tuff_this !== 'undefined') __tuff_this.progressed = progressed;
} else { if (((movePtr === 0) && pAt(TK_KEYWORD, "move"))) {
  pEat();
  movePtr = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.movePtr = movePtr;
  progressed = true; if (typeof __tuff_this !== 'undefined') __tuff_this.progressed = progressed;
} else { if ((((lifeName === 0) && pAtKind(TK_IDENTIFIER)) && pCanStartTypeAfterLifetimeTokAt(1))) {
  lifeName = tokValue(pEat()); if (typeof __tuff_this !== 'undefined') __tuff_this.lifeName = lifeName;
  progressed = true; if (typeof __tuff_this !== 'undefined') __tuff_this.progressed = progressed;
} } }
}
  let inner = pParseTypePrimary(); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let node = nodeNew(NK_POINTER_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, mutable);
  nodeSetData2(node, inner);
  nodeSetData3(node, movePtr);
  nodeSetData4(node, lifeName);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseTypePrimaryPointer = pParseTypePrimaryPointer;

const __tuff_outer_for_pParseTypePrimaryInlineStructVariant = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseTypePrimaryInlineStructVariant() {
  let __tuff_this = { this: __tuff_outer_for_pParseTypePrimaryInlineStructVariant };
  pExpect(TK_KEYWORD, "struct", "Expected 'struct' in inline union variant");
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  pExpect(TK_SYMBOL, "{", "Expected '{' after inline struct variant name");
  while ((!pAt(TK_SYMBOL, "}"))) {
  pParseIdentifier();
  pExpect(TK_SYMBOL, ":", "Expected ':' after inline struct field name");
  pParseType();
  pExpect(TK_SYMBOL, ";", "Expected ';' after inline struct field type");
}
  pExpect(TK_SYMBOL, "}", "Expected '}' after inline struct variant");
  let typeNode = nodeNew(NK_NAMED_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
  nodeSetData1(typeNode, name);
  nodeSetData2(typeNode, vecNew());
  return typeNode;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseTypePrimaryInlineStructVariant = pParseTypePrimaryInlineStructVariant;

const __tuff_outer_for_pParseTypePrimaryArray = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseTypePrimaryArray() {
  let __tuff_this = { this: __tuff_outer_for_pParseTypePrimaryArray };
  pEat();
  let elem = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.elem = elem;
  let init = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.init = init;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
  init = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.init = init;
  pExpect(TK_SYMBOL, ";", "Expected ';' in array type");
  total = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  pExpect(TK_SYMBOL, "]", "Expected ']'");
  let node = nodeNew(NK_ARRAY_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, elem);
  nodeSetData2(node, init);
  nodeSetData3(node, total);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseTypePrimaryArray = pParseTypePrimaryArray;

const __tuff_outer_for_pTrySkipNamedTupleMemberLabel = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTrySkipNamedTupleMemberLabel() {
  let __tuff_this = { this: __tuff_outer_for_pTrySkipNamedTupleMemberLabel };
  if (((tokKind(pPeek(0)) === TK_IDENTIFIER) && (tokKind(pPeek(1)) === TK_SYMBOL))) {
  let sym = getIntern(tokValue(pPeek(1))); if (typeof __tuff_this !== 'undefined') __tuff_this.sym = sym;
  if ((() => { const __recv = sym; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, ":") : strEq(__recv, ":"); })()) {
  pEat();
  pEat();
}
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTrySkipNamedTupleMemberLabel = pTrySkipNamedTupleMemberLabel;

const __tuff_outer_for_pParseTypePrimaryTupleOrFn = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseTypePrimaryTupleOrFn() {
  let __tuff_this = { this: __tuff_outer_for_pParseTypePrimaryTupleOrFn };
  pEat();
  let members = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.members = members;
  if ((!pAt(TK_SYMBOL, ")"))) {
  pTrySkipNamedTupleMemberLabel();
  (() => { const __recv = members; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseType()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseType()) : vecPush(__recv, pParseType()); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  pTrySkipNamedTupleMemberLabel();
  (() => { const __recv = members; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseType()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseType()) : vecPush(__recv, pParseType()); })();
}
}
  pExpect(TK_SYMBOL, ")", "Expected ')' in tuple type");
  if (pAt(TK_SYMBOL, "=>")) {
  pEat();
  let ret = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
  let fnty = nodeNew(NK_FUNCTION_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.fnty = fnty;
  nodeSetData1(fnty, members);
  nodeSetData2(fnty, ret);
  return fnty;
}
  let node = nodeNew(NK_TUPLE_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, members);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseTypePrimaryTupleOrFn = pParseTypePrimaryTupleOrFn;

const __tuff_outer_for_pParseTypePrimaryNumericSentinel = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseTypePrimaryNumericSentinel() {
  let __tuff_this = { this: __tuff_outer_for_pParseTypePrimaryNumericSentinel };
  let t = pEat(); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let raw = getIntern(tokValue(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.raw = raw;
  if ((!((() => { const __recv = raw; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("0USize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "0USize") : strEq(__recv, "0USize"); })() || (() => { const __recv = raw; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("0"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "0") : strEq(__recv, "0"); })()))) {
  pPanicLoc("E_PARSE_INVALID_LITERAL", "Only 0 or 0USize is supported as a type-level numeric sentinel", "Type-level numeric literals are restricted to zero sentinels", "Use 0 or 0USize for type-level numeric sentinels");
}
  let base = nodeNew(NK_NAMED_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  nodeSetData1(base, intern("USize"));
  nodeSetData2(base, vecNew());
  let lit = nodeNew(NK_NUMBER_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.lit = lit;
  nodeSetData1(lit, tokValue(t));
  let refine = nodeNew(NK_REFINEMENT_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.refine = refine;
  nodeSetData1(refine, base);
  nodeSetData2(refine, intern("=="));
  nodeSetData3(refine, lit);
  return refine;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseTypePrimaryNumericSentinel = pParseTypePrimaryNumericSentinel;

const __tuff_outer_for_pParseTypePrimaryNamedOrApplied = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseTypePrimaryNamedOrApplied() {
  let __tuff_this = { this: __tuff_outer_for_pParseTypePrimaryNamedOrApplied };
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let generics = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  while (pAt(TK_SYMBOL, "::")) {
  pEat();
  pParseIdentifier();
}
  let wouldBeMemberRefine = false; if (typeof __tuff_this !== 'undefined') __tuff_this.wouldBeMemberRefine = wouldBeMemberRefine;
  if (pAt(TK_SYMBOL, "<")) {
  let k1 = tokKind(pPeek(1)); if (typeof __tuff_this !== 'undefined') __tuff_this.k1 = k1;
  let k2 = tokKind(pPeek(2)); if (typeof __tuff_this !== 'undefined') __tuff_this.k2 = k2;
  if (((k1 === TK_IDENTIFIER) && (k2 === TK_SYMBOL))) {
  let s2 = getIntern(tokValue(pPeek(2))); if (typeof __tuff_this !== 'undefined') __tuff_this.s2 = s2;
  if (((() => { const __recv = s2; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, ".") : strEq(__recv, "."); })() || (() => { const __recv = s2; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "(") : strEq(__recv, "("); })())) {
  wouldBeMemberRefine = true; if (typeof __tuff_this !== 'undefined') __tuff_this.wouldBeMemberRefine = wouldBeMemberRefine;
}
}
}
  if (((pAt(TK_SYMBOL, "<") && pCanStartTypeTokAt(1)) && (!wouldBeMemberRefine))) {
  pEat();
  if ((!pAt(TK_SYMBOL, ">"))) {
  (() => { const __recv = generics; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseType()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseType()) : vecPush(__recv, pParseType()); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = generics; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseType()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseType()) : vecPush(__recv, pParseType()); })();
}
}
  pExpect(TK_SYMBOL, ">", "Expected '>' in generic args");
}
  let typeNode = nodeNew(NK_NAMED_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
  nodeSetData1(typeNode, name);
  nodeSetData2(typeNode, generics);
  if ((pAt(TK_SYMBOL, "(") && ((() => { const __recv = generics; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 0))) {
  pEat();
  let args = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if ((!pAt(TK_SYMBOL, ")"))) {
  (() => { const __recv = args; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseExpression(0)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseExpression(0)) : vecPush(__recv, pParseExpression(0)); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = args; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseExpression(0)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseExpression(0)) : vecPush(__recv, pParseExpression(0)); })();
}
}
  pExpect(TK_SYMBOL, ")", "Expected ')' after type-application arguments");
  let applied = nodeNew(NK_APPLIED_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.applied = applied;
  nodeSetData1(applied, name);
  nodeSetData2(applied, args);
  return applied;
}
  return typeNode;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseTypePrimaryNamedOrApplied = pParseTypePrimaryNamedOrApplied;

const __tuff_outer_for_pParseTypePrimary = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseTypePrimary() {
  let __tuff_this = { this: __tuff_outer_for_pParseTypePrimary };
  if (pAt(TK_KEYWORD, "struct")) {
  return pParseTypePrimaryInlineStructVariant();
}
  if (pAt(TK_SYMBOL, "*")) {
  return pParseTypePrimaryPointer();
}
  if (pAt(TK_SYMBOL, "[")) {
  return pParseTypePrimaryArray();
}
  if (pAt(TK_SYMBOL, "(")) {
  return pParseTypePrimaryTupleOrFn();
}
  if (pAtKind(TK_NUMBER)) {
  return pParseTypePrimaryNumericSentinel();
}
  return pParseTypePrimaryNamedOrApplied();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseTypePrimary = pParseTypePrimary;

const __tuff_outer_for_pParseType = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseType() {
  let __tuff_this = { this: __tuff_outer_for_pParseType };
  let typeNode = pParseTypePrimary(); if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
  let hasRefine = ((((pAt(TK_SYMBOL, "!=") || pAt(TK_SYMBOL, "<")) || pAt(TK_SYMBOL, ">")) || pAt(TK_SYMBOL, "<=")) || pAt(TK_SYMBOL, ">=")); if (typeof __tuff_this !== 'undefined') __tuff_this.hasRefine = hasRefine;
  let startsGenericCallSuffix = false; if (typeof __tuff_this !== 'undefined') __tuff_this.startsGenericCallSuffix = startsGenericCallSuffix;
  if ((pAt(TK_SYMBOL, ">") && (tokKind(pPeek(1)) === TK_SYMBOL))) {
  let nextSym = getIntern(tokValue(pPeek(1))); if (typeof __tuff_this !== 'undefined') __tuff_this.nextSym = nextSym;
  if ((() => { const __recv = nextSym; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "(") : strEq(__recv, "("); })()) {
  startsGenericCallSuffix = true; if (typeof __tuff_this !== 'undefined') __tuff_this.startsGenericCallSuffix = startsGenericCallSuffix;
}
}
  if (((hasRefine && pCanStartRefinementExprAt(1)) && (!startsGenericCallSuffix))) {
  let op = tokValue(pEat()); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let valExpr = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.valExpr = valExpr;
  let refine = nodeNew(NK_REFINEMENT_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.refine = refine;
  nodeSetData1(refine, typeNode);
  nodeSetData2(refine, op);
  nodeSetData3(refine, valExpr);
  typeNode = refine; if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
}
  while (((((pAt(TK_SYMBOL, "+") || pAt(TK_SYMBOL, "-")) || pAt(TK_SYMBOL, "*")) || pAt(TK_SYMBOL, "/")) || pAt(TK_SYMBOL, "%"))) {
  let op = tokValue(pEat()); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let right = pParseTypePrimary(); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let bin = nodeNew(NK_BINARY_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.bin = bin;
  nodeSetData1(bin, op);
  nodeSetData2(bin, typeNode);
  nodeSetData3(bin, right);
  typeNode = bin; if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
}
  while ((pAt(TK_SYMBOL, "|") || pAt(TK_SYMBOL, "|>"))) {
  let isExtract = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.isExtract = isExtract;
  if (pAt(TK_SYMBOL, "|>")) {
  isExtract = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.isExtract = isExtract;
}
  pEat();
  let right = pParseTypePrimary(); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let unionNode = nodeNew(NK_UNION_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.unionNode = unionNode;
  nodeSetData1(unionNode, typeNode);
  nodeSetData2(unionNode, right);
  nodeSetData3(unionNode, isExtract);
  typeNode = unionNode; if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
}
  return typeNode;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseType = pParseType;

const __tuff_outer_for_pParsePattern = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParsePattern() {
  let __tuff_this = { this: __tuff_outer_for_pParsePattern };
  if ((pAt(TK_SYMBOL, "_") || pAt(TK_IDENTIFIER, "_"))) {
  pEat();
  return nodeNew(NK_WILDCARD_PAT);
}
  if (pAtKind(TK_NUMBER)) {
  let t = pEat(); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let node = nodeNew(NK_LITERAL_PAT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, tokValue(t));
  return node;
}
  if (pAtKind(TK_BOOL)) {
  let t = pEat(); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let node = nodeNew(NK_LITERAL_PAT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, tokValue(t));
  return node;
}
  let hasStructKeyword = false; if (typeof __tuff_this !== 'undefined') __tuff_this.hasStructKeyword = hasStructKeyword;
  if (pAt(TK_KEYWORD, "struct")) {
  pEat();
  hasStructKeyword = true; if (typeof __tuff_this !== 'undefined') __tuff_this.hasStructKeyword = hasStructKeyword;
}
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((pAt(TK_SYMBOL, "<") && pCanStartTypeTokAt(1))) {
  pEat();
  if ((!pAt(TK_SYMBOL, ">"))) {
  pParseType();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  pParseType();
}
}
  pExpect(TK_SYMBOL, ">", "Expected '>' in pattern generic args");
}
  if (pAt(TK_SYMBOL, "{")) {
  pEat();
  let fields = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  if ((!pAt(TK_SYMBOL, "}"))) {
  (() => { const __recv = fields; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = fields; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
}
}
  pExpect(TK_SYMBOL, "}", "Expected '}' in pattern");
  let node = nodeNew(NK_STRUCT_PAT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, fields);
  return node;
}
  if (hasStructKeyword) {
  let node = nodeNew(NK_STRUCT_PAT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, vecNew());
  return node;
}
  let node = nodeNew(NK_NAME_PAT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParsePattern = pParsePattern;

const __tuff_outer_for_selfhostParserCoreMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostParserCoreMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostParserCoreMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostParserCoreMarker = selfhostParserCoreMarker;

const __tuff_outer_for_pParseConstraintValueAtom = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseConstraintValueAtom() {
  let __tuff_this = { this: __tuff_outer_for_pParseConstraintValueAtom };
  if (pAtKind(TK_IDENTIFIER)) {
  let n = nodeNew(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  nodeSetData1(n, tokValue(pEat()));
  return n;
}
  if (pAtKind(TK_NUMBER)) {
  let n = nodeNew(NK_NUMBER_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  nodeSetData1(n, tokValue(pEat()));
  return n;
}
  if (pAtKind(TK_BOOL)) {
  let n = nodeNew(NK_BOOL_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  nodeSetData1(n, tokValue(pEat()));
  return n;
}
  if (pAtKind(TK_STRING)) {
  let n = nodeNew(NK_STRING_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  nodeSetData1(n, tokValue(pEat()));
  return n;
}
  if (pAtKind(TK_CHAR)) {
  let n = nodeNew(NK_CHAR_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  nodeSetData1(n, tokValue(pEat()));
  return n;
}
  if (pAt(TK_SYMBOL, "(")) {
  pEat();
  let inner = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  pExpect(TK_SYMBOL, ")", "Expected ')' in generic constraint expression");
  return inner;
}
  return pParseTypePrimary();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseConstraintValueAtom = pParseConstraintValueAtom;

const __tuff_outer_for_pParseConstraintValueExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseConstraintValueExpr() {
  let __tuff_this = { this: __tuff_outer_for_pParseConstraintValueExpr };
  let left = pParseConstraintValueAtom(); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  while (((((pAt(TK_SYMBOL, "+") || pAt(TK_SYMBOL, "-")) || pAt(TK_SYMBOL, "*")) || pAt(TK_SYMBOL, "/")) || pAt(TK_SYMBOL, "%"))) {
  let op = tokValue(pEat()); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let right = pParseConstraintValueAtom(); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let bin = nodeNew(NK_BINARY_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.bin = bin;
  nodeSetData1(bin, op);
  nodeSetData2(bin, left);
  nodeSetData3(bin, right);
  left = bin; if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
}
  return left;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseConstraintValueExpr = pParseConstraintValueExpr;

const __tuff_outer_for_pParseGenericConstraintType = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseGenericConstraintType() {
  let __tuff_this = { this: __tuff_outer_for_pParseGenericConstraintType };
  let typeNode = pParseTypePrimary(); if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
  let startsGenericCallSuffix = false; if (typeof __tuff_this !== 'undefined') __tuff_this.startsGenericCallSuffix = startsGenericCallSuffix;
  if ((pAt(TK_SYMBOL, ">") && (tokKind(pPeek(1)) === TK_SYMBOL))) {
  let nextSym = getIntern(tokValue(pPeek(1))); if (typeof __tuff_this !== 'undefined') __tuff_this.nextSym = nextSym;
  if ((() => { const __recv = nextSym; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "(") : strEq(__recv, "("); })()) {
  startsGenericCallSuffix = true; if (typeof __tuff_this !== 'undefined') __tuff_this.startsGenericCallSuffix = startsGenericCallSuffix;
}
}
  let hasRefine = ((((((pAt(TK_SYMBOL, "!=") || pAt(TK_SYMBOL, "<")) || pAt(TK_SYMBOL, ">")) || pAt(TK_SYMBOL, "<=")) || pAt(TK_SYMBOL, ">=")) && pCanStartRefinementExprAt(1)) && (!startsGenericCallSuffix)); if (typeof __tuff_this !== 'undefined') __tuff_this.hasRefine = hasRefine;
  if (hasRefine) {
  let op = tokValue(pEat()); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let value = pParseConstraintValueExpr(); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  let refine = nodeNew(NK_REFINEMENT_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.refine = refine;
  nodeSetData1(refine, typeNode);
  nodeSetData2(refine, op);
  nodeSetData3(refine, value);
  typeNode = refine; if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
}
  while ((pAt(TK_SYMBOL, "|") || pAt(TK_SYMBOL, "|>"))) {
  let isExtract = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.isExtract = isExtract;
  if (pAt(TK_SYMBOL, "|>")) {
  isExtract = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.isExtract = isExtract;
}
  pEat();
  let right = pParseTypePrimary(); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let unionNode = nodeNew(NK_UNION_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.unionNode = unionNode;
  nodeSetData1(unionNode, typeNode);
  nodeSetData2(unionNode, right);
  nodeSetData3(unionNode, isExtract);
  typeNode = unionNode; if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
}
  return typeNode;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseGenericConstraintType = pParseGenericConstraintType;

const __tuff_outer_for_pParseDeclGenerics = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseDeclGenerics(closeMessage) {
  let __tuff_this = { closeMessage: closeMessage, this: __tuff_outer_for_pParseDeclGenerics };
  let generics = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  if (pAt(TK_SYMBOL, "<")) {
  pEat();
  if ((!pAt(TK_SYMBOL, ">"))) {
  while (true) {
  (() => { const __recv = generics; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  pParseGenericConstraintType();
}
  if ((!pAt(TK_SYMBOL, ","))) {
  break;
}
  pEat();
}
}
  pExpect(TK_SYMBOL, ">", closeMessage);
}
  return generics;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseDeclGenerics = pParseDeclGenerics;

const __tuff_outer_for_pParseFunction = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseFunction(isClass, mode) {
  let __tuff_this = { isClass: isClass, mode: mode, this: __tuff_outer_for_pParseFunction };
  pExpect(TK_KEYWORD, "fn", "Expected 'fn'");
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let generics = pParseDeclGenerics("Expected '>'"); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  pExpect(TK_SYMBOL, "(", "Expected '('");
  let params = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  if ((!pAt(TK_SYMBOL, ")"))) {
  while (true) {
  let pname = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (pAt(TK_SYMBOL, "*")) {
  ptype = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (pAtKind(TK_IDENTIFIER)) {
  pname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
} else {
  if ((nodeKind(ptype) === NK_POINTER_TYPE)) {
  let inner = nodeGetData2(ptype); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  if (((inner !== 0) && (nodeKind(inner) === NK_NAMED_TYPE))) {
  let innerName = nodeGetData1(inner); if (typeof __tuff_this !== 'undefined') __tuff_this.innerName = innerName;
  if ((() => { const __recv = getIntern(innerName); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })()) {
  pname = innerName; if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
} else {
  pExpectKind(TK_IDENTIFIER, "Expected identifier");
}
} else {
  pExpectKind(TK_IDENTIFIER, "Expected identifier");
}
} else {
  pExpectKind(TK_IDENTIFIER, "Expected identifier");
}
}
} else {
  pname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  ptype = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
}
  let param = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pname) : vecPush(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, ptype) : vecPush(__recv, ptype); })();
  (() => { const __recv = params; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, param) : vecPush(__recv, param); })();
  if ((!pAt(TK_SYMBOL, ","))) {
  break;
}
  pEat();
}
}
  pExpect(TK_SYMBOL, ")", "Expected ')'");
  let retType = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.retType = retType;
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  retType = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.retType = retType;
}
  let body = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if ((mode === 1)) {
  pExpect(TK_SYMBOL, ";", "Expected ';' after expect function declaration");
} else {
  pExpect(TK_SYMBOL, "=>", "Expected '=>'");
  if (pAt(TK_SYMBOL, "{")) {
  body = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
} else {
  body = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
}
  if ((nodeKind(body) !== NK_BLOCK)) {
  if (((!pAt(TK_SYMBOL, "}")) && (!pAtKind(TK_EOF)))) {
  pExpect(TK_SYMBOL, ";", "Expected ';'");
}
}
}
  let kind = NK_FN_DECL; if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((isClass === 1)) {
  kind = NK_CLASS_FN_DECL; if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
} else { if ((mode === 1)) {
  kind = NK_EXPECT_FN_DECL; if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
} else { if ((mode === 2)) {
  kind = NK_ACTUAL_FN_DECL; if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
} } }
  let node = nodeNew(kind); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, generics);
  nodeSetData3(node, params);
  nodeSetData4(node, retType);
  nodeSetData5(node, body);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseFunction = pParseFunction;

const __tuff_outer_for_pParseStruct = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseStruct(isCopy) {
  let __tuff_this = { isCopy: isCopy, this: __tuff_outer_for_pParseStruct };
  pExpect(TK_KEYWORD, "struct", "Expected 'struct'");
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let generics = pParseDeclGenerics("Expected '>'"); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  pExpect(TK_SYMBOL, "{", "Expected '{'");
  let fields = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  while ((!pAt(TK_SYMBOL, "}"))) {
  let fname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  pExpect(TK_SYMBOL, ":", "Expected ':'");
  let ftype = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.ftype = ftype;
  let field = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  (() => { const __recv = field; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, fname) : vecPush(__recv, fname); })();
  (() => { const __recv = field; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(ftype); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, ftype) : vecPush(__recv, ftype); })();
  (() => { const __recv = fields; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(field); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, field) : vecPush(__recv, field); })();
  if ((pAt(TK_SYMBOL, ",") || pAt(TK_SYMBOL, ";"))) {
  pEat();
}
}
  pExpect(TK_SYMBOL, "}", "Expected '}'");
  let node = nodeNew(NK_STRUCT_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, generics);
  nodeSetData3(node, fields);
  nodeSetData4(node, isCopy);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseStruct = pParseStruct;

const __tuff_outer_for_pParseEnum = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseEnum() {
  let __tuff_this = { this: __tuff_outer_for_pParseEnum };
  pExpect(TK_KEYWORD, "enum", "Expected 'enum'");
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  pExpect(TK_SYMBOL, "{", "Expected '{' after enum name");
  let variants = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.variants = variants;
  while ((!pAt(TK_SYMBOL, "}"))) {
  (() => { const __recv = variants; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
  if ((pAt(TK_SYMBOL, ",") || pAt(TK_SYMBOL, ";"))) {
  pEat();
}
}
  pExpect(TK_SYMBOL, "}", "Expected '}' after enum body");
  let node = nodeNew(NK_ENUM_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, variants);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseEnum = pParseEnum;

const __tuff_outer_for_pParseObject = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseObject() {
  let __tuff_this = { this: __tuff_outer_for_pParseObject };
  pExpect(TK_KEYWORD, "object", "Expected 'object'");
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let generics = pParseDeclGenerics("Expected '>'"); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  pExpect(TK_SYMBOL, "{", "Expected '{' after object name");
  let inputs = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.inputs = inputs;
  while ((!pAt(TK_SYMBOL, "}"))) {
  pExpect(TK_KEYWORD, "in", "Expected 'in' in object input declaration");
  pExpect(TK_KEYWORD, "let", "Expected 'let' in object input declaration");
  let inputName = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.inputName = inputName;
  pExpect(TK_SYMBOL, ":", "Expected ':' in object input declaration");
  let inputType = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.inputType = inputType;
  pExpect(TK_SYMBOL, ";", "Expected ';' after object input declaration");
  let inputField = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.inputField = inputField;
  (() => { const __recv = inputField; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(inputName); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, inputName) : vecPush(__recv, inputName); })();
  (() => { const __recv = inputField; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(inputType); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, inputType) : vecPush(__recv, inputType); })();
  (() => { const __recv = inputs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(inputField); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, inputField) : vecPush(__recv, inputField); })();
}
  pExpect(TK_SYMBOL, "}", "Expected '}' after object body");
  let node = nodeNew(NK_OBJECT_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, generics);
  nodeSetData3(node, inputs);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseObject = pParseObject;

const __tuff_outer_for_pParseContract = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseContract() {
  let __tuff_this = { this: __tuff_outer_for_pParseContract };
  pExpect(TK_KEYWORD, "contract", "Expected 'contract'");
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  pExpect(TK_SYMBOL, "{", "Expected '{' after contract name");
  let methods = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.methods = methods;
  while ((!pAt(TK_SYMBOL, "}"))) {
  pExpect(TK_KEYWORD, "fn", "Expected 'fn' in contract declaration");
  let mname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.mname = mname;
  let mgenerics = pParseDeclGenerics("Expected '>' after contract method generics"); if (typeof __tuff_this !== 'undefined') __tuff_this.mgenerics = mgenerics;
  pExpect(TK_SYMBOL, "(", "Expected '(' in contract method signature");
  let params = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  if ((!pAt(TK_SYMBOL, ")"))) {
  while (true) {
  let pname = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  let implicitThis = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.implicitThis = implicitThis;
  if (pAt(TK_SYMBOL, "*")) {
  pEat();
  if (pAt(TK_KEYWORD, "mut")) {
  pEat();
}
  pname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  implicitThis = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.implicitThis = implicitThis;
} else {
  pname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  ptype = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
}
  let param = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pname) : vecPush(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, ptype) : vecPush(__recv, ptype); })();
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(implicitThis); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, implicitThis) : vecPush(__recv, implicitThis); })();
  (() => { const __recv = params; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, param) : vecPush(__recv, param); })();
  if ((!pAt(TK_SYMBOL, ","))) {
  break;
}
  pEat();
}
}
  pExpect(TK_SYMBOL, ")", "Expected ')' after contract method params");
  let ret = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  ret = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
}
  pExpect(TK_SYMBOL, ";", "Expected ';' after contract method signature");
  let method = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.method = method;
  (() => { const __recv = method; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(mname); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, mname) : vecPush(__recv, mname); })();
  (() => { const __recv = method; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(mgenerics); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, mgenerics) : vecPush(__recv, mgenerics); })();
  (() => { const __recv = method; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(params); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, params) : vecPush(__recv, params); })();
  (() => { const __recv = method; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(ret); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, ret) : vecPush(__recv, ret); })();
  (() => { const __recv = methods; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(method); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, method) : vecPush(__recv, method); })();
}
  pExpect(TK_SYMBOL, "}", "Expected '}' after contract body");
  let node = nodeNew(NK_CONTRACT_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, methods);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseContract = pParseContract;

const __tuff_outer_for_pParseTypeAlias = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseTypeAlias(isCopy) {
  let __tuff_this = { isCopy: isCopy, this: __tuff_outer_for_pParseTypeAlias };
  pExpect(TK_KEYWORD, "type", "Expected 'type'");
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if (pAt(TK_SYMBOL, "(")) {
  pEat();
  let valueParams = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.valueParams = valueParams;
  if ((!pAt(TK_SYMBOL, ")"))) {
  while (true) {
  let pname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  ptype = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
  let param = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pname) : vecPush(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, ptype) : vecPush(__recv, ptype); })();
  (() => { const __recv = valueParams; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, param) : vecPush(__recv, param); })();
  if ((!pAt(TK_SYMBOL, ","))) {
  break;
}
  pEat();
}
}
  pExpect(TK_SYMBOL, ")", "Expected ')' after dep-type-alias value params");
  pExpect(TK_SYMBOL, "=", "Expected '=' in dep-type-alias");
  let aliased = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.aliased = aliased;
  let destructorName = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
  if (pAt(TK_KEYWORD, "then")) {
  pEat();
  destructorName = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
}
  pExpect(TK_SYMBOL, ";", "Expected ';' after dep-type-alias");
  let node = nodeNew(NK_DEP_TYPE_ALIAS); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, valueParams);
  nodeSetData3(node, aliased);
  nodeSetData4(node, isCopy);
  nodeSetData5(node, destructorName);
  return node;
}
  let generics = pParseDeclGenerics("Expected '>'"); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  pExpect(TK_SYMBOL, "=", "Expected '='");
  let aliased = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.aliased = aliased;
  let destructorName = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
  if (pAt(TK_KEYWORD, "then")) {
  pEat();
  destructorName = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
}
  pExpect(TK_SYMBOL, ";", "Expected ';'");
  let node = nodeNew(NK_TYPE_ALIAS); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, generics);
  nodeSetData3(node, aliased);
  nodeSetData4(node, isCopy);
  nodeSetData5(node, destructorName);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseTypeAlias = pParseTypeAlias;

const __tuff_outer_for_pParseFor = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseFor() {
  let __tuff_this = { this: __tuff_outer_for_pParseFor };
  pExpect(TK_KEYWORD, "for", "Expected 'for'");
  pExpect(TK_SYMBOL, "(", "Expected '('");
  let iter = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.iter = iter;
  pExpect(TK_KEYWORD, "in", "Expected 'in'");
  let start = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.start = start;
  pExpect(TK_SYMBOL, "..", "Expected '..'");
  let end = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
  pExpect(TK_SYMBOL, ")", "Expected ')'");
  let body = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let node = nodeNew(NK_FOR_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, iter);
  nodeSetData2(node, start);
  nodeSetData3(node, end);
  nodeSetData4(node, body);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseFor = pParseFor;

const __tuff_outer_for_pParseLifetime = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseLifetime() {
  let __tuff_this = { this: __tuff_outer_for_pParseLifetime };
  pExpect(TK_KEYWORD, "lifetime", "Expected 'lifetime'");
  let names = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  (() => { const __recv = names; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = names; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
}
  let body = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let node = nodeNew(NK_LIFETIME_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, names);
  nodeSetData2(node, body);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseLifetime = pParseLifetime;

const __tuff_outer_for_selfhostParserDeclsHelpersMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostParserDeclsHelpersMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostParserDeclsHelpersMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostParserDeclsHelpersMarker = selfhostParserDeclsHelpersMarker;

let parseTempCounter = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.parseTempCounter = parseTempCounter;

const __tuff_outer_for_pNewTempName = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pNewTempName(prefix) {
  let __tuff_this = { prefix: prefix, this: __tuff_outer_for_pNewTempName };
  parseTempCounter = (parseTempCounter + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.parseTempCounter = parseTempCounter;
  return intern((() => { const __recv = prefix; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(parseTempCounter)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(parseTempCounter)) : strConcat(__recv, intToString(parseTempCounter)); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pNewTempName = pNewTempName;

const __tuff_outer_for_pDeclsLetExternNewStmtList = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pDeclsLetExternNewStmtList(stmts) {
  let __tuff_this = { stmts: stmts, this: __tuff_outer_for_pDeclsLetExternNewStmtList };
  let n = nodeNew(NK_STMT_LIST); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  nodeSetData1(n, stmts);
  return n;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pDeclsLetExternNewStmtList = pDeclsLetExternNewStmtList;

const __tuff_outer_for_pParseLet = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseLet() {
  let __tuff_this = { this: __tuff_outer_for_pParseLet };
  pExpect(TK_KEYWORD, "let", "Expected 'let'");
  if (pAt(TK_KEYWORD, "mut")) {
  pEat();
}
  if (pAt(TK_SYMBOL, "{")) {
  pEat();
  let names = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  if ((!pAt(TK_SYMBOL, "}"))) {
  (() => { const __recv = names; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = names; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
}
}
  pExpect(TK_SYMBOL, "}", "Expected '}'");
  pExpect(TK_SYMBOL, "=", "Expected '='");
  let parts = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.parts = parts;
  (() => { const __recv = parts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
  while (pAt(TK_SYMBOL, "::")) {
  pEat();
  (() => { const __recv = parts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
}
  pExpect(TK_SYMBOL, ";", "Expected ';'");
  let node = nodeNew(NK_IMPORT_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, names);
  nodeSetData2(node, parts);
  return node;
}
  if (pAt(TK_SYMBOL, "(")) {
  pEat();
  let names = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  if ((!pAt(TK_SYMBOL, ")"))) {
  (() => { const __recv = names; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = names; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
}
}
  pExpect(TK_SYMBOL, ")", "Expected ')' in tuple let destructuring");
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  pParseType();
}
  pExpect(TK_SYMBOL, "=", "Expected '=' in tuple let destructuring");
  let rhs = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.rhs = rhs;
  pExpect(TK_SYMBOL, ";", "Expected ';' after tuple let destructuring");
  let lowered = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.lowered = lowered;
  let tmpName = pNewTempName("__tuple_tmp_"); if (typeof __tuff_this !== 'undefined') __tuff_this.tmpName = tmpName;
  let tmpDecl = nodeNew(NK_LET_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.tmpDecl = tmpDecl;
  nodeSetData1(tmpDecl, tmpName);
  nodeSetData2(tmpDecl, 0);
  nodeSetData3(tmpDecl, rhs);
  (() => { const __recv = lowered; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(tmpDecl); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, tmpDecl) : vecPush(__recv, tmpDecl); })();
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len = (() => { const __recv = names; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len = __len;
  while ((i < __len)) {
  let tmpIdent = nodeNew(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.tmpIdent = tmpIdent;
  nodeSetData1(tmpIdent, tmpName);
  let idxLit = nodeNew(NK_NUMBER_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.idxLit = idxLit;
  nodeSetData1(idxLit, intern(intToString(i)));
  let idxExpr = nodeNew(NK_INDEX_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.idxExpr = idxExpr;
  nodeSetData1(idxExpr, tmpIdent);
  nodeSetData2(idxExpr, idxLit);
  let elemDecl = nodeNew(NK_LET_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.elemDecl = elemDecl;
  nodeSetData1(elemDecl, (() => { const __recv = names; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })());
  nodeSetData2(elemDecl, 0);
  nodeSetData3(elemDecl, idxExpr);
  (() => { const __recv = lowered; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(elemDecl); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, elemDecl) : vecPush(__recv, elemDecl); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return pDeclsLetExternNewStmtList(lowered);
}
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let vtype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.vtype = vtype;
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  vtype = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.vtype = vtype;
}
  pExpect(TK_SYMBOL, "=", "Expected '='");
  let value = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  pExpect(TK_SYMBOL, ";", "Expected ';'");
  let node = nodeNew(NK_LET_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, vtype);
  nodeSetData3(node, value);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseLet = pParseLet;

const __tuff_outer_for_pLeParseConstraintValueAtom = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pLeParseConstraintValueAtom() {
  let __tuff_this = { this: __tuff_outer_for_pLeParseConstraintValueAtom };
  if (pAtKind(TK_IDENTIFIER)) {
  let n = nodeNew(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  nodeSetData1(n, tokValue(pEat()));
  return n;
}
  if (pAtKind(TK_NUMBER)) {
  let n = nodeNew(NK_NUMBER_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  nodeSetData1(n, tokValue(pEat()));
  return n;
}
  if (pAtKind(TK_BOOL)) {
  let n = nodeNew(NK_BOOL_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  nodeSetData1(n, tokValue(pEat()));
  return n;
}
  if (pAtKind(TK_STRING)) {
  let n = nodeNew(NK_STRING_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  nodeSetData1(n, tokValue(pEat()));
  return n;
}
  if (pAtKind(TK_CHAR)) {
  let n = nodeNew(NK_CHAR_LIT); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  nodeSetData1(n, tokValue(pEat()));
  return n;
}
  if (pAt(TK_SYMBOL, "(")) {
  pEat();
  let inner = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  pExpect(TK_SYMBOL, ")", "Expected ')' in generic constraint expression");
  return inner;
}
  return pParseTypePrimary();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pLeParseConstraintValueAtom = pLeParseConstraintValueAtom;

const __tuff_outer_for_pLeParseConstraintValueExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pLeParseConstraintValueExpr() {
  let __tuff_this = { this: __tuff_outer_for_pLeParseConstraintValueExpr };
  let left = pLeParseConstraintValueAtom(); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  while (((((pAt(TK_SYMBOL, "+") || pAt(TK_SYMBOL, "-")) || pAt(TK_SYMBOL, "*")) || pAt(TK_SYMBOL, "/")) || pAt(TK_SYMBOL, "%"))) {
  let op = tokValue(pEat()); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let right = pLeParseConstraintValueAtom(); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let bin = nodeNew(NK_BINARY_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.bin = bin;
  nodeSetData1(bin, op);
  nodeSetData2(bin, left);
  nodeSetData3(bin, right);
  left = bin; if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
}
  return left;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pLeParseConstraintValueExpr = pLeParseConstraintValueExpr;

const __tuff_outer_for_pLeParseGenericConstraintType = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pLeParseGenericConstraintType() {
  let __tuff_this = { this: __tuff_outer_for_pLeParseGenericConstraintType };
  let typeNode = pParseTypePrimary(); if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
  let startsGenericCallSuffix = false; if (typeof __tuff_this !== 'undefined') __tuff_this.startsGenericCallSuffix = startsGenericCallSuffix;
  if ((pAt(TK_SYMBOL, ">") && (tokKind(pPeek(1)) === TK_SYMBOL))) {
  let nextSym = getIntern(tokValue(pPeek(1))); if (typeof __tuff_this !== 'undefined') __tuff_this.nextSym = nextSym;
  if ((() => { const __recv = nextSym; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "(") : strEq(__recv, "("); })()) {
  startsGenericCallSuffix = true; if (typeof __tuff_this !== 'undefined') __tuff_this.startsGenericCallSuffix = startsGenericCallSuffix;
}
}
  let hasRefine = ((((((pAt(TK_SYMBOL, "!=") || pAt(TK_SYMBOL, "<")) || pAt(TK_SYMBOL, ">")) || pAt(TK_SYMBOL, "<=")) || pAt(TK_SYMBOL, ">=")) && pCanStartRefinementExprAt(1)) && (!startsGenericCallSuffix)); if (typeof __tuff_this !== 'undefined') __tuff_this.hasRefine = hasRefine;
  if (hasRefine) {
  let op = tokValue(pEat()); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let value = pLeParseConstraintValueExpr(); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  let refine = nodeNew(NK_REFINEMENT_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.refine = refine;
  nodeSetData1(refine, typeNode);
  nodeSetData2(refine, op);
  nodeSetData3(refine, value);
  typeNode = refine; if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
}
  while ((pAt(TK_SYMBOL, "|") || pAt(TK_SYMBOL, "|>"))) {
  let isExtract = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.isExtract = isExtract;
  if (pAt(TK_SYMBOL, "|>")) {
  isExtract = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.isExtract = isExtract;
}
  pEat();
  let right = pParseTypePrimary(); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let unionNode = nodeNew(NK_UNION_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.unionNode = unionNode;
  nodeSetData1(unionNode, typeNode);
  nodeSetData2(unionNode, right);
  nodeSetData3(unionNode, isExtract);
  typeNode = unionNode; if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
}
  return typeNode;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pLeParseGenericConstraintType = pLeParseGenericConstraintType;

const __tuff_outer_for_pLeParseDeclGenerics = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pLeParseDeclGenerics(closeMessage) {
  let __tuff_this = { closeMessage: closeMessage, this: __tuff_outer_for_pLeParseDeclGenerics };
  let generics = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  if (pAt(TK_SYMBOL, "<")) {
  pEat();
  if ((!pAt(TK_SYMBOL, ">"))) {
  while (true) {
  (() => { const __recv = generics; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  pLeParseGenericConstraintType();
}
  if ((!pAt(TK_SYMBOL, ","))) {
  break;
}
  pEat();
}
}
  pExpect(TK_SYMBOL, ">", closeMessage);
}
  return generics;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pLeParseDeclGenerics = pLeParseDeclGenerics;

const __tuff_outer_for_pParseExternFnDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseExternFnDecl() {
  let __tuff_this = { this: __tuff_outer_for_pParseExternFnDecl };
  pExpect(TK_KEYWORD, "fn", "Expected 'fn'");
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let generics = pLeParseDeclGenerics("Expected '>'"); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  pExpect(TK_SYMBOL, "(", "Expected '('");
  let params = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  if ((!pAt(TK_SYMBOL, ")"))) {
  while (true) {
  let pname = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (pAt(TK_SYMBOL, "*")) {
  ptype = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  pname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
} else {
  pname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  ptype = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
}
  let param = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pname) : vecPush(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, ptype) : vecPush(__recv, ptype); })();
  (() => { const __recv = params; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, param) : vecPush(__recv, param); })();
  if ((!pAt(TK_SYMBOL, ","))) {
  break;
}
  pEat();
}
}
  pExpect(TK_SYMBOL, ")", "Expected ')'");
  let retType = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.retType = retType;
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  retType = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.retType = retType;
}
  pExpect(TK_SYMBOL, ";", "Expected ';' after extern fn");
  let node = nodeNew(NK_FN_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, generics);
  nodeSetData3(node, params);
  nodeSetData4(node, retType);
  nodeSetData5(node, 0);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseExternFnDecl = pParseExternFnDecl;

const __tuff_outer_for_pParseExternDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseExternDecl() {
  let __tuff_this = { this: __tuff_outer_for_pParseExternDecl };
  if (pAt(TK_KEYWORD, "fn")) {
  return ((typeof Ok === "function") ? Ok({value: pParseExternFnDecl()}) : ({ __tag: "Ok", value: pParseExternFnDecl() }));
}
  if (pAt(TK_KEYWORD, "let")) {
  pEat();
  if (pAt(TK_SYMBOL, "{")) {
  pEat();
  let names = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  if ((!pAt(TK_SYMBOL, "}"))) {
  (() => { const __recv = names; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = names; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
}
}
  pExpect(TK_SYMBOL, "}", "Expected '}' after extern let bindings");
  pExpect(TK_SYMBOL, "=", "Expected '=' in extern let bindings");
  let sourceParts = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sourceParts = sourceParts;
  (() => { const __recv = sourceParts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
  while (pAt(TK_SYMBOL, "::")) {
  pEat();
  (() => { const __recv = sourceParts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
}
  pExpect(TK_SYMBOL, ";", "Expected ';' after extern let bindings");
  let node = nodeNew(NK_EXTERN_IMPORT_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, names);
  nodeSetData2(node, sourceParts);
  return ((typeof Ok === "function") ? Ok({value: node}) : ({ __tag: "Ok", value: node }));
}
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let typ = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.typ = typ;
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  typ = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.typ = typ;
}
  pExpect(TK_SYMBOL, ";", "Expected ';' after extern let");
  let node = nodeNew(NK_EXTERN_LET_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, typ);
  return ((typeof Ok === "function") ? Ok({value: node}) : ({ __tag: "Ok", value: node }));
}
  if (pAt(TK_KEYWORD, "type")) {
  pEat();
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let generics = pLeParseDeclGenerics("Expected '>' after extern type generics"); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  let destructorName = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
  if (pAt(TK_KEYWORD, "then")) {
  pEat();
  destructorName = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
}
  pExpect(TK_SYMBOL, ";", "Expected ';' after extern type");
  let node = nodeNew(NK_EXTERN_TYPE_DECL); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, name);
  nodeSetData2(node, generics);
  nodeSetData5(node, destructorName);
  return ((typeof Ok === "function") ? Ok({value: node}) : ({ __tag: "Ok", value: node }));
}
  return pResultError("E_PARSE_EXPECTED_TOKEN", "Expected fn, let, or type after extern", "External declarations must be functions, variables, or types", "Add fn, let, or type keyword after extern");
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseExternDecl = pParseExternDecl;

const __tuff_outer_for_selfhostParserDeclsLetExternMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostParserDeclsLetExternMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostParserDeclsLetExternMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostParserDeclsLetExternMarker = selfhostParserDeclsLetExternMarker;

const __tuff_outer_for_pNewStmtList = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pNewStmtList(stmts) {
  let __tuff_this = { stmts: stmts, this: __tuff_outer_for_pNewStmtList };
  let n = nodeNew(NK_STMT_LIST); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  nodeSetData1(n, stmts);
  return n;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pNewStmtList = pNewStmtList;

const __tuff_outer_for_pParseTemplateWrapper = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseTemplateWrapper() {
  let __tuff_this = { this: __tuff_outer_for_pParseTemplateWrapper };
  pEat();
  pParseIdentifier();
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  pParseType();
}
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  pParseIdentifier();
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  pParseType();
}
}
  pExpect(TK_SYMBOL, "{", "Expected '{' after template declaration");
  let stmts = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  while ((!pAt(TK_SYMBOL, "}"))) {
  let stmt = pParseStatement(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if ((nodeKind(stmt) === NK_BLOCK)) {
  let inner = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let __len2 = (() => { const __recv = inner; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len2 = __len2;
  while ((j < __len2)) {
  (() => { const __recv = stmts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = inner; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = inner; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()) : vecPush(__recv, (() => { const __recv = inner; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
} else {
  (() => { const __recv = stmts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(stmt); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, stmt) : vecPush(__recv, stmt); })();
}
}
  pExpect(TK_SYMBOL, "}", "Expected '}' after template block");
  return pNewStmtList(stmts);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseTemplateWrapper = pParseTemplateWrapper;

const __tuff_outer_for_pParseModuleWrapper = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseModuleWrapper() {
  let __tuff_this = { this: __tuff_outer_for_pParseModuleWrapper };
  pExpect(TK_KEYWORD, "module", "Expected 'module'");
  pParseIdentifier();
  pExpect(TK_SYMBOL, "{", "Expected '{' after module name");
  let stmts = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  while ((!pAt(TK_SYMBOL, "}"))) {
  let stmt = pParseStatement(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if ((nodeKind(stmt) === NK_BLOCK)) {
  let inner = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let __len1 = (() => { const __recv = inner; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len1 = __len1;
  while ((j < __len1)) {
  (() => { const __recv = stmts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = inner; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = inner; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()) : vecPush(__recv, (() => { const __recv = inner; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
} else {
  (() => { const __recv = stmts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(stmt); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, stmt) : vecPush(__recv, stmt); })();
}
}
  pExpect(TK_SYMBOL, "}", "Expected '}' after module body");
  return pNewStmtList(stmts);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseModuleWrapper = pParseModuleWrapper;

const __tuff_outer_for_pParseDeclModifiers = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseDeclModifiers() {
  let __tuff_this = { this: __tuff_outer_for_pParseDeclModifiers };
  let exported = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.exported = exported;
  let externDecl = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.externDecl = externDecl;
  let copyDecl = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.copyDecl = copyDecl;
  let expectDecl = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.expectDecl = expectDecl;
  let actualDecl = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.actualDecl = actualDecl;
  let consumedModifier = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.consumedModifier = consumedModifier;
  let modifierWatchdog = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.modifierWatchdog = modifierWatchdog;
  while (((((((pAt(TK_KEYWORD, "out") || pAt(TK_KEYWORD, "extern")) || pAt(TK_KEYWORD, "copy")) || pAt(TK_KEYWORD, "expect")) || (pAt(TK_IDENTIFIER, "expect") && ((tokKind(pPeek(1)) === TK_KEYWORD) || (tokKind(pPeek(1)) === TK_IDENTIFIER)))) || pAt(TK_KEYWORD, "actual")) || (pAt(TK_IDENTIFIER, "actual") && ((tokKind(pPeek(1)) === TK_KEYWORD) || (tokKind(pPeek(1)) === TK_IDENTIFIER))))) {
  modifierWatchdog = (modifierWatchdog + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.modifierWatchdog = modifierWatchdog;
  if ((modifierWatchdog > 1000)) {
  pErrorWithTokenContext("Parser watchdog: declaration-modifier loop exceeded 1000 iterations");
}
  consumedModifier = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.consumedModifier = consumedModifier;
  if (pAt(TK_KEYWORD, "out")) {
  pEat();
  if ((exported === 1)) {
  pPanicLoc("E_PARSE_DUPLICATE_MODIFIER", "Duplicate 'out' modifier", "The 'out' modifier was specified more than once", "Remove duplicate 'out' modifiers, keeping only one");
}
  exported = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.exported = exported;
} else { if (pAt(TK_KEYWORD, "extern")) {
  pEat();
  if ((externDecl === 1)) {
  pPanicLoc("E_PARSE_DUPLICATE_MODIFIER", "Duplicate 'extern' modifier", "The 'extern' modifier was specified more than once", "Remove duplicate 'extern' modifiers, keeping only one");
}
  externDecl = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.externDecl = externDecl;
} else { if (pAt(TK_KEYWORD, "copy")) {
  pEat();
  if ((copyDecl === 1)) {
  pPanicLoc("E_PARSE_DUPLICATE_MODIFIER", "Duplicate 'copy' modifier", "The 'copy' modifier was specified more than once", "Remove duplicate 'copy' modifiers, keeping only one");
}
  copyDecl = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.copyDecl = copyDecl;
} else { if ((pAt(TK_KEYWORD, "expect") || (pAt(TK_IDENTIFIER, "expect") && ((tokKind(pPeek(1)) === TK_KEYWORD) || (tokKind(pPeek(1)) === TK_IDENTIFIER))))) {
  pEat();
  if ((expectDecl === 1)) {
  pPanicLoc("E_PARSE_DUPLICATE_MODIFIER", "Duplicate 'expect' modifier", "The 'expect' modifier was specified more than once", "Remove duplicate 'expect' modifiers, keeping only one");
}
  expectDecl = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.expectDecl = expectDecl;
} else { if ((pAt(TK_KEYWORD, "actual") || (pAt(TK_IDENTIFIER, "actual") && ((tokKind(pPeek(1)) === TK_KEYWORD) || (tokKind(pPeek(1)) === TK_IDENTIFIER))))) {
  pEat();
  if ((actualDecl === 1)) {
  pPanicLoc("E_PARSE_DUPLICATE_MODIFIER", "Duplicate 'actual' modifier", "The 'actual' modifier was specified more than once", "Remove duplicate 'actual' modifiers, keeping only one");
}
  actualDecl = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.actualDecl = actualDecl;
} else {
  pPanicLoc("E_PARSE_INVALID_MODIFIER", "Unexpected declaration modifier", "Encountered an unrecognized or invalid modifier", "Use only valid modifiers: out, extern, copy, expect, actual");
} } } } }
}
  let mods = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.mods = mods;
  (() => { const __recv = mods; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(exported); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, exported) : vecPush(__recv, exported); })();
  (() => { const __recv = mods; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(externDecl); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, externDecl) : vecPush(__recv, externDecl); })();
  (() => { const __recv = mods; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(copyDecl); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, copyDecl) : vecPush(__recv, copyDecl); })();
  (() => { const __recv = mods; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(expectDecl); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, expectDecl) : vecPush(__recv, expectDecl); })();
  (() => { const __recv = mods; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(actualDecl); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, actualDecl) : vecPush(__recv, actualDecl); })();
  (() => { const __recv = mods; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(consumedModifier); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, consumedModifier) : vecPush(__recv, consumedModifier); })();
  return mods;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseDeclModifiers = pParseDeclModifiers;

const __tuff_outer_for_pParseAfterModifiers = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseAfterModifiers(exported, externDecl, copyDecl, expectDecl, actualDecl) {
  let __tuff_this = { exported: exported, externDecl: externDecl, copyDecl: copyDecl, expectDecl: expectDecl, actualDecl: actualDecl, this: __tuff_outer_for_pParseAfterModifiers };
  if (((expectDecl === 1) && (actualDecl === 1))) {
  return pResultError("E_PARSE_CONFLICTING_MODIFIERS", "Cannot combine 'expect' and 'actual' modifiers", "These modifiers are mutually exclusive", "Use either 'expect' or 'actual', not both");
}
  let outNode = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.outNode = outNode;
  if ((externDecl === 1)) {
  if ((copyDecl === 1)) {
  return pResultError("E_PARSE_INVALID_MODIFIER", "'copy' is not supported on extern declarations", "External declarations cannot use the copy modifier", "Remove the 'copy' modifier from extern declarations");
}
  if (((expectDecl === 1) || (actualDecl === 1))) {
  return pResultError("E_PARSE_INVALID_MODIFIER", "'expect'/'actual' are not supported on extern declarations", "External declarations cannot use expect/actual modifiers", "Remove the 'expect'/'actual' modifiers from extern declarations");
}
  if (pAt(TK_KEYWORD, "extern")) {
  pEat();
}
  if ((!((pAt(TK_KEYWORD, "fn") || pAt(TK_KEYWORD, "let")) || pAt(TK_KEYWORD, "type")))) {
  return pResultError("E_PARSE_INVALID_MODIFIER", "'extern' modifier must be followed by fn, let, or type declaration", "The extern modifier can only be used with function, variable, or type declarations", "Add fn, let, or type after extern");
}
  outNode = pParseExternDecl(); if (typeof __tuff_this !== 'undefined') __tuff_this.outNode = outNode;
} else { if (pAt(TK_KEYWORD, "struct")) {
  outNode = pParseStruct(copyDecl); if (typeof __tuff_this !== 'undefined') __tuff_this.outNode = outNode;
} else { if (pAt(TK_KEYWORD, "enum")) {
  outNode = pParseEnum(); if (typeof __tuff_this !== 'undefined') __tuff_this.outNode = outNode;
} else { if (pAt(TK_KEYWORD, "object")) {
  if ((copyDecl === 1)) {
  return pResultError("E_PARSE_INVALID_MODIFIER", "'copy' is only supported on struct/type declarations", "The copy modifier can only be used with struct or type declarations", "Remove 'copy' or use it with struct/type declarations");
}
  if (((expectDecl === 1) || (actualDecl === 1))) {
  return pResultError("E_PARSE_INVALID_MODIFIER", "'expect'/'actual' are currently supported only on fn declarations", "These modifiers are only available for function declarations", "Remove 'expect'/'actual' or use them with fn declarations");
}
  outNode = pParseObject(); if (typeof __tuff_this !== 'undefined') __tuff_this.outNode = outNode;
} else { if (pAt(TK_KEYWORD, "contract")) {
  if ((copyDecl === 1)) {
  return pResultError("E_PARSE_INVALID_MODIFIER", "'copy' is only supported on struct/type declarations", "The copy modifier can only be used with struct or type declarations", "Remove 'copy' or use it with struct/type declarations");
}
  if (((expectDecl === 1) || (actualDecl === 1))) {
  return pResultError("E_PARSE_INVALID_MODIFIER", "'expect'/'actual' are currently supported only on fn declarations", "These modifiers are only available for function declarations", "Remove 'expect'/'actual' or use them with fn declarations");
}
  outNode = pParseContract(); if (typeof __tuff_this !== 'undefined') __tuff_this.outNode = outNode;
} else { if (pAt(TK_KEYWORD, "type")) {
  outNode = pParseTypeAlias(copyDecl); if (typeof __tuff_this !== 'undefined') __tuff_this.outNode = outNode;
} else { if (pAt(TK_KEYWORD, "fn")) {
  if ((copyDecl === 1)) {
  return pResultError("E_PARSE_INVALID_MODIFIER", "'copy' is only supported on struct/type declarations", "The copy modifier can only be used with struct or type declarations", "Remove 'copy' or use it with struct/type declarations");
}
  let mode = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
  if ((expectDecl === 1)) {
  mode = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
} else { if ((actualDecl === 1)) {
  mode = 2; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
} }
  outNode = pParseFunction(0, mode); if (typeof __tuff_this !== 'undefined') __tuff_this.outNode = outNode;
} else { if (pAt(TK_KEYWORD, "class")) {
  if ((copyDecl === 1)) {
  return pResultError("E_PARSE_INVALID_MODIFIER", "'copy' is only supported on struct/type declarations", "The copy modifier can only be used with struct or type declarations", "Remove 'copy' or use it with struct/type declarations");
}
  if (((expectDecl === 1) || (actualDecl === 1))) {
  return pResultError("E_PARSE_INVALID_MODIFIER", "'expect'/'actual' are currently supported only on fn declarations", "These modifiers are only available for function declarations", "Remove 'expect'/'actual' or use them with fn declarations");
}
  pEat();
  outNode = pParseFunction(1, 0); if (typeof __tuff_this !== 'undefined') __tuff_this.outNode = outNode;
} else { if (pAt(TK_KEYWORD, "module")) {
  if ((copyDecl === 1)) {
  return pResultError("E_PARSE_INVALID_MODIFIER", "'copy' is only supported on struct/type declarations", "The copy modifier can only be used with struct or type declarations", "Remove 'copy' or use it with struct/type declarations");
}
  if (((expectDecl === 1) || (actualDecl === 1))) {
  return pResultError("E_PARSE_INVALID_MODIFIER", "'expect'/'actual' are currently supported only on fn declarations", "These modifiers are only available for function declarations", "Remove 'expect'/'actual' or use them with fn declarations");
}
  outNode = pParseModuleWrapper(); if (typeof __tuff_this !== 'undefined') __tuff_this.outNode = outNode;
} else {
  pErrorWithTokenContext("Expected declaration after modifiers");
  return ((typeof Err === "function") ? Err({error: ((typeof ParseError === "function") ? ParseError({code: "E_PARSE_UNEXPECTED_TOKEN", message: "Unreachable", reason: "", fix: "", line: 0, col: 0}) : ({ __tag: "ParseError", code: "E_PARSE_UNEXPECTED_TOKEN", message: "Unreachable", reason: "", fix: "", line: 0, col: 0 }))}) : ({ __tag: "Err", error: ((typeof ParseError === "function") ? ParseError({code: "E_PARSE_UNEXPECTED_TOKEN", message: "Unreachable", reason: "", fix: "", line: 0, col: 0}) : ({ __tag: "ParseError", code: "E_PARSE_UNEXPECTED_TOKEN", message: "Unreachable", reason: "", fix: "", line: 0, col: 0 })) }));
} } } } } } } } }
  if (((exported === 1) && (nodeKind(outNode) !== NK_STMT_LIST))) {
  (() => { const __recv = parseExports; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(outNode))); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(outNode))) : setAdd(__recv, getInternedStr(nodeGetData1(outNode))); })();
}
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
}
  let successResult = ((typeof Ok === "function") ? Ok({value: outNode}) : ({ __tag: "Ok", value: outNode })); if (typeof __tuff_this !== 'undefined') __tuff_this.successResult = successResult;
  return successResult;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseAfterModifiers = pParseAfterModifiers;

const __tuff_outer_for_pTryParsePlainDeclStatement = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTryParsePlainDeclStatement() {
  let __tuff_this = { this: __tuff_outer_for_pTryParsePlainDeclStatement };
  if (pAt(TK_KEYWORD, "let")) {
  return pParseLet();
}
  if (pAt(TK_KEYWORD, "struct")) {
  let node = pParseStruct(0); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
}
  return node;
}
  if (pAt(TK_KEYWORD, "enum")) {
  let node = pParseEnum(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
}
  return node;
}
  if (pAt(TK_KEYWORD, "object")) {
  let node = pParseObject(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
}
  return node;
}
  if (pAt(TK_KEYWORD, "module")) {
  let node = pParseModuleWrapper(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
}
  return node;
}
  if ((pAt(TK_KEYWORD, "template") || pAt(TK_IDENTIFIER, "template"))) {
  let node = pParseTemplateWrapper(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
}
  return node;
}
  if (pAt(TK_KEYWORD, "contract")) {
  let node = pParseContract(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
}
  return node;
}
  if (pAt(TK_KEYWORD, "type")) {
  let node = pParseTypeAlias(0); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
}
  return node;
}
  if (pAt(TK_KEYWORD, "fn")) {
  let node = pParseFunction(0, 0); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
}
  return node;
}
  if (pAt(TK_KEYWORD, "extern")) {
  pEat();
  let externResult = pParseExternDecl(); if (typeof __tuff_this !== 'undefined') __tuff_this.externResult = externResult;
  if ((externResult && externResult.__tag === "Err")) {
  panicWithCodeLoc(externResult.error.code, externResult.error.message, externResult.error.reason, externResult.error.fix, externResult.error.line, externResult.error.col);
  return 0;
}
  return externResult.value;
}
  if (pAt(TK_KEYWORD, "class")) {
  pEat();
  let node = pParseFunction(1, 0); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
}
  return node;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTryParsePlainDeclStatement = pTryParsePlainDeclStatement;

const __tuff_outer_for_pParseIfStmtOrExprStmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseIfStmtOrExprStmt() {
  let __tuff_this = { this: __tuff_outer_for_pParseIfStmtOrExprStmt };
  pEat();
  pExpect(TK_SYMBOL, "(", "Expected '(' after if");
  let cond = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  pExpect(TK_SYMBOL, ")", "Expected ')' after condition");
  if (((((((((pAt(TK_SYMBOL, "{") || pAt(TK_KEYWORD, "break")) || pAt(TK_KEYWORD, "continue")) || pAt(TK_KEYWORD, "return")) || pAt(TK_KEYWORD, "if")) || pAt(TK_KEYWORD, "while")) || pAt(TK_KEYWORD, "for")) || pAt(TK_KEYWORD, "loop")) || pAt(TK_KEYWORD, "let"))) {
  let thenBranch = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.thenBranch = thenBranch;
  if (pAt(TK_SYMBOL, "{")) {
  thenBranch = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.thenBranch = thenBranch;
} else {
  thenBranch = pParseStatement(); if (typeof __tuff_this !== 'undefined') __tuff_this.thenBranch = thenBranch;
}
  let elseBranch = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.elseBranch = elseBranch;
  if (pAt(TK_KEYWORD, "else")) {
  pEat();
  if (pAt(TK_SYMBOL, "{")) {
  elseBranch = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.elseBranch = elseBranch;
} else {
  elseBranch = pParseStatement(); if (typeof __tuff_this !== 'undefined') __tuff_this.elseBranch = elseBranch;
}
}
  let stmt = nodeNew(NK_IF_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  nodeSetData1(stmt, cond);
  nodeSetData2(stmt, thenBranch);
  nodeSetData3(stmt, elseBranch);
  return stmt;
}
  let thenExpr = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.thenExpr = thenExpr;
  let elseExpr = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.elseExpr = elseExpr;
  if (pAt(TK_KEYWORD, "else")) {
  pEat();
  if (pAt(TK_SYMBOL, "{")) {
  elseExpr = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.elseExpr = elseExpr;
} else {
  elseExpr = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.elseExpr = elseExpr;
}
}
  let ifExpr = nodeNew(NK_IF_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.ifExpr = ifExpr;
  nodeSetData1(ifExpr, cond);
  nodeSetData2(ifExpr, thenExpr);
  nodeSetData3(ifExpr, elseExpr);
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
} else { if ((!pAt(TK_SYMBOL, "}"))) {
  pExpect(TK_SYMBOL, ";", "Expected ';'");
} }
  let estmt = nodeNew(NK_EXPR_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.estmt = estmt;
  nodeSetData1(estmt, ifExpr);
  return estmt;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseIfStmtOrExprStmt = pParseIfStmtOrExprStmt;

const __tuff_outer_for_pTryParsePlainControlStatement = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTryParsePlainControlStatement() {
  let __tuff_this = { this: __tuff_outer_for_pTryParsePlainControlStatement };
  if (pAt(TK_KEYWORD, "return")) {
  pEat();
  let value = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  if ((!pAt(TK_SYMBOL, ";"))) {
  value = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
}
  pExpect(TK_SYMBOL, ";", "Expected ';'");
  let node = nodeNew(NK_RETURN_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, value);
  return node;
}
  if (pAt(TK_KEYWORD, "if")) {
  return pParseIfStmtOrExprStmt();
}
  if (pAt(TK_KEYWORD, "while")) {
  pEat();
  pExpect(TK_SYMBOL, "(", "Expected '('");
  let cond = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  pExpect(TK_SYMBOL, ")", "Expected ')'");
  let body = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let node = nodeNew(NK_WHILE_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, cond);
  nodeSetData2(node, body);
  return node;
}
  if (pAt(TK_KEYWORD, "for")) {
  return pParseFor();
}
  if (pAt(TK_KEYWORD, "loop")) {
  pEat();
  let body = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let node = nodeNew(NK_LOOP_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, body);
  return node;
}
  if (pAt(TK_KEYWORD, "then")) {
  pEat();
  pExpect(TK_SYMBOL, "(", "Expected '(' after then in then-statement");
  pExpect(TK_SYMBOL, ")", "Expected ')' in then-statement parameter list");
  pExpect(TK_SYMBOL, "=>", "Expected '=>' in then-statement");
  if (pAt(TK_SYMBOL, "{")) {
  return pParseBlock();
}
  let expr = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  pExpect(TK_SYMBOL, ";", "Expected ';' after then-statement expression");
  let estmt = nodeNew(NK_EXPR_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.estmt = estmt;
  nodeSetData1(estmt, expr);
  return estmt;
}
  if (pAt(TK_KEYWORD, "lifetime")) {
  return pParseLifetime();
}
  if (pAt(TK_KEYWORD, "into")) {
  pEat();
  let cname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
  pExpect(TK_SYMBOL, ";", "Expected ';' after into statement");
  let node = nodeNew(NK_INTO_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, cname);
  return node;
}
  if (pAt(TK_KEYWORD, "break")) {
  pEat();
  pExpect(TK_SYMBOL, ";", "Expected ';'");
  return nodeNew(NK_BREAK_STMT);
}
  if (pAt(TK_KEYWORD, "continue")) {
  pEat();
  pExpect(TK_SYMBOL, ";", "Expected ';'");
  return nodeNew(NK_CONTINUE_STMT);
}
  if (pAt(TK_SYMBOL, "{")) {
  return pParseBlock();
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTryParsePlainControlStatement = pTryParsePlainControlStatement;

const __tuff_outer_for_pParseStatement = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseStatement() {
  let __tuff_this = { this: __tuff_outer_for_pParseStatement };
  let mods = pParseDeclModifiers(); if (typeof __tuff_this !== 'undefined') __tuff_this.mods = mods;
  if (((() => { const __recv = mods; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(5); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 5) : vecGet(__recv, 5); })() === 1)) {
  let modResultAny = pParseAfterModifiers((() => { const __recv = mods; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(), (() => { const __recv = mods; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), (() => { const __recv = mods; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 2) : vecGet(__recv, 2); })(), (() => { const __recv = mods; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(3); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 3) : vecGet(__recv, 3); })(), (() => { const __recv = mods; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(4); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 4) : vecGet(__recv, 4); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.modResultAny = modResultAny;
  if ((modResultAny && modResultAny.__tag === "Err")) {
  panicWithCodeLoc(modResultAny.error.code, modResultAny.error.message, modResultAny.error.reason, modResultAny.error.fix, modResultAny.error.line, modResultAny.error.col);
}
  if ((modResultAny && modResultAny.__tag === "Ok")) {
  return modResultAny.value;
}
  panic("Unexpected parser result variant");
  return 0;
}
  let node = pTryParsePlainDeclStatement(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if ((node !== 0)) {
  return node;
}
  node = pTryParsePlainControlStatement(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if ((node !== 0)) {
  return node;
}
  let expr = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  if (pAt(TK_SYMBOL, "=")) {
  pEat();
  let value = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  pExpect(TK_SYMBOL, ";", "Expected ';'");
  let node = nodeNew(NK_ASSIGN_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, expr);
  nodeSetData2(node, value);
  return node;
}
  if ((((((((((pAt(TK_SYMBOL, "+") || pAt(TK_SYMBOL, "-")) || pAt(TK_SYMBOL, "*")) || pAt(TK_SYMBOL, "/")) || pAt(TK_SYMBOL, "%")) || pAt(TK_SYMBOL, "&")) || pAt(TK_SYMBOL, "|")) || pAt(TK_SYMBOL, "^")) && (tokKind(pPeek(1)) === TK_SYMBOL)) && (() => { const __recv = getInternedStr(tokValue(pPeek(1))); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "=") : strEq(__recv, "="); })())) {
  let opTok = pEat(); if (typeof __tuff_this !== 'undefined') __tuff_this.opTok = opTok;
  pEat();
  let rhs = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.rhs = rhs;
  pExpect(TK_SYMBOL, ";", "Expected ';'");
  let bin = nodeNew(NK_BINARY_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.bin = bin;
  nodeSetData1(bin, tokValue(opTok));
  nodeSetData2(bin, expr);
  nodeSetData3(bin, rhs);
  let node = nodeNew(NK_ASSIGN_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, expr);
  nodeSetData2(node, bin);
  return node;
}
  if (pAt(TK_SYMBOL, ";")) {
  pEat();
} else { if ((!pAt(TK_SYMBOL, "}"))) {
  pExpect(TK_SYMBOL, ";", "Expected ';'");
} }
  let stmt = nodeNew(NK_EXPR_STMT); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  nodeSetData1(stmt, expr);
  return stmt;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseStatement = pParseStatement;

const __tuff_outer_for_pParseProgram = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseProgram() {
  let __tuff_this = { this: __tuff_outer_for_pParseProgram };
  let stmts = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let atEof = pAtKind(TK_EOF); if (typeof __tuff_this !== 'undefined') __tuff_this.atEof = atEof;
  while ((!atEof)) {
  let before = pMark(); if (typeof __tuff_this !== 'undefined') __tuff_this.before = before;
  let stmt = pParseStatement(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let after = pMark(); if (typeof __tuff_this !== 'undefined') __tuff_this.after = after;
  if ((after === before)) {
  pErrorWithTokenContext("Parser made no progress while parsing top-level statement");
}
  if ((nodeKind(stmt) === NK_STMT_LIST)) {
  let inner = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len = (() => { const __recv = inner; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len = __len;
  while ((i < __len)) {
  (() => { const __recv = stmts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = inner; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = inner; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()) : vecPush(__recv, (() => { const __recv = inner; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
} else {
  (() => { const __recv = stmts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(stmt); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, stmt) : vecPush(__recv, stmt); })();
}
  atEof = pAtKind(TK_EOF); if (typeof __tuff_this !== 'undefined') __tuff_this.atEof = atEof;
}
  let node = nodeNew(NK_PROGRAM); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, stmts);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseProgram = pParseProgram;

const __tuff_outer_for_desugar = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function desugar(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_desugar };
  return program;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.desugar = desugar;

const __tuff_outer_for_selfhostParserDeclsMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostParserDeclsMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostParserDeclsMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostParserDeclsMarker = selfhostParserDeclsMarker;

const __tuff_outer_for_rslvUtilsPanicNode = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslvUtilsPanicNode(errNode, code, msg, reason, fix) {
  let __tuff_this = { errNode: errNode, code: code, msg: msg, reason: reason, fix: fix, this: __tuff_outer_for_rslvUtilsPanicNode };
  return panicWithCodeLoc(code, msg, reason, fix, nodeGetLine(errNode), nodeGetCol(errNode));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslvUtilsPanicNode = rslvUtilsPanicNode;

const __tuff_outer_for_initHostBuiltins = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function initHostBuiltins() {
  let __tuff_this = { this: __tuff_outer_for_initHostBuiltins };
  let builtins = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.builtins = builtins;
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("sizeOf"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "sizeOf") : setAdd(__recv, "sizeOf"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("malloc"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "malloc") : setAdd(__recv, "malloc"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("realloc"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "realloc") : setAdd(__recv, "realloc"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("free"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "free") : setAdd(__recv, "free"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("memcpy"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "memcpy") : setAdd(__recv, "memcpy"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("memset"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "memset") : setAdd(__recv, "memset"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("drop"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "drop") : setAdd(__recv, "drop"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("panic"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "panic") : setAdd(__recv, "panic"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "this") : setAdd(__recv, "this"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("print"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "print") : setAdd(__recv, "print"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("parseInt"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "parseInt") : setAdd(__recv, "parseInt"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("charCode"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "charCode") : setAdd(__recv, "charCode"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("strConcat"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "strConcat") : setAdd(__recv, "strConcat"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("strFromCharCode"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "strFromCharCode") : setAdd(__recv, "strFromCharCode"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("readFile"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "readFile") : setAdd(__recv, "readFile"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("writeFile"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "writeFile") : setAdd(__recv, "writeFile"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("pathJoin"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "pathJoin") : setAdd(__recv, "pathJoin"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("pathDirname"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "pathDirname") : setAdd(__recv, "pathDirname"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("getArgc"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "getArgc") : setAdd(__recv, "getArgc"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("getArgv"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "getArgv") : setAdd(__recv, "getArgv"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("panicWithCode"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "panicWithCode") : setAdd(__recv, "panicWithCode"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("panicWithCodeLoc"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "panicWithCodeLoc") : setAdd(__recv, "panicWithCodeLoc"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("profileMark"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "profileMark") : setAdd(__recv, "profileMark"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("sbNew"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "sbNew") : setAdd(__recv, "sbNew"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("sbAppend"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "sbAppend") : setAdd(__recv, "sbAppend"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("sbAppendChar"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "sbAppendChar") : setAdd(__recv, "sbAppendChar"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("sbBuild"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "sbBuild") : setAdd(__recv, "sbBuild"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__vec_new"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__vec_new") : setAdd(__recv, "__vec_new"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__vec_push"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__vec_push") : setAdd(__recv, "__vec_push"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__vec_pop"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__vec_pop") : setAdd(__recv, "__vec_pop"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__vec_get"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__vec_get") : setAdd(__recv, "__vec_get"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__vec_set"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__vec_set") : setAdd(__recv, "__vec_set"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__vec_length"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__vec_length") : setAdd(__recv, "__vec_length"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__vec_init"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__vec_init") : setAdd(__recv, "__vec_init"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__vec_capacity"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__vec_capacity") : setAdd(__recv, "__vec_capacity"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__vec_clear"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__vec_clear") : setAdd(__recv, "__vec_clear"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__vec_clone"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__vec_clone") : setAdd(__recv, "__vec_clone"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__vec_includes"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__vec_includes") : setAdd(__recv, "__vec_includes"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__vec_join"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__vec_join") : setAdd(__recv, "__vec_join"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__set_new"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__set_new") : setAdd(__recv, "__set_new"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__map_new"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__map_new") : setAdd(__recv, "__map_new"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__int_to_string"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__int_to_string") : setAdd(__recv, "__int_to_string"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__str_index_of"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__str_index_of") : setAdd(__recv, "__str_index_of"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__perf_now"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__perf_now") : setAdd(__recv, "__perf_now"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__print_error"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__print_error") : setAdd(__recv, "__print_error"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__profile_take_json"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__profile_take_json") : setAdd(__recv, "__profile_take_json"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__host_get_c_substrate"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__host_get_c_substrate") : setAdd(__recv, "__host_get_c_substrate"); })();
  (() => { const __recv = builtins; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("__host_get_c_runtime_prelude_source"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "__host_get_c_runtime_prelude_source") : setAdd(__recv, "__host_get_c_runtime_prelude_source"); })();
  return builtins;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.initHostBuiltins = initHostBuiltins;

let HOST_BUILTINS = initHostBuiltins(); if (typeof __tuff_this !== 'undefined') __tuff_this.HOST_BUILTINS = HOST_BUILTINS;

const __tuff_outer_for_levenshteinDistance = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function levenshteinDistance(a, b) {
  let __tuff_this = { a: a, b: b, this: __tuff_outer_for_levenshteinDistance };
  let an = (0 + (() => { const __recv = a; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.an = an;
  let bn = (0 + (() => { const __recv = b; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.bn = bn;
  if ((an === 0)) {
  return bn;
}
  if ((bn === 0)) {
  return an;
}
  let prev = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.prev = prev;
  let curr = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.curr = curr;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j <= bn)) {
  (() => { const __recv = prev; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, j) : vecPush(__recv, j); })();
  (() => { const __recv = curr; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  let i = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i <= an)) {
  (() => { const __recv = curr; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(0, i); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, 0, i) : vecSet(__recv, 0, i); })();
  let j2 = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.j2 = j2;
  while ((j2 <= bn)) {
  let cost = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cost = cost;
  if (((() => { const __recv = a; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i - 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i - 1)) : strCharAt(__recv, (i - 1)); })() !== (() => { const __recv = b; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((j2 - 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (j2 - 1)) : strCharAt(__recv, (j2 - 1)); })())) {
  cost = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.cost = cost;
}
  let delCost = ((() => { const __recv = prev; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j2); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j2) : vecGet(__recv, j2); })() + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.delCost = delCost;
  let insCost = ((() => { const __recv = curr; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((j2 - 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (j2 - 1)) : vecGet(__recv, (j2 - 1)); })() + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.insCost = insCost;
  let repCost = ((() => { const __recv = prev; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((j2 - 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (j2 - 1)) : vecGet(__recv, (j2 - 1)); })() + cost); if (typeof __tuff_this !== 'undefined') __tuff_this.repCost = repCost;
  let best = delCost; if (typeof __tuff_this !== 'undefined') __tuff_this.best = best;
  if ((insCost < best)) {
  best = insCost; if (typeof __tuff_this !== 'undefined') __tuff_this.best = best;
}
  if ((repCost < best)) {
  best = repCost; if (typeof __tuff_this !== 'undefined') __tuff_this.best = best;
}
  (() => { const __recv = curr; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(j2, best); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, j2, best) : vecSet(__recv, j2, best); })();
  j2 = (j2 + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j2 = j2;
}
  let k = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  while ((k <= bn)) {
  (() => { const __recv = prev; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(k, (() => { const __recv = curr; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, k) : vecGet(__recv, k); })()); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, k, (() => { const __recv = curr; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, k) : vecGet(__recv, k); })()) : vecSet(__recv, k, (() => { const __recv = curr; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, k) : vecGet(__recv, k); })()); })();
  k = (k + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = prev; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(bn); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, bn) : vecGet(__recv, bn); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.levenshteinDistance = levenshteinDistance;

const __tuff_outer_for_rslvUtilsFindDidYouMean = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslvUtilsFindDidYouMean(name, candidates) {
  let __tuff_this = { name: name, candidates: candidates, this: __tuff_outer_for_rslvUtilsFindDidYouMean };
  let best = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.best = best;
  let bestDist = 9999; if (typeof __tuff_this !== 'undefined') __tuff_this.bestDist = bestDist;
  let nameLen = (0 + (() => { const __recv = name; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.nameLen = nameLen;
  let threshold = ((nameLen / 3) + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.threshold = threshold;
  if ((threshold > 3)) {
  threshold = 3; if (typeof __tuff_this !== 'undefined') __tuff_this.threshold = threshold;
}
  let n = (() => { const __recv = candidates; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  let ci = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ci = ci;
  while ((ci < n)) {
  let cand = (() => { const __recv = candidates; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(ci); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, ci) : vecGet(__recv, ci); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cand = cand;
  let dist = levenshteinDistance(name, cand); if (typeof __tuff_this !== 'undefined') __tuff_this.dist = dist;
  if (((dist <= threshold) && (dist < bestDist))) {
  bestDist = dist; if (typeof __tuff_this !== 'undefined') __tuff_this.bestDist = bestDist;
  best = cand; if (typeof __tuff_this !== 'undefined') __tuff_this.best = best;
}
  ci = (ci + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.ci = ci;
}
  return best;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslvUtilsFindDidYouMean = rslvUtilsFindDidYouMean;

const __tuff_outer_for_fnTypeSig = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fnTypeSig(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_fnTypeSig };
  if ((t === 0)) {
  return "_";
}
  let k = nodeKind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_NAMED_TYPE)) {
  return getInternedStr(nodeGetData1(t));
}
  if ((k === NK_POINTER_TYPE)) {
  let mutv = nodeGetData1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.mutv = mutv;
  let inner = fnTypeSig(nodeGetData2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let lifeIdx = nodeGetData4(t); if (typeof __tuff_this !== 'undefined') __tuff_this.lifeIdx = lifeIdx;
  let lifePrefix = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.lifePrefix = lifePrefix;
  if ((lifeIdx !== 0)) {
  lifePrefix = (() => { const __recv = getInternedStr(lifeIdx); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.lifePrefix = lifePrefix;
}
  if ((mutv === 1)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lifePrefix); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lifePrefix) : strConcat(__recv, lifePrefix); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "mut ") : strConcat(__recv, "mut "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })();
}
  return (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lifePrefix); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lifePrefix) : strConcat(__recv, lifePrefix); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })();
}
  if ((k === NK_ARRAY_TYPE)) {
  return "Array";
}
  if ((k === NK_TUPLE_TYPE)) {
  return "Tuple";
}
  if ((k === NK_REFINEMENT_TYPE)) {
  return (() => { const __recv = (() => { const __recv = "Ref<"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fnTypeSig(nodeGetData1(t))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fnTypeSig(nodeGetData1(t))) : strConcat(__recv, fnTypeSig(nodeGetData1(t))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(">"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ">") : strConcat(__recv, ">"); })();
}
  if ((k === NK_APPLIED_TYPE)) {
  return (() => { const __recv = getInternedStr(nodeGetData1(t)); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(...)"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(...)") : strConcat(__recv, "(...)"); })();
}
  if ((k === NK_UNION_TYPE)) {
  return (() => { const __recv = (() => { const __recv = fnTypeSig(nodeGetData1(t)); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "|") : strConcat(__recv, "|"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fnTypeSig(nodeGetData2(t))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fnTypeSig(nodeGetData2(t))) : strConcat(__recv, fnTypeSig(nodeGetData2(t))); })();
}
  if ((k === NK_FUNCTION_TYPE)) {
  let parts = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.parts = parts;
  let ps = nodeGetData1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.ps = ps;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len2 = (() => { const __recv = ps; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len2 = __len2;
  while ((i < __len2)) {
  (() => { const __recv = parts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(fnTypeSig((() => { const __recv = ps; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, fnTypeSig((() => { const __recv = ps; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())) : vecPush(__recv, fnTypeSig((() => { const __recv = ps; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = parts; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ",") : vecJoin(__recv, ","); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = parts; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ",") : vecJoin(__recv, ","); })()) : strConcat(__recv, (() => { const __recv = parts; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ",") : vecJoin(__recv, ","); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")=>"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")=>") : strConcat(__recv, ")=>"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fnTypeSig(nodeGetData2(t))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fnTypeSig(nodeGetData2(t))) : strConcat(__recv, fnTypeSig(nodeGetData2(t))); })();
}
  return "Unknown";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fnTypeSig = fnTypeSig;

const __tuff_outer_for_fnDeclSig = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fnDeclSig(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_fnDeclSig };
  let gens = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.gens = gens;
  let params = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let ret = nodeGetData4(n); if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
  let pparts = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.pparts = pparts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len1 = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len1 = __len1;
  while ((i < __len1)) {
  let p = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let pname = getInternedStr((() => { const __recv = p; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = fnTypeSig((() => { const __recv = p; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  (() => { const __recv = pparts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = pname; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ptype) : strConcat(__recv, ptype); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = pname; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ptype) : strConcat(__recv, ptype); })()) : vecPush(__recv, (() => { const __recv = (() => { const __recv = pname; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ptype) : strConcat(__recv, ptype); })()); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let gcountLen = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gcountLen = gcountLen;
  let gcount = intToString(gcountLen); if (typeof __tuff_this !== 'undefined') __tuff_this.gcount = gcount;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "g="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(gcount); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, gcount) : strConcat(__recv, gcount); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";p="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";p=") : strConcat(__recv, ";p="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = pparts; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ",") : vecJoin(__recv, ","); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = pparts; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ",") : vecJoin(__recv, ","); })()) : strConcat(__recv, (() => { const __recv = pparts; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ",") : vecJoin(__recv, ","); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";r="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";r=") : strConcat(__recv, ";r="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fnTypeSig(ret)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fnTypeSig(ret)) : strConcat(__recv, fnTypeSig(ret)); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fnDeclSig = fnDeclSig;

const __tuff_outer_for_rslvUtilsValidateExpectActualPairs = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslvUtilsValidateExpectActualPairs(body) {
  let __tuff_this = { body: body, this: __tuff_outer_for_rslvUtilsValidateExpectActualPairs };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = body; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if (((kind === NK_EXPECT_FN_DECL) || (kind === NK_ACTUAL_FN_DECL))) {
  let name = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let expectCount = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.expectCount = expectCount;
  let actualCount = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.actualCount = actualCount;
  let expectNode = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.expectNode = expectNode;
  let actualNode = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.actualNode = actualNode;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < len)) {
  let cand = (() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cand = cand;
  let ck = nodeKind(cand); if (typeof __tuff_this !== 'undefined') __tuff_this.ck = ck;
  if ((((ck === NK_EXPECT_FN_DECL) || (ck === NK_ACTUAL_FN_DECL)) && (() => { const __recv = getInternedStr(nodeGetData1(cand)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, name) : strEq(__recv, name); })())) {
  if ((ck === NK_EXPECT_FN_DECL)) {
  expectCount = (expectCount + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.expectCount = expectCount;
  expectNode = cand; if (typeof __tuff_this !== 'undefined') __tuff_this.expectNode = expectNode;
} else {
  actualCount = (actualCount + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.actualCount = actualCount;
  actualNode = cand; if (typeof __tuff_this !== 'undefined') __tuff_this.actualNode = actualNode;
}
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  if (((expectCount !== 1) || (actualCount !== 1))) {
  rslvUtilsPanicNode(stmt, "E_EXPECT_ACTUAL_PAIRING", (() => { const __recv = (() => { const __recv = "expect/actual pairing requires exactly one expect and one actual for '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "Platform declarations require exactly one expect and one actual declaration for each symbol.", "Declare exactly one 'expect fn' and one matching 'actual fn' for each platform symbol.");
}
  if ((!(() => { const __recv = fnDeclSig(expectNode); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(fnDeclSig(actualNode)); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, fnDeclSig(actualNode)) : strEq(__recv, fnDeclSig(actualNode)); })())) {
  rslvUtilsPanicNode(stmt, "E_EXPECT_ACTUAL_SIGNATURE_MISMATCH", (() => { const __recv = (() => { const __recv = "expect/actual signatures do not match for '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "An expect declaration and its actual implementation have different signatures.", "Make generic params, parameter list, and return type identical between expect and actual declarations.");
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslvUtilsValidateExpectActualPairs = rslvUtilsValidateExpectActualPairs;

const __tuff_outer_for_rslvUtilsScopeDefine = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslvUtilsScopeDefine(scopes, depth, name, errNode) {
  let __tuff_this = { scopes: scopes, depth: depth, name: name, errNode: errNode, this: __tuff_outer_for_rslvUtilsScopeDefine };
  let scope = (() => { const __recv = scopes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(depth); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, depth) : vecGet(__recv, depth); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.scope = scope;
  if ((() => { const __recv = scope; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })()) {
  rslvUtilsPanicNode(errNode, "E_RESOLVE_SHADOWING", (() => { const __recv = "Variable shadowing/redeclaration is not allowed: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(), "A name was declared multiple times in the same lexical scope.", "Rename one of the bindings or move it to a different scope.");
}
  (() => { const __recv = scope; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, name) : setAdd(__recv, name); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslvUtilsScopeDefine = rslvUtilsScopeDefine;

const __tuff_outer_for_rslvUtilsScopeHas = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslvUtilsScopeHas(scopes, depth, name) {
  let __tuff_this = { scopes: scopes, depth: depth, name: name, this: __tuff_outer_for_rslvUtilsScopeHas };
  let i = depth; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i >= 0)) {
  if ((() => { const __recv = (() => { const __recv = scopes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })()) {
  return true;
}
  i = (i - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslvUtilsScopeHas = rslvUtilsScopeHas;

const __tuff_outer_for_rslvUtilsIsHostBuiltinName = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslvUtilsIsHostBuiltinName(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_rslvUtilsIsHostBuiltinName };
  return (() => { const __recv = HOST_BUILTINS; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslvUtilsIsHostBuiltinName = rslvUtilsIsHostBuiltinName;

const __tuff_outer_for_lifetimeScopeHas = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lifetimeScopeHas(resolveLifetimeScopes, name) {
  let __tuff_this = { resolveLifetimeScopes: resolveLifetimeScopes, name: name, this: __tuff_outer_for_lifetimeScopeHas };
  let len = (() => { const __recv = resolveLifetimeScopes; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  if ((() => { const __recv = (() => { const __recv = resolveLifetimeScopes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })()) {
  return true;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lifetimeScopeHas = lifetimeScopeHas;

const __tuff_outer_for_rslvUtilsResolveTypeLifetimes = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslvUtilsResolveTypeLifetimes(t, resolveLifetimeScopes, errNode) {
  let __tuff_this = { t: t, resolveLifetimeScopes: resolveLifetimeScopes, errNode: errNode, this: __tuff_outer_for_rslvUtilsResolveTypeLifetimes };
  if ((t === 0)) {
  return 0;
}
  let k = nodeKind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_POINTER_TYPE)) {
  let lifeIdx = nodeGetData4(t); if (typeof __tuff_this !== 'undefined') __tuff_this.lifeIdx = lifeIdx;
  if ((lifeIdx !== 0)) {
  let lname = getInternedStr(lifeIdx); if (typeof __tuff_this !== 'undefined') __tuff_this.lname = lname;
  if ((!lifetimeScopeHas(resolveLifetimeScopes, lname))) {
  rslvUtilsPanicNode(errNode, "E_RESOLVE_UNDEFINED_LIFETIME", (() => { const __recv = (() => { const __recv = "Undefined lifetime '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lname) : strConcat(__recv, lname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "A pointer type annotation references a lifetime name that is not declared in any active lifetime block.", "Declare the lifetime in an enclosing `lifetime ... { ... }` block before using it in pointer types.");
}
}
  rslvUtilsResolveTypeLifetimes(nodeGetData2(t), resolveLifetimeScopes, errNode);
  return 0;
}
  if ((k === NK_ARRAY_TYPE)) {
  rslvUtilsResolveTypeLifetimes(nodeGetData1(t), resolveLifetimeScopes, errNode);
  return 0;
}
  if ((k === NK_REFINEMENT_TYPE)) {
  rslvUtilsResolveTypeLifetimes(nodeGetData1(t), resolveLifetimeScopes, errNode);
  return 0;
}
  if ((k === NK_UNION_TYPE)) {
  rslvUtilsResolveTypeLifetimes(nodeGetData1(t), resolveLifetimeScopes, errNode);
  rslvUtilsResolveTypeLifetimes(nodeGetData2(t), resolveLifetimeScopes, errNode);
  return 0;
}
  if ((k === NK_TUPLE_TYPE)) {
  let members = nodeGetData1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.members = members;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = members; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  rslvUtilsResolveTypeLifetimes((() => { const __recv = members; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), resolveLifetimeScopes, errNode);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((k === NK_FUNCTION_TYPE)) {
  let ps = nodeGetData1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.ps = ps;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len = (() => { const __recv = ps; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len = __len;
  while ((i < __len)) {
  rslvUtilsResolveTypeLifetimes((() => { const __recv = ps; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), resolveLifetimeScopes, errNode);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  rslvUtilsResolveTypeLifetimes(nodeGetData2(t), resolveLifetimeScopes, errNode);
  return 0;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslvUtilsResolveTypeLifetimes = rslvUtilsResolveTypeLifetimes;

const __tuff_outer_for_selfhostResolverUtilsMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostResolverUtilsMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostResolverUtilsMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostResolverUtilsMarker = selfhostResolverUtilsMarker;

let rslvCurrentNode = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.rslvCurrentNode = rslvCurrentNode;

let scopePool = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.scopePool = scopePool;

const __tuff_outer_for_scopePoolGet = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function scopePoolGet() {
  let __tuff_this = { this: __tuff_outer_for_scopePoolGet };
  return ((((() => { const __recv = scopePool; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > 0)) ? (() => {
    return (() => { const __recv = scopePool; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })();
  })() : (() => {
    return setNew();
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.scopePoolGet = scopePoolGet;

const __tuff_outer_for_scopePoolReturn = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function scopePoolReturn(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_scopePoolReturn };
  (() => { const __recv = s; const __prop = __recv?.["setClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.setClear; return __dyn ? __dyn(__recv.ref) : setClear(__recv); })();
  return (() => { const __recv = scopePool; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(s); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, s) : vecPush(__recv, s); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.scopePoolReturn = scopePoolReturn;

const __tuff_outer_for_rslvPanicLoc = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function rslvPanicLoc(code, msg, reason, fix) {
  let __tuff_this = { code: code, msg: msg, reason: reason, fix: fix, this: __tuff_outer_for_rslvPanicLoc };
  return ((typeof Err === "function") ? Err({error: ((typeof ResolveError === "function") ? ResolveError({code: code, message: msg, reason: reason, fix: fix, line: nodeGetLine(rslvCurrentNode), col: nodeGetCol(rslvCurrentNode)}) : ({ __tag: "ResolveError", code: code, message: msg, reason: reason, fix: fix, line: nodeGetLine(rslvCurrentNode), col: nodeGetCol(rslvCurrentNode) }))}) : ({ __tag: "Err", error: ((typeof ResolveError === "function") ? ResolveError({code: code, message: msg, reason: reason, fix: fix, line: nodeGetLine(rslvCurrentNode), col: nodeGetCol(rslvCurrentNode)}) : ({ __tag: "ResolveError", code: code, message: msg, reason: reason, fix: fix, line: nodeGetLine(rslvCurrentNode), col: nodeGetCol(rslvCurrentNode) })) }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.rslvPanicLoc = rslvPanicLoc;

let resolveLifetimeScopes = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveLifetimeScopes = resolveLifetimeScopes;

let resolveGlobalDeclNodes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveGlobalDeclNodes = resolveGlobalDeclNodes;

let resolveGlobalNamesList = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveGlobalNamesList = resolveGlobalNamesList;

let resolveStmtTotalCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtTotalCalls = resolveStmtTotalCalls;

let resolveStmtTotalMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtTotalMs = resolveStmtTotalMs;

let resolveStmtBlockCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtBlockCalls = resolveStmtBlockCalls;

let resolveStmtBlockMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtBlockMs = resolveStmtBlockMs;

let resolveStmtFnCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFnCalls = resolveStmtFnCalls;

let resolveStmtFnMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFnMs = resolveStmtFnMs;

let resolveStmtLetImportCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLetImportCalls = resolveStmtLetImportCalls;

let resolveStmtLetImportMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLetImportMs = resolveStmtLetImportMs;

let resolveStmtFlowCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFlowCalls = resolveStmtFlowCalls;

let resolveStmtFlowMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFlowMs = resolveStmtFlowMs;

let resolveStmtLifetimeIntoCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLifetimeIntoCalls = resolveStmtLifetimeIntoCalls;

let resolveStmtLifetimeIntoMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLifetimeIntoMs = resolveStmtLifetimeIntoMs;

let resolveStmtDeclSkipCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtDeclSkipCalls = resolveStmtDeclSkipCalls;

let resolveStmtDeclSkipMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtDeclSkipMs = resolveStmtDeclSkipMs;

let resolveStmtFallbackExprCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFallbackExprCalls = resolveStmtFallbackExprCalls;

let resolveStmtFallbackExprMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFallbackExprMs = resolveStmtFallbackExprMs;

let resolveBlockPredeclareMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveBlockPredeclareMs = resolveBlockPredeclareMs;

let resolveBlockBodyMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveBlockBodyMs = resolveBlockBodyMs;

let resolveExprIdentifierCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIdentifierCalls = resolveExprIdentifierCalls;

let resolveExprBinaryCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprBinaryCalls = resolveExprBinaryCalls;

let resolveExprUnaryOrUnwrapCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprUnaryOrUnwrapCalls = resolveExprUnaryOrUnwrapCalls;

let resolveExprCallCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprCallCalls = resolveExprCallCalls;

let resolveExprMemberCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprMemberCalls = resolveExprMemberCalls;

let resolveExprIndexCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIndexCalls = resolveExprIndexCalls;

let resolveExprStructInitCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprStructInitCalls = resolveExprStructInitCalls;

let resolveExprTupleCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprTupleCalls = resolveExprTupleCalls;

let resolveExprIfCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIfCalls = resolveExprIfCalls;

let resolveExprMatchCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprMatchCalls = resolveExprMatchCalls;

let resolveExprIsCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIsCalls = resolveExprIsCalls;

let resolveExprLambdaCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprLambdaCalls = resolveExprLambdaCalls;

let resolveExprFnExprCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprFnExprCalls = resolveExprFnExprCalls;

let resolveExprOtherCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprOtherCalls = resolveExprOtherCalls;

let resolveExprOtherKindCounts = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprOtherKindCounts = resolveExprOtherKindCounts;

let resolveExprOtherKindKeys = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprOtherKindKeys = resolveExprOtherKindKeys;

const __tuff_outer_for_resolveLogStep = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveLogStep(name, stepStart, totalStart) {
  let __tuff_this = { name: name, stepStart: stepStart, totalStart: totalStart, this: __tuff_outer_for_resolveLogStep };
  let now = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.now = now;
  let stepDt = (now - stepStart); if (typeof __tuff_this !== 'undefined') __tuff_this.stepDt = stepDt;
  let totalDt = (now - totalStart); if (typeof __tuff_this !== 'undefined') __tuff_this.totalDt = totalDt;
  printError((() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "[selfhost][resolve] "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" dt="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " dt=") : strConcat(__recv, " dt="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(stepDt)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(stepDt)) : strConcat(__recv, intToString(stepDt)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("ms total="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "ms total=") : strConcat(__recv, "ms total="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(totalDt)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(totalDt)) : strConcat(__recv, intToString(totalDt)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("ms\n"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "ms\n") : strConcat(__recv, "ms\n"); })());
  return now;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveLogStep = resolveLogStep;

const __tuff_outer_for_resolveLogBucket = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveLogBucket(name, calls, ms) {
  let __tuff_this = { name: name, calls: calls, ms: ms, this: __tuff_outer_for_resolveLogBucket };
  if ((calls <= 0)) {
  return 0;
}
  printError((() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "[selfhost][resolve][bucket] "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" calls="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " calls=") : strConcat(__recv, " calls="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(calls)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(calls)) : strConcat(__recv, intToString(calls)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" ms="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ms=") : strConcat(__recv, " ms="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(ms)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(ms)) : strConcat(__recv, intToString(ms)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\n") : strConcat(__recv, "\n"); })());
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveLogBucket = resolveLogBucket;

const __tuff_outer_for_resolveLogCount = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveLogCount(name, count) {
  let __tuff_this = { name: name, count: count, this: __tuff_outer_for_resolveLogCount };
  if ((count <= 0)) {
  return 0;
}
  printError((() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "[selfhost][resolve][count] "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" calls="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " calls=") : strConcat(__recv, " calls="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(count)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(count)) : strConcat(__recv, intToString(count)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\n") : strConcat(__recv, "\n"); })());
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveLogCount = resolveLogCount;

const __tuff_outer_for_resolveExprIdentifier = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveExprIdentifier(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolveExprIdentifier };
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((((!rslvUtilsScopeHas(scopes, depth, name)) && (!(() => { const __recv = globals; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })())) && (!rslvUtilsIsHostBuiltinName(name)))) {
  let suggestion = rslvUtilsFindDidYouMean(name, resolveGlobalNamesList); if (typeof __tuff_this !== 'undefined') __tuff_this.suggestion = suggestion;
  let fixMsg = "Declare the identifier before use or import it from the correct module."; if (typeof __tuff_this !== 'undefined') __tuff_this.fixMsg = fixMsg;
  if ((!(() => { const __recv = suggestion; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  fixMsg = (() => { const __recv = (() => { const __recv = "Did you mean '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(suggestion); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, suggestion) : strConcat(__recv, suggestion); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'? Declare or import it from the correct module."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'? Declare or import it from the correct module.") : strConcat(__recv, "'? Declare or import it from the correct module."); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fixMsg = fixMsg;
}
  return rslvPanicLoc("E_RESOLVE_UNKNOWN_IDENTIFIER", (() => { const __recv = "Unknown identifier: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(), "The identifier is not declared in local scope, global declarations, or imports.", fixMsg);
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIdentifier = resolveExprIdentifier;

const __tuff_outer_for_resolveExprCall = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveExprCall(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolveExprCall };
  let callee = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  if (((nodeKind(callee) === NK_IDENTIFIER) && (() => { const __recv = getInternedStr(nodeGetData1(callee)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("drop"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "drop") : strEq(__recv, "drop"); })())) {
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() !== 1)) {
  return rslvPanicLoc("E_RESOLVE_UNKNOWN_IDENTIFIER", "drop expects exactly one argument", "Built-in drop requires exactly one receiver value.", "Use drop(value) or value.drop() with exactly one receiver value.");
}
  resolveExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(), globals, scopes, depth);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((((nodeKind(callee) === NK_IDENTIFIER) && (() => { const __recv = getInternedStr(nodeGetData1(callee)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "into") : strEq(__recv, "into"); })()) && (nodeGetData3(n) === 1))) {
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() < 1)) {
  return rslvPanicLoc("E_RESOLVE_UNKNOWN_IDENTIFIER", "into conversion requires a receiver", "Method-sugar into conversion requires a source value as receiver.", "Use value.into<Contract>(...) with a receiver value.");
}
  let typeArgs = nodeGetData4(n); if (typeof __tuff_this !== 'undefined') __tuff_this.typeArgs = typeArgs;
  let contractName = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.contractName = contractName;
  if ((((() => { const __recv = typeArgs; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 1) && (nodeKind((() => { const __recv = typeArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()) === NK_NAMED_TYPE))) {
  contractName = getInternedStr(nodeGetData1((() => { const __recv = typeArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })())); if (typeof __tuff_this !== 'undefined') __tuff_this.contractName = contractName;
}
  let contractDeclared = false; if (typeof __tuff_this !== 'undefined') __tuff_this.contractDeclared = contractDeclared;
  if ((!(() => { const __recv = contractName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  contractDeclared = (() => { const __recv = globals; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(contractName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, contractName) : setHas(__recv, contractName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.contractDeclared = contractDeclared;
}
  if (((() => { const __recv = contractName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })() || (!contractDeclared))) {
  let contractLabel = contractName; if (typeof __tuff_this !== 'undefined') __tuff_this.contractLabel = contractLabel;
  if ((() => { const __recv = contractLabel; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) {
  contractLabel = "<missing>"; if (typeof __tuff_this !== 'undefined') __tuff_this.contractLabel = contractLabel;
}
  return rslvPanicLoc("E_RESOLVE_UNKNOWN_IDENTIFIER", (() => { const __recv = (() => { const __recv = "Unknown contract '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(contractLabel); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, contractLabel) : strConcat(__recv, contractLabel); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "An into conversion referenced a contract that is not declared in scope.", "Use value.into<Contract>(...) with a declared contract name.");
}
  resolveExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(), globals, scopes, depth);
  let i = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  resolveExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), globals, scopes, depth);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((nodeGetData3(n) !== 1)) {
  resolveExpr(nodeGetData1(n), globals, scopes, depth);
}
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  resolveExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), globals, scopes, depth);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprCall = resolveExprCall;

const __tuff_outer_for_resolveExprMatch = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveExprMatch(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolveExprMatch };
  resolveExpr(nodeGetData1(n), globals, scopes, depth);
  let cases = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let caseNode = (() => { const __recv = cases; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.caseNode = caseNode;
  let pat = (() => { const __recv = caseNode; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  let body = (() => { const __recv = caseNode; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let nextDepth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nextDepth = nextDepth;
  (() => { const __recv = scopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(scopePoolGet()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, scopePoolGet()) : vecPush(__recv, scopePoolGet()); })();
  if ((nodeKind(pat) === NK_STRUCT_PAT)) {
  let fields = nodeGetData2(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let fLen = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fLen = fLen;
  while ((j < fLen)) {
  rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr((() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()), pat);
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
} else { if ((nodeKind(pat) === NK_NAME_PAT)) {
  let patName = getInternedStr(nodeGetData1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.patName = patName;
  if ((!(() => { const __recv = globals; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(patName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, patName) : setHas(__recv, patName); })())) {
  rslvUtilsScopeDefine(scopes, nextDepth, patName, pat);
}
} }
  resolveStmt(body, globals, scopes, nextDepth);
  scopePoolReturn((() => { const __recv = scopes; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprMatch = resolveExprMatch;

const __tuff_outer_for_resolveExprLambda = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveExprLambda(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolveExprLambda };
  let nextDepth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nextDepth = nextDepth;
  (() => { const __recv = scopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(scopePoolGet()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, scopePoolGet()) : vecPush(__recv, scopePoolGet()); })();
  let params = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let param = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr((() => { const __recv = param; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()), n);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  resolveStmt(nodeGetData2(n), globals, scopes, nextDepth);
  scopePoolReturn((() => { const __recv = scopes; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })());
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprLambda = resolveExprLambda;

const __tuff_outer_for_resolveExprFnExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveExprFnExpr(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolveExprFnExpr };
  let nextDepth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nextDepth = nextDepth;
  (() => { const __recv = scopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(scopePoolGet()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, scopePoolGet()) : vecPush(__recv, scopePoolGet()); })();
  let fnameIdx = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fnameIdx = fnameIdx;
  if ((fnameIdx !== 0)) {
  rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr(fnameIdx), n);
}
  let params = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let param = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr((() => { const __recv = param; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()), n);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  resolveStmt(nodeGetData5(n), globals, scopes, nextDepth);
  scopePoolReturn((() => { const __recv = scopes; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })());
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprFnExpr = resolveExprFnExpr;

const __tuff_outer_for_resolveStmtBlock = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveStmtBlock(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolveStmtBlock };
  let nextDepth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nextDepth = nextDepth;
  (() => { const __recv = scopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(scopePoolGet()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, scopePoolGet()) : vecPush(__recv, scopePoolGet()); })();
  let stmts = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let predeclareT0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.predeclareT0 = predeclareT0;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let stmtKind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.stmtKind = stmtKind;
  if ((((stmtKind === NK_FN_DECL) || (stmtKind === NK_CLASS_FN_DECL)) || (stmtKind === NK_ACTUAL_FN_DECL))) {
  rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr(nodeGetData1(stmt)), stmt);
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  resolveBlockPredeclareMs = (resolveBlockPredeclareMs + (perfNow() - predeclareT0)); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveBlockPredeclareMs = resolveBlockPredeclareMs;
  let bodyT0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.bodyT0 = bodyT0;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  resolveStmt((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), globals, scopes, nextDepth);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  resolveBlockBodyMs = (resolveBlockBodyMs + (perfNow() - bodyT0)); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveBlockBodyMs = resolveBlockBodyMs;
  scopePoolReturn((() => { const __recv = scopes; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })());
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtBlock = resolveStmtBlock;

const __tuff_outer_for_resolveStmtFnDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveStmtFnDecl(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolveStmtFnDecl };
  let nextDepth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nextDepth = nextDepth;
  (() => { const __recv = scopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(scopePoolGet()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, scopePoolGet()) : vecPush(__recv, scopePoolGet()); })();
  let params = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let param = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr((() => { const __recv = param; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()), n);
  rslvUtilsResolveTypeLifetimes((() => { const __recv = param; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), resolveLifetimeScopes, n);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  rslvUtilsResolveTypeLifetimes(nodeGetData4(n), resolveLifetimeScopes, n);
  resolveStmt(nodeGetData5(n), globals, scopes, nextDepth);
  scopePoolReturn((() => { const __recv = scopes; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })());
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFnDecl = resolveStmtFnDecl;

const __tuff_outer_for_resolveStmtLetOrImport = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveStmtLetOrImport(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolveStmtLetOrImport };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LET_DECL)) {
  if ((nodeGetData2(n) !== 0)) {
  rslvUtilsResolveTypeLifetimes(nodeGetData2(n), resolveLifetimeScopes, n);
}
  resolveExpr(nodeGetData3(n), globals, scopes, depth);
  rslvUtilsScopeDefine(scopes, depth, getInternedStr(nodeGetData1(n)), n);
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  if ((kind === NK_IMPORT_DECL)) {
  let names = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = names; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  rslvUtilsScopeDefine(scopes, depth, getInternedStr((() => { const __recv = names; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()), n);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLetOrImport = resolveStmtLetOrImport;

const __tuff_outer_for_resolveStmtFlow = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveStmtFlow(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolveStmtFlow };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_EXPR_STMT)) {
  resolveExpr(nodeGetData1(n), globals, scopes, depth);
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  if ((kind === NK_ASSIGN_STMT)) {
  resolveExpr(nodeGetData1(n), globals, scopes, depth);
  resolveExpr(nodeGetData2(n), globals, scopes, depth);
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  if ((kind === NK_RETURN_STMT)) {
  resolveExpr(nodeGetData1(n), globals, scopes, depth);
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  if ((kind === NK_IF_STMT)) {
  resolveExpr(nodeGetData1(n), globals, scopes, depth);
  resolveStmt(nodeGetData2(n), globals, scopes, depth);
  if ((nodeGetData3(n) !== 0)) {
  resolveStmt(nodeGetData3(n), globals, scopes, depth);
}
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  if ((kind === NK_FOR_STMT)) {
  let nextDepth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nextDepth = nextDepth;
  (() => { const __recv = scopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(scopePoolGet()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, scopePoolGet()) : vecPush(__recv, scopePoolGet()); })();
  rslvUtilsScopeDefine(scopes, nextDepth, getInternedStr(nodeGetData1(n)), n);
  resolveExpr(nodeGetData2(n), globals, scopes, nextDepth);
  resolveExpr(nodeGetData3(n), globals, scopes, nextDepth);
  resolveStmt(nodeGetData4(n), globals, scopes, nextDepth);
  scopePoolReturn((() => { const __recv = scopes; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })());
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  if ((kind === NK_WHILE_STMT)) {
  resolveExpr(nodeGetData1(n), globals, scopes, depth);
  resolveStmt(nodeGetData2(n), globals, scopes, depth);
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  if ((kind === NK_LOOP_STMT)) {
  resolveStmt(nodeGetData1(n), globals, scopes, depth);
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFlow = resolveStmtFlow;

const __tuff_outer_for_resolveStmtLifetimeOrInto = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveStmtLifetimeOrInto(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolveStmtLifetimeOrInto };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LIFETIME_STMT)) {
  let nextDepth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nextDepth = nextDepth;
  (() => { const __recv = scopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(scopePoolGet()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, scopePoolGet()) : vecPush(__recv, scopePoolGet()); })();
  let lifetimeNames = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.lifetimeNames = lifetimeNames;
  let lifetimeScope = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.lifetimeScope = lifetimeScope;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = lifetimeNames; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let lname = getInternedStr((() => { const __recv = lifetimeNames; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.lname = lname;
  if ((() => { const __recv = lifetimeScope; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(lname); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, lname) : setHas(__recv, lname); })()) {
  return rslvPanicLoc("E_RESOLVE_DUPLICATE_LIFETIME", (() => { const __recv = (() => { const __recv = "Duplicate lifetime name '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lname) : strConcat(__recv, lname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' in lifetime block"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' in lifetime block") : strConcat(__recv, "' in lifetime block"); })(), "A lifetime block contains duplicate lifetime names.", "Use unique lifetime names within a lifetime declaration block.");
}
  (() => { const __recv = lifetimeScope; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(lname); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, lname) : setAdd(__recv, lname); })();
  rslvUtilsScopeDefine(scopes, nextDepth, lname, n);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  (() => { const __recv = resolveLifetimeScopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(lifetimeScope); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, lifetimeScope) : vecPush(__recv, lifetimeScope); })();
  resolveStmt(nodeGetData2(n), globals, scopes, nextDepth);
  (() => { const __recv = resolveLifetimeScopes; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })();
  scopePoolReturn((() => { const __recv = scopes; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })());
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  if ((kind === NK_INTO_STMT)) {
  let cname = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
  if ((!(() => { const __recv = globals; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, cname) : setHas(__recv, cname); })())) {
  return rslvPanicLoc("E_RESOLVE_UNKNOWN_IDENTIFIER", (() => { const __recv = "Unknown contract: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cname) : strConcat(__recv, cname); })(), "An into statement referenced a contract that is not declared in scope.", "Declare the contract before using 'into'.");
}
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLifetimeOrInto = resolveStmtLifetimeOrInto;

const __tuff_outer_for_resolveExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveExpr(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolveExpr };
  if ((n === 0)) {
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  rslvCurrentNode = n; if (typeof __tuff_this !== 'undefined') __tuff_this.rslvCurrentNode = rslvCurrentNode;
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_IDENTIFIER)) {
  resolveExprIdentifierCalls = (resolveExprIdentifierCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIdentifierCalls = resolveExprIdentifierCalls;
  return resolveExprIdentifier(n, globals, scopes, depth);
}
  if ((kind === NK_BINARY_EXPR)) {
  resolveExprBinaryCalls = (resolveExprBinaryCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprBinaryCalls = resolveExprBinaryCalls;
  resolveExpr(nodeGetData2(n), globals, scopes, depth);
  resolveExpr(nodeGetData3(n), globals, scopes, depth);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if (((kind === NK_UNARY_EXPR) || (kind === NK_UNWRAP_EXPR))) {
  resolveExprUnaryOrUnwrapCalls = (resolveExprUnaryOrUnwrapCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprUnaryOrUnwrapCalls = resolveExprUnaryOrUnwrapCalls;
  resolveExpr(nodeGetData2(n), globals, scopes, depth);
  if ((kind === NK_UNWRAP_EXPR)) {
  resolveExpr(nodeGetData1(n), globals, scopes, depth);
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_CALL_EXPR)) {
  resolveExprCallCalls = (resolveExprCallCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprCallCalls = resolveExprCallCalls;
  return resolveExprCall(n, globals, scopes, depth);
}
  if ((kind === NK_MEMBER_EXPR)) {
  resolveExprMemberCalls = (resolveExprMemberCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprMemberCalls = resolveExprMemberCalls;
  resolveExpr(nodeGetData1(n), globals, scopes, depth);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_INDEX_EXPR)) {
  resolveExprIndexCalls = (resolveExprIndexCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIndexCalls = resolveExprIndexCalls;
  resolveExpr(nodeGetData1(n), globals, scopes, depth);
  resolveExpr(nodeGetData2(n), globals, scopes, depth);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_STRUCT_INIT)) {
  resolveExprStructInitCalls = (resolveExprStructInitCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprStructInitCalls = resolveExprStructInitCalls;
  let typeName = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.typeName = typeName;
  if ((!(() => { const __recv = globals; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(typeName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, typeName) : setHas(__recv, typeName); })())) {
  return rslvPanicLoc("E_RESOLVE_UNKNOWN_STRUCT", (() => { const __recv = "Unknown struct/type in initializer: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(typeName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, typeName) : strConcat(__recv, typeName); })(), "A struct initializer referenced a type that is not declared in the merged module scope.", "Declare the struct/type first or import the module that defines it.");
}
  let fields = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  resolveExpr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), globals, scopes, depth);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_TUPLE_EXPR)) {
  resolveExprTupleCalls = (resolveExprTupleCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprTupleCalls = resolveExprTupleCalls;
  let items = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = items; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  resolveExpr((() => { const __recv = items; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), globals, scopes, depth);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_IF_EXPR)) {
  resolveExprIfCalls = (resolveExprIfCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIfCalls = resolveExprIfCalls;
  resolveExpr(nodeGetData1(n), globals, scopes, depth);
  resolveStmt(nodeGetData2(n), globals, scopes, depth);
  if ((nodeGetData3(n) !== 0)) {
  let kindKey = intToString(kind); if (typeof __tuff_this !== 'undefined') __tuff_this.kindKey = kindKey;
  if ((!(() => { const __recv = resolveExprOtherKindCounts; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(kindKey); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, kindKey) : mapHas(__recv, kindKey); })())) {
  (() => { const __recv = resolveExprOtherKindCounts; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(kindKey, 0); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, kindKey, 0) : mapSet(__recv, kindKey, 0); })();
  (() => { const __recv = resolveExprOtherKindKeys; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(kindKey); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, kindKey) : vecPush(__recv, kindKey); })();
}
  (() => { const __recv = resolveExprOtherKindCounts; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(kindKey, ((() => { const __recv = resolveExprOtherKindCounts; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(kindKey); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, kindKey) : mapGet(__recv, kindKey); })() + 1)); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, kindKey, ((() => { const __recv = resolveExprOtherKindCounts; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(kindKey); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, kindKey) : mapGet(__recv, kindKey); })() + 1)) : mapSet(__recv, kindKey, ((() => { const __recv = resolveExprOtherKindCounts; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(kindKey); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, kindKey) : mapGet(__recv, kindKey); })() + 1)); })();
  resolveStmt(nodeGetData3(n), globals, scopes, depth);
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_MATCH_EXPR)) {
  resolveExprMatchCalls = (resolveExprMatchCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprMatchCalls = resolveExprMatchCalls;
  return resolveExprMatch(n, globals, scopes, depth);
}
  if ((kind === NK_IS_EXPR)) {
  resolveExprIsCalls = (resolveExprIsCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIsCalls = resolveExprIsCalls;
  resolveExpr(nodeGetData1(n), globals, scopes, depth);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_LAMBDA_EXPR)) {
  resolveExprLambdaCalls = (resolveExprLambdaCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprLambdaCalls = resolveExprLambdaCalls;
  return resolveExprLambda(n, globals, scopes, depth);
}
  if ((kind === NK_FN_EXPR)) {
  resolveExprFnExprCalls = (resolveExprFnExprCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprFnExprCalls = resolveExprFnExprCalls;
  return resolveExprFnExpr(n, globals, scopes, depth);
}
  resolveExprOtherCalls = (resolveExprOtherCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprOtherCalls = resolveExprOtherCalls;
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExpr = resolveExpr;

const __tuff_outer_for_resolveStmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveStmt(n, globals, scopes, depth) {
  let __tuff_this = { n: n, globals: globals, scopes: scopes, depth: depth, this: __tuff_outer_for_resolveStmt };
  if ((n === 0)) {
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  let stmtT0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmtT0 = stmtT0;
  resolveStmtTotalCalls = (resolveStmtTotalCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtTotalCalls = resolveStmtTotalCalls;
  rslvCurrentNode = n; if (typeof __tuff_this !== 'undefined') __tuff_this.rslvCurrentNode = rslvCurrentNode;
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  let resultValue = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resultValue = resultValue;
  let catName = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.catName = catName;
  if ((kind === NK_BLOCK)) {
  resultValue = resolveStmtBlock(n, globals, scopes, depth); if (typeof __tuff_this !== 'undefined') __tuff_this.resultValue = resultValue;
  catName = "block"; if (typeof __tuff_this !== 'undefined') __tuff_this.catName = catName;
} else { if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  resultValue = resolveStmtFnDecl(n, globals, scopes, depth); if (typeof __tuff_this !== 'undefined') __tuff_this.resultValue = resultValue;
  catName = "fn"; if (typeof __tuff_this !== 'undefined') __tuff_this.catName = catName;
} else { if ((resolveStmtLetOrImport(n, globals, scopes, depth) === 1)) {
  catName = "let"; if (typeof __tuff_this !== 'undefined') __tuff_this.catName = catName;
} else { if ((resolveStmtFlow(n, globals, scopes, depth) === 1)) {
  catName = "flow"; if (typeof __tuff_this !== 'undefined') __tuff_this.catName = catName;
} else { if ((resolveStmtLifetimeOrInto(n, globals, scopes, depth) === 1)) {
  catName = "lifetime"; if (typeof __tuff_this !== 'undefined') __tuff_this.catName = catName;
} else { if (((((((((((kind === NK_TYPE_ALIAS) || (kind === NK_DEP_TYPE_ALIAS)) || (kind === NK_STRUCT_DECL)) || (kind === NK_ENUM_DECL)) || (kind === NK_EXTERN_LET_DECL)) || (kind === NK_EXTERN_TYPE_DECL)) || (kind === NK_EXTERN_IMPORT_DECL)) || (kind === NK_OBJECT_DECL)) || (kind === NK_CONTRACT_DECL)) || (kind === NK_EXPECT_FN_DECL))) {
  catName = "decl"; if (typeof __tuff_this !== 'undefined') __tuff_this.catName = catName;
} else {
  resolveExpr(n, globals, scopes, depth);
  catName = "expr"; if (typeof __tuff_this !== 'undefined') __tuff_this.catName = catName;
} } } } } }
  let dt = (perfNow() - stmtT0); if (typeof __tuff_this !== 'undefined') __tuff_this.dt = dt;
  resolveStmtTotalMs = (resolveStmtTotalMs + dt); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtTotalMs = resolveStmtTotalMs;
  if ((() => { const __recv = catName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("block"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "block") : strEq(__recv, "block"); })()) {
  resolveStmtBlockCalls = (resolveStmtBlockCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtBlockCalls = resolveStmtBlockCalls;
  resolveStmtBlockMs = (resolveStmtBlockMs + dt); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtBlockMs = resolveStmtBlockMs;
} else { if ((() => { const __recv = catName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("fn"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "fn") : strEq(__recv, "fn"); })()) {
  resolveStmtFnCalls = (resolveStmtFnCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFnCalls = resolveStmtFnCalls;
  resolveStmtFnMs = (resolveStmtFnMs + dt); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFnMs = resolveStmtFnMs;
} else { if ((() => { const __recv = catName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("let"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "let") : strEq(__recv, "let"); })()) {
  resolveStmtLetImportCalls = (resolveStmtLetImportCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLetImportCalls = resolveStmtLetImportCalls;
  resolveStmtLetImportMs = (resolveStmtLetImportMs + dt); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLetImportMs = resolveStmtLetImportMs;
} else { if ((() => { const __recv = catName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("flow"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "flow") : strEq(__recv, "flow"); })()) {
  resolveStmtFlowCalls = (resolveStmtFlowCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFlowCalls = resolveStmtFlowCalls;
  resolveStmtFlowMs = (resolveStmtFlowMs + dt); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFlowMs = resolveStmtFlowMs;
} else { if ((() => { const __recv = catName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("lifetime"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "lifetime") : strEq(__recv, "lifetime"); })()) {
  resolveStmtLifetimeIntoCalls = (resolveStmtLifetimeIntoCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLifetimeIntoCalls = resolveStmtLifetimeIntoCalls;
  resolveStmtLifetimeIntoMs = (resolveStmtLifetimeIntoMs + dt); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLifetimeIntoMs = resolveStmtLifetimeIntoMs;
} else { if ((() => { const __recv = catName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("decl"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "decl") : strEq(__recv, "decl"); })()) {
  resolveStmtDeclSkipCalls = (resolveStmtDeclSkipCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtDeclSkipCalls = resolveStmtDeclSkipCalls;
  resolveStmtDeclSkipMs = (resolveStmtDeclSkipMs + dt); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtDeclSkipMs = resolveStmtDeclSkipMs;
} else { if ((() => { const __recv = catName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("expr"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "expr") : strEq(__recv, "expr"); })()) {
  resolveStmtFallbackExprCalls = (resolveStmtFallbackExprCalls + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFallbackExprCalls = resolveStmtFallbackExprCalls;
  resolveStmtFallbackExprMs = (resolveStmtFallbackExprMs + dt); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFallbackExprMs = resolveStmtFallbackExprMs;
} } } } } } }
  return ((typeof Ok === "function") ? Ok({value: resultValue}) : ({ __tag: "Ok", value: resultValue }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmt = resolveStmt;

const __tuff_outer_for_resolveNames = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function resolveNames(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_resolveNames };
  let resolveTotalStart = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveTotalStart = resolveTotalStart;
  let resolveStepStart = resolveTotalStart; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStepStart = resolveStepStart;
  (() => { const __recv = resolveLifetimeScopes; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  (() => { const __recv = resolveGlobalNamesList; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  resolveGlobalDeclNodes = (() => { const __recv = resolveGlobalDeclNodes; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveGlobalDeclNodes = resolveGlobalDeclNodes;
  resolveStmtTotalCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtTotalCalls = resolveStmtTotalCalls;
  resolveStmtTotalMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtTotalMs = resolveStmtTotalMs;
  resolveStmtBlockCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtBlockCalls = resolveStmtBlockCalls;
  resolveStmtBlockMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtBlockMs = resolveStmtBlockMs;
  resolveStmtFnCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFnCalls = resolveStmtFnCalls;
  resolveStmtFnMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFnMs = resolveStmtFnMs;
  resolveStmtLetImportCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLetImportCalls = resolveStmtLetImportCalls;
  resolveStmtLetImportMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLetImportMs = resolveStmtLetImportMs;
  resolveStmtFlowCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFlowCalls = resolveStmtFlowCalls;
  resolveStmtFlowMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFlowMs = resolveStmtFlowMs;
  resolveStmtLifetimeIntoCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLifetimeIntoCalls = resolveStmtLifetimeIntoCalls;
  resolveStmtLifetimeIntoMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtLifetimeIntoMs = resolveStmtLifetimeIntoMs;
  resolveStmtDeclSkipCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtDeclSkipCalls = resolveStmtDeclSkipCalls;
  resolveStmtDeclSkipMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtDeclSkipMs = resolveStmtDeclSkipMs;
  resolveStmtFallbackExprCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFallbackExprCalls = resolveStmtFallbackExprCalls;
  resolveStmtFallbackExprMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStmtFallbackExprMs = resolveStmtFallbackExprMs;
  resolveBlockPredeclareMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveBlockPredeclareMs = resolveBlockPredeclareMs;
  resolveBlockBodyMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveBlockBodyMs = resolveBlockBodyMs;
  resolveExprIdentifierCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIdentifierCalls = resolveExprIdentifierCalls;
  resolveExprBinaryCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprBinaryCalls = resolveExprBinaryCalls;
  resolveExprUnaryOrUnwrapCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprUnaryOrUnwrapCalls = resolveExprUnaryOrUnwrapCalls;
  resolveExprCallCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprCallCalls = resolveExprCallCalls;
  resolveExprMemberCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprMemberCalls = resolveExprMemberCalls;
  resolveExprIndexCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIndexCalls = resolveExprIndexCalls;
  resolveExprStructInitCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprStructInitCalls = resolveExprStructInitCalls;
  resolveExprTupleCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprTupleCalls = resolveExprTupleCalls;
  resolveExprIfCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIfCalls = resolveExprIfCalls;
  resolveExprMatchCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprMatchCalls = resolveExprMatchCalls;
  resolveExprIsCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprIsCalls = resolveExprIsCalls;
  resolveExprLambdaCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprLambdaCalls = resolveExprLambdaCalls;
  resolveExprFnExprCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprFnExprCalls = resolveExprFnExprCalls;
  resolveExprOtherCalls = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprOtherCalls = resolveExprOtherCalls;
  resolveExprOtherKindCounts = (() => { const __recv = resolveExprOtherKindCounts; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveExprOtherKindCounts = resolveExprOtherKindCounts;
  (() => { const __recv = resolveExprOtherKindKeys; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  resolveStepStart = resolveLogStep("reset-state", resolveStepStart, resolveTotalStart); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStepStart = resolveStepStart;
  let globals = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.globals = globals;
  let body = nodeGetData1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  rslvUtilsValidateExpectActualPairs(body);
  resolveStepStart = resolveLogStep("validate-expect-actual", resolveStepStart, resolveTotalStart); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStepStart = resolveStepStart;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = body; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if (((((((((((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL)) || (kind === NK_STRUCT_DECL)) || (kind === NK_ENUM_DECL)) || (kind === NK_OBJECT_DECL)) || (kind === NK_CONTRACT_DECL)) || (kind === NK_TYPE_ALIAS)) || (kind === NK_DEP_TYPE_ALIAS)) || (kind === NK_LET_DECL)) || (kind === NK_EXTERN_LET_DECL)) || (kind === NK_EXTERN_TYPE_DECL))) {
  let gname = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.gname = gname;
  if ((() => { const __recv = globals; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(gname); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, gname) : setHas(__recv, gname); })()) {
  let firstNode = (() => { const __recv = resolveGlobalDeclNodes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(gname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, gname) : mapGet(__recv, gname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.firstNode = firstNode;
  let firstLine = intToString(nodeGetLine(firstNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.firstLine = firstLine;
  let firstCol = intToString(nodeGetCol(firstNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.firstCol = firstCol;
  rslvPanicLoc("E_RESOLVE_SHADOWING", (() => { const __recv = "Duplicate global declaration: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(gname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, gname) : strConcat(__recv, gname); })(), (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "First declared at line "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(firstLine); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, firstLine) : strConcat(__recv, firstLine); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(", col "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ", col ") : strConcat(__recv, ", col "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(firstCol); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, firstCol) : strConcat(__recv, firstCol); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })(), "Rename one of the global declarations or split conflicting declarations into separate modules.");
}
  (() => { const __recv = globals; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(gname); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, gname) : setAdd(__recv, gname); })();
  (() => { const __recv = resolveGlobalNamesList; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(gname); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, gname) : vecPush(__recv, gname); })();
  (() => { const __recv = resolveGlobalDeclNodes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(gname, stmt); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, gname, stmt) : mapSet(__recv, gname, stmt); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  resolveStepStart = resolveLogStep("predeclare-globals", resolveStepStart, resolveTotalStart); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStepStart = resolveStepStart;
  let topScopes = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.topScopes = topScopes;
  (() => { const __recv = topScopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(setNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, setNew()) : vecPush(__recv, setNew()); })();
  resolveStepStart = resolveLogStep("init-top-scope", resolveStepStart, resolveTotalStart); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStepStart = resolveStepStart;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let topStmt = (() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.topStmt = topStmt;
  let topKind = nodeKind(topStmt); if (typeof __tuff_this !== 'undefined') __tuff_this.topKind = topKind;
  let topName = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.topName = topName;
  if (((((((((((((topKind === NK_FN_DECL) || (topKind === NK_CLASS_FN_DECL)) || (topKind === NK_ACTUAL_FN_DECL)) || (topKind === NK_STRUCT_DECL)) || (topKind === NK_ENUM_DECL)) || (topKind === NK_OBJECT_DECL)) || (topKind === NK_CONTRACT_DECL)) || (topKind === NK_TYPE_ALIAS)) || (topKind === NK_DEP_TYPE_ALIAS)) || (topKind === NK_LET_DECL)) || (topKind === NK_EXTERN_LET_DECL)) || (topKind === NK_EXTERN_TYPE_DECL))) {
  topName = getInternedStr(nodeGetData1(topStmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.topName = topName;
}
  printError((() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "[selfhost][resolve] top-stmt:start i="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(i)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(i)) : strConcat(__recv, intToString(i)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" kind="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " kind=") : strConcat(__recv, " kind="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(topKind)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(topKind)) : strConcat(__recv, intToString(topKind)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" name="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " name=") : strConcat(__recv, " name="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(topName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, topName) : strConcat(__recv, topName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\n") : strConcat(__recv, "\n"); })());
  resolveStmt(topStmt, globals, topScopes, 0);
  printError((() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "[selfhost][resolve] top-stmt:done i="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(i)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(i)) : strConcat(__recv, intToString(i)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" kind="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " kind=") : strConcat(__recv, " kind="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(topKind)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(topKind)) : strConcat(__recv, intToString(topKind)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\n") : strConcat(__recv, "\n"); })());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  resolveStepStart = resolveLogStep("resolve-top-level", resolveStepStart, resolveTotalStart); if (typeof __tuff_this !== 'undefined') __tuff_this.resolveStepStart = resolveStepStart;
  resolveLogBucket("stmt-total", resolveStmtTotalCalls, resolveStmtTotalMs);
  resolveLogBucket("stmt-block", resolveStmtBlockCalls, resolveStmtBlockMs);
  resolveLogBucket("stmt-fn-decl", resolveStmtFnCalls, resolveStmtFnMs);
  resolveLogBucket("stmt-let-import", resolveStmtLetImportCalls, resolveStmtLetImportMs);
  resolveLogBucket("stmt-flow", resolveStmtFlowCalls, resolveStmtFlowMs);
  resolveLogBucket("stmt-lifetime-into", resolveStmtLifetimeIntoCalls, resolveStmtLifetimeIntoMs);
  resolveLogBucket("stmt-decl-skip", resolveStmtDeclSkipCalls, resolveStmtDeclSkipMs);
  resolveLogBucket("stmt-fallback-expr", resolveStmtFallbackExprCalls, resolveStmtFallbackExprMs);
  resolveLogBucket("block-predeclare", resolveStmtBlockCalls, resolveBlockPredeclareMs);
  resolveLogBucket("block-body", resolveStmtBlockCalls, resolveBlockBodyMs);
  resolveLogCount("expr-identifier", resolveExprIdentifierCalls);
  resolveLogCount("expr-binary", resolveExprBinaryCalls);
  resolveLogCount("expr-unary-or-unwrap", resolveExprUnaryOrUnwrapCalls);
  resolveLogCount("expr-call", resolveExprCallCalls);
  resolveLogCount("expr-member", resolveExprMemberCalls);
  resolveLogCount("expr-index", resolveExprIndexCalls);
  resolveLogCount("expr-struct-init", resolveExprStructInitCalls);
  resolveLogCount("expr-tuple", resolveExprTupleCalls);
  resolveLogCount("expr-if", resolveExprIfCalls);
  resolveLogCount("expr-match", resolveExprMatchCalls);
  resolveLogCount("expr-is", resolveExprIsCalls);
  resolveLogCount("expr-lambda", resolveExprLambdaCalls);
  resolveLogCount("expr-fn-expr", resolveExprFnExprCalls);
  resolveLogCount("expr-other", resolveExprOtherCalls);
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let jLen = (() => { const __recv = resolveExprOtherKindKeys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.jLen = jLen;
  while ((j < jLen)) {
  let kindKey = (() => { const __recv = resolveExprOtherKindKeys; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.kindKey = kindKey;
  let kindCount = (() => { const __recv = resolveExprOtherKindCounts; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(kindKey); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, kindKey) : mapGet(__recv, kindKey); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.kindCount = kindCount;
  resolveLogCount((() => { const __recv = "expr-other-kind="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(kindKey)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(kindKey)) : strConcat(__recv, intToString(kindKey)); })(), kindCount);
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  return ((typeof Ok === "function") ? Ok({value: program}) : ({ __tag: "Ok", value: program }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.resolveNames = resolveNames;

const __tuff_outer_for_selfhostResolverMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostResolverMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostResolverMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostResolverMarker = selfhostResolverMarker;

function TypeError(fields = {}) { return { __tag: "TypeError", code: fields.code, message: fields.message, reason: fields.reason, fix: fields.fix, line: fields.line, col: fields.col }; }

let tcCurrentNode = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.tcCurrentNode = tcCurrentNode;

let tcTypeNameCache = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcTypeNameCache = tcTypeNameCache;

const __tuff_outer_for_tcPanicLoc = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tcPanicLoc(code, msg, reason, fix) {
  let __tuff_this = { code: code, msg: msg, reason: reason, fix: fix, this: __tuff_outer_for_tcPanicLoc };
  return panicWithCodeLoc(code, msg, reason, fix, nodeGetLine(tcCurrentNode), nodeGetCol(tcCurrentNode));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tcPanicLoc = tcPanicLoc;

const __tuff_outer_for_tcResultError = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tcResultError(code, msg, reason, fix) {
  let __tuff_this = { code: code, msg: msg, reason: reason, fix: fix, this: __tuff_outer_for_tcResultError };
  return ((typeof Err === "function") ? Err({error: ((typeof TypeError === "function") ? TypeError({code: code, message: msg, reason: reason, fix: fix, line: nodeGetLine(tcCurrentNode), col: nodeGetCol(tcCurrentNode)}) : ({ __tag: "TypeError", code: code, message: msg, reason: reason, fix: fix, line: nodeGetLine(tcCurrentNode), col: nodeGetCol(tcCurrentNode) }))}) : ({ __tag: "Err", error: ((typeof TypeError === "function") ? TypeError({code: code, message: msg, reason: reason, fix: fix, line: nodeGetLine(tcCurrentNode), col: nodeGetCol(tcCurrentNode)}) : ({ __tag: "TypeError", code: code, message: msg, reason: reason, fix: fix, line: nodeGetLine(tcCurrentNode), col: nodeGetCol(tcCurrentNode) })) }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tcResultError = tcResultError;

const __tuff_outer_for_unionTypeContains = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function unionTypeContains(unionName, candidate) {
  let __tuff_this = { unionName: unionName, candidate: candidate, this: __tuff_outer_for_unionTypeContains };
  if ((() => { const __recv = unionName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(candidate); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, candidate) : strEq(__recv, candidate); })()) {
  return true;
}
  let prefix = (() => { const __recv = candidate; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "|") : strConcat(__recv, "|"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.prefix = prefix;
  if ((() => { const __recv = unionName; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop(prefix); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, prefix) : strStartsWith(__recv, prefix); })()) {
  return true;
}
  let middle = (() => { const __recv = (() => { const __recv = "|"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(candidate); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, candidate) : strConcat(__recv, candidate); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "|") : strConcat(__recv, "|"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.middle = middle;
  if ((() => { const __recv = unionName; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop(middle); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, middle) : strIncludes(__recv, middle); })()) {
  return true;
}
  let tail = (() => { const __recv = "|"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(candidate); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, candidate) : strConcat(__recv, candidate); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tail = tail;
  if (((!(() => { const __recv = unionName; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop((() => { const __recv = tail; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "|") : strConcat(__recv, "|"); })()); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, (() => { const __recv = tail; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "|") : strConcat(__recv, "|"); })()) : strIncludes(__recv, (() => { const __recv = tail; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "|") : strConcat(__recv, "|"); })()); })()) && (() => { const __recv = unionName; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop(tail); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, tail) : strIncludes(__recv, tail); })())) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.unionTypeContains = unionTypeContains;

const __tuff_outer_for_unionTypeSplitTags = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function unionTypeSplitTags(unionName) {
  let __tuff_this = { unionName: unionName, this: __tuff_outer_for_unionTypeSplitTags };
  let tags = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tags = tags;
  return tags;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.unionTypeSplitTags = unionTypeSplitTags;

const __tuff_outer_for_isThisReturnTypeFor = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isThisReturnTypeFor(actual, declared) {
  let __tuff_this = { actual: actual, declared: declared, this: __tuff_outer_for_isThisReturnTypeFor };
  if ((!(() => { const __recv = actual; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("__this_"); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "__this_") : strStartsWith(__recv, "__this_"); })())) {
  return false;
}
  let n = (() => { const __recv = actual; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  if ((n < 7)) {
  return false;
}
  return (() => { const __recv = (() => { const __recv = actual; const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(7, n); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, 7, n) : strSlice(__recv, 7, n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(declared); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, declared) : strEq(__recv, declared); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isThisReturnTypeFor = isThisReturnTypeFor;

const __tuff_outer_for_typeNameFromTypeNode = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typeNameFromTypeNode(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_typeNameFromTypeNode };
  if ((() => { const __recv = tcTypeNameCache; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(t); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, t) : mapHas(__recv, t); })()) {
  return (() => { const __recv = tcTypeNameCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(t); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, t) : mapGet(__recv, t); })();
}
  if ((t === 0)) {
  (() => { const __recv = tcTypeNameCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(t, "Unknown"); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, t, "Unknown") : mapSet(__recv, t, "Unknown"); })();
  return "Unknown";
}
  let result = "Unknown"; if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  let k = nodeKind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === 40)) {
  result = getInternedStr(nodeGetData1(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  let genericArgs = nodeGetData2(t); if (typeof __tuff_this !== 'undefined') __tuff_this.genericArgs = genericArgs;
  let namedActualArity = (() => { const __recv = genericArgs; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.namedActualArity = namedActualArity;
  if ((() => { const __recv = tcExternTypeParams; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(result); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, result) : mapHas(__recv, result); })()) {
  let externExpectedArity = (() => { const __recv = tcExternTypeParams; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(result); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, result) : mapGet(__recv, result); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.externExpectedArity = externExpectedArity;
  if ((namedActualArity !== externExpectedArity)) {
  tcPanicLoc("E_TYPE_APPLIED_ARITY", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "'"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(result); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, result) : strConcat(__recv, result); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' applied with "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' applied with ") : strConcat(__recv, "' applied with "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(namedActualArity)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(namedActualArity)) : strConcat(__recv, intToString(namedActualArity)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" argument(s), expected "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " argument(s), expected ") : strConcat(__recv, " argument(s), expected "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(externExpectedArity)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(externExpectedArity)) : strConcat(__recv, intToString(externExpectedArity)); })(), "Extern types must be applied with exactly the number of generic parameters declared by their extern type declaration.", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Provide exactly "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(externExpectedArity)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(externExpectedArity)) : strConcat(__recv, intToString(externExpectedArity)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" argument(s) to '"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " argument(s) to '") : strConcat(__recv, " argument(s) to '"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(result); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, result) : strConcat(__recv, result); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'.") : strConcat(__recv, "'."); })());
}
}
  (() => { const __recv = tcTypeNameCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, t, result) : mapSet(__recv, t, result); })();
  return result;
}
  if ((k === 41)) {
  let mutable = nodeGetData1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.mutable = mutable;
  let inner = typeNameFromTypeNode(nodeGetData2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let movePtr = nodeGetData3(t); if (typeof __tuff_this !== 'undefined') __tuff_this.movePtr = movePtr;
  let lifeIdx = nodeGetData4(t); if (typeof __tuff_this !== 'undefined') __tuff_this.lifeIdx = lifeIdx;
  let lifePrefix = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.lifePrefix = lifePrefix;
  if ((lifeIdx !== 0)) {
  lifePrefix = (() => { const __recv = getInternedStr(lifeIdx); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.lifePrefix = lifePrefix;
}
  if ((movePtr === 1)) {
  result = (() => { const __recv = (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lifePrefix); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lifePrefix) : strConcat(__recv, lifePrefix); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("move "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "move ") : strConcat(__recv, "move "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  (() => { const __recv = tcTypeNameCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, t, result) : mapSet(__recv, t, result); })();
  return result;
}
  if ((mutable === 1)) {
  result = (() => { const __recv = (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lifePrefix); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lifePrefix) : strConcat(__recv, lifePrefix); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "mut ") : strConcat(__recv, "mut "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  (() => { const __recv = tcTypeNameCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, t, result) : mapSet(__recv, t, result); })();
  return result;
}
  result = (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lifePrefix); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lifePrefix) : strConcat(__recv, lifePrefix); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  (() => { const __recv = tcTypeNameCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, t, result) : mapSet(__recv, t, result); })();
  return result;
}
  if ((k === 44)) {
  result = typeNameFromTypeNode(nodeGetData1(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  (() => { const __recv = tcTypeNameCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, t, result) : mapSet(__recv, t, result); })();
  return result;
}
  if ((k === 71)) {
  let aliasName = getInternedStr(nodeGetData1(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  let args = nodeGetData2(t); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let actualArity = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.actualArity = actualArity;
  if ((() => { const __recv = tcExternTypeParams; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, aliasName) : mapHas(__recv, aliasName); })()) {
  let externExpectedArity = (() => { const __recv = tcExternTypeParams; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, aliasName) : mapGet(__recv, aliasName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.externExpectedArity = externExpectedArity;
  if ((actualArity !== externExpectedArity)) {
  tcPanicLoc("E_TYPE_APPLIED_ARITY", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "'"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, aliasName) : strConcat(__recv, aliasName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' applied with "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' applied with ") : strConcat(__recv, "' applied with "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(actualArity)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(actualArity)) : strConcat(__recv, intToString(actualArity)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" argument(s), expected "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " argument(s), expected ") : strConcat(__recv, " argument(s), expected "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(externExpectedArity)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(externExpectedArity)) : strConcat(__recv, intToString(externExpectedArity)); })(), "Extern types must be applied with exactly the number of generic parameters declared by their extern type declaration.", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Provide exactly "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(externExpectedArity)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(externExpectedArity)) : strConcat(__recv, intToString(externExpectedArity)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" argument(s) to '"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " argument(s) to '") : strConcat(__recv, " argument(s) to '"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, aliasName) : strConcat(__recv, aliasName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'.") : strConcat(__recv, "'."); })());
}
}
  if ((() => { const __recv = tcDepTypeAliasParams; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, aliasName) : mapHas(__recv, aliasName); })()) {
  let expectedArity = (() => { const __recv = tcDepTypeAliasParams; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, aliasName) : mapGet(__recv, aliasName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedArity = expectedArity;
  if ((actualArity !== expectedArity)) {
  tcPanicLoc("E_TYPE_APPLIED_ARITY", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "'"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, aliasName) : strConcat(__recv, aliasName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' applied with "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' applied with ") : strConcat(__recv, "' applied with "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(actualArity)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(actualArity)) : strConcat(__recv, intToString(actualArity)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" argument(s), expected "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " argument(s), expected ") : strConcat(__recv, " argument(s), expected "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(expectedArity)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(expectedArity)) : strConcat(__recv, intToString(expectedArity)); })(), "Dependent type aliases must be applied with exactly the number of arguments declared in the type parameter list.", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Provide exactly "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(expectedArity)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(expectedArity)) : strConcat(__recv, intToString(expectedArity)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" argument(s) to '"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " argument(s) to '") : strConcat(__recv, " argument(s) to '"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, aliasName) : strConcat(__recv, aliasName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'.") : strConcat(__recv, "'."); })());
}
}
  result = aliasName; if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  (() => { const __recv = tcTypeNameCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, t, result) : mapSet(__recv, t, result); })();
  return result;
}
  if ((k === 45)) {
  let left = typeNameFromTypeNode(nodeGetData1(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  let right = typeNameFromTypeNode(nodeGetData2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  result = (() => { const __recv = (() => { const __recv = left; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "|") : strConcat(__recv, "|"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, right) : strConcat(__recv, right); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  (() => { const __recv = tcTypeNameCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, t, result) : mapSet(__recv, t, result); })();
  return result;
}
  (() => { const __recv = tcTypeNameCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(t, result); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, t, result) : mapSet(__recv, t, result); })();
  return result;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typeNameFromTypeNode = typeNameFromTypeNode;

const __tuff_outer_for_pointerTypesCompatible = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pointerTypesCompatible(expected, actual) {
  let __tuff_this = { expected: expected, actual: actual, this: __tuff_outer_for_pointerTypesCompatible };
  if ((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(actual); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, actual) : strEq(__recv, actual); })()) {
  return true;
}
  if ((() => { const __recv = expected; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, "|") : strIncludes(__recv, "|"); })()) {
  if (unionTypeContains(expected, actual)) {
  return true;
}
}
  if (((() => { const __recv = expected; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "*") : strStartsWith(__recv, "*"); })() && (() => { const __recv = actual; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "*") : strStartsWith(__recv, "*"); })())) {
  let expectedBody = (() => { const __recv = expected; const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(1, (() => { const __recv = expected; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, 1, (() => { const __recv = expected; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()) : strSlice(__recv, 1, (() => { const __recv = expected; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedBody = expectedBody;
  let actualBody = (() => { const __recv = actual; const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(1, (() => { const __recv = actual; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, 1, (() => { const __recv = actual; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()) : strSlice(__recv, 1, (() => { const __recv = actual; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.actualBody = actualBody;
  let expectedHasLife = (((!(() => { const __recv = expectedBody; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "mut ") : strStartsWith(__recv, "mut "); })()) && (!(() => { const __recv = expectedBody; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("move "); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "move ") : strStartsWith(__recv, "move "); })())) && (() => { const __recv = expectedBody; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, " ") : strIncludes(__recv, " "); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedHasLife = expectedHasLife;
  let actualHasLife = (((!(() => { const __recv = actualBody; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "mut ") : strStartsWith(__recv, "mut "); })()) && (!(() => { const __recv = actualBody; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("move "); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "move ") : strStartsWith(__recv, "move "); })())) && (() => { const __recv = actualBody; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, " ") : strIncludes(__recv, " "); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.actualHasLife = actualHasLife;
  if (expectedHasLife) {
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < (() => { const __recv = expectedBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })())) {
  if (((() => { const __recv = expectedBody; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })() === 32)) {
  break;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  if ((i < (() => { const __recv = expectedBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })())) {
  let expectedStart = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedStart = expectedStart;
  if ((expectedStart <= (() => { const __recv = expectedBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })())) {
  expectedBody = (() => { const __recv = expectedBody; const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(expectedStart, (() => { const __recv = expectedBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, expectedStart, (() => { const __recv = expectedBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()) : strSlice(__recv, expectedStart, (() => { const __recv = expectedBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedBody = expectedBody;
}
}
}
  if (actualHasLife) {
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < (() => { const __recv = actualBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })())) {
  if (((() => { const __recv = actualBody; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, j) : strCharAt(__recv, j); })() === 32)) {
  break;
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  if ((j < (() => { const __recv = actualBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })())) {
  let actualStart = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.actualStart = actualStart;
  if ((actualStart <= (() => { const __recv = actualBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })())) {
  actualBody = (() => { const __recv = actualBody; const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(actualStart, (() => { const __recv = actualBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, actualStart, (() => { const __recv = actualBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()) : strSlice(__recv, actualStart, (() => { const __recv = actualBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.actualBody = actualBody;
}
}
}
  if (((!(() => { const __recv = expectedBody; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "mut ") : strStartsWith(__recv, "mut "); })()) && (() => { const __recv = actualBody; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "mut ") : strStartsWith(__recv, "mut "); })())) {
  let expectedInner = expectedBody; if (typeof __tuff_this !== 'undefined') __tuff_this.expectedInner = expectedInner;
  let actualInner = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.actualInner = actualInner;
  if (((() => { const __recv = actualBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() >= 4)) {
  actualInner = (() => { const __recv = actualBody; const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(4, (() => { const __recv = actualBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, 4, (() => { const __recv = actualBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()) : strSlice(__recv, 4, (() => { const __recv = actualBody; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.actualInner = actualInner;
} else {
  actualInner = actualBody; if (typeof __tuff_this !== 'undefined') __tuff_this.actualInner = actualInner;
}
  return (() => { const __recv = expectedInner; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(actualInner); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, actualInner) : strEq(__recv, actualInner); })();
}
  if (((() => { const __recv = expectedBody; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "mut ") : strStartsWith(__recv, "mut "); })() && (!(() => { const __recv = actualBody; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "mut ") : strStartsWith(__recv, "mut "); })()))) {
  return false;
}
  return (() => { const __recv = expectedBody; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(actualBody); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, actualBody) : strEq(__recv, actualBody); })();
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pointerTypesCompatible = pointerTypesCompatible;

const __tuff_outer_for_strEndsWithLocal = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function strEndsWithLocal(s, suffix) {
  let __tuff_this = { s: s, suffix: suffix, this: __tuff_outer_for_strEndsWithLocal };
  let ns = (() => { const __recv = s; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ns = ns;
  let nf = (() => { const __recv = suffix; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.nf = nf;
  if ((nf > ns)) {
  return false;
}
  if ((nf === 0)) {
  return true;
}
  if ((nf === ns)) {
  return (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(0, ns); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, 0, ns) : strSlice(__recv, 0, ns); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(suffix); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, suffix) : strEq(__recv, suffix); })();
}
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < nf)) {
  if (((() => { const __recv = s; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(((ns - nf) + i)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, ((ns - nf) + i)) : strCharAt(__recv, ((ns - nf) + i)); })() !== (() => { const __recv = suffix; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })())) {
  return false;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return true;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.strEndsWithLocal = strEndsWithLocal;

const __tuff_outer_for_isNumberLiteralWithSuffix = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isNumberLiteralWithSuffix(n, suffix) {
  let __tuff_this = { n: n, suffix: suffix, this: __tuff_outer_for_isNumberLiteralWithSuffix };
  if (((n === 0) || (nodeKind(n) !== NK_NUMBER_LIT))) {
  return false;
}
  let text = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  return strEndsWithLocal(text, suffix);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isNumberLiteralWithSuffix = isNumberLiteralWithSuffix;

const __tuff_outer_for_isUsizeZeroLiteralNode = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isUsizeZeroLiteralNode(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_isUsizeZeroLiteralNode };
  if ((!isNumberLiteralWithSuffix(n, "USize"))) {
  return false;
}
  return (() => { const __recv = getInternedStr(nodeGetData1(n)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("0USize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "0USize") : strEq(__recv, "0USize"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isUsizeZeroLiteralNode = isUsizeZeroLiteralNode;

const __tuff_outer_for_isNullablePointerTypeName = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isNullablePointerTypeName(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_isNullablePointerTypeName };
  if ((!(() => { const __recv = name; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, "|") : strIncludes(__recv, "|"); })())) {
  return false;
}
  if (((() => { const __recv = name; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "*") : strStartsWith(__recv, "*"); })() && strEndsWithLocal(name, "|USize"))) {
  return true;
}
  if (((() => { const __recv = name; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("USize|*"); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "USize|*") : strStartsWith(__recv, "USize|*"); })() && (() => { const __recv = name; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, "*") : strIncludes(__recv, "*"); })())) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isNullablePointerTypeName = isNullablePointerTypeName;

const __tuff_outer_for_numericTypesCompatible = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function numericTypesCompatible(expected, actual, rhs) {
  let __tuff_this = { expected: expected, actual: actual, rhs: rhs, this: __tuff_outer_for_numericTypesCompatible };
  if ((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(actual); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, actual) : strEq(__recv, actual); })()) {
  return true;
}
  if (((((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "USize") : strEq(__recv, "USize"); })() && (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I32") : strEq(__recv, "I32"); })()) && (rhs !== 0)) && (nodeKind(rhs) === NK_NUMBER_LIT))) {
  let lit = getInternedStr(nodeGetData1(rhs)); if (typeof __tuff_this !== 'undefined') __tuff_this.lit = lit;
  return (!(() => { const __recv = lit; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "-") : strStartsWith(__recv, "-"); })());
}
  if (((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "USize") : strEq(__recv, "USize"); })() && (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I32") : strEq(__recv, "I32"); })())) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I32") : strEq(__recv, "I32"); })() && (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "USize") : strEq(__recv, "USize"); })())) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U16") : strEq(__recv, "U16"); })() && (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U8") : strEq(__recv, "U8"); })())) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U32") : strEq(__recv, "U32"); })() && ((() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U8") : strEq(__recv, "U8"); })() || (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U16") : strEq(__recv, "U16"); })()))) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U64"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U64") : strEq(__recv, "U64"); })() && (((() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U8") : strEq(__recv, "U8"); })() || (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U16") : strEq(__recv, "U16"); })()) || (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U32") : strEq(__recv, "U32"); })()))) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U128"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U128") : strEq(__recv, "U128"); })() && ((((() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U8") : strEq(__recv, "U8"); })() || (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U16") : strEq(__recv, "U16"); })()) || (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U32") : strEq(__recv, "U32"); })()) || (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U64"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U64") : strEq(__recv, "U64"); })()))) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "USize") : strEq(__recv, "USize"); })() && ((((() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U8") : strEq(__recv, "U8"); })() || (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U16") : strEq(__recv, "U16"); })()) || (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U32") : strEq(__recv, "U32"); })()) || (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U64"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U64") : strEq(__recv, "U64"); })()))) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.numericTypesCompatible = numericTypesCompatible;

const __tuff_outer_for_isTypeVariableName = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isTypeVariableName(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_isTypeVariableName };
  if (((() => { const __recv = name; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() !== 1)) {
  return false;
}
  let ch = charCode(name); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  return ((ch >= 65) && (ch <= 90));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isTypeVariableName = isTypeVariableName;

const __tuff_outer_for_isBuiltinPrimitiveTypeName = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isBuiltinPrimitiveTypeName(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_isBuiltinPrimitiveTypeName };
  return (((((((((((((((((() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I8"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I8") : strEq(__recv, "I8"); })() || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I16"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I16") : strEq(__recv, "I16"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I32") : strEq(__recv, "I32"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I64"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I64") : strEq(__recv, "I64"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I128"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I128") : strEq(__recv, "I128"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U8") : strEq(__recv, "U8"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U16") : strEq(__recv, "U16"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U32") : strEq(__recv, "U32"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U64"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U64") : strEq(__recv, "U64"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U128"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U128") : strEq(__recv, "U128"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "USize") : strEq(__recv, "USize"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("ISize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "ISize") : strEq(__recv, "ISize"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("F32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "F32") : strEq(__recv, "F32"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("F64"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "F64") : strEq(__recv, "F64"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Bool"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Bool") : strEq(__recv, "Bool"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Char"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Char") : strEq(__recv, "Char"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Void"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Void") : strEq(__recv, "Void"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isBuiltinPrimitiveTypeName = isBuiltinPrimitiveTypeName;

const __tuff_outer_for_runtimeOpaqueHandleCompatible = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function runtimeOpaqueHandleCompatible(expected, actual) {
  let __tuff_this = { expected: expected, actual: actual, this: __tuff_outer_for_runtimeOpaqueHandleCompatible };
  if (((() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I32") : strEq(__recv, "I32"); })() && (((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Vec"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Vec") : strEq(__recv, "Vec"); })() || (() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Map"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Map") : strEq(__recv, "Map"); })()) || (() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Set"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Set") : strEq(__recv, "Set"); })()))) {
  return true;
}
  if (((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I32") : strEq(__recv, "I32"); })() && (((() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Vec"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Vec") : strEq(__recv, "Vec"); })() || (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Map"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Map") : strEq(__recv, "Map"); })()) || (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Set"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Set") : strEq(__recv, "Set"); })()))) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.runtimeOpaqueHandleCompatible = runtimeOpaqueHandleCompatible;

const __tuff_outer_for_typeNameWithAliasBase = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typeNameWithAliasBase(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_typeNameWithAliasBase };
  if ((() => { const __recv = tcAliasBaseType; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  return (() => { const __recv = tcAliasBaseType; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })();
}
  return name;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typeNameWithAliasBase = typeNameWithAliasBase;

const __tuff_outer_for_typeNamesCompatible = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typeNamesCompatible(expected, actual, rhs) {
  let __tuff_this = { expected: expected, actual: actual, rhs: rhs, this: __tuff_outer_for_typeNamesCompatible };
  if (((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Unknown") : strEq(__recv, "Unknown"); })() || (() => { const __recv = actual; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Unknown") : strEq(__recv, "Unknown"); })())) {
  return true;
}
  if ((() => { const __recv = expected; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(actual); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, actual) : strEq(__recv, actual); })()) {
  return true;
}
  if ((isTypeVariableName(expected) || isTypeVariableName(actual))) {
  return true;
}
  let expectedBase = typeNameWithAliasBase(expected); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedBase = expectedBase;
  let actualBase = typeNameWithAliasBase(actual); if (typeof __tuff_this !== 'undefined') __tuff_this.actualBase = actualBase;
  if ((() => { const __recv = expectedBase; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(actualBase); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, actualBase) : strEq(__recv, actualBase); })()) {
  return true;
}
  if (runtimeOpaqueHandleCompatible(expectedBase, actualBase)) {
  return true;
}
  if (pointerTypesCompatible(expectedBase, actualBase)) {
  return true;
}
  if (numericTypesCompatible(expectedBase, actualBase, rhs)) {
  return true;
}
  if (runtimeOpaqueHandleCompatible(expected, actual)) {
  return true;
}
  if (pointerTypesCompatible(expected, actual)) {
  return true;
}
  if (numericTypesCompatible(expected, actual, rhs)) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typeNamesCompatible = typeNamesCompatible;

const __tuff_outer_for_inferExprTypeName = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function inferExprTypeName(n, fnReturnTypes, localTypes) {
  let __tuff_this = { n: n, fnReturnTypes: fnReturnTypes, localTypes: localTypes, this: __tuff_outer_for_inferExprTypeName };
  if ((n === 0)) {
  return "Unknown";
}
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === 20)) {
  let text = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  if (strEndsWithLocal(text, "USize")) {
  return "USize";
}
  if (strEndsWithLocal(text, "ISize")) {
  return "ISize";
}
  if (strEndsWithLocal(text, "U128")) {
  return "U128";
}
  if (strEndsWithLocal(text, "I128")) {
  return "I128";
}
  if (strEndsWithLocal(text, "U64")) {
  return "U64";
}
  if (strEndsWithLocal(text, "I64")) {
  return "I64";
}
  if (strEndsWithLocal(text, "U32")) {
  return "U32";
}
  if (strEndsWithLocal(text, "I32")) {
  return "I32";
}
  if (strEndsWithLocal(text, "U16")) {
  return "U16";
}
  if (strEndsWithLocal(text, "I16")) {
  return "I16";
}
  if (strEndsWithLocal(text, "U8")) {
  return "U8";
}
  if (strEndsWithLocal(text, "I8")) {
  return "I8";
}
  return "I32";
}
  if ((kind === 21)) {
  return "Bool";
}
  if ((kind === 22)) {
  return "*Str";
}
  if ((kind === 23)) {
  return "Char";
}
  if ((kind === 24)) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = localTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  return (() => { const __recv = localTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })();
}
  if ((() => { const __recv = tcGlobalValueTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  return (() => { const __recv = tcGlobalValueTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })();
}
  return "Unknown";
}
  if ((kind === 26)) {
  let op = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let inner = inferExprTypeName(nodeGetData2(n), fnReturnTypes, localTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&") : strEq(__recv, "&"); })()) {
  return (() => { const __recv = "*"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })();
}
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&mut"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&mut") : strEq(__recv, "&mut"); })()) {
  return (() => { const __recv = "*mut "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })();
}
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("!"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "!") : strEq(__recv, "!"); })()) {
  return "Bool";
}
  return inner;
}
  if ((kind === 25)) {
  let op = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((((((((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("=="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "==") : strEq(__recv, "=="); })() || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "!=") : strEq(__recv, "!="); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<") : strEq(__recv, "<"); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<=") : strEq(__recv, "<="); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(">"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, ">") : strEq(__recv, ">"); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(">="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, ">=") : strEq(__recv, ">="); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&&"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&&") : strEq(__recv, "&&"); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("||"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "||") : strEq(__recv, "||"); })())) {
  return "Bool";
}
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(".."); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "..") : strEq(__recv, ".."); })()) {
  return "Iter";
}
  return inferExprTypeName(nodeGetData2(n), fnReturnTypes, localTypes);
}
  if ((kind === 27)) {
  let callee = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  if ((nodeKind(callee) === 24)) {
  let fname = getInternedStr(nodeGetData1(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if (((() => { const __recv = fname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "into") : strEq(__recv, "into"); })() && (nodeGetData3(n) === 1))) {
  let typeArgs = nodeGetData4(n); if (typeof __tuff_this !== 'undefined') __tuff_this.typeArgs = typeArgs;
  if ((((() => { const __recv = typeArgs; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 1) && (nodeKind((() => { const __recv = typeArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()) === NK_NAMED_TYPE))) {
  let cname = getInternedStr(nodeGetData1((() => { const __recv = typeArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })())); if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
  return (() => { const __recv = "__dyn_"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cname) : strConcat(__recv, cname); })();
}
  return "Unknown";
}
  if ((() => { const __recv = fnReturnTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, fname) : mapHas(__recv, fname); })()) {
  return (() => { const __recv = fnReturnTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, fname) : mapGet(__recv, fname); })();
}
}
  if ((nodeKind(callee) === NK_MEMBER_EXPR)) {
  let methodName = getInternedStr(nodeGetData2(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.methodName = methodName;
  if ((() => { const __recv = fnReturnTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(methodName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, methodName) : mapHas(__recv, methodName); })()) {
  return (() => { const __recv = fnReturnTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(methodName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, methodName) : mapGet(__recv, methodName); })();
}
}
}
  if ((kind === NK_TUPLE_EXPR)) {
  return "Unknown";
}
  return "Unknown";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.inferExprTypeName = inferExprTypeName;

const __tuff_outer_for_exprIsNumberLiteralNonzero = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function exprIsNumberLiteralNonzero(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_exprIsNumberLiteralNonzero };
  if (((n === 0) || (nodeKind(n) !== NK_NUMBER_LIT))) {
  return false;
}
  return (!(() => { const __recv = getInternedStr(nodeGetData1(n)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("0"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "0") : strEq(__recv, "0"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.exprIsNumberLiteralNonzero = exprIsNumberLiteralNonzero;

const __tuff_outer_for_isDecimalDigits = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isDecimalDigits(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_isDecimalDigits };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if (((() => { const __recv = s; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() === 0)) {
  return false;
}
  while ((i < (() => { const __recv = s; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })())) {
  let ch = (() => { const __recv = s; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if (((ch < 48) || (ch > 57))) {
  return false;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return true;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isDecimalDigits = isDecimalDigits;

const __tuff_outer_for_tryGetDecimalLiteralValue = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tryGetDecimalLiteralValue(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_tryGetDecimalLiteralValue };
  if (((n === 0) || (nodeKind(n) !== NK_NUMBER_LIT))) {
  return 0;
}
  let text = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  if ((!isDecimalDigits(text))) {
  return 0;
}
  return parseInt(text);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tryGetDecimalLiteralValue = tryGetDecimalLiteralValue;

const __tuff_outer_for_tryGetKnownIntValue = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tryGetKnownIntValue(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_tryGetKnownIntValue };
  if ((n === 0)) {
  return (-2147483649);
}
  let k = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_NUMBER_LIT)) {
  let text = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  if (isDecimalDigits(text)) {
  return parseInt(text);
}
  return (-2147483649);
}
  if ((k === NK_IDENTIFIER)) {
  let vname = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.vname = vname;
  if ((() => { const __recv = tcVarLiteralValues; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(vname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, vname) : mapHas(__recv, vname); })()) {
  return (() => { const __recv = tcVarLiteralValues; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(vname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, vname) : mapGet(__recv, vname); })();
}
}
  return (-2147483649);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tryGetKnownIntValue = tryGetKnownIntValue;

const __tuff_outer_for_knownIntValueIsValid = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function knownIntValueIsValid(v) {
  let __tuff_this = { v: v, this: __tuff_outer_for_knownIntValueIsValid };
  return ((v >= (-2147483648)) && (v <= 2147483647));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.knownIntValueIsValid = knownIntValueIsValid;

const __tuff_outer_for_isDecimalZeroLiteral = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isDecimalZeroLiteral(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_isDecimalZeroLiteral };
  if (((n === 0) || (nodeKind(n) !== NK_NUMBER_LIT))) {
  return false;
}
  return (() => { const __recv = getInternedStr(nodeGetData1(n)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("0"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "0") : strEq(__recv, "0"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isDecimalZeroLiteral = isDecimalZeroLiteral;

let tcArrayInitBounds = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcArrayInitBounds = tcArrayInitBounds;

let tcIndexUpperBounds = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcIndexUpperBounds = tcIndexUpperBounds;

let tcCallBounds = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcCallBounds = tcCallBounds;

let fnParamCallBounds = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnParamCallBounds = fnParamCallBounds;

let tcVarLiteralValues = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcVarLiteralValues = tcVarLiteralValues;

let tcGlobalValueTypes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcGlobalValueTypes = tcGlobalValueTypes;

let tcAliasUnionTags = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcAliasUnionTags = tcAliasUnionTags;

let tcTypeAliasNames = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcTypeAliasNames = tcTypeAliasNames;

let tcDepTypeAliasParams = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcDepTypeAliasParams = tcDepTypeAliasParams;

let tcExternTypeParams = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcExternTypeParams = tcExternTypeParams;

let tcContractNames = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcContractNames = tcContractNames;

let tcDestructorAliasByAlias = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcDestructorAliasByAlias = tcDestructorAliasByAlias;

let tcDestructorAliasNames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcDestructorAliasNames = tcDestructorAliasNames;

let tcAliasBaseType = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcAliasBaseType = tcAliasBaseType;

let tcFnThisFields = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcFnThisFields = tcFnThisFields;

const __tuff_outer_for_typeNodeIsDestructorReceiver = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typeNodeIsDestructorReceiver(t, aliasName) {
  let __tuff_this = { t: t, aliasName: aliasName, this: __tuff_outer_for_typeNodeIsDestructorReceiver };
  if ((t === 0)) {
  return false;
}
  if (((nodeKind(t) === NK_NAMED_TYPE) && (() => { const __recv = getInternedStr(nodeGetData1(t)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, aliasName) : strEq(__recv, aliasName); })())) {
  return true;
}
  if (((nodeKind(t) === NK_POINTER_TYPE) && (nodeGetData3(t) === 1))) {
  return (() => { const __recv = typeNameFromTypeNode(nodeGetData2(t)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, aliasName) : strEq(__recv, aliasName); })();
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typeNodeIsDestructorReceiver = typeNodeIsDestructorReceiver;

const __tuff_outer_for_collectUnionNamedTags = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function collectUnionNamedTags(typeNode, tags) {
  let __tuff_this = { typeNode: typeNode, tags: tags, this: __tuff_outer_for_collectUnionNamedTags };
  if ((typeNode === 0)) {
  return 0;
}
  let kind = nodeKind(typeNode); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_UNION_TYPE)) {
  collectUnionNamedTags(nodeGetData1(typeNode), tags);
  collectUnionNamedTags(nodeGetData2(typeNode), tags);
  return 0;
}
  if ((kind === NK_NAMED_TYPE)) {
  (() => { const __recv = tags; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(typeNode))); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(typeNode))) : vecPush(__recv, getInternedStr(nodeGetData1(typeNode))); })();
  return 0;
}
  if ((kind === NK_REFINEMENT_TYPE)) {
  collectUnionNamedTags(nodeGetData1(typeNode), tags);
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.collectUnionNamedTags = collectUnionNamedTags;

const __tuff_outer_for_tryGetNonnegativeIntegerLiteral = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tryGetNonnegativeIntegerLiteral(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_tryGetNonnegativeIntegerLiteral };
  if (((n === 0) || (nodeKind(n) !== NK_NUMBER_LIT))) {
  return (-1);
}
  let text = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  if (strEndsWithLocal(text, "USize")) {
  let len = (() => { const __recv = text; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len < 5)) {
  return (-1);
}
  let raw = (() => { const __recv = text; const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(0, (len - 5)); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, 0, (len - 5)) : strSlice(__recv, 0, (len - 5)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.raw = raw;
  if ((!isDecimalDigits(raw))) {
  return (-1);
}
  return parseInt(raw);
}
  if ((!isDecimalDigits(text))) {
  return (-1);
}
  return parseInt(text);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tryGetNonnegativeIntegerLiteral = tryGetNonnegativeIntegerLiteral;

const __tuff_outer_for_tryGetArrayInitBoundFromTypeNode = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tryGetArrayInitBoundFromTypeNode(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_tryGetArrayInitBoundFromTypeNode };
  if ((t === 0)) {
  return (-1);
}
  let k = nodeKind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_REFINEMENT_TYPE)) {
  return tryGetArrayInitBoundFromTypeNode(nodeGetData1(t));
}
  if ((k === NK_POINTER_TYPE)) {
  return tryGetArrayInitBoundFromTypeNode(nodeGetData2(t));
}
  if ((k === NK_ARRAY_TYPE)) {
  return tryGetNonnegativeIntegerLiteral(nodeGetData2(t));
}
  return (-1);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tryGetArrayInitBoundFromTypeNode = tryGetArrayInitBoundFromTypeNode;

const __tuff_outer_for_tryGetIndexUpperBoundFromTypeNode = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tryGetIndexUpperBoundFromTypeNode(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_tryGetIndexUpperBoundFromTypeNode };
  if (((t === 0) || (nodeKind(t) !== NK_REFINEMENT_TYPE))) {
  return (-1);
}
  let base = nodeGetData1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  if (((base === 0) || (nodeKind(base) !== NK_NAMED_TYPE))) {
  return (-1);
}
  let baseName = getInternedStr(nodeGetData1(base)); if (typeof __tuff_this !== 'undefined') __tuff_this.baseName = baseName;
  if ((!(() => { const __recv = baseName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "USize") : strEq(__recv, "USize"); })())) {
  return (-1);
}
  let lit = tryGetNonnegativeIntegerLiteral(nodeGetData3(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.lit = lit;
  if ((lit < 0)) {
  return (-1);
}
  let op = getInternedStr(nodeGetData2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<") : strEq(__recv, "<"); })()) {
  return (lit - 1);
}
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<=") : strEq(__recv, "<="); })()) {
  return lit;
}
  return (-1);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tryGetIndexUpperBoundFromTypeNode = tryGetIndexUpperBoundFromTypeNode;

const __tuff_outer_for_isZeroNumericLiteralNode = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isZeroNumericLiteralNode(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_isZeroNumericLiteralNode };
  if (((n === 0) || (nodeKind(n) !== NK_NUMBER_LIT))) {
  return false;
}
  let text = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  return ((() => { const __recv = text; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("0"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "0") : strEq(__recv, "0"); })() || (() => { const __recv = text; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("0USize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "0USize") : strEq(__recv, "0USize"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isZeroNumericLiteralNode = isZeroNumericLiteralNode;

const __tuff_outer_for_tryExtractFnCallConstraint = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function tryExtractFnCallConstraint(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_tryExtractFnCallConstraint };
  if (((t === 0) || (nodeKind(t) !== NK_REFINEMENT_TYPE))) {
  return "";
}
  let base = nodeGetData1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  if (((base === 0) || (nodeKind(base) !== NK_NAMED_TYPE))) {
  return "";
}
  let baseName = getInternedStr(nodeGetData1(base)); if (typeof __tuff_this !== 'undefined') __tuff_this.baseName = baseName;
  if ((((!(() => { const __recv = baseName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "USize") : strEq(__recv, "USize"); })()) && (!(() => { const __recv = baseName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I32") : strEq(__recv, "I32"); })())) && (!(() => { const __recv = baseName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("ISize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "ISize") : strEq(__recv, "ISize"); })()))) {
  return "";
}
  let op = getInternedStr(nodeGetData2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((!(() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<") : strEq(__recv, "<"); })()) && (!(() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<=") : strEq(__recv, "<="); })()))) {
  return "";
}
  let constraintExpr = nodeGetData3(t); if (typeof __tuff_this !== 'undefined') __tuff_this.constraintExpr = constraintExpr;
  if (((constraintExpr === 0) || (nodeKind(constraintExpr) !== NK_CALL_EXPR))) {
  return "";
}
  let callee = nodeGetData1(constraintExpr); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  let args = nodeGetData2(constraintExpr); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((callee === 0) || (nodeKind(callee) !== NK_IDENTIFIER))) {
  return "";
}
  if (((() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() !== 1)) {
  return "";
}
  let arg0 = (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.arg0 = arg0;
  if (((arg0 === 0) || (nodeKind(arg0) !== NK_IDENTIFIER))) {
  return "";
}
  let fnName = getInternedStr(nodeGetData1(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.fnName = fnName;
  let refParamName = getInternedStr(nodeGetData1(arg0)); if (typeof __tuff_this !== 'undefined') __tuff_this.refParamName = refParamName;
  return (() => { const __recv = (() => { const __recv = fnName; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(refParamName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, refParamName) : strConcat(__recv, refParamName); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.tryExtractFnCallConstraint = tryExtractFnCallConstraint;

const __tuff_outer_for_isExternTypeLikeDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isExternTypeLikeDecl(stmt) {
  let __tuff_this = { stmt: stmt, this: __tuff_outer_for_isExternTypeLikeDecl };
  if ((stmt === 0)) {
  return false;
}
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_EXTERN_TYPE_DECL)) {
  return true;
}
  if (((kind === NK_TYPE_ALIAS) && (nodeGetData3(stmt) === 0))) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isExternTypeLikeDecl = isExternTypeLikeDecl;

const __tuff_outer_for_exprIsProvenNonzero = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function exprIsProvenNonzero(n, nonnullPtrs) {
  let __tuff_this = { n: n, nonnullPtrs: nonnullPtrs, this: __tuff_outer_for_exprIsProvenNonzero };
  if (exprIsNumberLiteralNonzero(n)) {
  return true;
}
  if (((n !== 0) && (nodeKind(n) === NK_IDENTIFIER))) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })();
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.exprIsProvenNonzero = exprIsProvenNonzero;

const __tuff_outer_for_typeNodeProvesNonzero = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typeNodeProvesNonzero(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_typeNodeProvesNonzero };
  if (((t === 0) || (nodeKind(t) !== NK_REFINEMENT_TYPE))) {
  return false;
}
  let op = getInternedStr(nodeGetData2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if ((!(() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "!=") : strEq(__recv, "!="); })())) {
  return false;
}
  return isZeroNumericLiteralNode(nodeGetData3(t));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typeNodeProvesNonzero = typeNodeProvesNonzero;

const __tuff_outer_for_typecheckIfExprBranch = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheckIfExprBranch(n, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs) {
  let __tuff_this = { n: n, fnArities: fnArities, fnParamTypes: fnParamTypes, fnReturnTypes: fnReturnTypes, localTypes: localTypes, nonnullPtrs: nonnullPtrs, this: __tuff_outer_for_typecheckIfExprBranch };
  let cond = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  typecheckExpr(cond, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  let condName = inferExprTypeName(cond, fnReturnTypes, localTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.condName = condName;
  if (((!(() => { const __recv = condName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Bool"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Bool") : strEq(__recv, "Bool"); })()) && (!(() => { const __recv = condName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Unknown") : strEq(__recv, "Unknown"); })()))) {
  return tcResultError("E_TYPE_IF_CONDITION", (() => { const __recv = "if condition must be Bool, got "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(condName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, condName) : strConcat(__recv, condName); })(), "Conditional branches require a boolean predicate, but the given expression has a non-Bool type.", "Return or compute a Bool expression in the if condition.");
}
  let ieThenKey = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.ieThenKey = ieThenKey;
  let ieElseKey = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.ieElseKey = ieElseKey;
  let ieCbKey = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.ieCbKey = ieCbKey;
  let ieCbValue = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.ieCbValue = ieCbValue;
  if ((nodeKind(cond) === NK_BINARY_EXPR)) {
  let bop = getInternedStr(nodeGetData1(cond)); if (typeof __tuff_this !== 'undefined') __tuff_this.bop = bop;
  let bleft = nodeGetData2(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.bleft = bleft;
  let bright = nodeGetData3(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.bright = bright;
  if ((() => { const __recv = bop; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "!=") : strEq(__recv, "!="); })()) {
  if ((((() => { const __recv = ieThenKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })() && (nodeKind(bleft) === NK_IDENTIFIER)) && (isUsizeZeroLiteralNode(bright) || isZeroNumericLiteralNode(bright)))) {
  ieThenKey = getInternedStr(nodeGetData1(bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.ieThenKey = ieThenKey;
}
  if ((((() => { const __recv = ieThenKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })() && (nodeKind(bright) === NK_IDENTIFIER)) && (isUsizeZeroLiteralNode(bleft) || isZeroNumericLiteralNode(bleft)))) {
  ieThenKey = getInternedStr(nodeGetData1(bright)); if (typeof __tuff_this !== 'undefined') __tuff_this.ieThenKey = ieThenKey;
}
}
  if ((() => { const __recv = bop; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("=="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "==") : strEq(__recv, "=="); })()) {
  if ((((() => { const __recv = ieElseKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })() && (nodeKind(bleft) === NK_IDENTIFIER)) && isZeroNumericLiteralNode(bright))) {
  ieElseKey = getInternedStr(nodeGetData1(bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.ieElseKey = ieElseKey;
}
  if ((((() => { const __recv = ieElseKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })() && (nodeKind(bright) === NK_IDENTIFIER)) && isZeroNumericLiteralNode(bleft))) {
  ieElseKey = getInternedStr(nodeGetData1(bright)); if (typeof __tuff_this !== 'undefined') __tuff_this.ieElseKey = ieElseKey;
}
}
  if (((((() => { const __recv = bop; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<") : strEq(__recv, "<"); })() || (() => { const __recv = bop; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<=") : strEq(__recv, "<="); })()) && (nodeKind(bleft) === NK_IDENTIFIER)) && (nodeKind(bright) === NK_CALL_EXPR))) {
  let ieCbCallee = nodeGetData1(bright); if (typeof __tuff_this !== 'undefined') __tuff_this.ieCbCallee = ieCbCallee;
  let ieCbArgs = nodeGetData2(bright); if (typeof __tuff_this !== 'undefined') __tuff_this.ieCbArgs = ieCbArgs;
  if ((((nodeKind(ieCbCallee) === NK_IDENTIFIER) && ((() => { const __recv = ieCbArgs; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 1)) && (nodeKind((() => { const __recv = ieCbArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()) === NK_IDENTIFIER))) {
  ieCbKey = getInternedStr(nodeGetData1(bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.ieCbKey = ieCbKey;
  ieCbValue = (() => { const __recv = (() => { const __recv = getInternedStr(nodeGetData1(ieCbCallee)); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1((() => { const __recv = ieCbArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1((() => { const __recv = ieCbArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))) : strConcat(__recv, getInternedStr(nodeGetData1((() => { const __recv = ieCbArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ieCbValue = ieCbValue;
}
}
}
  let ieThenPresent = false; if (typeof __tuff_this !== 'undefined') __tuff_this.ieThenPresent = ieThenPresent;
  if ((!(() => { const __recv = ieThenKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  ieThenPresent = (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(ieThenKey); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, ieThenKey) : mapHas(__recv, ieThenKey); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ieThenPresent = ieThenPresent;
  (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(ieThenKey, 1); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, ieThenKey, 1) : mapSet(__recv, ieThenKey, 1); })();
}
  let ieCbWasPresent = false; if (typeof __tuff_this !== 'undefined') __tuff_this.ieCbWasPresent = ieCbWasPresent;
  if ((!(() => { const __recv = ieCbKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  ieCbWasPresent = (() => { const __recv = tcCallBounds; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(ieCbKey); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, ieCbKey) : mapHas(__recv, ieCbKey); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ieCbWasPresent = ieCbWasPresent;
  (() => { const __recv = tcCallBounds; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(ieCbKey, ieCbValue); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, ieCbKey, ieCbValue) : mapSet(__recv, ieCbKey, ieCbValue); })();
}
  typecheckStmt(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, "Unknown");
  if (((!(() => { const __recv = ieThenKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) && (!ieThenPresent))) {
  (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapDelete"]; if (typeof __prop === "function") return __prop(ieThenKey); const __dyn = __recv?.table?.mapDelete; return __dyn ? __dyn(__recv.ref, ieThenKey) : mapDelete(__recv, ieThenKey); })();
}
  if (((!(() => { const __recv = ieCbKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) && (!ieCbWasPresent))) {
  (() => { const __recv = tcCallBounds; const __prop = __recv?.["mapDelete"]; if (typeof __prop === "function") return __prop(ieCbKey); const __dyn = __recv?.table?.mapDelete; return __dyn ? __dyn(__recv.ref, ieCbKey) : mapDelete(__recv, ieCbKey); })();
}
  if ((nodeGetData3(n) !== 0)) {
  let ieElsePresent = false; if (typeof __tuff_this !== 'undefined') __tuff_this.ieElsePresent = ieElsePresent;
  if ((!(() => { const __recv = ieElseKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  ieElsePresent = (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(ieElseKey); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, ieElseKey) : mapHas(__recv, ieElseKey); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ieElsePresent = ieElsePresent;
  (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(ieElseKey, 1); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, ieElseKey, 1) : mapSet(__recv, ieElseKey, 1); })();
}
  typecheckStmt(nodeGetData3(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, "Unknown");
  if (((!(() => { const __recv = ieElseKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) && (!ieElsePresent))) {
  (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapDelete"]; if (typeof __prop === "function") return __prop(ieElseKey); const __dyn = __recv?.table?.mapDelete; return __dyn ? __dyn(__recv.ref, ieElseKey) : mapDelete(__recv, ieElseKey); })();
}
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheckIfExprBranch = typecheckIfExprBranch;

const __tuff_outer_for_typecheckMatchExprBranch = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheckMatchExprBranch(n, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs) {
  let __tuff_this = { n: n, fnArities: fnArities, fnParamTypes: fnParamTypes, fnReturnTypes: fnReturnTypes, localTypes: localTypes, nonnullPtrs: nonnullPtrs, this: __tuff_outer_for_typecheckMatchExprBranch };
  let target = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  typecheckExpr(target, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  let targetName = inferExprTypeName(target, fnReturnTypes, localTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.targetName = targetName;
  let expectedTags = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedTags = expectedTags;
  if ((() => { const __recv = tcAliasUnionTags; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(targetName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, targetName) : mapHas(__recv, targetName); })()) {
  expectedTags = (() => { const __recv = tcAliasUnionTags; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(targetName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, targetName) : mapGet(__recv, targetName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedTags = expectedTags;
}
  let cases = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let seenTags = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.seenTags = seenTags;
  let hasWildcard = false; if (typeof __tuff_this !== 'undefined') __tuff_this.hasWildcard = hasWildcard;
  while ((i < len)) {
  let caseNode = (() => { const __recv = cases; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.caseNode = caseNode;
  let pat = (() => { const __recv = caseNode; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  if ((nodeKind(pat) === NK_WILDCARD_PAT)) {
  hasWildcard = true; if (typeof __tuff_this !== 'undefined') __tuff_this.hasWildcard = hasWildcard;
}
  if (((nodeKind(pat) === NK_NAME_PAT) || (nodeKind(pat) === NK_STRUCT_PAT))) {
  (() => { const __recv = seenTags; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(pat))); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(pat))) : setAdd(__recv, getInternedStr(nodeGetData1(pat))); })();
}
  typecheckStmt((() => { const __recv = caseNode; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, "Unknown");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  if ((((() => { const __recv = expectedTags; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > 0) && (!hasWildcard))) {
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let jlen = (() => { const __recv = expectedTags; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.jlen = jlen;
  while ((j < jlen)) {
  let tag = (() => { const __recv = expectedTags; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tag = tag;
  if ((!(() => { const __recv = seenTags; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(tag); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, tag) : setHas(__recv, tag); })())) {
  return tcResultError("E_TYPE_MATCH_NON_EXHAUSTIVE", (() => { const __recv = "Non-exhaustive match: missing case for "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(tag); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, tag) : strConcat(__recv, tag); })(), "A match expression over a known union type does not handle all variants.", "Add missing case arms or include a wildcard case '_'.");
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheckMatchExprBranch = typecheckMatchExprBranch;

const __tuff_outer_for_typecheckIfStmtBranch = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheckIfStmtBranch(n, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, expectedReturnType) {
  let __tuff_this = { n: n, fnArities: fnArities, fnParamTypes: fnParamTypes, fnReturnTypes: fnReturnTypes, localTypes: localTypes, nonnullPtrs: nonnullPtrs, expectedReturnType: expectedReturnType, this: __tuff_outer_for_typecheckIfStmtBranch };
  let cond = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  typecheckExpr(cond, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  let condName = inferExprTypeName(cond, fnReturnTypes, localTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.condName = condName;
  if (((!(() => { const __recv = condName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Bool"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Bool") : strEq(__recv, "Bool"); })()) && (!(() => { const __recv = condName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Unknown") : strEq(__recv, "Unknown"); })()))) {
  return tcResultError("E_TYPE_IF_CONDITION", (() => { const __recv = "if condition must be Bool, got "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(condName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, condName) : strConcat(__recv, condName); })(), "Conditional branches require a boolean predicate, but the given expression has a non-Bool type.", "Return or compute a Bool expression in the if condition.");
}
  let thenInjectKey = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.thenInjectKey = thenInjectKey;
  let elseInjectKey = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.elseInjectKey = elseInjectKey;
  let cbThenKey = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.cbThenKey = cbThenKey;
  let cbThenValue = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.cbThenValue = cbThenValue;
  if ((nodeKind(cond) === NK_BINARY_EXPR)) {
  let bop = getInternedStr(nodeGetData1(cond)); if (typeof __tuff_this !== 'undefined') __tuff_this.bop = bop;
  let bleft = nodeGetData2(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.bleft = bleft;
  let bright = nodeGetData3(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.bright = bright;
  if ((() => { const __recv = bop; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "!=") : strEq(__recv, "!="); })()) {
  if ((((() => { const __recv = thenInjectKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })() && (nodeKind(bleft) === NK_IDENTIFIER)) && (isUsizeZeroLiteralNode(bright) || isZeroNumericLiteralNode(bright)))) {
  thenInjectKey = getInternedStr(nodeGetData1(bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.thenInjectKey = thenInjectKey;
}
  if ((((() => { const __recv = thenInjectKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })() && (nodeKind(bright) === NK_IDENTIFIER)) && (isUsizeZeroLiteralNode(bleft) || isZeroNumericLiteralNode(bleft)))) {
  thenInjectKey = getInternedStr(nodeGetData1(bright)); if (typeof __tuff_this !== 'undefined') __tuff_this.thenInjectKey = thenInjectKey;
}
}
  if ((() => { const __recv = bop; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("=="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "==") : strEq(__recv, "=="); })()) {
  if ((((() => { const __recv = elseInjectKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })() && (nodeKind(bleft) === NK_IDENTIFIER)) && isZeroNumericLiteralNode(bright))) {
  elseInjectKey = getInternedStr(nodeGetData1(bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.elseInjectKey = elseInjectKey;
}
  if ((((() => { const __recv = elseInjectKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })() && (nodeKind(bright) === NK_IDENTIFIER)) && isZeroNumericLiteralNode(bleft))) {
  elseInjectKey = getInternedStr(nodeGetData1(bright)); if (typeof __tuff_this !== 'undefined') __tuff_this.elseInjectKey = elseInjectKey;
}
}
  if (((((() => { const __recv = bop; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<") : strEq(__recv, "<"); })() || (() => { const __recv = bop; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<=") : strEq(__recv, "<="); })()) && (nodeKind(bleft) === NK_IDENTIFIER)) && (nodeKind(bright) === NK_CALL_EXPR))) {
  let cbCallee = nodeGetData1(bright); if (typeof __tuff_this !== 'undefined') __tuff_this.cbCallee = cbCallee;
  let cbArgs = nodeGetData2(bright); if (typeof __tuff_this !== 'undefined') __tuff_this.cbArgs = cbArgs;
  if ((((nodeKind(cbCallee) === NK_IDENTIFIER) && ((() => { const __recv = cbArgs; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 1)) && (nodeKind((() => { const __recv = cbArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()) === NK_IDENTIFIER))) {
  cbThenKey = getInternedStr(nodeGetData1(bleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.cbThenKey = cbThenKey;
  cbThenValue = (() => { const __recv = (() => { const __recv = getInternedStr(nodeGetData1(cbCallee)); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1((() => { const __recv = cbArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1((() => { const __recv = cbArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))) : strConcat(__recv, getInternedStr(nodeGetData1((() => { const __recv = cbArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cbThenValue = cbThenValue;
}
}
}
  let narrowedIdent = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.narrowedIdent = narrowedIdent;
  let hadPrevNarrowed = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.hadPrevNarrowed = hadPrevNarrowed;
  let prevNarrowedType = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.prevNarrowedType = prevNarrowedType;
  if ((nodeKind(cond) === NK_IS_EXPR)) {
  let subject = nodeGetData1(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.subject = subject;
  let pat = nodeGetData2(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  if (((nodeKind(subject) === NK_IDENTIFIER) && ((nodeKind(pat) === NK_NAME_PAT) || (nodeKind(pat) === NK_STRUCT_PAT)))) {
  narrowedIdent = getInternedStr(nodeGetData1(subject)); if (typeof __tuff_this !== 'undefined') __tuff_this.narrowedIdent = narrowedIdent;
  let narrowedType = getInternedStr(nodeGetData1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.narrowedType = narrowedType;
  if ((() => { const __recv = localTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(narrowedIdent); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, narrowedIdent) : mapHas(__recv, narrowedIdent); })()) {
  hadPrevNarrowed = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.hadPrevNarrowed = hadPrevNarrowed;
  prevNarrowedType = (() => { const __recv = localTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(narrowedIdent); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, narrowedIdent) : mapGet(__recv, narrowedIdent); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.prevNarrowedType = prevNarrowedType;
}
  (() => { const __recv = localTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(narrowedIdent, narrowedType); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, narrowedIdent, narrowedType) : mapSet(__recv, narrowedIdent, narrowedType); })();
}
}
  let thenWasPresent = false; if (typeof __tuff_this !== 'undefined') __tuff_this.thenWasPresent = thenWasPresent;
  if ((!(() => { const __recv = thenInjectKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  thenWasPresent = (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(thenInjectKey); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, thenInjectKey) : mapHas(__recv, thenInjectKey); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.thenWasPresent = thenWasPresent;
  (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(thenInjectKey, 1); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, thenInjectKey, 1) : mapSet(__recv, thenInjectKey, 1); })();
}
  let cbThenWasPresent = false; if (typeof __tuff_this !== 'undefined') __tuff_this.cbThenWasPresent = cbThenWasPresent;
  if ((!(() => { const __recv = cbThenKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  cbThenWasPresent = (() => { const __recv = tcCallBounds; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(cbThenKey); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, cbThenKey) : mapHas(__recv, cbThenKey); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cbThenWasPresent = cbThenWasPresent;
  (() => { const __recv = tcCallBounds; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(cbThenKey, cbThenValue); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, cbThenKey, cbThenValue) : mapSet(__recv, cbThenKey, cbThenValue); })();
}
  typecheckStmt(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, expectedReturnType);
  if (((!(() => { const __recv = thenInjectKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) && (!thenWasPresent))) {
  (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapDelete"]; if (typeof __prop === "function") return __prop(thenInjectKey); const __dyn = __recv?.table?.mapDelete; return __dyn ? __dyn(__recv.ref, thenInjectKey) : mapDelete(__recv, thenInjectKey); })();
}
  if (((!(() => { const __recv = cbThenKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) && (!cbThenWasPresent))) {
  (() => { const __recv = tcCallBounds; const __prop = __recv?.["mapDelete"]; if (typeof __prop === "function") return __prop(cbThenKey); const __dyn = __recv?.table?.mapDelete; return __dyn ? __dyn(__recv.ref, cbThenKey) : mapDelete(__recv, cbThenKey); })();
}
  if ((!(() => { const __recv = narrowedIdent; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  if ((hadPrevNarrowed === 1)) {
  (() => { const __recv = localTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(narrowedIdent, prevNarrowedType); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, narrowedIdent, prevNarrowedType) : mapSet(__recv, narrowedIdent, prevNarrowedType); })();
} else {
  (() => { const __recv = localTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(narrowedIdent, "Unknown"); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, narrowedIdent, "Unknown") : mapSet(__recv, narrowedIdent, "Unknown"); })();
}
}
  if ((nodeGetData3(n) !== 0)) {
  let elseWasPresent = false; if (typeof __tuff_this !== 'undefined') __tuff_this.elseWasPresent = elseWasPresent;
  if ((!(() => { const __recv = elseInjectKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  elseWasPresent = (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(elseInjectKey); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, elseInjectKey) : mapHas(__recv, elseInjectKey); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.elseWasPresent = elseWasPresent;
  (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(elseInjectKey, 1); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, elseInjectKey, 1) : mapSet(__recv, elseInjectKey, 1); })();
}
  typecheckStmt(nodeGetData3(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, expectedReturnType);
  if (((!(() => { const __recv = elseInjectKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) && (!elseWasPresent))) {
  (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapDelete"]; if (typeof __prop === "function") return __prop(elseInjectKey); const __dyn = __recv?.table?.mapDelete; return __dyn ? __dyn(__recv.ref, elseInjectKey) : mapDelete(__recv, elseInjectKey); })();
}
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheckIfStmtBranch = typecheckIfStmtBranch;

const __tuff_outer_for_typecheckMemberOrIndexExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheckMemberOrIndexExpr(n, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs) {
  let __tuff_this = { n: n, fnArities: fnArities, fnParamTypes: fnParamTypes, fnReturnTypes: fnReturnTypes, localTypes: localTypes, nonnullPtrs: nonnullPtrs, this: __tuff_outer_for_typecheckMemberOrIndexExpr };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_MEMBER_EXPR)) {
  let obj = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.obj = obj;
  let objName = inferExprTypeName(obj, fnReturnTypes, localTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.objName = objName;
  if (isNullablePointerTypeName(objName)) {
  let guarded = false; if (typeof __tuff_this !== 'undefined') __tuff_this.guarded = guarded;
  if ((nodeKind(obj) === NK_IDENTIFIER)) {
  let oname = getInternedStr(nodeGetData1(obj)); if (typeof __tuff_this !== 'undefined') __tuff_this.oname = oname;
  guarded = (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(oname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, oname) : mapHas(__recv, oname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.guarded = guarded;
}
  if ((!guarded)) {
  return tcResultError("E_SAFETY_NULLABLE_POINTER_GUARD", "Nullable pointer access requires guard", "A nullable pointer must be proven non-null before pointer-consuming operations.", "Guard with if (p != 0USize) or if (0USize != p) before member access.");
}
}
  if ((() => { const __recv = objName; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("__this_"); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "__this_") : strStartsWith(__recv, "__this_"); })()) {
  let fnName = (() => { const __recv = objName; const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(7, (() => { const __recv = objName; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, 7, (() => { const __recv = objName; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()) : strSlice(__recv, 7, (() => { const __recv = objName; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnName = fnName;
  if ((() => { const __recv = tcFnThisFields; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(fnName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, fnName) : mapHas(__recv, fnName); })()) {
  let fieldNames = (() => { const __recv = tcFnThisFields; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(fnName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, fnName) : mapGet(__recv, fnName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fieldNames = fieldNames;
  let field = getInternedStr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  if ((!(() => { const __recv = fieldNames; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(field); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, field) : setHas(__recv, field); })())) {
  return tcResultError("E_TYPE_MEMBER_NOT_FOUND", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Field '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(field); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, field) : strConcat(__recv, field); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' does not exist on '"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' does not exist on '") : strConcat(__recv, "' does not exist on '"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fnName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fnName) : strConcat(__recv, fnName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' scope"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' scope") : strConcat(__recv, "' scope"); })(), "The function's 'this' struct does not declare the accessed field.", "Check that the field is declared in the function body or use a different access path.");
}
}
}
  typecheckExpr(nodeGetData1(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  if ((kind === NK_INDEX_EXPR)) {
  let targetNode = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.targetNode = targetNode;
  let targetName = inferExprTypeName(targetNode, fnReturnTypes, localTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.targetName = targetName;
  if (isNullablePointerTypeName(targetName)) {
  let guarded = false; if (typeof __tuff_this !== 'undefined') __tuff_this.guarded = guarded;
  if ((nodeKind(targetNode) === NK_IDENTIFIER)) {
  let tname = getInternedStr(nodeGetData1(targetNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.tname = tname;
  guarded = (() => { const __recv = nonnullPtrs; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(tname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, tname) : mapHas(__recv, tname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.guarded = guarded;
}
  if ((!guarded)) {
  return tcResultError("E_SAFETY_NULLABLE_POINTER_GUARD", "Nullable pointer indexing requires guard", "A nullable pointer must be proven non-null before pointer-consuming operations.", "Guard with if (p != 0USize) or if (0USize != p) before indexing.");
}
}
  if ((nodeKind(targetNode) === NK_IDENTIFIER)) {
  let tname = getInternedStr(nodeGetData1(targetNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.tname = tname;
  if ((() => { const __recv = tcArrayInitBounds; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(tname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, tname) : mapHas(__recv, tname); })()) {
  let bound = (() => { const __recv = tcArrayInitBounds; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(tname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, tname) : mapGet(__recv, tname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.bound = bound;
  if ((bound >= 0)) {
  let indexNode = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.indexNode = indexNode;
  let indexMax = (-1); if (typeof __tuff_this !== 'undefined') __tuff_this.indexMax = indexMax;
  if ((nodeKind(indexNode) === NK_IDENTIFIER)) {
  let iname = getInternedStr(nodeGetData1(indexNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.iname = iname;
  if ((() => { const __recv = tcIndexUpperBounds; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(iname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, iname) : mapHas(__recv, iname); })()) {
  indexMax = (() => { const __recv = tcIndexUpperBounds; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(iname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, iname) : mapGet(__recv, iname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.indexMax = indexMax;
}
}
  if ((indexMax < 0)) {
  indexMax = tryGetNonnegativeIntegerLiteral(indexNode); if (typeof __tuff_this !== 'undefined') __tuff_this.indexMax = indexMax;
}
  if ((indexMax < 0)) {
  tcPanicLoc("E_SAFETY_ARRAY_BOUNDS_UNPROVEN", "Cannot prove array index bound safety", "The array index does not have a proven upper bound under strict safety checks.", "Guard index with 'if (i < arr.length)' before indexing.");
}
  if ((indexMax >= bound)) {
  tcPanicLoc("E_SAFETY_ARRAY_BOUNDS", "Array index may be out of bounds", "The proven index upper bound can exceed initialized array length.", "Ensure 0 <= index < initialized length.");
}
}
}
}
  typecheckExpr(nodeGetData1(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  typecheckExpr(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  return ((typeof Ok === "function") ? Ok({value: 1}) : ({ __tag: "Ok", value: 1 }));
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheckMemberOrIndexExpr = typecheckMemberOrIndexExpr;

const __tuff_outer_for_typecheckExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheckExpr(n, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs) {
  let __tuff_this = { n: n, fnArities: fnArities, fnParamTypes: fnParamTypes, fnReturnTypes: fnReturnTypes, localTypes: localTypes, nonnullPtrs: nonnullPtrs, this: __tuff_outer_for_typecheckExpr };
  if ((n === 0)) {
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  tcCurrentNode = n; if (typeof __tuff_this !== 'undefined') __tuff_this.tcCurrentNode = tcCurrentNode;
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_BINARY_EXPR)) {
  typecheckExpr(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  typecheckExpr(nodeGetData3(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  let op = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("/"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "/") : strEq(__recv, "/"); })() && (!exprIsProvenNonzero(nodeGetData3(n), nonnullPtrs)))) {
  let denomNode = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.denomNode = denomNode;
  let denomDesc = "denominator"; if (typeof __tuff_this !== 'undefined') __tuff_this.denomDesc = denomDesc;
  if ((nodeKind(denomNode) === NK_IDENTIFIER)) {
  denomDesc = (() => { const __recv = (() => { const __recv = "denominator `"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(denomNode))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(denomNode))) : strConcat(__recv, getInternedStr(nodeGetData1(denomNode))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("`"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "`") : strConcat(__recv, "`"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.denomDesc = denomDesc;
}
  tcPanicLoc("E_SAFETY_DIV_BY_ZERO", "Division by zero cannot be ruled out at compile time", (() => { const __recv = (() => { const __recv = "The "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(denomDesc); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, denomDesc) : strConcat(__recv, denomDesc); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" is not proven non-zero; any value including 0 is possible."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " is not proven non-zero; any value including 0 is possible.") : strConcat(__recv, " is not proven non-zero; any value including 0 is possible."); })(), "Prove denominator != 0 via refinement type or control-flow guard.");
}
  if (((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("%"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "%") : strEq(__recv, "%"); })() && (!exprIsProvenNonzero(nodeGetData3(n), nonnullPtrs)))) {
  let modNode = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.modNode = modNode;
  let modDesc = "modulo denominator"; if (typeof __tuff_this !== 'undefined') __tuff_this.modDesc = modDesc;
  if ((nodeKind(modNode) === NK_IDENTIFIER)) {
  modDesc = (() => { const __recv = (() => { const __recv = "modulo denominator `"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(modNode))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(modNode))) : strConcat(__recv, getInternedStr(nodeGetData1(modNode))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("`"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "`") : strConcat(__recv, "`"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.modDesc = modDesc;
}
  return tcResultError("E_SAFETY_MOD_BY_ZERO", "Modulo by zero cannot be ruled out at compile time", (() => { const __recv = (() => { const __recv = "The "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(modDesc); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, modDesc) : strConcat(__recv, modDesc); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" is not proven non-zero; any value including 0 is possible."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " is not proven non-zero; any value including 0 is possible.") : strConcat(__recv, " is not proven non-zero; any value including 0 is possible."); })(), "Prove denominator != 0 via refinement type or control-flow guard.");
}
  if ((((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("+"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "+") : strEq(__recv, "+"); })() || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "-") : strEq(__recv, "-"); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "*") : strEq(__recv, "*"); })())) {
  let lnode = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.lnode = lnode;
  let rnode = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.rnode = rnode;
  let left = tryGetKnownIntValue(lnode); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  let right = tryGetKnownIntValue(rnode); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  if ((knownIntValueIsValid(left) && knownIntValueIsValid(right))) {
  let result = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("+"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "+") : strEq(__recv, "+"); })()) {
  result = (left + right); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
} else { if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "-") : strEq(__recv, "-"); })()) {
  result = (left - right); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
} else {
  result = (left * right); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
} }
  if (((result < (-2147483648)) || (result > 2147483647))) {
  let leftDesc = intToString(left); if (typeof __tuff_this !== 'undefined') __tuff_this.leftDesc = leftDesc;
  let rightDesc = intToString(right); if (typeof __tuff_this !== 'undefined') __tuff_this.rightDesc = rightDesc;
  if ((nodeKind(lnode) === NK_IDENTIFIER)) {
  leftDesc = (() => { const __recv = (() => { const __recv = getInternedStr(nodeGetData1(lnode)); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "=") : strConcat(__recv, "="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(left)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(left)) : strConcat(__recv, intToString(left)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.leftDesc = leftDesc;
}
  if ((nodeKind(rnode) === NK_IDENTIFIER)) {
  rightDesc = (() => { const __recv = (() => { const __recv = getInternedStr(nodeGetData1(rnode)); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "=") : strConcat(__recv, "="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(right)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(right)) : strConcat(__recv, intToString(right)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.rightDesc = rightDesc;
}
  let witness = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = leftDesc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, op) : strConcat(__recv, op); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(rightDesc); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, rightDesc) : strConcat(__recv, rightDesc); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(result)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(result)) : strConcat(__recv, intToString(result)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(", which is outside I32 range [-2147483648, 2147483647]"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ", which is outside I32 range [-2147483648, 2147483647]") : strConcat(__recv, ", which is outside I32 range [-2147483648, 2147483647]"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.witness = witness;
  tcPanicLoc("E_SAFETY_INTEGER_OVERFLOW", (() => { const __recv = (() => { const __recv = "Integer overflow/underflow proven possible for '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, op) : strConcat(__recv, op); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), witness, "Constrain operands or use a wider intermediate type before narrowing.");
}
}
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if (((kind === NK_UNARY_EXPR) || (kind === NK_UNWRAP_EXPR))) {
  if ((kind === NK_UNARY_EXPR)) {
  typecheckExpr(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
} else {
  typecheckExpr(nodeGetData1(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_CALL_EXPR)) {
  let callee = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let argCount = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.argCount = argCount;
  let fname = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if ((nodeKind(callee) === NK_IDENTIFIER)) {
  fname = getInternedStr(nodeGetData1(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if ((() => { const __recv = fname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("drop"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "drop") : strEq(__recv, "drop"); })()) {
  if ((argCount !== 1)) {
  return tcResultError("E_TYPE_ARG_COUNT", "drop expects exactly one argument", "The drop builtin requires one argument representing the value to drop.", "Call drop(value) with exactly one argument.");
}
  let target = (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let targetName = inferExprTypeName(target, fnReturnTypes, localTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.targetName = targetName;
  if ((!(() => { const __recv = tcDestructorAliasByAlias; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(targetName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, targetName) : mapHas(__recv, targetName); })())) {
  return tcResultError("E_TYPE_DESTRUCTOR_NOT_FOUND", (() => { const __recv = (() => { const __recv = "Type '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(targetName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, targetName) : strConcat(__recv, targetName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' does not have an associated destructor"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' does not have an associated destructor") : strConcat(__recv, "' does not have an associated destructor"); })(), "drop can only be called for values whose alias type declares a destructor.", "Define `type Alias = Base then destructorName;` and use that alias for dropped values.");
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if (((() => { const __recv = fname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "into") : strEq(__recv, "into"); })() && (nodeGetData3(n) === 1))) {
  if ((argCount < 1)) {
  return tcResultError("E_TYPE_ARG_COUNT", "into conversion requires a receiver", "Method-sugar into conversion requires a source value as receiver.", "Use value.into<Contract>(...) with a receiver value.");
}
  let typeArgs = nodeGetData4(n); if (typeof __tuff_this !== 'undefined') __tuff_this.typeArgs = typeArgs;
  let cname = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
  if ((((() => { const __recv = typeArgs; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 1) && (nodeKind((() => { const __recv = typeArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()) === NK_NAMED_TYPE))) {
  cname = getInternedStr(nodeGetData1((() => { const __recv = typeArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })())); if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
}
  let cnameDeclared = false; if (typeof __tuff_this !== 'undefined') __tuff_this.cnameDeclared = cnameDeclared;
  if ((!(() => { const __recv = cname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  cnameDeclared = (() => { const __recv = tcContractNames; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, cname) : setHas(__recv, cname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cnameDeclared = cnameDeclared;
}
  if (((() => { const __recv = cname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })() || (!cnameDeclared))) {
  let cnameLabel = cname; if (typeof __tuff_this !== 'undefined') __tuff_this.cnameLabel = cnameLabel;
  if ((() => { const __recv = cnameLabel; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) {
  cnameLabel = "<missing>"; if (typeof __tuff_this !== 'undefined') __tuff_this.cnameLabel = cnameLabel;
}
  return tcResultError("E_TYPE_INTO_UNKNOWN_CONTRACT", (() => { const __recv = (() => { const __recv = "Unknown contract '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cnameLabel); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cnameLabel) : strConcat(__recv, cnameLabel); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' in into conversion"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' in into conversion") : strConcat(__recv, "' in into conversion"); })(), "An into conversion referenced a contract that is not declared.", "Declare the contract before converting with into.");
}
  typecheckExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  let j = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < argCount)) {
  typecheckExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((() => { const __recv = fnArities; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, fname) : mapHas(__recv, fname); })()) {
  let expected = (() => { const __recv = fnArities; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, fname) : mapGet(__recv, fname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expected = expected;
  if ((expected !== argCount)) {
  let msg = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Function "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = " expects "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(expected)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(expected)) : strConcat(__recv, intToString(expected)); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = " expects "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(expected)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(expected)) : strConcat(__recv, intToString(expected)); })()) : strConcat(__recv, (() => { const __recv = " expects "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(expected)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(expected)) : strConcat(__recv, intToString(expected)); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = " args, got "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(argCount)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(argCount)) : strConcat(__recv, intToString(argCount)); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = " args, got "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(argCount)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(argCount)) : strConcat(__recv, intToString(argCount)); })()) : strConcat(__recv, (() => { const __recv = " args, got "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(argCount)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(argCount)) : strConcat(__recv, intToString(argCount)); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.msg = msg;
  return tcResultError("E_TYPE_ARG_COUNT", msg, "A function call provided a different number of arguments than the function signature requires.", "Pass exactly the number of parameters declared by the function.");
}
}
  if (((!(() => { const __recv = fnArities; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, fname) : mapHas(__recv, fname); })()) && (() => { const __recv = tcDepTypeAliasParams; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, fname) : mapHas(__recv, fname); })())) {
  let expectedArity = (() => { const __recv = tcDepTypeAliasParams; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, fname) : mapGet(__recv, fname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedArity = expectedArity;
  if ((argCount !== expectedArity)) {
  tcPanicLoc("E_TYPE_APPLIED_ARITY", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "'"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' applied with "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' applied with ") : strConcat(__recv, "' applied with "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(argCount)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(argCount)) : strConcat(__recv, intToString(argCount)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" argument(s), expected "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " argument(s), expected ") : strConcat(__recv, " argument(s), expected "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(expectedArity)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(expectedArity)) : strConcat(__recv, intToString(expectedArity)); })(), "Dependent type aliases must be applied with exactly the number of arguments declared in the type parameter list.", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Provide exactly "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(expectedArity)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(expectedArity)) : strConcat(__recv, intToString(expectedArity)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" argument(s) to '"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " argument(s) to '") : strConcat(__recv, " argument(s) to '"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'.") : strConcat(__recv, "'."); })());
}
}
  if ((() => { const __recv = fnParamTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, fname) : mapHas(__recv, fname); })()) {
  let expectedTypes = (() => { const __recv = fnParamTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, fname) : mapGet(__recv, fname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedTypes = expectedTypes;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < argCount)) {
  let argNode = (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.argNode = argNode;
  let argName = inferExprTypeName(argNode, fnReturnTypes, localTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.argName = argName;
  let expectedName = (() => { const __recv = expectedTypes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedName = expectedName;
  if (((() => { const __recv = expectedName; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "*") : strStartsWith(__recv, "*"); })() && isNullablePointerTypeName(argName))) {
  return tcResultError("E_SAFETY_NULLABLE_POINTER_GUARD", "Call requires nullable pointer guard", "A nullable pointer argument must be proven non-null before pointer-consuming calls.", "Guard pointer use with if (p != 0USize) or if (0USize != p) before the call.");
}
  if (((!typeNamesCompatible(expectedName, argName, argNode)) && (!((() => { const __recv = tcTypeAliasNames; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(expectedName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, expectedName) : setHas(__recv, expectedName); })() && (!isBuiltinPrimitiveTypeName(expectedName)))))) {
  let msg = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Type mismatch in call to "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" arg "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " arg ") : strConcat(__recv, " arg "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((j + 1))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((j + 1))) : strConcat(__recv, intToString((j + 1))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(": expected "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ": expected ") : strConcat(__recv, ": expected "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(expectedName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, expectedName) : strConcat(__recv, expectedName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(", got "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ", got ") : strConcat(__recv, ", got "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(argName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, argName) : strConcat(__recv, argName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.msg = msg;
  tcPanicLoc("E_TYPE_ARG_MISMATCH", msg, "A function argument type does not match the corresponding parameter type.", "Update the call argument or function parameter type so both sides are compatible.");
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
}
  if ((() => { const __recv = fnParamCallBounds; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, fname) : mapHas(__recv, fname); })()) {
  let callBoundsVec = (() => { const __recv = fnParamCallBounds; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, fname) : mapGet(__recv, fname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.callBoundsVec = callBoundsVec;
  let cj = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cj = cj;
  while (((cj < (() => { const __recv = callBoundsVec; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()) && (cj < argCount))) {
  let cb = (() => { const __recv = callBoundsVec; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(cj); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, cj) : vecGet(__recv, cj); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cb = cb;
  if ((!(() => { const __recv = cb; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  if ((() => { const __recv = cb; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("__REFINE__"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "__REFINE__") : strEq(__recv, "__REFINE__"); })()) {
  let constrainedArg = (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(cj); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, cj) : vecGet(__recv, cj); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.constrainedArg = constrainedArg;
  let refinedOk = false; if (typeof __tuff_this !== 'undefined') __tuff_this.refinedOk = refinedOk;
  if ((((((() => { const __recv = fname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("str_slice"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "str_slice") : strEq(__recv, "str_slice"); })() && (cj === 0)) && (argCount >= 2)) && (nodeKind((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()) === NK_NUMBER_LIT)) && (() => { const __recv = getInternedStr(nodeGetData1((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })())); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("0"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "0") : strEq(__recv, "0"); })())) {
  refinedOk = true; if (typeof __tuff_this !== 'undefined') __tuff_this.refinedOk = refinedOk;
}
  if ((tryGetNonnegativeIntegerLiteral(constrainedArg) >= 0)) {
  refinedOk = true; if (typeof __tuff_this !== 'undefined') __tuff_this.refinedOk = refinedOk;
} else { if ((nodeKind(constrainedArg) === NK_IDENTIFIER)) {
  let constrainedName = getInternedStr(nodeGetData1(constrainedArg)); if (typeof __tuff_this !== 'undefined') __tuff_this.constrainedName = constrainedName;
  if (((() => { const __recv = tcIndexUpperBounds; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(constrainedName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, constrainedName) : mapHas(__recv, constrainedName); })() || (() => { const __recv = tcCallBounds; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(constrainedName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, constrainedName) : mapHas(__recv, constrainedName); })())) {
  refinedOk = true; if (typeof __tuff_this !== 'undefined') __tuff_this.refinedOk = refinedOk;
}
} }
  if ((!refinedOk)) {
  let msg = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Call to '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' argument "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' argument ") : strConcat(__recv, "' argument "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((cj + 1))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((cj + 1))) : strConcat(__recv, intToString((cj + 1))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" must satisfy its refinement constraint"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " must satisfy its refinement constraint") : strConcat(__recv, " must satisfy its refinement constraint"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.msg = msg;
  tcPanicLoc("E_SAFETY_STR_BOUNDS_UNPROVEN", msg, "The argument does not have a compile-time proof for the parameter refinement constraint.", "Provide a guard that proves the refinement before the call.");
}
  cj = (cj + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cj = cj;
  continue;
}
  let cbSep = (() => { const __recv = cb; const __prop = __recv?.["strIndexOf"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strIndexOf; return __dyn ? __dyn(__recv.ref, ":") : strIndexOf(__recv, ":"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cbSep = cbSep;
  if ((cbSep < 0)) {
  tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", (() => { const __recv = (() => { const __recv = "Malformed internal call-bound metadata for '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "The typechecker expected call-bound metadata in the form 'fnName:paramIndex' but the separator ':' was missing.", "Regenerate the program AST and ensure call-bound metadata is emitted as 'fnName:paramIndex'.");
}
  let cbLen = (() => { const __recv = cb; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cbLen = cbLen;
  if ((cbSep > cbLen)) {
  tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", (() => { const __recv = (() => { const __recv = "Malformed internal call-bound metadata for '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "The separator ':' index is outside the metadata string bounds.", "Regenerate the program AST and ensure call-bound metadata indexes are valid.");
}
  let cbFn = (() => { const __recv = cb; const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(0, cbSep); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, 0, cbSep) : strSlice(__recv, 0, cbSep); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cbFn = cbFn;
  let cbRefIdx = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cbRefIdx = cbRefIdx;
  let cbIdxPos = (cbSep + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cbIdxPos = cbIdxPos;
  let cbIdxHasDigit = false; if (typeof __tuff_this !== 'undefined') __tuff_this.cbIdxHasDigit = cbIdxHasDigit;
  while ((cbIdxPos < (() => { const __recv = cb; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })())) {
  let cbCh = (() => { const __recv = cb; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(cbIdxPos); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, cbIdxPos) : strCharAt(__recv, cbIdxPos); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cbCh = cbCh;
  if (((cbCh < 48) || (cbCh > 57))) {
  tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", (() => { const __recv = (() => { const __recv = "Malformed internal call-bound metadata for '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "The parameter index suffix in call-bound metadata must contain only decimal digits.", "Regenerate the program AST and ensure call-bound metadata suffixes are numeric.");
}
  cbRefIdx = ((cbRefIdx * 10) + (cbCh - 48)); if (typeof __tuff_this !== 'undefined') __tuff_this.cbRefIdx = cbRefIdx;
  cbIdxHasDigit = true; if (typeof __tuff_this !== 'undefined') __tuff_this.cbIdxHasDigit = cbIdxHasDigit;
  cbIdxPos = (cbIdxPos + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cbIdxPos = cbIdxPos;
}
  if ((!cbIdxHasDigit)) {
  tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", (() => { const __recv = (() => { const __recv = "Malformed internal call-bound metadata for '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "The call-bound metadata separator ':' was present, but no parameter index followed it.", "Regenerate the program AST and ensure metadata includes a numeric parameter index after ':'.");
}
  let constrainedArg = (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(cj); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, cj) : vecGet(__recv, cj); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.constrainedArg = constrainedArg;
  if ((((nodeKind(constrainedArg) === NK_IDENTIFIER) && (cbRefIdx >= 0)) && (cbRefIdx < argCount))) {
  let constrainedName = getInternedStr(nodeGetData1(constrainedArg)); if (typeof __tuff_this !== 'undefined') __tuff_this.constrainedName = constrainedName;
  let refArg = (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(cbRefIdx); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, cbRefIdx) : vecGet(__recv, cbRefIdx); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.refArg = refArg;
  if ((nodeKind(refArg) === NK_IDENTIFIER)) {
  let refArgName = getInternedStr(nodeGetData1(refArg)); if (typeof __tuff_this !== 'undefined') __tuff_this.refArgName = refArgName;
  let expectedBound = (() => { const __recv = (() => { const __recv = cbFn; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(refArgName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, refArgName) : strConcat(__recv, refArgName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedBound = expectedBound;
  let proven = ((() => { const __recv = tcCallBounds; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(constrainedName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, constrainedName) : mapHas(__recv, constrainedName); })() && (() => { const __recv = (() => { const __recv = tcCallBounds; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(constrainedName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, constrainedName) : mapGet(__recv, constrainedName); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(expectedBound); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, expectedBound) : strEq(__recv, expectedBound); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.proven = proven;
  if ((!proven)) {
  let msg = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Call to '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' argument "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' argument ") : strConcat(__recv, "' argument "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((cj + 1))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((cj + 1))) : strConcat(__recv, intToString((cj + 1))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" ('"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ('") : strConcat(__recv, " ('"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(constrainedName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, constrainedName) : strConcat(__recv, constrainedName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("')"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "')") : strConcat(__recv, "')"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" must be proven < "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " must be proven < ") : strConcat(__recv, " must be proven < "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cbFn); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cbFn) : strConcat(__recv, cbFn); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(refArgName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, refArgName) : strConcat(__recv, refArgName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.msg = msg;
  tcPanicLoc("E_SAFETY_STR_BOUNDS_UNPROVEN", msg, "The argument does not have a proven upper bound matching the parameter constraint.", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Guard the call with 'if ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(constrainedName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, constrainedName) : strConcat(__recv, constrainedName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" < "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " < ") : strConcat(__recv, " < "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cbFn); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cbFn) : strConcat(__recv, cbFn); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(refArgName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, refArgName) : strConcat(__recv, refArgName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("))' before calling "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "))' before calling ") : strConcat(__recv, "))' before calling "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })());
}
}
}
}
  cj = (cj + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cj = cj;
}
}
}
  typecheckExpr(callee, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < argCount)) {
  typecheckExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((typecheckMemberOrIndexExpr(n, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs) === 1)) {
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_STRUCT_INIT)) {
  let fields = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  typecheckExpr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_TUPLE_EXPR)) {
  let items = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = items; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  typecheckExpr((() => { const __recv = items; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_IF_EXPR)) {
  typecheckIfExprBranch(n, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_MATCH_EXPR)) {
  typecheckMatchExprBranch(n, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_IS_EXPR)) {
  typecheckExpr(nodeGetData1(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheckExpr = typecheckExpr;

const __tuff_outer_for_typecheckStmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheckStmt(n, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, expectedReturnType) {
  let __tuff_this = { n: n, fnArities: fnArities, fnParamTypes: fnParamTypes, fnReturnTypes: fnReturnTypes, localTypes: localTypes, nonnullPtrs: nonnullPtrs, expectedReturnType: expectedReturnType, this: __tuff_outer_for_typecheckStmt };
  if ((n === 0)) {
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  tcCurrentNode = n; if (typeof __tuff_this !== 'undefined') __tuff_this.tcCurrentNode = tcCurrentNode;
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_BLOCK)) {
  let stmts = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  typecheckStmt((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, expectedReturnType);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_EXPECT_FN_DECL)) {
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_CONTRACT_DECL)) {
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  let prevArrayBounds = tcArrayInitBounds; if (typeof __tuff_this !== 'undefined') __tuff_this.prevArrayBounds = prevArrayBounds;
  let prevIndexBounds = tcIndexUpperBounds; if (typeof __tuff_this !== 'undefined') __tuff_this.prevIndexBounds = prevIndexBounds;
  let prevVarLiterals = tcVarLiteralValues; if (typeof __tuff_this !== 'undefined') __tuff_this.prevVarLiterals = prevVarLiterals;
  tcArrayInitBounds = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcArrayInitBounds = tcArrayInitBounds;
  tcIndexUpperBounds = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcIndexUpperBounds = tcIndexUpperBounds;
  tcVarLiteralValues = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcVarLiteralValues = tcVarLiteralValues;
  let fnLocalTypes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnLocalTypes = fnLocalTypes;
  let fnNonnullPtrs = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnNonnullPtrs = fnNonnullPtrs;
  let params = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let p = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let pname = getInternedStr((() => { const __recv = p; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = (() => { const __recv = p; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if ((ptype !== 0)) {
  (() => { const __recv = fnLocalTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(pname, typeNameFromTypeNode(ptype)); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, pname, typeNameFromTypeNode(ptype)) : mapSet(__recv, pname, typeNameFromTypeNode(ptype)); })();
  let arrInitBound = tryGetArrayInitBoundFromTypeNode(ptype); if (typeof __tuff_this !== 'undefined') __tuff_this.arrInitBound = arrInitBound;
  if ((arrInitBound >= 0)) {
  (() => { const __recv = tcArrayInitBounds; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(pname, arrInitBound); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, pname, arrInitBound) : mapSet(__recv, pname, arrInitBound); })();
}
  let indexUpperBound = tryGetIndexUpperBoundFromTypeNode(ptype); if (typeof __tuff_this !== 'undefined') __tuff_this.indexUpperBound = indexUpperBound;
  if ((indexUpperBound >= 0)) {
  (() => { const __recv = tcIndexUpperBounds; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(pname, indexUpperBound); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, pname, indexUpperBound) : mapSet(__recv, pname, indexUpperBound); })();
}
  if (typeNodeProvesNonzero(ptype)) {
  (() => { const __recv = fnNonnullPtrs; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(pname, 1); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, pname, 1) : mapSet(__recv, pname, 1); })();
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let expectedName = typeNameFromTypeNode(nodeGetData4(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedName = expectedName;
  let fnBody = nodeGetData5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fnBody = fnBody;
  let fnameStr = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.fnameStr = fnameStr;
  let hasThisParam = false; if (typeof __tuff_this !== 'undefined') __tuff_this.hasThisParam = hasThisParam;
  let pi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.pi = pi;
  let __len3 = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len3 = __len3;
  while ((pi < __len3)) {
  if ((() => { const __recv = getInternedStr((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(pi); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, pi) : vecGet(__recv, pi); })(); const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })()) {
  hasThisParam = true; if (typeof __tuff_this !== 'undefined') __tuff_this.hasThisParam = hasThisParam;
}
  pi = (pi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.pi = pi;
}
  if (((!hasThisParam) && (nodeGetData4(n) === 0))) {
  let terminatesWithThis = false; if (typeof __tuff_this !== 'undefined') __tuff_this.terminatesWithThis = terminatesWithThis;
  if ((nodeKind(fnBody) === NK_BLOCK)) {
  let bodyStmts = nodeGetData1(fnBody); if (typeof __tuff_this !== 'undefined') __tuff_this.bodyStmts = bodyStmts;
  let blen = (() => { const __recv = bodyStmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.blen = blen;
  if ((blen > 0)) {
  let lastStmt = (() => { const __recv = bodyStmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((blen - 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (blen - 1)) : vecGet(__recv, (blen - 1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.lastStmt = lastStmt;
  if ((nodeKind(lastStmt) === NK_EXPR_STMT)) {
  let lastExpr = nodeGetData1(lastStmt); if (typeof __tuff_this !== 'undefined') __tuff_this.lastExpr = lastExpr;
  if (((nodeKind(lastExpr) === NK_IDENTIFIER) && (() => { const __recv = getInternedStr(nodeGetData1(lastExpr)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })())) {
  terminatesWithThis = true; if (typeof __tuff_this !== 'undefined') __tuff_this.terminatesWithThis = terminatesWithThis;
}
}
  if (((nodeKind(lastStmt) === NK_IDENTIFIER) && (() => { const __recv = getInternedStr(nodeGetData1(lastStmt)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })())) {
  terminatesWithThis = true; if (typeof __tuff_this !== 'undefined') __tuff_this.terminatesWithThis = terminatesWithThis;
}
}
} else { if ((nodeKind(fnBody) === NK_IDENTIFIER)) {
  if ((() => { const __recv = getInternedStr(nodeGetData1(fnBody)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })()) {
  terminatesWithThis = true; if (typeof __tuff_this !== 'undefined') __tuff_this.terminatesWithThis = terminatesWithThis;
}
} }
  if (terminatesWithThis) {
  let thisFields = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.thisFields = thisFields;
  (() => { const __recv = thisFields; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, "this") : setAdd(__recv, "this"); })();
  let qi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.qi = qi;
  let __len2 = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len2 = __len2;
  while ((qi < __len2)) {
  let pn = getInternedStr((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(qi); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, qi) : vecGet(__recv, qi); })(); const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pn = pn;
  if ((!(() => { const __recv = pn; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })())) {
  (() => { const __recv = thisFields; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(pn); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, pn) : setAdd(__recv, pn); })();
}
  qi = (qi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.qi = qi;
}
  if ((nodeKind(fnBody) === NK_BLOCK)) {
  let bodyStmts = nodeGetData1(fnBody); if (typeof __tuff_this !== 'undefined') __tuff_this.bodyStmts = bodyStmts;
  let bi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.bi = bi;
  let blen2 = (() => { const __recv = bodyStmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.blen2 = blen2;
  while ((bi < blen2)) {
  let bstmt = (() => { const __recv = bodyStmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(bi); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, bi) : vecGet(__recv, bi); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.bstmt = bstmt;
  let bkind = nodeKind(bstmt); if (typeof __tuff_this !== 'undefined') __tuff_this.bkind = bkind;
  if ((bkind === NK_LET_DECL)) {
  (() => { const __recv = thisFields; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(bstmt))); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(bstmt))) : setAdd(__recv, getInternedStr(nodeGetData1(bstmt))); })();
}
  if (((bkind === NK_FN_DECL) || (bkind === NK_CLASS_FN_DECL))) {
  (() => { const __recv = thisFields; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(bstmt))); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(bstmt))) : setAdd(__recv, getInternedStr(nodeGetData1(bstmt))); })();
}
  bi = (bi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.bi = bi;
}
}
  (() => { const __recv = tcFnThisFields; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(fnameStr, thisFields); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, fnameStr, thisFields) : mapSet(__recv, fnameStr, thisFields); })();
  (() => { const __recv = fnReturnTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(fnameStr, (() => { const __recv = "__this_"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fnameStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fnameStr) : strConcat(__recv, fnameStr); })()); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, fnameStr, (() => { const __recv = "__this_"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fnameStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fnameStr) : strConcat(__recv, fnameStr); })()) : mapSet(__recv, fnameStr, (() => { const __recv = "__this_"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fnameStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fnameStr) : strConcat(__recv, fnameStr); })()); })();
}
}
  typecheckStmt(nodeGetData5(n), fnArities, fnParamTypes, fnReturnTypes, fnLocalTypes, fnNonnullPtrs, expectedName);
  let body = nodeGetData5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if ((nodeKind(body) !== NK_BLOCK)) {
  let bodyName = inferExprTypeName(body, fnReturnTypes, fnLocalTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.bodyName = bodyName;
  if ((!typeNamesCompatible(expectedName, bodyName, body))) {
  let fname = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  return tcResultError("E_TYPE_RETURN_MISMATCH", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Function "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" return type mismatch: expected "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " return type mismatch: expected ") : strConcat(__recv, " return type mismatch: expected "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(expectedName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, expectedName) : strConcat(__recv, expectedName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(", got "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ", got ") : strConcat(__recv, ", got "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(bodyName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, bodyName) : strConcat(__recv, bodyName); })(), "The function body expression type does not match the declared return type.", "Update the function return type annotation or adjust the returned expression.");
}
}
  tcArrayInitBounds = prevArrayBounds; if (typeof __tuff_this !== 'undefined') __tuff_this.tcArrayInitBounds = tcArrayInitBounds;
  tcIndexUpperBounds = prevIndexBounds; if (typeof __tuff_this !== 'undefined') __tuff_this.tcIndexUpperBounds = tcIndexUpperBounds;
  tcVarLiteralValues = prevVarLiterals; if (typeof __tuff_this !== 'undefined') __tuff_this.tcVarLiteralValues = tcVarLiteralValues;
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_LET_DECL)) {
  let declaredType = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.declaredType = declaredType;
  let rhs = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.rhs = rhs;
  typecheckExpr(rhs, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  let rhsName = inferExprTypeName(rhs, fnReturnTypes, localTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.rhsName = rhsName;
  if ((declaredType !== 0)) {
  let declaredName = typeNameFromTypeNode(declaredType); if (typeof __tuff_this !== 'undefined') __tuff_this.declaredName = declaredName;
  if ((((!typeNamesCompatible(declaredName, rhsName, rhs)) && (!isThisReturnTypeFor(rhsName, declaredName))) && (!((() => { const __recv = tcTypeAliasNames; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(declaredName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, declaredName) : setHas(__recv, declaredName); })() && (!isBuiltinPrimitiveTypeName(declaredName)))))) {
  let vname = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.vname = vname;
  let msg = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Type mismatch for let "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(vname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, vname) : strConcat(__recv, vname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(": expected "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ": expected ") : strConcat(__recv, ": expected "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(declaredName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, declaredName) : strConcat(__recv, declaredName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(", got "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ", got ") : strConcat(__recv, ", got "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(rhsName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, rhsName) : strConcat(__recv, rhsName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.msg = msg;
  tcPanicLoc("E_TYPE_LET_MISMATCH", msg, "An explicit let type annotation does not match the assigned RHS expression type.", "Update the explicit type annotation or change the RHS expression to match.");
}
  let lname = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.lname = lname;
  (() => { const __recv = localTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(lname, declaredName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, lname, declaredName) : mapSet(__recv, lname, declaredName); })();
  let arrInitBound = tryGetArrayInitBoundFromTypeNode(declaredType); if (typeof __tuff_this !== 'undefined') __tuff_this.arrInitBound = arrInitBound;
  if ((arrInitBound >= 0)) {
  (() => { const __recv = tcArrayInitBounds; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(lname, arrInitBound); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, lname, arrInitBound) : mapSet(__recv, lname, arrInitBound); })();
}
  let indexUpperBound = tryGetIndexUpperBoundFromTypeNode(declaredType); if (typeof __tuff_this !== 'undefined') __tuff_this.indexUpperBound = indexUpperBound;
  if ((indexUpperBound >= 0)) {
  (() => { const __recv = tcIndexUpperBounds; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(lname, indexUpperBound); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, lname, indexUpperBound) : mapSet(__recv, lname, indexUpperBound); })();
}
} else { if ((!(() => { const __recv = rhsName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Unknown") : strEq(__recv, "Unknown"); })())) {
  (() => { const __recv = localTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n)), rhsName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n)), rhsName) : mapSet(__recv, getInternedStr(nodeGetData1(n)), rhsName); })();
} }
  let litVal = tryGetKnownIntValue(rhs); if (typeof __tuff_this !== 'undefined') __tuff_this.litVal = litVal;
  if (knownIntValueIsValid(litVal)) {
  (() => { const __recv = tcVarLiteralValues; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n)), litVal); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n)), litVal) : mapSet(__recv, getInternedStr(nodeGetData1(n)), litVal); })();
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_EXPR_STMT)) {
  typecheckExpr(nodeGetData1(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_ASSIGN_STMT)) {
  let target = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let value = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  typecheckExpr(target, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  typecheckExpr(value, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  if ((nodeKind(target) === NK_IDENTIFIER)) {
  let tname = getInternedStr(nodeGetData1(target)); if (typeof __tuff_this !== 'undefined') __tuff_this.tname = tname;
  if ((() => { const __recv = localTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(tname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, tname) : mapHas(__recv, tname); })()) {
  let expectedName = (() => { const __recv = localTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(tname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, tname) : mapGet(__recv, tname); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedName = expectedName;
  let valueName = inferExprTypeName(value, fnReturnTypes, localTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.valueName = valueName;
  if (((!typeNamesCompatible(expectedName, valueName, value)) && (!((() => { const __recv = tcTypeAliasNames; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(expectedName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, expectedName) : setHas(__recv, expectedName); })() && (!isBuiltinPrimitiveTypeName(expectedName)))))) {
  tcPanicLoc("E_TYPE_ASSIGN_MISMATCH", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Assignment mismatch for "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(tname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, tname) : strConcat(__recv, tname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(": expected "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ": expected ") : strConcat(__recv, ": expected "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(expectedName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, expectedName) : strConcat(__recv, expectedName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(", got "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ", got ") : strConcat(__recv, ", got "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(valueName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, valueName) : strConcat(__recv, valueName); })(), "The assigned value type is incompatible with the declared variable type.", "Assign a compatible value or change the variable type declaration.");
}
}
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_RETURN_STMT)) {
  let value = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  typecheckExpr(value, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  if ((!(() => { const __recv = expectedReturnType; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Unknown") : strEq(__recv, "Unknown"); })())) {
  let valueName = inferExprTypeName(value, fnReturnTypes, localTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.valueName = valueName;
  if ((!typeNamesCompatible(expectedReturnType, valueName, value))) {
  return tcResultError("E_TYPE_RETURN_MISMATCH", (() => { const __recv = (() => { const __recv = (() => { const __recv = "Return type mismatch: expected "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(expectedReturnType); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, expectedReturnType) : strConcat(__recv, expectedReturnType); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(", got "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ", got ") : strConcat(__recv, ", got "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(valueName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, valueName) : strConcat(__recv, valueName); })(), "A return statement produced a value incompatible with the function's declared return type.", "Return a value of the declared type or adjust the function return annotation.");
}
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_IF_STMT)) {
  typecheckIfStmtBranch(n, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, expectedReturnType);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_FOR_STMT)) {
  typecheckExpr(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  typecheckExpr(nodeGetData3(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  typecheckStmt(nodeGetData4(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, expectedReturnType);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_WHILE_STMT)) {
  let cond = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  typecheckExpr(cond, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  let condName = inferExprTypeName(cond, fnReturnTypes, localTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.condName = condName;
  if (((!(() => { const __recv = condName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Bool"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Bool") : strEq(__recv, "Bool"); })()) && (!(() => { const __recv = condName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Unknown") : strEq(__recv, "Unknown"); })()))) {
  return tcResultError("E_TYPE_IF_CONDITION", (() => { const __recv = "if condition must be Bool, got "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(condName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, condName) : strConcat(__recv, condName); })(), "Conditional branches require a boolean predicate, but the given expression has a non-Bool type.", "Return or compute a Bool expression in the condition.");
}
  let whCbKey = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.whCbKey = whCbKey;
  let whCbValue = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.whCbValue = whCbValue;
  if ((nodeKind(cond) === NK_BINARY_EXPR)) {
  let whBop = getInternedStr(nodeGetData1(cond)); if (typeof __tuff_this !== 'undefined') __tuff_this.whBop = whBop;
  let whBleft = nodeGetData2(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.whBleft = whBleft;
  let whBright = nodeGetData3(cond); if (typeof __tuff_this !== 'undefined') __tuff_this.whBright = whBright;
  if (((((() => { const __recv = whBop; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<") : strEq(__recv, "<"); })() || (() => { const __recv = whBop; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<=") : strEq(__recv, "<="); })()) && (nodeKind(whBleft) === NK_IDENTIFIER)) && (nodeKind(whBright) === NK_CALL_EXPR))) {
  let whCallee = nodeGetData1(whBright); if (typeof __tuff_this !== 'undefined') __tuff_this.whCallee = whCallee;
  let whArgs = nodeGetData2(whBright); if (typeof __tuff_this !== 'undefined') __tuff_this.whArgs = whArgs;
  if ((((nodeKind(whCallee) === NK_IDENTIFIER) && ((() => { const __recv = whArgs; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 1)) && (nodeKind((() => { const __recv = whArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()) === NK_IDENTIFIER))) {
  whCbKey = getInternedStr(nodeGetData1(whBleft)); if (typeof __tuff_this !== 'undefined') __tuff_this.whCbKey = whCbKey;
  whCbValue = (() => { const __recv = (() => { const __recv = getInternedStr(nodeGetData1(whCallee)); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1((() => { const __recv = whArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1((() => { const __recv = whArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))) : strConcat(__recv, getInternedStr(nodeGetData1((() => { const __recv = whArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.whCbValue = whCbValue;
}
}
}
  let whCbWasPresent = false; if (typeof __tuff_this !== 'undefined') __tuff_this.whCbWasPresent = whCbWasPresent;
  if ((!(() => { const __recv = whCbKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  whCbWasPresent = (() => { const __recv = tcCallBounds; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(whCbKey); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, whCbKey) : mapHas(__recv, whCbKey); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.whCbWasPresent = whCbWasPresent;
  (() => { const __recv = tcCallBounds; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(whCbKey, whCbValue); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, whCbKey, whCbValue) : mapSet(__recv, whCbKey, whCbValue); })();
}
  typecheckStmt(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, expectedReturnType);
  if (((!(() => { const __recv = whCbKey; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) && (!whCbWasPresent))) {
  (() => { const __recv = tcCallBounds; const __prop = __recv?.["mapDelete"]; if (typeof __prop === "function") return __prop(whCbKey); const __dyn = __recv?.table?.mapDelete; return __dyn ? __dyn(__recv.ref, whCbKey) : mapDelete(__recv, whCbKey); })();
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_LOOP_STMT)) {
  typecheckStmt(nodeGetData1(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, expectedReturnType);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_LIFETIME_STMT)) {
  typecheckStmt(nodeGetData2(n), fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs, expectedReturnType);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_INTO_STMT)) {
  let cname = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
  if ((!(() => { const __recv = tcContractNames; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, cname) : setHas(__recv, cname); })())) {
  return tcResultError("E_TYPE_UNKNOWN_CONTRACT", (() => { const __recv = (() => { const __recv = "Unknown contract '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cname) : strConcat(__recv, cname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' in into statement"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' in into statement") : strConcat(__recv, "' in into statement"); })(), "An into statement referenced a contract that is not declared.", "Declare the contract before using 'into'.");
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_TYPE_ALIAS)) {
  let aliasName = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  (() => { const __recv = tcTypeAliasNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, aliasName) : setAdd(__recv, aliasName); })();
  let destructorNameIdx = nodeGetData5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorNameIdx = destructorNameIdx;
  if ((destructorNameIdx !== 0)) {
  let destructorName = getInternedStr(destructorNameIdx); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
  (() => { const __recv = tcDestructorAliasByAlias; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, destructorName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, destructorName) : mapSet(__recv, aliasName, destructorName); })();
  (() => { const __recv = tcDestructorAliasNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, aliasName) : vecPush(__recv, aliasName); })();
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_DEP_TYPE_ALIAS)) {
  let aliasName = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  (() => { const __recv = tcTypeAliasNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, aliasName) : setAdd(__recv, aliasName); })();
  let valueParams = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.valueParams = valueParams;
  (() => { const __recv = tcDepTypeAliasParams; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()) : mapSet(__recv, aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); })();
  let aliasBaseType = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasBaseType = aliasBaseType;
  let aliasBaseTypeName = typeNameFromTypeNode(aliasBaseType); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasBaseTypeName = aliasBaseTypeName;
  if ((!(() => { const __recv = aliasBaseTypeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Unknown") : strEq(__recv, "Unknown"); })())) {
  (() => { const __recv = tcAliasBaseType; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, aliasBaseTypeName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, aliasBaseTypeName) : mapSet(__recv, aliasName, aliasBaseTypeName); })();
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  if ((kind === NK_EXTERN_TYPE_DECL)) {
  let aliasName = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  (() => { const __recv = tcTypeAliasNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, aliasName) : setAdd(__recv, aliasName); })();
  let valueParams = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.valueParams = valueParams;
  (() => { const __recv = tcExternTypeParams; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()) : mapSet(__recv, aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); })();
  let destructorNameIdx = nodeGetData5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorNameIdx = destructorNameIdx;
  if ((destructorNameIdx !== 0)) {
  let destructorName = getInternedStr(destructorNameIdx); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
  (() => { const __recv = tcDestructorAliasByAlias; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, destructorName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, destructorName) : mapSet(__recv, aliasName, destructorName); })();
  (() => { const __recv = tcDestructorAliasNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, aliasName) : vecPush(__recv, aliasName); })();
}
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
  typecheckExpr(n, fnArities, fnParamTypes, fnReturnTypes, localTypes, nonnullPtrs);
  return ((typeof Ok === "function") ? Ok({value: 0}) : ({ __tag: "Ok", value: 0 }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheckStmt = typecheckStmt;

const __tuff_outer_for_typecheckProgramWithOptionsImpl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheckProgramWithOptionsImpl(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_typecheckProgramWithOptionsImpl };
  let fnArities = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnArities = fnArities;
  let fnParamTypes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnParamTypes = fnParamTypes;
  let fnReturnTypes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnReturnTypes = fnReturnTypes;
  let fnNodes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnNodes = fnNodes;
  let localTypes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.localTypes = localTypes;
  tcGlobalValueTypes = (() => { const __recv = tcGlobalValueTypes; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcGlobalValueTypes = tcGlobalValueTypes;
  tcAliasUnionTags = (() => { const __recv = tcAliasUnionTags; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcAliasUnionTags = tcAliasUnionTags;
  tcTypeAliasNames = (() => { const __recv = tcTypeAliasNames; const __prop = __recv?.["setClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.setClear; return __dyn ? __dyn(__recv.ref) : setClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcTypeAliasNames = tcTypeAliasNames;
  tcDepTypeAliasParams = (() => { const __recv = tcDepTypeAliasParams; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcDepTypeAliasParams = tcDepTypeAliasParams;
  tcExternTypeParams = (() => { const __recv = tcExternTypeParams; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcExternTypeParams = tcExternTypeParams;
  tcContractNames = (() => { const __recv = tcContractNames; const __prop = __recv?.["setClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.setClear; return __dyn ? __dyn(__recv.ref) : setClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcContractNames = tcContractNames;
  tcDestructorAliasByAlias = (() => { const __recv = tcDestructorAliasByAlias; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcDestructorAliasByAlias = tcDestructorAliasByAlias;
  tcDestructorAliasNames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcDestructorAliasNames = tcDestructorAliasNames;
  tcFnThisFields = (() => { const __recv = tcFnThisFields; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcFnThisFields = tcFnThisFields;
  tcAliasBaseType = (() => { const __recv = tcAliasBaseType; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcAliasBaseType = tcAliasBaseType;
  tcTypeNameCache = (() => { const __recv = tcTypeNameCache; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcTypeNameCache = tcTypeNameCache;
  tcCallBounds = (() => { const __recv = tcCallBounds; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tcCallBounds = tcCallBounds;
  fnParamCallBounds = (() => { const __recv = fnParamCallBounds; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnParamCallBounds = fnParamCallBounds;
  let body = nodeGetData1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let preI = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.preI = preI;
  let preLen = (() => { const __recv = body; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.preLen = preLen;
  while ((preI < preLen)) {
  let preStmt = (() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(preI); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, preI) : vecGet(__recv, preI); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.preStmt = preStmt;
  let preKind = nodeKind(preStmt); if (typeof __tuff_this !== 'undefined') __tuff_this.preKind = preKind;
  if (isExternTypeLikeDecl(preStmt)) {
  let aliasName = getInternedStr(nodeGetData1(preStmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  (() => { const __recv = tcTypeAliasNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, aliasName) : setAdd(__recv, aliasName); })();
  let valueParams = nodeGetData2(preStmt); if (typeof __tuff_this !== 'undefined') __tuff_this.valueParams = valueParams;
  (() => { const __recv = tcExternTypeParams; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()) : mapSet(__recv, aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); })();
}
  if ((preKind === NK_DEP_TYPE_ALIAS)) {
  let aliasName = getInternedStr(nodeGetData1(preStmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  (() => { const __recv = tcTypeAliasNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, aliasName) : setAdd(__recv, aliasName); })();
  let valueParams = nodeGetData2(preStmt); if (typeof __tuff_this !== 'undefined') __tuff_this.valueParams = valueParams;
  (() => { const __recv = tcDepTypeAliasParams; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()) : mapSet(__recv, aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); })();
}
  preI = (preI + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.preI = preI;
}
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = body; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  let name = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  (() => { const __recv = fnNodes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(name, stmt); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, name, stmt) : mapSet(__recv, name, stmt); })();
  let params = nodeGetData3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  (() => { const __recv = fnArities; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(name, (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, name, (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()) : mapSet(__recv, name, (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); })();
  let paramTypes = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.paramTypes = paramTypes;
  let paramCallBoundsVec = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.paramCallBoundsVec = paramCallBoundsVec;
  let p = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let __len1 = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len1 = __len1;
  while ((p < __len1)) {
  let param = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(p); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, p) : vecGet(__recv, p); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  let paramTypeNode = (() => { const __recv = param; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.paramTypeNode = paramTypeNode;
  (() => { const __recv = paramTypes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(typeNameFromTypeNode(paramTypeNode)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, typeNameFromTypeNode(paramTypeNode)) : vecPush(__recv, typeNameFromTypeNode(paramTypeNode)); })();
  let rawConstraint = tryExtractFnCallConstraint(paramTypeNode); if (typeof __tuff_this !== 'undefined') __tuff_this.rawConstraint = rawConstraint;
  if ((!(() => { const __recv = rawConstraint; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  let sep = (() => { const __recv = rawConstraint; const __prop = __recv?.["strIndexOf"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strIndexOf; return __dyn ? __dyn(__recv.ref, ":") : strIndexOf(__recv, ":"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.sep = sep;
  if ((sep < 0)) {
  tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", (() => { const __recv = (() => { const __recv = "Malformed internal call-bound constraint metadata in function '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "Expected call-bound metadata in the form 'fnName:paramName', but ':' was missing.", "Ensure refinement call-bound metadata is emitted as 'fnName:paramName'.");
}
  let rawLen = (() => { const __recv = rawConstraint; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.rawLen = rawLen;
  if ((sep > rawLen)) {
  tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", (() => { const __recv = (() => { const __recv = "Malformed internal call-bound constraint metadata in function '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "The separator ':' index is outside the metadata string bounds.", "Ensure refinement call-bound metadata is emitted with valid separator positions.");
}
  if (((sep + 1) > rawLen)) {
  tcPanicLoc("E_TYPE_INTERNAL_CALL_BOUND_METADATA", (() => { const __recv = (() => { const __recv = "Malformed internal call-bound constraint metadata in function '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "The metadata separator ':' is in an invalid position for extracting the parameter name.", "Ensure call-bound metadata includes a non-empty parameter name after ':'.");
}
  let fnPart = (() => { const __recv = rawConstraint; const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(0, sep); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, 0, sep) : strSlice(__recv, 0, sep); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnPart = fnPart;
  let refIdx = (-1); if (typeof __tuff_this !== 'undefined') __tuff_this.refIdx = refIdx;
  let pi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.pi = pi;
  let __len = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len = __len;
  while ((pi < __len)) {
  let piName = getInternedStr((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(pi); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, pi) : vecGet(__recv, pi); })(); const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.piName = piName;
  let expectedRaw = (() => { const __recv = (() => { const __recv = fnPart; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(piName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, piName) : strConcat(__recv, piName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.expectedRaw = expectedRaw;
  if ((() => { const __recv = expectedRaw; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(rawConstraint); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, rawConstraint) : strEq(__recv, rawConstraint); })()) {
  refIdx = pi; if (typeof __tuff_this !== 'undefined') __tuff_this.refIdx = refIdx;
}
  pi = (pi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.pi = pi;
}
  if ((refIdx >= 0)) {
  (() => { const __recv = paramCallBoundsVec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = fnPart; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(refIdx)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(refIdx)) : strConcat(__recv, intToString(refIdx)); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = fnPart; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(refIdx)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(refIdx)) : strConcat(__recv, intToString(refIdx)); })()) : vecPush(__recv, (() => { const __recv = (() => { const __recv = fnPart; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(refIdx)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(refIdx)) : strConcat(__recv, intToString(refIdx)); })()); })();
} else {
  (() => { const __recv = paramCallBoundsVec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, "") : vecPush(__recv, ""); })();
}
} else {
  if (((paramTypeNode !== 0) && (nodeKind(paramTypeNode) === NK_REFINEMENT_TYPE))) {
  (() => { const __recv = paramCallBoundsVec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop("__REFINE__"); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, "__REFINE__") : vecPush(__recv, "__REFINE__"); })();
} else {
  (() => { const __recv = paramCallBoundsVec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, "") : vecPush(__recv, ""); })();
}
}
  p = (p + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
}
  (() => { const __recv = fnParamTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(name, paramTypes); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, name, paramTypes) : mapSet(__recv, name, paramTypes); })();
  (() => { const __recv = fnParamCallBounds; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(name, paramCallBoundsVec); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, name, paramCallBoundsVec) : mapSet(__recv, name, paramCallBoundsVec); })();
  let retType = nodeGetData4(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.retType = retType;
  (() => { const __recv = fnReturnTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(name, typeNameFromTypeNode(retType)); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, name, typeNameFromTypeNode(retType)) : mapSet(__recv, name, typeNameFromTypeNode(retType)); })();
}
  if ((kind === NK_EXTERN_LET_DECL)) {
  let vname = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.vname = vname;
  let vtype = nodeGetData2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.vtype = vtype;
  let tname = typeNameFromTypeNode(vtype); if (typeof __tuff_this !== 'undefined') __tuff_this.tname = tname;
  (() => { const __recv = localTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(vname, tname); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, vname, tname) : mapSet(__recv, vname, tname); })();
  (() => { const __recv = tcGlobalValueTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(vname, tname); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, vname, tname) : mapSet(__recv, vname, tname); })();
}
  if ((kind === NK_TYPE_ALIAS)) {
  let aliasName = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  (() => { const __recv = tcTypeAliasNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, aliasName) : setAdd(__recv, aliasName); })();
  let aliasType = nodeGetData3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasType = aliasType;
  let tags = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.tags = tags;
  collectUnionNamedTags(aliasType, tags);
  if (((() => { const __recv = tags; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > 0)) {
  (() => { const __recv = tcAliasUnionTags; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, tags); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, tags) : mapSet(__recv, aliasName, tags); })();
}
  let destructorNameIdx = nodeGetData5(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorNameIdx = destructorNameIdx;
  if ((destructorNameIdx !== 0)) {
  let destructorName = getInternedStr(destructorNameIdx); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
  (() => { const __recv = tcDestructorAliasByAlias; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, destructorName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, destructorName) : mapSet(__recv, aliasName, destructorName); })();
  (() => { const __recv = tcDestructorAliasNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, aliasName) : vecPush(__recv, aliasName); })();
}
  let aliasBaseType = nodeGetData3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasBaseType = aliasBaseType;
  let aliasBaseTypeName = typeNameFromTypeNode(aliasBaseType); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasBaseTypeName = aliasBaseTypeName;
  if ((!(() => { const __recv = aliasBaseTypeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Unknown") : strEq(__recv, "Unknown"); })())) {
  (() => { const __recv = tcAliasBaseType; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, aliasBaseTypeName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, aliasBaseTypeName) : mapSet(__recv, aliasName, aliasBaseTypeName); })();
}
}
  if ((kind === NK_DEP_TYPE_ALIAS)) {
  let aliasName = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  (() => { const __recv = tcTypeAliasNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, aliasName) : setAdd(__recv, aliasName); })();
  let valueParams = nodeGetData2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.valueParams = valueParams;
  (() => { const __recv = tcDepTypeAliasParams; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()) : mapSet(__recv, aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); })();
  let aliasBaseType = nodeGetData3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasBaseType = aliasBaseType;
  let aliasBaseTypeName = typeNameFromTypeNode(aliasBaseType); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasBaseTypeName = aliasBaseTypeName;
  if ((!(() => { const __recv = aliasBaseTypeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Unknown") : strEq(__recv, "Unknown"); })())) {
  (() => { const __recv = tcAliasBaseType; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, aliasBaseTypeName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, aliasBaseTypeName) : mapSet(__recv, aliasName, aliasBaseTypeName); })();
}
}
  if (isExternTypeLikeDecl(stmt)) {
  let aliasName = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  (() => { const __recv = tcTypeAliasNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, aliasName) : setAdd(__recv, aliasName); })();
  let valueParams = nodeGetData2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.valueParams = valueParams;
  (() => { const __recv = tcExternTypeParams; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()) : mapSet(__recv, aliasName, (() => { const __recv = valueParams; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); })();
  let destructorNameIdx = nodeGetData5(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorNameIdx = destructorNameIdx;
  if ((destructorNameIdx !== 0)) {
  let destructorName = getInternedStr(destructorNameIdx); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
  (() => { const __recv = tcDestructorAliasByAlias; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, destructorName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, destructorName) : mapSet(__recv, aliasName, destructorName); })();
  (() => { const __recv = tcDestructorAliasNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, aliasName) : vecPush(__recv, aliasName); })();
}
}
  if ((kind === NK_CONTRACT_DECL)) {
  (() => { const __recv = tcContractNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(stmt))); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(stmt))) : setAdd(__recv, getInternedStr(nodeGetData1(stmt))); })();
}
  if ((kind === NK_LET_DECL)) {
  let vname = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.vname = vname;
  let vtype = nodeGetData2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.vtype = vtype;
  if ((vtype !== 0)) {
  (() => { const __recv = tcGlobalValueTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(vname, typeNameFromTypeNode(vtype)); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, vname, typeNameFromTypeNode(vtype)) : mapSet(__recv, vname, typeNameFromTypeNode(vtype)); })();
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let destructorAliasCount = (() => { const __recv = tcDestructorAliasNames; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorAliasCount = destructorAliasCount;
  while ((i < destructorAliasCount)) {
  let aliasName = (() => { const __recv = tcDestructorAliasNames; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  let destructorName = (() => { const __recv = tcDestructorAliasByAlias; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, aliasName) : mapGet(__recv, aliasName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
  if ((!(() => { const __recv = fnNodes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(destructorName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, destructorName) : mapHas(__recv, destructorName); })())) {
  tcPanicLoc("E_TYPE_DESTRUCTOR_NOT_FOUND", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Destructor '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(destructorName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, destructorName) : strConcat(__recv, destructorName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' for alias '"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' for alias '") : strConcat(__recv, "' for alias '"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, aliasName) : strConcat(__recv, aliasName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' was not found"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' was not found") : strConcat(__recv, "' was not found"); })(), "A type alias referenced a destructor function that does not exist.", "Declare the destructor function before using it in 'type Alias = ... then destructor'.");
}
  let fnNode = (() => { const __recv = fnNodes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(destructorName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, destructorName) : mapGet(__recv, destructorName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnNode = fnNode;
  let params = nodeGetData3(fnNode); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let valid = true; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
  if (((() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() !== 1)) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
} else {
  let p0 = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p0 = p0;
  let pname = getInternedStr((() => { const __recv = p0; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = (() => { const __recv = p0; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if ((!(() => { const __recv = pname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })())) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
}
  if ((!typeNodeIsDestructorReceiver(ptype, aliasName))) {
  let ptypeName = typeNameFromTypeNode(ptype); if (typeof __tuff_this !== 'undefined') __tuff_this.ptypeName = ptypeName;
  let baseTypeOk = ((() => { const __recv = tcAliasBaseType; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, aliasName) : mapHas(__recv, aliasName); })() && (() => { const __recv = ptypeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop((() => { const __recv = tcAliasBaseType; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, aliasName) : mapGet(__recv, aliasName); })()); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, (() => { const __recv = tcAliasBaseType; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, aliasName) : mapGet(__recv, aliasName); })()) : strEq(__recv, (() => { const __recv = tcAliasBaseType; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, aliasName) : mapGet(__recv, aliasName); })()); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.baseTypeOk = baseTypeOk;
  if ((!baseTypeOk)) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
}
}
}
  let retName = typeNameFromTypeNode(nodeGetData4(fnNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.retName = retName;
  if (((!(() => { const __recv = retName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Void"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Void") : strEq(__recv, "Void"); })()) && (!(() => { const __recv = retName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Unknown") : strEq(__recv, "Unknown"); })()))) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
}
  if ((!valid)) {
  tcPanicLoc("E_TYPE_DESTRUCTOR_SIGNATURE", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Destructor '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(destructorName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, destructorName) : strConcat(__recv, destructorName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' must have signature fn "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' must have signature fn ") : strConcat(__recv, "' must have signature fn "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(destructorName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, destructorName) : strConcat(__recv, destructorName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(this : "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(this : ") : strConcat(__recv, "(this : "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, aliasName) : strConcat(__recv, aliasName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("<...>) : Void"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "<...>) : Void") : strConcat(__recv, "<...>) : Void"); })(), "Destructor signatures must follow the required receiver and return type contract.", "Use exactly one receiver parameter named 'this' with the alias type (or legacy '*move AliasType') and return Void.");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  typecheckStmt((() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), fnArities, fnParamTypes, fnReturnTypes, localTypes, mapNew(), "Unknown");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return ((typeof Ok === "function") ? Ok({value: program}) : ({ __tag: "Ok", value: program }));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheckProgramWithOptionsImpl = typecheckProgramWithOptionsImpl;

const __tuff_outer_for_typecheckProgramImpl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheckProgramImpl(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_typecheckProgramImpl };
  return typecheckProgramWithOptionsImpl(program);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheckProgramImpl = typecheckProgramImpl;

const __tuff_outer_for_selfhostTypecheckImplMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostTypecheckImplMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostTypecheckImplMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostTypecheckImplMarker = selfhostTypecheckImplMarker;

const __tuff_outer_for_typecheckProgramWithOptions = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheckProgramWithOptions(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_typecheckProgramWithOptions };
  return typecheckProgramWithOptionsImpl(program);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheckProgramWithOptions = typecheckProgramWithOptions;

const __tuff_outer_for_typecheckProgram = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function typecheckProgram(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_typecheckProgram };
  return typecheckProgramImpl(program);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.typecheckProgram = typecheckProgram;

const __tuff_outer_for_selfhostTypecheckMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostTypecheckMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostTypecheckMarker };
  return selfhostTypecheckImplMarker();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostTypecheckMarker = selfhostTypecheckMarker;

let bcCurrentNode = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.bcCurrentNode = bcCurrentNode;

let bcGlobalValueTypes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.bcGlobalValueTypes = bcGlobalValueTypes;

let bcCopyTypes = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.bcCopyTypes = bcCopyTypes;

let bcCopyAliasTypes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.bcCopyAliasTypes = bcCopyAliasTypes;

let bcCopyAliasNames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.bcCopyAliasNames = bcCopyAliasNames;

let bcDestructorAliases = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.bcDestructorAliases = bcDestructorAliases;

let bcDestructorAliasNames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.bcDestructorAliasNames = bcDestructorAliasNames;

const __tuff_outer_for_bcStrEndsWithLocal = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bcStrEndsWithLocal(s, suffix) {
  let __tuff_this = { s: s, suffix: suffix, this: __tuff_outer_for_bcStrEndsWithLocal };
  let ns = (() => { const __recv = s; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ns = ns;
  let nf = (() => { const __recv = suffix; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.nf = nf;
  if ((nf > ns)) {
  return false;
}
  return (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((ns - nf), ns); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (ns - nf), ns) : strSliceWindow(__recv, (ns - nf), ns); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(suffix); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, suffix) : strEq(__recv, suffix); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bcStrEndsWithLocal = bcStrEndsWithLocal;

const __tuff_outer_for_bcTypeNameFromTypeNode = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bcTypeNameFromTypeNode(t) {
  let __tuff_this = { t: t, this: __tuff_outer_for_bcTypeNameFromTypeNode };
  if ((t === 0)) {
  return "Unknown";
}
  let k = nodeKind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_NAMED_TYPE)) {
  return getInternedStr(nodeGetData1(t));
}
  if ((k === NK_REFINEMENT_TYPE)) {
  return bcTypeNameFromTypeNode(nodeGetData1(t));
}
  if ((k === NK_POINTER_TYPE)) {
  let mutable = nodeGetData1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.mutable = mutable;
  let inner = bcTypeNameFromTypeNode(nodeGetData2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let movePtr = nodeGetData3(t); if (typeof __tuff_this !== 'undefined') __tuff_this.movePtr = movePtr;
  let lifeIdx = nodeGetData4(t); if (typeof __tuff_this !== 'undefined') __tuff_this.lifeIdx = lifeIdx;
  let lifePrefix = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.lifePrefix = lifePrefix;
  if ((lifeIdx !== 0)) {
  lifePrefix = (() => { const __recv = getInternedStr(lifeIdx); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.lifePrefix = lifePrefix;
}
  if ((movePtr === 1)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lifePrefix); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lifePrefix) : strConcat(__recv, lifePrefix); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("move "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "move ") : strConcat(__recv, "move "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })();
}
  if ((mutable === 1)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lifePrefix); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lifePrefix) : strConcat(__recv, lifePrefix); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("mut "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "mut ") : strConcat(__recv, "mut "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })();
}
  return (() => { const __recv = (() => { const __recv = "*"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lifePrefix); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lifePrefix) : strConcat(__recv, lifePrefix); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })();
}
  if ((k === NK_UNION_TYPE)) {
  let left = bcTypeNameFromTypeNode(nodeGetData1(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  let right = bcTypeNameFromTypeNode(nodeGetData2(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  return (() => { const __recv = (() => { const __recv = left; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "|") : strConcat(__recv, "|"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, right) : strConcat(__recv, right); })();
}
  return "Unknown";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bcTypeNameFromTypeNode = bcTypeNameFromTypeNode;

const __tuff_outer_for_isCopyPrimitive = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isCopyPrimitive(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_isCopyPrimitive };
  return ((((((((((((((((() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I8"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I8") : strEq(__recv, "I8"); })() || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I16"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I16") : strEq(__recv, "I16"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I32") : strEq(__recv, "I32"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I64"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I64") : strEq(__recv, "I64"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I128"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I128") : strEq(__recv, "I128"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U8") : strEq(__recv, "U8"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U16") : strEq(__recv, "U16"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U32") : strEq(__recv, "U32"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U64"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U64") : strEq(__recv, "U64"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U128"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U128") : strEq(__recv, "U128"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "USize") : strEq(__recv, "USize"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("ISize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "ISize") : strEq(__recv, "ISize"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("F32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "F32") : strEq(__recv, "F32"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("F64"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "F64") : strEq(__recv, "F64"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Bool"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Bool") : strEq(__recv, "Bool"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Char"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Char") : strEq(__recv, "Char"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isCopyPrimitive = isCopyPrimitive;

const __tuff_outer_for_isCopyType = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isCopyType(typeName, externTypeNames) {
  let __tuff_this = { typeName: typeName, externTypeNames: externTypeNames, this: __tuff_outer_for_isCopyType };
  if ((() => { const __recv = typeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Unknown"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Unknown") : strEq(__recv, "Unknown"); })()) {
  return false;
}
  if ((() => { const __recv = typeName; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "*") : strStartsWith(__recv, "*"); })()) {
  return true;
}
  if (isCopyPrimitive(typeName)) {
  return true;
}
  if ((() => { const __recv = bcDestructorAliases; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(typeName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, typeName) : mapHas(__recv, typeName); })()) {
  return false;
}
  if ((((() => { const __recv = typeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Vec"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Vec") : strEq(__recv, "Vec"); })() || (() => { const __recv = typeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Map"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Map") : strEq(__recv, "Map"); })()) || (() => { const __recv = typeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Set"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Set") : strEq(__recv, "Set"); })())) {
  return true;
}
  if ((() => { const __recv = bcCopyTypes; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(typeName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, typeName) : setHas(__recv, typeName); })()) {
  return true;
}
  if ((() => { const __recv = externTypeNames; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(typeName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, typeName) : setHas(__recv, typeName); })()) {
  return false;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isCopyType = isCopyType;

const __tuff_outer_for_bcFindCopyAliasType = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bcFindCopyAliasType(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_bcFindCopyAliasType };
  if ((() => { const __recv = bcCopyAliasTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  return (() => { const __recv = bcCopyAliasTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })();
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bcFindCopyAliasType = bcFindCopyAliasType;

const __tuff_outer_for_bcTypeNodeIsCopyable = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bcTypeNodeIsCopyable(t, externTypeNames, visitingAliases) {
  let __tuff_this = { t: t, externTypeNames: externTypeNames, visitingAliases: visitingAliases, this: __tuff_outer_for_bcTypeNodeIsCopyable };
  if ((t === 0)) {
  return false;
}
  let k = nodeKind(t); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_NAMED_TYPE)) {
  let name = getInternedStr(nodeGetData1(t)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = bcDestructorAliases; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  return false;
}
  if (isCopyPrimitive(name)) {
  return true;
}
  if ((((() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Vec"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Vec") : strEq(__recv, "Vec"); })() || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Map"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Map") : strEq(__recv, "Map"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Set"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Set") : strEq(__recv, "Set"); })())) {
  return true;
}
  if ((() => { const __recv = bcCopyTypes; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })()) {
  return true;
}
  if ((() => { const __recv = externTypeNames; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })()) {
  return false;
}
  let aliasType = bcFindCopyAliasType(name); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasType = aliasType;
  if ((aliasType !== 0)) {
  if ((() => { const __recv = visitingAliases; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })()) {
  return false;
}
  (() => { const __recv = visitingAliases; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, name) : setAdd(__recv, name); })();
  let ok = bcTypeNodeIsCopyable(aliasType, externTypeNames, visitingAliases); if (typeof __tuff_this !== 'undefined') __tuff_this.ok = ok;
  (() => { const __recv = visitingAliases; const __prop = __recv?.["setDelete"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setDelete; return __dyn ? __dyn(__recv.ref, name) : setDelete(__recv, name); })();
  return ok;
}
  return false;
}
  if ((k === NK_REFINEMENT_TYPE)) {
  return bcTypeNodeIsCopyable(nodeGetData1(t), externTypeNames, visitingAliases);
}
  if ((k === NK_POINTER_TYPE)) {
  return true;
}
  if ((k === NK_UNION_TYPE)) {
  return (bcTypeNodeIsCopyable(nodeGetData1(t), externTypeNames, visitingAliases) && bcTypeNodeIsCopyable(nodeGetData2(t), externTypeNames, visitingAliases));
}
  if ((k === NK_TUPLE_TYPE)) {
  let members = nodeGetData1(t); if (typeof __tuff_this !== 'undefined') __tuff_this.members = members;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = members; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  if ((!bcTypeNodeIsCopyable((() => { const __recv = members; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), externTypeNames, visitingAliases))) {
  return false;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bcTypeNodeIsCopyable = bcTypeNodeIsCopyable;

const __tuff_outer_for_bcTypeNodeIsDestructorReceiver = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bcTypeNodeIsDestructorReceiver(t, aliasName) {
  let __tuff_this = { t: t, aliasName: aliasName, this: __tuff_outer_for_bcTypeNodeIsDestructorReceiver };
  if ((t === 0)) {
  return false;
}
  if (((nodeKind(t) === NK_NAMED_TYPE) && (() => { const __recv = getInternedStr(nodeGetData1(t)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, aliasName) : strEq(__recv, aliasName); })())) {
  return true;
}
  if (((nodeKind(t) === NK_POINTER_TYPE) && (nodeGetData3(t) === 1))) {
  return (() => { const __recv = bcTypeNameFromTypeNode(nodeGetData2(t)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, aliasName) : strEq(__recv, aliasName); })();
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bcTypeNodeIsDestructorReceiver = bcTypeNodeIsDestructorReceiver;

const __tuff_outer_for_bcInferExprTypeName = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bcInferExprTypeName(n, envTypes, fnReturnTypes) {
  let __tuff_this = { n: n, envTypes: envTypes, fnReturnTypes: fnReturnTypes, this: __tuff_outer_for_bcInferExprTypeName };
  if ((n === 0)) {
  return "Unknown";
}
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_NUMBER_LIT)) {
  let text = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.text = text;
  if (bcStrEndsWithLocal(text, "USize")) {
  return "USize";
}
  return "I32";
}
  if ((kind === NK_BOOL_LIT)) {
  return "Bool";
}
  if ((kind === NK_STRING_LIT)) {
  return "*Str";
}
  if ((kind === NK_CHAR_LIT)) {
  return "Char";
}
  if ((kind === NK_IDENTIFIER)) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = envTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  return (() => { const __recv = envTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })();
}
  if ((() => { const __recv = bcGlobalValueTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  return (() => { const __recv = bcGlobalValueTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })();
}
  return "Unknown";
}
  if ((kind === NK_UNARY_EXPR)) {
  let op = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let inner = bcInferExprTypeName(nodeGetData2(n), envTypes, fnReturnTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&") : strEq(__recv, "&"); })()) {
  return (() => { const __recv = "*"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })();
}
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&mut"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&mut") : strEq(__recv, "&mut"); })()) {
  return (() => { const __recv = "*mut "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })();
}
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("!"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "!") : strEq(__recv, "!"); })()) {
  return "Bool";
}
  return inner;
}
  if ((kind === NK_BINARY_EXPR)) {
  let op = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((((((((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("=="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "==") : strEq(__recv, "=="); })() || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "!=") : strEq(__recv, "!="); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<") : strEq(__recv, "<"); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("<="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "<=") : strEq(__recv, "<="); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(">"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, ">") : strEq(__recv, ">"); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(">="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, ">=") : strEq(__recv, ">="); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&&"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&&") : strEq(__recv, "&&"); })()) || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("||"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "||") : strEq(__recv, "||"); })())) {
  return "Bool";
}
  return bcInferExprTypeName(nodeGetData2(n), envTypes, fnReturnTypes);
}
  if ((kind === NK_CALL_EXPR)) {
  let callee = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  if ((nodeKind(callee) === NK_IDENTIFIER)) {
  let fname = getInternedStr(nodeGetData1(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if ((() => { const __recv = fnReturnTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, fname) : mapHas(__recv, fname); })()) {
  return (() => { const __recv = fnReturnTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, fname) : mapGet(__recv, fname); })();
}
}
}
  if ((kind === NK_STRUCT_INIT)) {
  return getInternedStr(nodeGetData1(n));
}
  return "Unknown";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bcInferExprTypeName = bcInferExprTypeName;

const __tuff_outer_for_placeNew = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function placeNew(base, path) {
  let __tuff_this = { base: base, path: path, this: __tuff_outer_for_placeNew };
  let p = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  (() => { const __recv = p; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, base) : vecPush(__recv, base); })();
  (() => { const __recv = p; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(path); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, path) : vecPush(__recv, path); })();
  return p;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.placeNew = placeNew;

const __tuff_outer_for_placeIsValid = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function placeIsValid(p) {
  let __tuff_this = { p: p, this: __tuff_outer_for_placeIsValid };
  return ((() => { const __recv = p; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 2);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.placeIsValid = placeIsValid;

const __tuff_outer_for_placeBase = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function placeBase(p) {
  let __tuff_this = { p: p, this: __tuff_outer_for_placeBase };
  return (() => { const __recv = p; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.placeBase = placeBase;

const __tuff_outer_for_placePath = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function placePath(p) {
  let __tuff_this = { p: p, this: __tuff_outer_for_placePath };
  return (() => { const __recv = p; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.placePath = placePath;

const __tuff_outer_for_canonicalPlace = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function canonicalPlace(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_canonicalPlace };
  if ((n === 0)) {
  return vecNew();
}
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_IDENTIFIER)) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return placeNew(name, name);
}
  if ((kind === NK_MEMBER_EXPR)) {
  let base = canonicalPlace(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  if ((!placeIsValid(base))) {
  return vecNew();
}
  let prop = getInternedStr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  return placeNew(placeBase(base), (() => { const __recv = (() => { const __recv = placePath(base); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prop) : strConcat(__recv, prop); })());
}
  if ((kind === NK_INDEX_EXPR)) {
  let base = canonicalPlace(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  if ((!placeIsValid(base))) {
  return vecNew();
}
  return placeNew(placeBase(base), (() => { const __recv = placePath(base); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("[]"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "[]") : strConcat(__recv, "[]"); })());
}
  return vecNew();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.canonicalPlace = canonicalPlace;

const __tuff_outer_for_placesConflict = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function placesConflict(aBase, aPath, bBase, bPath) {
  let __tuff_this = { aBase: aBase, aPath: aPath, bBase: bBase, bPath: bPath, this: __tuff_outer_for_placesConflict };
  if ((!(() => { const __recv = aBase; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(bBase); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, bBase) : strEq(__recv, bBase); })())) {
  return false;
}
  if ((() => { const __recv = aPath; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(bPath); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, bPath) : strEq(__recv, bPath); })()) {
  return true;
}
  if (((() => { const __recv = aPath; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop("[]"); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, "[]") : strIncludes(__recv, "[]"); })() || (() => { const __recv = bPath; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop("[]"); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, "[]") : strIncludes(__recv, "[]"); })())) {
  return true;
}
  return ((() => { const __recv = aPath; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop((() => { const __recv = bPath; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })()); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, (() => { const __recv = bPath; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })()) : strStartsWith(__recv, (() => { const __recv = bPath; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })()); })() || (() => { const __recv = bPath; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop((() => { const __recv = aPath; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })()); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, (() => { const __recv = aPath; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })()) : strStartsWith(__recv, (() => { const __recv = aPath; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })()); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.placesConflict = placesConflict;

const __tuff_outer_for_stateNew = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateNew() {
  let __tuff_this = { this: __tuff_outer_for_stateNew };
  let s = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  (() => { const __recv = s; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(setNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, setNew()) : vecPush(__recv, setNew()); })();
  (() => { const __recv = s; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(vecNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, vecNew()) : vecPush(__recv, vecNew()); })();
  (() => { const __recv = s; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(vecNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, vecNew()) : vecPush(__recv, vecNew()); })();
  (() => { const __recv = s; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(vecNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, vecNew()) : vecPush(__recv, vecNew()); })();
  (() => { const __recv = s; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(setNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, setNew()) : vecPush(__recv, setNew()); })();
  (() => { const __recv = s; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(vecNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, vecNew()) : vecPush(__recv, vecNew()); })();
  (() => { const __recv = s; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(mapNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, mapNew()) : vecPush(__recv, mapNew()); })();
  return s;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateNew = stateNew;

const __tuff_outer_for_stateMovedSet = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateMovedSet(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_stateMovedSet };
  return (() => { const __recv = state; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateMovedSet = stateMovedSet;

const __tuff_outer_for_stateMovedVec = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateMovedVec(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_stateMovedVec };
  return (() => { const __recv = state; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateMovedVec = stateMovedVec;

const __tuff_outer_for_stateLoans = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateLoans(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_stateLoans };
  return (() => { const __recv = state; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 2) : vecGet(__recv, 2); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateLoans = stateLoans;

const __tuff_outer_for_stateScopeStarts = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateScopeStarts(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_stateScopeStarts };
  return (() => { const __recv = state; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(3); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 3) : vecGet(__recv, 3); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateScopeStarts = stateScopeStarts;

const __tuff_outer_for_stateDroppedSet = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateDroppedSet(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_stateDroppedSet };
  return (() => { const __recv = state; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(4); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 4) : vecGet(__recv, 4); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateDroppedSet = stateDroppedSet;

const __tuff_outer_for_stateDroppedVec = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateDroppedVec(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_stateDroppedVec };
  return (() => { const __recv = state; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(5); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 5) : vecGet(__recv, 5); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateDroppedVec = stateDroppedVec;

const __tuff_outer_for_stateLoansByBase = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateLoansByBase(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_stateLoansByBase };
  return (() => { const __recv = state; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(6); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 6) : vecGet(__recv, 6); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateLoansByBase = stateLoansByBase;

const __tuff_outer_for_stateMovedHas = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateMovedHas(state, name) {
  let __tuff_this = { state: state, name: name, this: __tuff_outer_for_stateMovedHas };
  return (() => { const __recv = stateMovedSet(state); const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateMovedHas = stateMovedHas;

const __tuff_outer_for_stateDroppedHas = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateDroppedHas(state, name) {
  let __tuff_this = { state: state, name: name, this: __tuff_outer_for_stateDroppedHas };
  return (() => { const __recv = stateDroppedSet(state); const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateDroppedHas = stateDroppedHas;

const __tuff_outer_for_stateMovedAdd = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateMovedAdd(state, name) {
  let __tuff_this = { state: state, name: name, this: __tuff_outer_for_stateMovedAdd };
  if ((!(() => { const __recv = stateMovedSet(state); const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })())) {
  (() => { const __recv = stateMovedSet(state); const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, name) : setAdd(__recv, name); })();
  (() => { const __recv = stateMovedVec(state); const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, name) : vecPush(__recv, name); })();
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateMovedAdd = stateMovedAdd;

const __tuff_outer_for_stateMovedDelete = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateMovedDelete(state, name) {
  let __tuff_this = { state: state, name: name, this: __tuff_outer_for_stateMovedDelete };
  (() => { const __recv = stateMovedSet(state); const __prop = __recv?.["setDelete"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setDelete; return __dyn ? __dyn(__recv.ref, name) : setDelete(__recv, name); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateMovedDelete = stateMovedDelete;

const __tuff_outer_for_stateDroppedAdd = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateDroppedAdd(state, name) {
  let __tuff_this = { state: state, name: name, this: __tuff_outer_for_stateDroppedAdd };
  if ((!(() => { const __recv = stateDroppedSet(state); const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })())) {
  (() => { const __recv = stateDroppedSet(state); const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, name) : setAdd(__recv, name); })();
  (() => { const __recv = stateDroppedVec(state); const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, name) : vecPush(__recv, name); })();
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateDroppedAdd = stateDroppedAdd;

const __tuff_outer_for_stateDroppedDelete = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateDroppedDelete(state, name) {
  let __tuff_this = { state: state, name: name, this: __tuff_outer_for_stateDroppedDelete };
  (() => { const __recv = stateDroppedSet(state); const __prop = __recv?.["setDelete"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setDelete; return __dyn ? __dyn(__recv.ref, name) : setDelete(__recv, name); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateDroppedDelete = stateDroppedDelete;

const __tuff_outer_for_stateBeginScope = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateBeginScope(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_stateBeginScope };
  (() => { const __recv = stateScopeStarts(state); const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = stateLoans(state); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = stateLoans(state); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()) : vecPush(__recv, (() => { const __recv = stateLoans(state); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateBeginScope = stateBeginScope;

const __tuff_outer_for_stateEndScope = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateEndScope(state) {
  let __tuff_this = { state: state, this: __tuff_outer_for_stateEndScope };
  let starts = stateScopeStarts(state); if (typeof __tuff_this !== 'undefined') __tuff_this.starts = starts;
  if (((() => { const __recv = starts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 0)) {
  return 0;
}
  let start = (() => { const __recv = starts; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.start = start;
  let loans = stateLoans(state); if (typeof __tuff_this !== 'undefined') __tuff_this.loans = loans;
  while (((() => { const __recv = loans; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > start)) {
  (() => { const __recv = loans; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })();
}
  let idx = (() => { const __recv = stateLoansByBase(state); const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = loans; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let e = (() => { const __recv = loans; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.e = e;
  let eb = (() => { const __recv = e; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.eb = eb;
  let existing = (() => { const __recv = idx; const __prop = __recv?.["mapGetOrDefault"]; if (typeof __prop === "function") return __prop(eb, vecNew()); const __dyn = __recv?.table?.mapGetOrDefault; return __dyn ? __dyn(__recv.ref, eb, vecNew()) : mapGetOrDefault(__recv, eb, vecNew()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.existing = existing;
  (() => { const __recv = existing; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(e); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, e) : vecPush(__recv, e); })();
  (() => { const __recv = idx; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(eb, existing); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, eb, existing) : mapSet(__recv, eb, existing); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateEndScope = stateEndScope;

const __tuff_outer_for_stateAddLoan = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateAddLoan(state, kind, base, path) {
  let __tuff_this = { state: state, kind: kind, base: base, path: path, this: __tuff_outer_for_stateAddLoan };
  let entry = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.entry = entry;
  (() => { const __recv = entry; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(kind); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, kind) : vecPush(__recv, kind); })();
  (() => { const __recv = entry; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, base) : vecPush(__recv, base); })();
  (() => { const __recv = entry; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(path); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, path) : vecPush(__recv, path); })();
  (() => { const __recv = stateLoans(state); const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(entry); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, entry) : vecPush(__recv, entry); })();
  let idx = stateLoansByBase(state); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  let existing = (() => { const __recv = idx; const __prop = __recv?.["mapGetOrDefault"]; if (typeof __prop === "function") return __prop(base, vecNew()); const __dyn = __recv?.table?.mapGetOrDefault; return __dyn ? __dyn(__recv.ref, base, vecNew()) : mapGetOrDefault(__recv, base, vecNew()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.existing = existing;
  (() => { const __recv = existing; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(entry); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, entry) : vecPush(__recv, entry); })();
  (() => { const __recv = idx; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(base, existing); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, base, existing) : mapSet(__recv, base, existing); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateAddLoan = stateAddLoan;

const __tuff_outer_for_stateAnyConflictingLoan = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateAnyConflictingLoan(state, base, path) {
  let __tuff_this = { state: state, base: base, path: path, this: __tuff_outer_for_stateAnyConflictingLoan };
  let baseLoans = (() => { const __recv = stateLoansByBase(state); const __prop = __recv?.["mapGetOrDefault"]; if (typeof __prop === "function") return __prop(base, vecNew()); const __dyn = __recv?.table?.mapGetOrDefault; return __dyn ? __dyn(__recv.ref, base, vecNew()) : mapGetOrDefault(__recv, base, vecNew()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.baseLoans = baseLoans;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = baseLoans; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let e = (() => { const __recv = baseLoans; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.e = e;
  let ep = (() => { const __recv = e; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 2) : vecGet(__recv, 2); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ep = ep;
  if (placesConflict(base, path, base, ep)) {
  return true;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateAnyConflictingLoan = stateAnyConflictingLoan;

const __tuff_outer_for_stateConflictingMutLoan = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateConflictingMutLoan(state, base, path) {
  let __tuff_this = { state: state, base: base, path: path, this: __tuff_outer_for_stateConflictingMutLoan };
  let baseLoans = (() => { const __recv = stateLoansByBase(state); const __prop = __recv?.["mapGetOrDefault"]; if (typeof __prop === "function") return __prop(base, vecNew()); const __dyn = __recv?.table?.mapGetOrDefault; return __dyn ? __dyn(__recv.ref, base, vecNew()) : mapGetOrDefault(__recv, base, vecNew()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.baseLoans = baseLoans;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = baseLoans; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let e = (() => { const __recv = baseLoans; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.e = e;
  if (((() => { const __recv = e; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })() === 2)) {
  let ep = (() => { const __recv = e; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 2) : vecGet(__recv, 2); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ep = ep;
  if (placesConflict(base, path, base, ep)) {
  return true;
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateConflictingMutLoan = stateConflictingMutLoan;

const __tuff_outer_for_stateConflictingImmutLoan = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateConflictingImmutLoan(state, base, path) {
  let __tuff_this = { state: state, base: base, path: path, this: __tuff_outer_for_stateConflictingImmutLoan };
  let baseLoans = (() => { const __recv = stateLoansByBase(state); const __prop = __recv?.["mapGetOrDefault"]; if (typeof __prop === "function") return __prop(base, vecNew()); const __dyn = __recv?.table?.mapGetOrDefault; return __dyn ? __dyn(__recv.ref, base, vecNew()) : mapGetOrDefault(__recv, base, vecNew()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.baseLoans = baseLoans;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = baseLoans; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let e = (() => { const __recv = baseLoans; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.e = e;
  if (((() => { const __recv = e; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })() === 1)) {
  let ep = (() => { const __recv = e; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 2) : vecGet(__recv, 2); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ep = ep;
  if (placesConflict(base, path, base, ep)) {
  return true;
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateConflictingImmutLoan = stateConflictingImmutLoan;

const __tuff_outer_for_stateClone = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateClone(src) {
  let __tuff_this = { src: src, this: __tuff_outer_for_stateClone };
  let dst = stateNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.dst = dst;
  let srcMoved = stateMovedVec(src); if (typeof __tuff_this !== 'undefined') __tuff_this.srcMoved = srcMoved;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = srcMoved; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  stateMovedAdd(dst, (() => { const __recv = srcMoved; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let srcLoans = stateLoans(src); if (typeof __tuff_this !== 'undefined') __tuff_this.srcLoans = srcLoans;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  len = (() => { const __recv = srcLoans; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let e = (() => { const __recv = srcLoans; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.e = e;
  stateAddLoan(dst, (() => { const __recv = e; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(), (() => { const __recv = e; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), (() => { const __recv = e; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 2) : vecGet(__recv, 2); })());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let srcScopes = stateScopeStarts(src); if (typeof __tuff_this !== 'undefined') __tuff_this.srcScopes = srcScopes;
  (() => { const __recv = dst; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(3, (() => { const __recv = srcScopes; const __prop = __recv?.["vecClone"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClone; return __dyn ? __dyn(__recv.ref) : vecClone(__recv); })()); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, 3, (() => { const __recv = srcScopes; const __prop = __recv?.["vecClone"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClone; return __dyn ? __dyn(__recv.ref) : vecClone(__recv); })()) : vecSet(__recv, 3, (() => { const __recv = srcScopes; const __prop = __recv?.["vecClone"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClone; return __dyn ? __dyn(__recv.ref) : vecClone(__recv); })()); })();
  let srcDropped = stateDroppedVec(src); if (typeof __tuff_this !== 'undefined') __tuff_this.srcDropped = srcDropped;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  len = (() => { const __recv = srcDropped; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  stateDroppedAdd(dst, (() => { const __recv = srcDropped; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return dst;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateClone = stateClone;

const __tuff_outer_for_stateMergeMovedFromBranches = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stateMergeMovedFromBranches(dst, a, b) {
  let __tuff_this = { dst: dst, a: a, b: b, this: __tuff_outer_for_stateMergeMovedFromBranches };
  let newSet = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.newSet = newSet;
  let newVec = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.newVec = newVec;
  let av = stateMovedVec(a); if (typeof __tuff_this !== 'undefined') __tuff_this.av = av;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = av; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let n = (() => { const __recv = av; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  if (((() => { const __recv = stateMovedSet(a); const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, n) : setHas(__recv, n); })() && (!(() => { const __recv = newSet; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, n) : setHas(__recv, n); })()))) {
  (() => { const __recv = newSet; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, n) : setAdd(__recv, n); })();
  (() => { const __recv = newVec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, n) : vecPush(__recv, n); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let bv = stateMovedVec(b); if (typeof __tuff_this !== 'undefined') __tuff_this.bv = bv;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  len = (() => { const __recv = bv; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let n = (() => { const __recv = bv; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  if (((() => { const __recv = stateMovedSet(b); const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, n) : setHas(__recv, n); })() && (!(() => { const __recv = newSet; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, n) : setHas(__recv, n); })()))) {
  (() => { const __recv = newSet; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, n) : setAdd(__recv, n); })();
  (() => { const __recv = newVec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, n) : vecPush(__recv, n); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  (() => { const __recv = dst; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(0, newSet); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, 0, newSet) : vecSet(__recv, 0, newSet); })();
  (() => { const __recv = dst; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(1, newVec); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, 1, newVec) : vecSet(__recv, 1, newVec); })();
  let droppedSet = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.droppedSet = droppedSet;
  let droppedVec = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.droppedVec = droppedVec;
  let adv = stateDroppedVec(a); if (typeof __tuff_this !== 'undefined') __tuff_this.adv = adv;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  len = (() => { const __recv = adv; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let n = (() => { const __recv = adv; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  if (((() => { const __recv = stateDroppedSet(a); const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, n) : setHas(__recv, n); })() && (!(() => { const __recv = droppedSet; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, n) : setHas(__recv, n); })()))) {
  (() => { const __recv = droppedSet; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, n) : setAdd(__recv, n); })();
  (() => { const __recv = droppedVec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, n) : vecPush(__recv, n); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let bdv = stateDroppedVec(b); if (typeof __tuff_this !== 'undefined') __tuff_this.bdv = bdv;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  len = (() => { const __recv = bdv; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let n = (() => { const __recv = bdv; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  if (((() => { const __recv = stateDroppedSet(b); const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, n) : setHas(__recv, n); })() && (!(() => { const __recv = droppedSet; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, n) : setHas(__recv, n); })()))) {
  (() => { const __recv = droppedSet; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, n) : setAdd(__recv, n); })();
  (() => { const __recv = droppedVec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, n) : vecPush(__recv, n); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  (() => { const __recv = dst; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(4, droppedSet); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, 4, droppedSet) : vecSet(__recv, 4, droppedSet); })();
  (() => { const __recv = dst; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(5, droppedVec); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, 5, droppedVec) : vecSet(__recv, 5, droppedVec); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stateMergeMovedFromBranches = stateMergeMovedFromBranches;

const __tuff_outer_for_panicBorrow = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function panicBorrow(code, message, fix) {
  let __tuff_this = { code: code, message: message, fix: fix, this: __tuff_outer_for_panicBorrow };
  return panicWithCodeLoc(code, message, "Borrowing and ownership rules require exclusive mutable access or shared immutable access, and disallow use-after-move.", fix, nodeGetLine(bcCurrentNode), nodeGetCol(bcCurrentNode));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.panicBorrow = panicBorrow;

const __tuff_outer_for_ensureReadable = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ensureReadable(expr, state) {
  let __tuff_this = { expr: expr, state: state, this: __tuff_outer_for_ensureReadable };
  let p = canonicalPlace(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  if ((!placeIsValid(p))) {
  return 0;
}
  let base = placeBase(p); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  if ((() => { const __recv = bcGlobalValueTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, base) : mapHas(__recv, base); })()) {
  return 0;
}
  if (stateDroppedHas(state, base)) {
  panicBorrow("E_BORROW_USE_AFTER_DROP", (() => { const __recv = (() => { const __recv = "Use of dropped value '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, base) : strConcat(__recv, base); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "Do not use a value after explicit or implicit drop; move/copy before dropping if needed.");
}
  if (stateMovedHas(state, base)) {
  panicBorrow("E_BORROW_USE_AFTER_MOVE", (() => { const __recv = (() => { const __recv = "Use of moved value '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, base) : strConcat(__recv, base); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "Reinitialize the value before use, or borrow it before moving.");
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ensureReadable = ensureReadable;

const __tuff_outer_for_consumePlace = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function consumePlace(expr, state, envTypes, fnReturnTypes, externTypeNames) {
  let __tuff_this = { expr: expr, state: state, envTypes: envTypes, fnReturnTypes: fnReturnTypes, externTypeNames: externTypeNames, this: __tuff_outer_for_consumePlace };
  let p = canonicalPlace(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  if ((!placeIsValid(p))) {
  return 0;
}
  let base = placeBase(p); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  let path = placePath(p); if (typeof __tuff_this !== 'undefined') __tuff_this.path = path;
  if ((() => { const __recv = base; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("__tuple_tmp_"); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "__tuple_tmp_") : strStartsWith(__recv, "__tuple_tmp_"); })()) {
  return 0;
}
  if ((() => { const __recv = bcGlobalValueTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, base) : mapHas(__recv, base); })()) {
  return 0;
}
  if (stateDroppedHas(state, base)) {
  panicBorrow("E_BORROW_USE_AFTER_DROP", (() => { const __recv = (() => { const __recv = "Use of dropped value '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, base) : strConcat(__recv, base); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "Do not use a value after explicit or implicit drop; move/copy before dropping if needed.");
}
  if (stateMovedHas(state, base)) {
  panicBorrow("E_BORROW_USE_AFTER_MOVE", (() => { const __recv = (() => { const __recv = "Use of moved value '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, base) : strConcat(__recv, base); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "Reinitialize the value before use, or borrow it with '&' / '&mut' instead of moving.");
}
  if (stateAnyConflictingLoan(state, base, path)) {
  panicBorrow("E_BORROW_MOVE_WHILE_BORROWED", (() => { const __recv = (() => { const __recv = "Cannot move '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, base) : strConcat(__recv, base); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' while it is borrowed"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' while it is borrowed") : strConcat(__recv, "' while it is borrowed"); })(), "Ensure all borrows end before moving, or pass a borrow (&/&mut) instead.");
}
  let ty = bcInferExprTypeName(expr, envTypes, fnReturnTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.ty = ty;
  if ((!isCopyType(ty, externTypeNames))) {
  stateMovedAdd(state, base);
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.consumePlace = consumePlace;

const __tuff_outer_for_checkExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function checkExpr(expr, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, mode) {
  let __tuff_this = { expr: expr, state: state, envTypes: envTypes, fnReturnTypes: fnReturnTypes, externTypeNames: externTypeNames, globalFnNames: globalFnNames, mode: mode, this: __tuff_outer_for_checkExpr };
  if ((expr === 0)) {
  return 0;
}
  bcCurrentNode = expr; if (typeof __tuff_this !== 'undefined') __tuff_this.bcCurrentNode = bcCurrentNode;
  if (((() => { const __recv = mode; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("move"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "move") : strEq(__recv, "move"); })() && (nodeKind(expr) === NK_IDENTIFIER))) {
  let nm = getInternedStr(nodeGetData1(expr)); if (typeof __tuff_this !== 'undefined') __tuff_this.nm = nm;
  if ((() => { const __recv = globalFnNames; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(nm); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, nm) : setHas(__recv, nm); })()) {
  return 0;
}
}
  if ((nodeKind(expr) === NK_UNARY_EXPR)) {
  let op = getInternedStr(nodeGetData1(expr)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&") : strEq(__recv, "&"); })() || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&mut"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&mut") : strEq(__recv, "&mut"); })())) {
  let target = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let p = canonicalPlace(target); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  if ((!placeIsValid(p))) {
  if ((nodeKind(target) === NK_STRUCT_INIT)) {
  checkExpr(target, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  return 0;
}
  panicBorrow("E_BORROW_INVALID_TARGET", "Borrow target is not a place expression", "Borrow only identifiers, fields, or index places (e.g. &x, &obj.f, &arr[i]).");
}
  ensureReadable(target, state);
  let base = placeBase(p); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  let path = placePath(p); if (typeof __tuff_this !== 'undefined') __tuff_this.path = path;
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&") : strEq(__recv, "&"); })()) {
  if (stateConflictingMutLoan(state, base, path)) {
  panicBorrow("E_BORROW_IMMUT_WHILE_MUT", (() => { const __recv = (() => { const __recv = "Cannot immutably borrow '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, base) : strConcat(__recv, base); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' because it is mutably borrowed"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' because it is mutably borrowed") : strConcat(__recv, "' because it is mutably borrowed"); })(), "End the mutable borrow first, or borrow mutably in a non-overlapping scope.");
}
  stateAddLoan(state, 1, base, path);
} else {
  if ((stateConflictingMutLoan(state, base, path) || stateConflictingImmutLoan(state, base, path))) {
  panicBorrow("E_BORROW_MUT_CONFLICT", (() => { const __recv = (() => { const __recv = "Cannot mutably borrow '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, base) : strConcat(__recv, base); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' because it is already borrowed"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' because it is already borrowed") : strConcat(__recv, "' because it is already borrowed"); })(), "Ensure no active borrows overlap this place before taking '&mut'.");
}
  stateAddLoan(state, 2, base, path);
}
  return 0;
}
}
  let kind = nodeKind(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((((kind === NK_IDENTIFIER) || (kind === NK_MEMBER_EXPR)) || (kind === NK_INDEX_EXPR))) {
  if ((() => { const __recv = mode; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("read"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "read") : strEq(__recv, "read"); })()) {
  ensureReadable(expr, state);
  return 0;
}
  consumePlace(expr, state, envTypes, fnReturnTypes, externTypeNames);
  return 0;
}
  if (((((kind === NK_NUMBER_LIT) || (kind === NK_BOOL_LIT)) || (kind === NK_STRING_LIT)) || (kind === NK_CHAR_LIT))) {
  return 0;
}
  if ((kind === NK_UNARY_EXPR)) {
  checkExpr(nodeGetData2(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  return 0;
}
  if ((kind === NK_BINARY_EXPR)) {
  checkExpr(nodeGetData2(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  checkExpr(nodeGetData3(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  return 0;
}
  if ((kind === NK_CALL_EXPR)) {
  let callee = nodeGetData1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  if (((nodeKind(callee) === NK_IDENTIFIER) && (() => { const __recv = getInternedStr(nodeGetData1(callee)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("drop"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "drop") : strEq(__recv, "drop"); })())) {
  let args = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() !== 1)) {
  panicBorrow("E_BORROW_INVALID_TARGET", "drop expects exactly one argument", "Call drop with exactly one local/place value such as drop(x) or x.drop().");
}
  let target = (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let p = canonicalPlace(target); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  if ((!placeIsValid(p))) {
  panicBorrow("E_BORROW_INVALID_TARGET", "drop target must be a place expression", "Call drop with a local/place value such as drop(x) or x.drop().");
}
  let base = placeBase(p); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  let path = placePath(p); if (typeof __tuff_this !== 'undefined') __tuff_this.path = path;
  if (stateDroppedHas(state, base)) {
  panicBorrow("E_BORROW_DOUBLE_DROP", (() => { const __recv = (() => { const __recv = "Double drop of '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, base) : strConcat(__recv, base); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "Ensure each owned value is dropped exactly once.");
}
  let targetType = bcInferExprTypeName(target, envTypes, fnReturnTypes); if (typeof __tuff_this !== 'undefined') __tuff_this.targetType = targetType;
  if ((!(() => { const __recv = bcDestructorAliases; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(targetType); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, targetType) : mapHas(__recv, targetType); })())) {
  panicBorrow("E_BORROW_DROP_MISSING_DESTRUCTOR", (() => { const __recv = (() => { const __recv = "Type '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(targetType); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, targetType) : strConcat(__recv, targetType); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' has no associated destructor"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' has no associated destructor") : strConcat(__recv, "' has no associated destructor"); })(), "Associate a destructor via 'type Alias = Base then destructorName;' and use that alias type.");
}
  ensureReadable(target, state);
  if (stateAnyConflictingLoan(state, base, path)) {
  panicBorrow("E_BORROW_MOVE_WHILE_BORROWED", (() => { const __recv = (() => { const __recv = "Cannot drop '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, base) : strConcat(__recv, base); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' while it is borrowed"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' while it is borrowed") : strConcat(__recv, "' while it is borrowed"); })(), "Ensure all borrows end before dropping the value.");
}
  stateDroppedAdd(state, base);
  stateMovedAdd(state, base);
  return 0;
}
  if ((((nodeKind(callee) === NK_IDENTIFIER) && (() => { const __recv = getInternedStr(nodeGetData1(callee)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "into") : strEq(__recv, "into"); })()) && (nodeGetData3(expr) === 1))) {
  let args = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() >= 1)) {
  let receiver = (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.receiver = receiver;
  let receiverMode = "read"; if (typeof __tuff_this !== 'undefined') __tuff_this.receiverMode = receiverMode;
  if (placeIsValid(canonicalPlace(receiver))) {
  receiverMode = "move"; if (typeof __tuff_this !== 'undefined') __tuff_this.receiverMode = receiverMode;
}
  checkExpr(receiver, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, receiverMode);
}
  let i = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  checkExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((!((nodeKind(callee) === NK_IDENTIFIER) && (() => { const __recv = globalFnNames; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(callee))); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(callee))) : setHas(__recv, getInternedStr(nodeGetData1(callee))); })()))) {
  checkExpr(callee, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
}
  let args = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  checkExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_STRUCT_INIT)) {
  let fields = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  checkExpr((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_TUPLE_EXPR)) {
  let items = nodeGetData1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = items; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  checkExpr((() => { const __recv = items; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_IF_EXPR)) {
  checkExpr(nodeGetData1(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  let thenState = stateClone(state); if (typeof __tuff_this !== 'undefined') __tuff_this.thenState = thenState;
  checkStmt(nodeGetData2(expr), thenState, envTypes, fnReturnTypes, externTypeNames, globalFnNames);
  if ((nodeGetData3(expr) !== 0)) {
  let elseState = stateClone(state); if (typeof __tuff_this !== 'undefined') __tuff_this.elseState = elseState;
  checkStmt(nodeGetData3(expr), elseState, envTypes, fnReturnTypes, externTypeNames, globalFnNames);
  stateMergeMovedFromBranches(state, thenState, elseState);
} else {
  stateMergeMovedFromBranches(state, thenState, state);
}
  return 0;
}
  if ((kind === NK_MATCH_EXPR)) {
  checkExpr(nodeGetData1(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  let cases = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let merged = stateClone(state); if (typeof __tuff_this !== 'undefined') __tuff_this.merged = merged;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let c = (() => { const __recv = cases; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.c = c;
  let branch = stateClone(state); if (typeof __tuff_this !== 'undefined') __tuff_this.branch = branch;
  checkStmt((() => { const __recv = c; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), branch, envTypes, fnReturnTypes, externTypeNames, globalFnNames);
  stateMergeMovedFromBranches(merged, merged, branch);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  stateMergeMovedFromBranches(state, merged, state);
  return 0;
}
  if ((kind === NK_IS_EXPR)) {
  checkExpr(nodeGetData1(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  return 0;
}
  if ((kind === NK_UNWRAP_EXPR)) {
  checkExpr(nodeGetData1(expr), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  return 0;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.checkExpr = checkExpr;

const __tuff_outer_for_bcStmtDiverges = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function bcStmtDiverges(stmt) {
  let __tuff_this = { stmt: stmt, this: __tuff_outer_for_bcStmtDiverges };
  if ((stmt === 0)) {
  return false;
}
  let k = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((k === NK_RETURN_STMT)) {
  return true;
}
  if ((k === NK_BLOCK)) {
  let stmts = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return false;
}
  return bcStmtDiverges((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((len - 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (len - 1)) : vecGet(__recv, (len - 1)); })());
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.bcStmtDiverges = bcStmtDiverges;

const __tuff_outer_for_checkBlock = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function checkBlock(block, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames) {
  let __tuff_this = { block: block, state: state, envTypes: envTypes, fnReturnTypes: fnReturnTypes, externTypeNames: externTypeNames, globalFnNames: globalFnNames, this: __tuff_outer_for_checkBlock };
  stateBeginScope(state);
  let stmts = nodeGetData1(block); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  checkStmt((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return stateEndScope(state);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.checkBlock = checkBlock;

const __tuff_outer_for_checkStmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function checkStmt(stmt, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames) {
  let __tuff_this = { stmt: stmt, state: state, envTypes: envTypes, fnReturnTypes: fnReturnTypes, externTypeNames: externTypeNames, globalFnNames: globalFnNames, this: __tuff_outer_for_checkStmt };
  if ((stmt === 0)) {
  return 0;
}
  bcCurrentNode = stmt; if (typeof __tuff_this !== 'undefined') __tuff_this.bcCurrentNode = bcCurrentNode;
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LET_DECL)) {
  let rhs = nodeGetData3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.rhs = rhs;
  let mode = "read"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
  let p = canonicalPlace(rhs); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  if (placeIsValid(p)) {
  if ((nodeKind(rhs) === NK_IDENTIFIER)) {
  mode = "move"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
} else {
  mode = "read"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
}
}
  checkExpr(rhs, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, mode);
  let name = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let tnode = nodeGetData2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.tnode = tnode;
  if ((tnode !== 0)) {
  (() => { const __recv = envTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(name, bcTypeNameFromTypeNode(tnode)); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, name, bcTypeNameFromTypeNode(tnode)) : mapSet(__recv, name, bcTypeNameFromTypeNode(tnode)); })();
} else {
  (() => { const __recv = envTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(name, bcInferExprTypeName(rhs, envTypes, fnReturnTypes)); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, name, bcInferExprTypeName(rhs, envTypes, fnReturnTypes)) : mapSet(__recv, name, bcInferExprTypeName(rhs, envTypes, fnReturnTypes)); })();
}
  stateMovedDelete(state, name);
  stateDroppedDelete(state, name);
  return 0;
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  return 0;
}
  if ((kind === NK_ASSIGN_STMT)) {
  let target = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let tplace = canonicalPlace(target); if (typeof __tuff_this !== 'undefined') __tuff_this.tplace = tplace;
  if (placeIsValid(tplace)) {
  let base = placeBase(tplace); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  let path = placePath(tplace); if (typeof __tuff_this !== 'undefined') __tuff_this.path = path;
  if (stateAnyConflictingLoan(state, base, path)) {
  panicBorrow("E_BORROW_ASSIGN_WHILE_BORROWED", (() => { const __recv = (() => { const __recv = "Cannot assign to '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, base) : strConcat(__recv, base); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' while it is borrowed"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' while it is borrowed") : strConcat(__recv, "' while it is borrowed"); })(), "End active borrows before assignment, or assign in a non-overlapping scope.");
}
}
  let rhs = nodeGetData2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.rhs = rhs;
  let mode = "read"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
  let rhsPlace = canonicalPlace(rhs); if (typeof __tuff_this !== 'undefined') __tuff_this.rhsPlace = rhsPlace;
  if (placeIsValid(rhsPlace)) {
  mode = "move"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
}
  checkExpr(rhs, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, mode);
  if ((nodeKind(target) === NK_IDENTIFIER)) {
  let targetName = getInternedStr(nodeGetData1(target)); if (typeof __tuff_this !== 'undefined') __tuff_this.targetName = targetName;
  stateMovedDelete(state, targetName);
  stateDroppedDelete(state, targetName);
}
  return 0;
}
  if ((kind === NK_EXPR_STMT)) {
  checkExpr(nodeGetData1(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "move");
  return 0;
}
  if ((kind === NK_RETURN_STMT)) {
  let v = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  if ((v !== 0)) {
  let mode = "read"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
  if (placeIsValid(canonicalPlace(v))) {
  mode = "move"; if (typeof __tuff_this !== 'undefined') __tuff_this.mode = mode;
}
  checkExpr(v, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, mode);
}
  return 0;
}
  if ((kind === NK_IF_STMT)) {
  checkExpr(nodeGetData1(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  let thenBranch = nodeGetData2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.thenBranch = thenBranch;
  let elseBranch = nodeGetData3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.elseBranch = elseBranch;
  let thenState = stateClone(state); if (typeof __tuff_this !== 'undefined') __tuff_this.thenState = thenState;
  checkStmt(thenBranch, thenState, envTypes, fnReturnTypes, externTypeNames, globalFnNames);
  let thenDiverges = bcStmtDiverges(thenBranch); if (typeof __tuff_this !== 'undefined') __tuff_this.thenDiverges = thenDiverges;
  if ((elseBranch !== 0)) {
  let elseState = stateClone(state); if (typeof __tuff_this !== 'undefined') __tuff_this.elseState = elseState;
  checkStmt(elseBranch, elseState, envTypes, fnReturnTypes, externTypeNames, globalFnNames);
  let elseDiverges = bcStmtDiverges(elseBranch); if (typeof __tuff_this !== 'undefined') __tuff_this.elseDiverges = elseDiverges;
  if ((thenDiverges && elseDiverges)) {
  stateMergeMovedFromBranches(state, thenState, elseState);
} else { if (thenDiverges) {
  stateMergeMovedFromBranches(state, elseState, elseState);
} else { if (elseDiverges) {
  stateMergeMovedFromBranches(state, thenState, thenState);
} else {
  stateMergeMovedFromBranches(state, thenState, elseState);
} } }
} else {
  if (thenDiverges) {
  0;
} else {
  stateMergeMovedFromBranches(state, thenState, state);
}
}
  return 0;
}
  if ((kind === NK_FOR_STMT)) {
  checkExpr(nodeGetData2(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  checkExpr(nodeGetData3(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  stateBeginScope(state);
  (() => { const __recv = envTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(stmt)), "I32"); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(stmt)), "I32") : mapSet(__recv, getInternedStr(nodeGetData1(stmt)), "I32"); })();
  checkStmt(nodeGetData4(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames);
  stateEndScope(state);
  return 0;
}
  if ((kind === NK_WHILE_STMT)) {
  checkExpr(nodeGetData1(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "read");
  stateBeginScope(state);
  checkStmt(nodeGetData2(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames);
  stateEndScope(state);
  return 0;
}
  if ((kind === NK_LOOP_STMT)) {
  stateBeginScope(state);
  checkStmt(nodeGetData1(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames);
  stateEndScope(state);
  return 0;
}
  if ((kind === NK_BLOCK)) {
  checkBlock(stmt, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames);
  return 0;
}
  if ((kind === NK_LIFETIME_STMT)) {
  checkStmt(nodeGetData2(stmt), state, envTypes, fnReturnTypes, externTypeNames, globalFnNames);
  return 0;
}
  if (((kind === NK_CONTRACT_DECL) || (kind === NK_INTO_STMT))) {
  return 0;
}
  if ((kind === NK_FN_DECL)) {
  let fnState = stateNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnState = fnState;
  let fnEnv = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnEnv = fnEnv;
  let params = nodeGetData3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let p = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let pname = getInternedStr((() => { const __recv = p; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = (() => { const __recv = p; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  (() => { const __recv = fnEnv; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(pname, bcTypeNameFromTypeNode(ptype)); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, pname, bcTypeNameFromTypeNode(ptype)) : mapSet(__recv, pname, bcTypeNameFromTypeNode(ptype)); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let body = nodeGetData5(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if ((nodeKind(body) === NK_BLOCK)) {
  checkBlock(body, fnState, fnEnv, fnReturnTypes, externTypeNames, globalFnNames);
} else {
  checkExpr(body, fnState, fnEnv, fnReturnTypes, externTypeNames, globalFnNames, "move");
}
  return 0;
}
  checkExpr(stmt, state, envTypes, fnReturnTypes, externTypeNames, globalFnNames, "move");
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.checkStmt = checkStmt;

const __tuff_outer_for_borrowcheckProgramImpl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function borrowcheckProgramImpl(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_borrowcheckProgramImpl };
  let fnReturnTypes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnReturnTypes = fnReturnTypes;
  let externTypeNames = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.externTypeNames = externTypeNames;
  let globalTypeByName = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.globalTypeByName = globalTypeByName;
  let globalFnNames = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.globalFnNames = globalFnNames;
  let body = nodeGetData1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  bcCopyTypes = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.bcCopyTypes = bcCopyTypes;
  bcCopyAliasTypes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.bcCopyAliasTypes = bcCopyAliasTypes;
  bcCopyAliasNames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.bcCopyAliasNames = bcCopyAliasNames;
  bcDestructorAliases = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.bcDestructorAliases = bcDestructorAliases;
  bcDestructorAliasNames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.bcDestructorAliasNames = bcDestructorAliasNames;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = body; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_EXTERN_TYPE_DECL)) {
  (() => { const __recv = externTypeNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(stmt))); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(stmt))) : setAdd(__recv, getInternedStr(nodeGetData1(stmt))); })();
}
  if ((kind === NK_FN_DECL)) {
  let fname = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  (() => { const __recv = globalFnNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, fname) : setAdd(__recv, fname); })();
  (() => { const __recv = fnReturnTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(fname, bcTypeNameFromTypeNode(nodeGetData4(stmt))); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, fname, bcTypeNameFromTypeNode(nodeGetData4(stmt))) : mapSet(__recv, fname, bcTypeNameFromTypeNode(nodeGetData4(stmt))); })();
}
  if (((kind === NK_LET_DECL) || (kind === NK_EXTERN_LET_DECL))) {
  (() => { const __recv = globalTypeByName; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(stmt)), bcTypeNameFromTypeNode(nodeGetData2(stmt))); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(stmt)), bcTypeNameFromTypeNode(nodeGetData2(stmt))) : mapSet(__recv, getInternedStr(nodeGetData1(stmt)), bcTypeNameFromTypeNode(nodeGetData2(stmt))); })();
}
  if ((kind === NK_ENUM_DECL)) {
  (() => { const __recv = bcCopyTypes; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(stmt))); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(stmt))) : setAdd(__recv, getInternedStr(nodeGetData1(stmt))); })();
}
  if (((kind === NK_STRUCT_DECL) && (nodeGetData4(stmt) === 1))) {
  (() => { const __recv = bcCopyTypes; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(stmt))); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(stmt))) : setAdd(__recv, getInternedStr(nodeGetData1(stmt))); })();
}
  if (((kind === NK_TYPE_ALIAS) && (nodeGetData4(stmt) === 1))) {
  let aliasName = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  (() => { const __recv = bcCopyAliasNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, aliasName) : vecPush(__recv, aliasName); })();
  (() => { const __recv = bcCopyAliasTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, nodeGetData3(stmt)); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, nodeGetData3(stmt)) : mapSet(__recv, aliasName, nodeGetData3(stmt)); })();
}
  if (((kind === NK_TYPE_ALIAS) && (nodeGetData5(stmt) !== 0))) {
  let aliasName = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  let destructorName = getInternedStr(nodeGetData5(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
  (() => { const __recv = bcDestructorAliases; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, destructorName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, destructorName) : mapSet(__recv, aliasName, destructorName); })();
  (() => { const __recv = bcDestructorAliasNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, aliasName) : vecPush(__recv, aliasName); })();
}
  if (((kind === NK_EXTERN_TYPE_DECL) && (nodeGetData5(stmt) !== 0))) {
  let aliasName = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  let destructorName = getInternedStr(nodeGetData5(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
  (() => { const __recv = bcDestructorAliases; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, destructorName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, destructorName) : mapSet(__recv, aliasName, destructorName); })();
  (() => { const __recv = bcDestructorAliasNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, aliasName) : vecPush(__recv, aliasName); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let dlen = (() => { const __recv = bcDestructorAliasNames; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dlen = dlen;
  while ((i < dlen)) {
  let aliasName = (() => { const __recv = bcDestructorAliasNames; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  let destructorName = (() => { const __recv = bcDestructorAliases; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, aliasName) : mapGet(__recv, aliasName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.destructorName = destructorName;
  let found = false; if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let sk = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.sk = sk;
  if (((sk === NK_FN_DECL) && (() => { const __recv = getInternedStr(nodeGetData1(stmt)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(destructorName); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, destructorName) : strEq(__recv, destructorName); })())) {
  found = true; if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  let valid = true; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
  let params = nodeGetData3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  if (((() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() !== 1)) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
} else {
  let p0 = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p0 = p0;
  let pname = getInternedStr((() => { const __recv = p0; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = (() => { const __recv = p0; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if ((!(() => { const __recv = pname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })())) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
}
  if ((!bcTypeNodeIsDestructorReceiver(ptype, aliasName))) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
}
}
  if ((!(() => { const __recv = bcTypeNameFromTypeNode(nodeGetData4(stmt)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Void"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Void") : strEq(__recv, "Void"); })())) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
}
  if ((!valid)) {
  panicWithCode("E_TYPE_DESTRUCTOR_SIGNATURE", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Destructor '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(destructorName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, destructorName) : strConcat(__recv, destructorName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' must have signature fn "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' must have signature fn ") : strConcat(__recv, "' must have signature fn "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(destructorName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, destructorName) : strConcat(__recv, destructorName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(this : "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(this : ") : strConcat(__recv, "(this : "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, aliasName) : strConcat(__recv, aliasName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("<...>) : Void"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "<...>) : Void") : strConcat(__recv, "<...>) : Void"); })(), "Destructor signatures must use the alias receiver type (or legacy '*move Alias') and return Void.", "Use exactly one receiver parameter named 'this' with alias type and return Void.");
}
  break;
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  if ((!found)) {
  panicWithCode("E_TYPE_DESTRUCTOR_NOT_FOUND", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Destructor '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(destructorName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, destructorName) : strConcat(__recv, destructorName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' for alias '"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' for alias '") : strConcat(__recv, "' for alias '"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, aliasName) : strConcat(__recv, aliasName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' was not found"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' was not found") : strConcat(__recv, "' was not found"); })(), "A type declaration referenced a destructor function that does not exist.", "Declare the destructor function before using it in 'type Alias = ... then destructor' or 'extern type Alias then destructor'.");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let copyAliasCount = (() => { const __recv = bcCopyAliasNames; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.copyAliasCount = copyAliasCount;
  while ((i < copyAliasCount)) {
  let aliasName = (() => { const __recv = bcCopyAliasNames; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  let aliasType = (() => { const __recv = bcCopyAliasTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, aliasName) : mapGet(__recv, aliasName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasType = aliasType;
  let visiting = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.visiting = visiting;
  (() => { const __recv = visiting; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, aliasName) : setAdd(__recv, aliasName); })();
  if ((!bcTypeNodeIsCopyable(aliasType, externTypeNames, visiting))) {
  panicWithCode("E_BORROW_INVALID_COPY_ALIAS", (() => { const __recv = (() => { const __recv = "copy type "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, aliasName) : strConcat(__recv, aliasName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" must alias a copy-compatible type"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " must alias a copy-compatible type") : strConcat(__recv, " must alias a copy-compatible type"); })(), "A type alias marked 'copy' resolved to a non-copy type under move semantics.", "Only mark aliases as 'copy' when the aliased type is copy-compatible (primitives, pointers, enums, copy structs, or other copy aliases).");
}
  (() => { const __recv = bcCopyTypes; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, aliasName) : setAdd(__recv, aliasName); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let state = stateNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.state = state;
  let env = globalTypeByName; if (typeof __tuff_this !== 'undefined') __tuff_this.env = env;
  bcGlobalValueTypes = globalTypeByName; if (typeof __tuff_this !== 'undefined') __tuff_this.bcGlobalValueTypes = bcGlobalValueTypes;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  checkStmt((() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), state, env, fnReturnTypes, externTypeNames, globalFnNames);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return program;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.borrowcheckProgramImpl = borrowcheckProgramImpl;

const __tuff_outer_for_selfhostBorrowcheckImplMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostBorrowcheckImplMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostBorrowcheckImplMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostBorrowcheckImplMarker = selfhostBorrowcheckImplMarker;

const __tuff_outer_for_borrowcheckProgram = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function borrowcheckProgram(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_borrowcheckProgram };
  return borrowcheckProgramImpl(program);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.borrowcheckProgram = borrowcheckProgram;

const __tuff_outer_for_selfhostBorrowcheckMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostBorrowcheckMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostBorrowcheckMarker };
  return selfhostBorrowcheckImplMarker();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostBorrowcheckMarker = selfhostBorrowcheckMarker;

const __tuff_outer_for_jsEmitStructDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function jsEmitStructDecl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_jsEmitStructDecl };
  let nameIdx = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.nameIdx = nameIdx;
  let name = getInternedStr(nameIdx); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let fields = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "function ");
  sbAppend(sb, name);
  sbAppend(sb, "(fields = {}) { return { __tag: \"");
  sbAppend(sb, name);
  sbAppend(sb, "\"");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  let fname = getInternedStr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  sbAppend(sb, ", ");
  sbAppend(sb, fname);
  sbAppend(sb, ": fields.");
  sbAppend(sb, fname);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, " }; }");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.jsEmitStructDecl = jsEmitStructDecl;

const __tuff_outer_for_jsEmitEnumDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function jsEmitEnumDecl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_jsEmitEnumDecl };
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let variants = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.variants = variants;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "const ");
  sbAppend(sb, name);
  sbAppend(sb, " = { ");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = variants; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  if ((i > 0)) {
  sbAppend(sb, ", ");
}
  let v = getInternedStr((() => { const __recv = variants; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  sbAppend(sb, v);
  sbAppend(sb, ": { __tag: \"");
  sbAppend(sb, v);
  sbAppend(sb, "\" }");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, " }; ");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.jsEmitEnumDecl = jsEmitEnumDecl;

const __tuff_outer_for_jsEmitObjectDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function jsEmitObjectDecl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_jsEmitObjectDecl };
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let inputs = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.inputs = inputs;
  if (((inputs === 0) || ((() => { const __recv = inputs; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 0))) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "const "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = { __tag: \""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = { __tag: \"") : strConcat(__recv, " = { __tag: \""); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\" }; "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\" }; ") : strConcat(__recv, "\" }; "); })();
}
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "const ");
  sbAppend(sb, name);
  sbAppend(sb, " = (() => { const __cache = new Map(); return (fields = {}) => { const __key = JSON.stringify([");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = inputs; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  if ((i > 0)) {
  sbAppend(sb, ", ");
}
  let inputField = (() => { const __recv = inputs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.inputField = inputField;
  let fname = getInternedStr((() => { const __recv = inputField; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  sbAppend(sb, "fields.");
  sbAppend(sb, fname);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "]); const __cached = __cache.get(__key); if (__cached !== undefined) return __cached; const __value = { __tag: \"");
  sbAppend(sb, name);
  sbAppend(sb, "\"");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let inputField = (() => { const __recv = inputs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.inputField = inputField;
  let fname = getInternedStr((() => { const __recv = inputField; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  sbAppend(sb, ", ");
  sbAppend(sb, fname);
  sbAppend(sb, ": fields.");
  sbAppend(sb, fname);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, " }; __cache.set(__key, __value); return __value; }; })();");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.jsEmitObjectDecl = jsEmitObjectDecl;

const __tuff_outer_for_jsEmitContractDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function jsEmitContractDecl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_jsEmitContractDecl };
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = "// contract "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.jsEmitContractDecl = jsEmitContractDecl;

const __tuff_outer_for_selfhostCodegenStmtDeclEmittersMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostCodegenStmtDeclEmittersMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostCodegenStmtDeclEmittersMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostCodegenStmtDeclEmittersMarker = selfhostCodegenStmtDeclEmittersMarker;

let jsGlobalDtorTypeMap = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.jsGlobalDtorTypeMap = jsGlobalDtorTypeMap;

let jsFnStack = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.jsFnStack = jsFnStack;

const __tuff_outer_for_jsFnStackPush = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function jsFnStackPush(hasExplicitThis, fnName) {
  let __tuff_this = { hasExplicitThis: hasExplicitThis, fnName: fnName, this: __tuff_outer_for_jsFnStackPush };
  let frame = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.frame = frame;
  let _a = (() => { const __recv = frame; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(hasExplicitThis); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, hasExplicitThis) : vecPush(__recv, hasExplicitThis); })(); if (typeof __tuff_this !== 'undefined') __tuff_this._a = _a;
  let _b = (() => { const __recv = frame; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(fnName); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, fnName) : vecPush(__recv, fnName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this._b = _b;
  let _c = (() => { const __recv = jsFnStack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(frame); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, frame) : vecPush(__recv, frame); })(); if (typeof __tuff_this !== 'undefined') __tuff_this._c = _c;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.jsFnStackPush = jsFnStackPush;

const __tuff_outer_for_jsFnStackPop = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function jsFnStackPop() {
  let __tuff_this = { this: __tuff_outer_for_jsFnStackPop };
  let _pop = (() => { const __recv = jsFnStack; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this._pop = _pop;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.jsFnStackPop = jsFnStackPop;

const __tuff_outer_for_jsStackInSyntheticThis = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function jsStackInSyntheticThis() {
  let __tuff_this = { this: __tuff_outer_for_jsStackInSyntheticThis };
  let h = (() => { const __recv = jsFnStack; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.h = h;
  if ((h === 0)) {
  return false;
}
  let frame = (() => { const __recv = jsFnStack; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((h - 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (h - 1)) : vecGet(__recv, (h - 1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.frame = frame;
  return ((() => { const __recv = frame; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })() === 0);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.jsStackInSyntheticThis = jsStackInSyntheticThis;

const __tuff_outer_for_jsThisExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function jsThisExpr() {
  let __tuff_this = { this: __tuff_outer_for_jsThisExpr };
  let h = (() => { const __recv = jsFnStack; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.h = h;
  if ((h === 0)) {
  return "__tuff_this";
}
  let frame = (() => { const __recv = jsFnStack; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop((h - 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, (h - 1)) : vecGet(__recv, (h - 1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.frame = frame;
  if (((() => { const __recv = frame; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })() === 1)) {
  return "__this_param";
}
  return "__tuff_this";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.jsThisExpr = jsThisExpr;

const __tuff_outer_for_jsIdentStmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function jsIdentStmt(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_jsIdentStmt };
  if ((() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })()) {
  return jsThisExpr();
}
  return name;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.jsIdentStmt = jsIdentStmt;

const __tuff_outer_for_emitStmtLetOrAssign = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitStmtLetOrAssign(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitStmtLetOrAssign };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LET_DECL)) {
  let nameIdx = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.nameIdx = nameIdx;
  let name = jsIdentStmt(getInternedStr(nameIdx)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let value = emitExpr(nodeGetData3(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  let decl = (() => { const __recv = (() => { const __recv = (() => { const __recv = "let "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = value; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = value; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })()) : strConcat(__recv, (() => { const __recv = value; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.decl = decl;
  if ((() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("__this_param"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "__this_param") : strEq(__recv, "__this_param"); })()) {
  return decl;
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = decl; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" if (typeof __tuff_this !== 'undefined') __tuff_this."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " if (typeof __tuff_this !== 'undefined') __tuff_this.") : strConcat(__recv, " if (typeof __tuff_this !== 'undefined') __tuff_this."); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })();
}
  if ((kind === NK_ASSIGN_STMT)) {
  let targetNode = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.targetNode = targetNode;
  let target = emitExpr(targetNode); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let value = emitExpr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  let assign = (() => { const __recv = (() => { const __recv = (() => { const __recv = target; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, value) : strConcat(__recv, value); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.assign = assign;
  if ((nodeKind(targetNode) === NK_IDENTIFIER)) {
  let name = getInternedStr(nodeGetData1(targetNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let jsName = jsIdentStmt(name); if (typeof __tuff_this !== 'undefined') __tuff_this.jsName = jsName;
  if ((!(() => { const __recv = jsName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("__this_param"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "__this_param") : strEq(__recv, "__this_param"); })())) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = assign; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" if (typeof __tuff_this !== 'undefined') __tuff_this."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " if (typeof __tuff_this !== 'undefined') __tuff_this.") : strConcat(__recv, " if (typeof __tuff_this !== 'undefined') __tuff_this."); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(jsName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, jsName) : strConcat(__recv, jsName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(jsName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, jsName) : strConcat(__recv, jsName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })();
}
}
  if ((nodeKind(targetNode) === NK_MEMBER_EXPR)) {
  let objNode = nodeGetData1(targetNode); if (typeof __tuff_this !== 'undefined') __tuff_this.objNode = objNode;
  if ((nodeKind(objNode) === NK_IDENTIFIER)) {
  let objName = getInternedStr(nodeGetData1(objNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.objName = objName;
  if ((() => { const __recv = objName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })()) {
  let prop = getInternedStr(nodeGetData2(targetNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "if (typeof __this_param !== 'undefined') { __this_param."; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prop) : strConcat(__recv, prop); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, value) : strConcat(__recv, value); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; } else { "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; } else { ") : strConcat(__recv, "; } else { "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prop) : strConcat(__recv, prop); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, value) : strConcat(__recv, value); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; if (typeof __tuff_this !== 'undefined') __tuff_this."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; if (typeof __tuff_this !== 'undefined') __tuff_this.") : strConcat(__recv, "; if (typeof __tuff_this !== 'undefined') __tuff_this."); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prop) : strConcat(__recv, prop); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prop) : strConcat(__recv, prop); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; }"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; }") : strConcat(__recv, "; }"); })();
}
}
}
  return assign;
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitStmtLetOrAssign = emitStmtLetOrAssign;

const __tuff_outer_for_emitStmtFlow = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitStmtFlow(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitStmtFlow };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_IMPORT_DECL)) {
  return "// import placeholder";
}
  if ((kind === NK_EXPR_STMT)) {
  return (() => { const __recv = emitExpr(nodeGetData1(n)); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })();
}
  if ((kind === NK_RETURN_STMT)) {
  let value = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  if ((value === 0)) {
  return "return;";
}
  return (() => { const __recv = "return "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = emitExpr(value); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = emitExpr(value); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })()) : strConcat(__recv, (() => { const __recv = emitExpr(value); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })()); })();
}
  if ((kind === NK_IF_STMT)) {
  let cond = emitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let thenB = emitBlock(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.thenB = thenB;
  let elseB = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.elseB = elseB;
  if ((elseB === 0)) {
  return (() => { const __recv = (() => { const __recv = "if ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cond) : strConcat(__recv, cond); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(thenB); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, thenB) : strConcat(__recv, thenB); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(thenB); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, thenB) : strConcat(__recv, thenB); })()) : strConcat(__recv, (() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(thenB); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, thenB) : strConcat(__recv, thenB); })()); })();
}
  return strConcat((() => { const __recv = (() => { const __recv = (() => { const __recv = "if ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cond) : strConcat(__recv, cond); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") ") : strConcat(__recv, ") "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(thenB); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, thenB) : strConcat(__recv, thenB); })(), (() => { const __recv = " else "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitStmtOrBlock(elseB)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitStmtOrBlock(elseB)) : strConcat(__recv, emitStmtOrBlock(elseB)); })());
}
  if ((kind === NK_IF_EXPR)) {
  let cond = emitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let thenB = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.thenB = thenB;
  let elseB = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.elseB = elseB;
  let thenStr = emitStmtOrBlock(thenB); if (typeof __tuff_this !== 'undefined') __tuff_this.thenStr = thenStr;
  if ((elseB === 0)) {
  return (() => { const __recv = (() => { const __recv = "if ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cond) : strConcat(__recv, cond); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(thenStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, thenStr) : strConcat(__recv, thenStr); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(thenStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, thenStr) : strConcat(__recv, thenStr); })()) : strConcat(__recv, (() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(thenStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, thenStr) : strConcat(__recv, thenStr); })()); })();
}
  return strConcat((() => { const __recv = (() => { const __recv = (() => { const __recv = "if ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cond) : strConcat(__recv, cond); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") ") : strConcat(__recv, ") "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(thenStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, thenStr) : strConcat(__recv, thenStr); })(), (() => { const __recv = " else "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitStmtOrBlock(elseB)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitStmtOrBlock(elseB)) : strConcat(__recv, emitStmtOrBlock(elseB)); })());
}
  if ((kind === NK_WHILE_STMT)) {
  return (() => { const __recv = (() => { const __recv = "while ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitExpr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitExpr(nodeGetData1(n))) : strConcat(__recv, emitExpr(nodeGetData1(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitBlock(nodeGetData2(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitBlock(nodeGetData2(n))) : strConcat(__recv, emitBlock(nodeGetData2(n))); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitBlock(nodeGetData2(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitBlock(nodeGetData2(n))) : strConcat(__recv, emitBlock(nodeGetData2(n))); })()) : strConcat(__recv, (() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitBlock(nodeGetData2(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitBlock(nodeGetData2(n))) : strConcat(__recv, emitBlock(nodeGetData2(n))); })()); })();
}
  if ((kind === NK_FOR_STMT)) {
  let iter = jsIdentStmt(getInternedStr(nodeGetData1(n))); if (typeof __tuff_this !== 'undefined') __tuff_this.iter = iter;
  let start = emitExpr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.start = start;
  let end = emitExpr(nodeGetData3(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
  let body = emitBlock(nodeGetData4(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  return strConcat(strConcat(strConcat(strConcat((() => { const __recv = (() => { const __recv = (() => { const __recv = "for (let "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(iter); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, iter) : strConcat(__recv, iter); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(start); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, start) : strConcat(__recv, start); })(), (() => { const __recv = "; "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(iter); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, iter) : strConcat(__recv, iter); })()), (() => { const __recv = " < "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(end); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, end) : strConcat(__recv, end); })()), (() => { const __recv = "; "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = iter; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("++) "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "++) ") : strConcat(__recv, "++) "); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = iter; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("++) "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "++) ") : strConcat(__recv, "++) "); })()) : strConcat(__recv, (() => { const __recv = iter; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("++) "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "++) ") : strConcat(__recv, "++) "); })()); })()), body);
}
  if ((kind === NK_LOOP_STMT)) {
  return (() => { const __recv = "while (true) "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitBlock(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitBlock(nodeGetData1(n))) : strConcat(__recv, emitBlock(nodeGetData1(n))); })();
}
  if ((kind === NK_BREAK_STMT)) {
  return "break;";
}
  if ((kind === NK_CONTINUE_STMT)) {
  return "continue;";
}
  if ((kind === NK_INTO_STMT)) {
  return (() => { const __recv = "// into "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })();
}
  if ((kind === NK_LIFETIME_STMT)) {
  return emitBlock(nodeGetData2(n));
}
  if ((kind === NK_BLOCK)) {
  return emitBlock(n);
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitStmtFlow = emitStmtFlow;

const __tuff_outer_for_emitStmtFnDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitStmtFnDecl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitStmtFnDecl };
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let params = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let body = nodeGetData5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let paramNames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.paramNames = paramNames;
  let hasExplicitThis = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.hasExplicitThis = hasExplicitThis;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let pname = getInternedStr((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  if ((() => { const __recv = pname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })()) {
  hasExplicitThis = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.hasExplicitThis = hasExplicitThis;
  (() => { const __recv = paramNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop("__this_param"); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, "__this_param") : vecPush(__recv, "__this_param"); })();
} else {
  (() => { const __recv = paramNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pname) : vecPush(__recv, pname); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let paramsStr = (() => { const __recv = paramNames; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.paramsStr = paramsStr;
  let captureVar = (() => { const __recv = "__tuff_outer_for_"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.captureVar = captureVar;
  let preamble = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.preamble = preamble;
  let initThis = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.initThis = initThis;
  let suffix = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.suffix = suffix;
  if ((hasExplicitThis === 1)) {
  initThis = "let __tuff_this = undefined;\n"; if (typeof __tuff_this !== 'undefined') __tuff_this.initThis = initThis;
} else {
  preamble = (() => { const __recv = (() => { const __recv = "const "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(captureVar); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, captureVar) : strConcat(__recv, captureVar); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;\n"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;\n") : strConcat(__recv, " = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;\n"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.preamble = preamble;
  let fields = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < len)) {
  let pname = getInternedStr((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  if ((!(() => { const __recv = pname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })())) {
  (() => { const __recv = fields; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = pname; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(": "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ": ") : strConcat(__recv, ": "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, pname) : strConcat(__recv, pname); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = pname; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(": "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ": ") : strConcat(__recv, ": "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, pname) : strConcat(__recv, pname); })()) : vecPush(__recv, (() => { const __recv = (() => { const __recv = pname; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(": "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ": ") : strConcat(__recv, ": "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, pname) : strConcat(__recv, pname); })()); })();
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  (() => { const __recv = fields; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = "this: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(captureVar); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, captureVar) : strConcat(__recv, captureVar); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "this: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(captureVar); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, captureVar) : strConcat(__recv, captureVar); })()) : vecPush(__recv, (() => { const __recv = "this: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(captureVar); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, captureVar) : strConcat(__recv, captureVar); })()); })();
  initThis = (() => { const __recv = (() => { const __recv = "let __tuff_this = { "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = fields; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = fields; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })()) : strConcat(__recv, (() => { const __recv = fields; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" };\n"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " };\n") : strConcat(__recv, " };\n"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.initThis = initThis;
  suffix = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "\nif (typeof __tuff_this !== 'undefined') __tuff_this."; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.suffix = suffix;
}
  if ((nodeKind(body) === NK_BLOCK)) {
  return (() => { const __recv = (() => { const __recv = preamble; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = (() => { const __recv = "function "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()) : strConcat(__recv, (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitFnBlockWithInit(body, initThis)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitFnBlockWithInit(body, initThis)) : strConcat(__recv, emitFnBlockWithInit(body, initThis)); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitFnBlockWithInit(body, initThis)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitFnBlockWithInit(body, initThis)) : strConcat(__recv, emitFnBlockWithInit(body, initThis)); })()) : strConcat(__recv, (() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitFnBlockWithInit(body, initThis)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitFnBlockWithInit(body, initThis)) : strConcat(__recv, emitFnBlockWithInit(body, initThis)); })()); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = (() => { const __recv = "function "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()) : strConcat(__recv, (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitFnBlockWithInit(body, initThis)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitFnBlockWithInit(body, initThis)) : strConcat(__recv, emitFnBlockWithInit(body, initThis)); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitFnBlockWithInit(body, initThis)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitFnBlockWithInit(body, initThis)) : strConcat(__recv, emitFnBlockWithInit(body, initThis)); })()) : strConcat(__recv, (() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitFnBlockWithInit(body, initThis)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitFnBlockWithInit(body, initThis)) : strConcat(__recv, emitFnBlockWithInit(body, initThis)); })()); })()) : strConcat(__recv, (() => { const __recv = (() => { const __recv = (() => { const __recv = "function "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()) : strConcat(__recv, (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitFnBlockWithInit(body, initThis)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitFnBlockWithInit(body, initThis)) : strConcat(__recv, emitFnBlockWithInit(body, initThis)); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitFnBlockWithInit(body, initThis)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitFnBlockWithInit(body, initThis)) : strConcat(__recv, emitFnBlockWithInit(body, initThis)); })()) : strConcat(__recv, (() => { const __recv = ") "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitFnBlockWithInit(body, initThis)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitFnBlockWithInit(body, initThis)) : strConcat(__recv, emitFnBlockWithInit(body, initThis)); })()); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(suffix); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, suffix) : strConcat(__recv, suffix); })();
}
  return (() => { const __recv = (() => { const __recv = preamble; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "function "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()) : strConcat(__recv, (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") {\n  "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") {\n  ") : strConcat(__recv, ") {\n  "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(initThis); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, initThis) : strConcat(__recv, initThis); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("  return "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "  return ") : strConcat(__recv, "  return "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitExpr(body)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitExpr(body)) : strConcat(__recv, emitExpr(body)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";\n}"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";\n}") : strConcat(__recv, ";\n}"); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "function "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()) : strConcat(__recv, (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") {\n  "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") {\n  ") : strConcat(__recv, ") {\n  "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(initThis); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, initThis) : strConcat(__recv, initThis); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("  return "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "  return ") : strConcat(__recv, "  return "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitExpr(body)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitExpr(body)) : strConcat(__recv, emitExpr(body)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";\n}"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";\n}") : strConcat(__recv, ";\n}"); })()) : strConcat(__recv, (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "function "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()) : strConcat(__recv, (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") {\n  "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") {\n  ") : strConcat(__recv, ") {\n  "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(initThis); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, initThis) : strConcat(__recv, initThis); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("  return "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "  return ") : strConcat(__recv, "  return "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitExpr(body)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitExpr(body)) : strConcat(__recv, emitExpr(body)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";\n}"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";\n}") : strConcat(__recv, ";\n}"); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(suffix); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, suffix) : strConcat(__recv, suffix); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitStmtFnDecl = emitStmtFnDecl;

const __tuff_outer_for_jsIsExternFnDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function jsIsExternFnDecl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_jsIsExternFnDecl };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  return ((kind === NK_FN_DECL) && (nodeGetData5(n) === 0));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.jsIsExternFnDecl = jsIsExternFnDecl;

const __tuff_outer_for_emitStmtDecls = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitStmtDecls(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitStmtDecls };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_EXPECT_FN_DECL)) {
  return (() => { const __recv = "// expect fn "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })();
}
  if (jsIsExternFnDecl(n)) {
  return (() => { const __recv = "// extern fn "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })();
}
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  return emitStmtFnDecl(n);
}
  if ((kind === NK_STRUCT_DECL)) {
  return jsEmitStructDecl(n);
}
  if ((kind === NK_TYPE_ALIAS)) {
  return (() => { const __recv = (() => { const __recv = "// type "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = ..."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ...") : strConcat(__recv, " = ..."); })();
}
  if ((kind === NK_DEP_TYPE_ALIAS)) {
  return (() => { const __recv = (() => { const __recv = "// type "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(...) = ..."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(...) = ...") : strConcat(__recv, "(...) = ..."); })();
}
  if ((kind === NK_ENUM_DECL)) {
  return jsEmitEnumDecl(n);
}
  if ((kind === NK_OBJECT_DECL)) {
  return jsEmitObjectDecl(n);
}
  if ((kind === NK_CONTRACT_DECL)) {
  return jsEmitContractDecl(n);
}
  if ((kind === NK_EXTERN_LET_DECL)) {
  return (() => { const __recv = "// extern let "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })();
}
  if ((kind === NK_EXTERN_TYPE_DECL)) {
  return (() => { const __recv = "// extern type "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })();
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  let parts = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.parts = parts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let source = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.source = source;
  let __len = (() => { const __recv = parts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len = __len;
  while ((i < __len)) {
  if ((i > 0)) {
  source = (() => { const __recv = source; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("::"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "::") : strConcat(__recv, "::"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.source = source;
}
  source = (() => { const __recv = source; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr((() => { const __recv = parts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr((() => { const __recv = parts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())) : strConcat(__recv, getInternedStr((() => { const __recv = parts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.source = source;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = "// extern from "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(source); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, source) : strConcat(__recv, source); })();
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitStmtDecls = emitStmtDecls;

const __tuff_outer_for_emitStmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitStmt(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitStmt };
  let code = emitStmtLetOrAssign(n); if (typeof __tuff_this !== 'undefined') __tuff_this.code = code;
  if ((!(() => { const __recv = code; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  return code;
}
  code = emitStmtFlow(n); if (typeof __tuff_this !== 'undefined') __tuff_this.code = code;
  if ((!(() => { const __recv = code; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  return code;
}
  return emitStmtDecls(n);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitStmt = emitStmt;

const __tuff_outer_for_emitStmtOrBlock = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitStmtOrBlock(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitStmtOrBlock };
  if ((nodeKind(n) === NK_BLOCK)) {
  return emitBlock(n);
}
  return (() => { const __recv = "{ "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = emitStmt(n); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" }"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " }") : strConcat(__recv, " }"); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = emitStmt(n); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" }"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " }") : strConcat(__recv, " }"); })()) : strConcat(__recv, (() => { const __recv = emitStmt(n); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" }"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " }") : strConcat(__recv, " }"); })()); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitStmtOrBlock = emitStmtOrBlock;

const __tuff_outer_for_emitBlock = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitBlock(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitBlock };
  let stmts = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "{\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  sbAppend(sb, "  ");
  sbAppend(sb, emitStmt((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()));
  sbAppend(sb, "\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "}");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitBlock = emitBlock;

const __tuff_outer_for_emitBlockAsIife = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitBlockAsIife(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitBlockAsIife };
  let stmts = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return "(() => undefined)()";
}
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "(() => {\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let isLast = (i === (len - 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.isLast = isLast;
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((isLast && (kind === NK_EXPR_STMT))) {
  sbAppend(sb, "  return ");
  sbAppend(sb, emitExpr(nodeGetData1(stmt)));
  sbAppend(sb, ";\n");
} else { if ((isLast && ((kind === NK_IF_STMT) || (kind === NK_IF_EXPR)))) {
  sbAppend(sb, "  return ");
  sbAppend(sb, emitIfAsExpr(stmt));
  sbAppend(sb, ";\n");
} else {
  sbAppend(sb, "  ");
  sbAppend(sb, emitStmt(stmt));
  sbAppend(sb, "\n");
} }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "})()");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitBlockAsIife = emitBlockAsIife;

const __tuff_outer_for_emitFnBlockWithInit = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitFnBlockWithInit(n, initThis) {
  let __tuff_this = { n: n, initThis: initThis, this: __tuff_outer_for_emitFnBlockWithInit };
  let stmts = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "{\n");
  if ((!(() => { const __recv = initThis; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  sbAppend(sb, "  ");
  sbAppend(sb, initThis);
}
  if ((len === 0)) {
  sbAppend(sb, "}");
  return sbBuild(sb);
}
  let dtorTypeMap = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.dtorTypeMap = dtorTypeMap;
  let si = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.si = si;
  while ((si < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(si); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, si) : vecGet(__recv, si); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if (((nodeKind(stmt) === NK_TYPE_ALIAS) && (nodeGetData5(stmt) !== 0))) {
  let aliasName = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  let dtorName = getInternedStr(nodeGetData5(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.dtorName = dtorName;
  (() => { const __recv = dtorTypeMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, dtorName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, dtorName) : mapSet(__recv, aliasName, dtorName); })();
}
  si = (si + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.si = si;
}
  let dtorVarNames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.dtorVarNames = dtorVarNames;
  let dtorVarDtors = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.dtorVarDtors = dtorVarDtors;
  si = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.si = si;
  while ((si < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(si); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, si) : vecGet(__recv, si); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if ((nodeKind(stmt) === NK_LET_DECL)) {
  let typeNode = nodeGetData2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.typeNode = typeNode;
  if (((typeNode !== 0) && (nodeKind(typeNode) === 40))) {
  let typeName = getInternedStr(nodeGetData1(typeNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.typeName = typeName;
  let localDtor = (() => { const __recv = dtorTypeMap; const __prop = __recv?.["mapGetOrDefault"]; if (typeof __prop === "function") return __prop(typeName, ""); const __dyn = __recv?.table?.mapGetOrDefault; return __dyn ? __dyn(__recv.ref, typeName, "") : mapGetOrDefault(__recv, typeName, ""); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.localDtor = localDtor;
  let globalDtor = (() => { const __recv = jsGlobalDtorTypeMap; const __prop = __recv?.["mapGetOrDefault"]; if (typeof __prop === "function") return __prop(typeName, ""); const __dyn = __recv?.table?.mapGetOrDefault; return __dyn ? __dyn(__recv.ref, typeName, "") : mapGetOrDefault(__recv, typeName, ""); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.globalDtor = globalDtor;
  if (((localDtor !== "") || (globalDtor !== ""))) {
  (() => { const __recv = dtorVarNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(stmt))); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(stmt))) : vecPush(__recv, getInternedStr(nodeGetData1(stmt))); })();
  if ((localDtor !== "")) {
  (() => { const __recv = dtorVarDtors; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(localDtor); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, localDtor) : vecPush(__recv, localDtor); })();
} else {
  (() => { const __recv = dtorVarDtors; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(globalDtor); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, globalDtor) : vecPush(__recv, globalDtor); })();
}
}
}
}
  si = (si + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.si = si;
}
  let dtorCalls = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.dtorCalls = dtorCalls;
  let dtorCount = (() => { const __recv = dtorVarNames; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dtorCount = dtorCount;
  if ((dtorCount > 0)) {
  let di = (dtorCount - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.di = di;
  while ((di >= 0)) {
  let vn = (() => { const __recv = dtorVarNames; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(di); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, di) : vecGet(__recv, di); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.vn = vn;
  let dn = (() => { const __recv = dtorVarDtors; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(di); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, di) : vecGet(__recv, di); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dn = dn;
  dtorCalls = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = dtorCalls; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(dn); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, dn) : strConcat(__recv, dn); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(vn); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, vn) : strConcat(__recv, vn); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(");\n  "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ");\n  ") : strConcat(__recv, ");\n  "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dtorCalls = dtorCalls;
  di = (di - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.di = di;
}
}
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let isLast = (i === (len - 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.isLast = isLast;
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((isLast && (kind === NK_EXPR_STMT))) {
  if ((!(() => { const __recv = dtorCalls; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  sbAppend(sb, "  ");
  sbAppend(sb, dtorCalls);
}
  sbAppend(sb, "  return ");
  sbAppend(sb, emitExpr(nodeGetData1(stmt)));
  sbAppend(sb, ";\n");
} else { if ((isLast && ((kind === NK_IF_STMT) || (kind === NK_IF_EXPR)))) {
  if ((!(() => { const __recv = dtorCalls; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  sbAppend(sb, "  ");
  sbAppend(sb, dtorCalls);
}
  sbAppend(sb, "  return ");
  sbAppend(sb, emitIfAsExpr(stmt));
  sbAppend(sb, ";\n");
} else {
  sbAppend(sb, "  ");
  sbAppend(sb, emitStmt(stmt));
  sbAppend(sb, "\n");
} }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "}");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitFnBlockWithInit = emitFnBlockWithInit;

const __tuff_outer_for_emitFnBlockWithPreamble = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitFnBlockWithPreamble(n, preamble) {
  let __tuff_this = { n: n, preamble: preamble, this: __tuff_outer_for_emitFnBlockWithPreamble };
  let stmts = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  if ((() => { const __recv = preamble; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) {
  return "{\n}";
}
  return (() => { const __recv = (() => { const __recv = "{\n  "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(preamble); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, preamble) : strConcat(__recv, preamble); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\n}"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\n}") : strConcat(__recv, "\n}"); })();
}
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "{\n");
  if ((!(() => { const __recv = preamble; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  sbAppend(sb, "  ");
  sbAppend(sb, preamble);
  sbAppend(sb, "\n");
}
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let isLast = (i === (len - 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.isLast = isLast;
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((isLast && (kind === NK_EXPR_STMT))) {
  sbAppend(sb, "  return ");
  sbAppend(sb, emitExpr(nodeGetData1(stmt)));
  sbAppend(sb, ";\n");
} else { if ((isLast && ((kind === NK_IF_STMT) || (kind === NK_IF_EXPR)))) {
  sbAppend(sb, "  return ");
  sbAppend(sb, emitIfAsExpr(stmt));
  sbAppend(sb, ";\n");
} else {
  sbAppend(sb, "  ");
  sbAppend(sb, emitStmt(stmt));
  sbAppend(sb, "\n");
} }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "}");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitFnBlockWithPreamble = emitFnBlockWithPreamble;

const __tuff_outer_for_emitFnBlock = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitFnBlock(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitFnBlock };
  return emitFnBlockWithPreamble(n, "");
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitFnBlock = emitFnBlock;

const __tuff_outer_for_emitIfAsExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitIfAsExpr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitIfAsExpr };
  let cond = emitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let thenBranch = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.thenBranch = thenBranch;
  let elseBranch = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.elseBranch = elseBranch;
  let thenCode = emitBranchAsExpr(thenBranch); if (typeof __tuff_this !== 'undefined') __tuff_this.thenCode = thenCode;
  let elseCode = "undefined"; if (typeof __tuff_this !== 'undefined') __tuff_this.elseCode = elseCode;
  if ((elseBranch !== 0)) {
  elseCode = emitBranchAsExpr(elseBranch); if (typeof __tuff_this !== 'undefined') __tuff_this.elseCode = elseCode;
}
  return strConcat((() => { const __recv = (() => { const __recv = (() => { const __recv = "(("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cond) : strConcat(__recv, cond); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") ? "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") ? ") : strConcat(__recv, ") ? "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = thenCode; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" : "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " : ") : strConcat(__recv, " : "); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = thenCode; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" : "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " : ") : strConcat(__recv, " : "); })()) : strConcat(__recv, (() => { const __recv = thenCode; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" : "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " : ") : strConcat(__recv, " : "); })()); })(), (() => { const __recv = elseCode; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitIfAsExpr = emitIfAsExpr;

const __tuff_outer_for_emitBranchAsExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitBranchAsExpr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitBranchAsExpr };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_BLOCK)) {
  let stmts = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return "undefined";
}
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "(() => {\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let isLast = (i === (len - 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.isLast = isLast;
  let stmtKind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.stmtKind = stmtKind;
  if ((isLast && (stmtKind === NK_EXPR_STMT))) {
  sbAppend(sb, "    return ");
  sbAppend(sb, emitExpr(nodeGetData1(stmt)));
  sbAppend(sb, ";\n");
} else { if ((isLast && ((stmtKind === NK_IF_STMT) || (stmtKind === NK_IF_EXPR)))) {
  sbAppend(sb, "    return ");
  sbAppend(sb, emitIfAsExpr(stmt));
  sbAppend(sb, ";\n");
} else {
  sbAppend(sb, "    ");
  sbAppend(sb, emitStmt(stmt));
  sbAppend(sb, "\n");
} }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "  })()");
  return sbBuild(sb);
}
  if (((kind === NK_IF_STMT) || (kind === NK_IF_EXPR))) {
  return emitIfAsExpr(n);
}
  return emitExpr(n);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitBranchAsExpr = emitBranchAsExpr;

const __tuff_outer_for_generateJs = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function generateJs(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_generateJs };
  let stmts = nodeGetData1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  jsGlobalDtorTypeMap = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.jsGlobalDtorTypeMap = jsGlobalDtorTypeMap;
  let gi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gi = gi;
  let glen = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.glen = glen;
  while ((gi < glen)) {
  let s = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(gi); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, gi) : vecGet(__recv, gi); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  let k = nodeKind(s); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  if ((((k === NK_TYPE_ALIAS) || (k === NK_EXTERN_TYPE_DECL)) && (nodeGetData5(s) !== 0))) {
  (() => { const __recv = jsGlobalDtorTypeMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(s)), getInternedStr(nodeGetData5(s))); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(s)), getInternedStr(nodeGetData5(s))) : mapSet(__recv, getInternedStr(nodeGetData1(s)), getInternedStr(nodeGetData5(s))); })();
}
  gi = (gi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.gi = gi;
}
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "\"use strict\";\n\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  sbAppend(sb, emitStmt((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()));
  sbAppend(sb, "\n\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.generateJs = generateJs;

const __tuff_outer_for_selfhostCodegenStmtMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostCodegenStmtMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostCodegenStmtMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostCodegenStmtMarker = selfhostCodegenStmtMarker;

function CodegenError(fields = {}) { return { __tag: "CodegenError", code: fields.code, message: fields.message, reason: fields.reason, fix: fields.fix, line: fields.line, col: fields.col }; }

let ccTempCounter = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccTempCounter = ccTempCounter;

let ccEnumNames = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccEnumNames = ccEnumNames;

let ccEnumVariantConsts = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccEnumVariantConsts = ccEnumVariantConsts;

let ccStructFields = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccStructFields = ccStructFields;

let ccAliasByVariant = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccAliasByVariant = ccAliasByVariant;

let ccUnionAliasInfo = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccUnionAliasInfo = ccUnionAliasInfo;

let ccCoveredExternFns = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccCoveredExternFns = ccCoveredExternFns;

let ccLocalTypes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccLocalTypes = ccLocalTypes;

let ccFnReturnTypes = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccFnReturnTypes = ccFnReturnTypes;

let ccEmittedTuffError = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmittedTuffError = ccEmittedTuffError;

let ccIncStdint = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdint = ccIncStdint;

let ccIncStddef = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStddef = ccIncStddef;

let ccIncStdio = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdio = ccIncStdio;

let ccIncStdlib = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdlib = ccIncStdlib;

let ccIncString = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncString = ccIncString;

let ccIncCtype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncCtype = ccIncCtype;

let ccIncErrno = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncErrno = ccIncErrno;

let ccIncDirect = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncDirect = ccIncDirect;

let ccIncSysStat = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncSysStat = ccIncSysStat;

let ccIncSysTypes = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncSysTypes = ccIncSysTypes;

let ccDisableUnicodeEscape = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccDisableUnicodeEscape = ccDisableUnicodeEscape;

const __tuff_outer_for_ccNextTemp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccNextTemp(prefix) {
  let __tuff_this = { prefix: prefix, this: __tuff_outer_for_ccNextTemp };
  ccTempCounter = (ccTempCounter + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.ccTempCounter = ccTempCounter;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "__"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prefix); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prefix) : strConcat(__recv, prefix); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "_") : strConcat(__recv, "_"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(ccTempCounter)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(ccTempCounter)) : strConcat(__recv, intToString(ccTempCounter)); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccNextTemp = ccNextTemp;

const __tuff_outer_for_ccToName = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccToName(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_ccToName };
  return (((() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("main"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "main") : strEq(__recv, "main"); })()) ? (() => {
    return "tuff_main";
  })() : (() => {
    return name;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccToName = ccToName;

const __tuff_outer_for_ccStrEndsWith = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccStrEndsWith(s, suffix) {
  let __tuff_this = { s: s, suffix: suffix, this: __tuff_outer_for_ccStrEndsWith };
  let sn = (() => { const __recv = s; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.sn = sn;
  let tn = (() => { const __recv = suffix; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tn = tn;
  if ((sn < tn)) {
  return false;
}
  if ((sn === tn)) {
  return (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSlice"]; if (typeof __prop === "function") return __prop(0, sn); const __dyn = __recv?.table?.strSlice; return __dyn ? __dyn(__recv.ref, 0, sn) : strSlice(__recv, 0, sn); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(suffix); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, suffix) : strEq(__recv, suffix); })();
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccStrEndsWith = ccStrEndsWith;

const __tuff_outer_for_ccJoinParts = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccJoinParts(parts) {
  let __tuff_this = { parts: parts, this: __tuff_outer_for_ccJoinParts };
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = parts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  if ((i > 0)) {
  sbAppend(sb, "::");
}
  sbAppend(sb, getInternedStr((() => { const __recv = parts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccJoinParts = ccJoinParts;

const __tuff_outer_for_ccMarkHeaderFromSource = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccMarkHeaderFromSource(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_ccMarkHeaderFromSource };
  if ((() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("stdio"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "stdio") : strEq(__recv, "stdio"); })()) {
  ccIncStdio = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdio = ccIncStdio;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("stdlib"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "stdlib") : strEq(__recv, "stdlib"); })()) {
  ccIncStdlib = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdlib = ccIncStdlib;
  return 0;
}
  if (((() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("string"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "string") : strEq(__recv, "string"); })() || (() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("strings"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "strings") : strEq(__recv, "strings"); })())) {
  ccIncString = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncString = ccIncString;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("stdint"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "stdint") : strEq(__recv, "stdint"); })()) {
  ccIncStdint = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdint = ccIncStdint;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("stddef"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "stddef") : strEq(__recv, "stddef"); })()) {
  ccIncStddef = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStddef = ccIncStddef;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("errno"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "errno") : strEq(__recv, "errno"); })()) {
  ccIncErrno = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncErrno = ccIncErrno;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("direct"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "direct") : strEq(__recv, "direct"); })()) {
  ccIncDirect = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncDirect = ccIncDirect;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("sys::stat"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "sys::stat") : strEq(__recv, "sys::stat"); })()) {
  ccIncSysStat = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncSysStat = ccIncSysStat;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("sys::types"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "sys::types") : strEq(__recv, "sys::types"); })()) {
  ccIncSysTypes = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncSysTypes = ccIncSysTypes;
  return 0;
}
  if ((((() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("globalThis"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "globalThis") : strEq(__recv, "globalThis"); })() || (() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("substrate"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "substrate") : strEq(__recv, "substrate"); })()) || (() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("host_c"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "host_c") : strEq(__recv, "host_c"); })())) {
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("collections"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "collections") : strEq(__recv, "collections"); })()) {
  ccIncStdlib = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdlib = ccIncStdlib;
  return 0;
}
  if ((() => { const __recv = source; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("io"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "io") : strEq(__recv, "io"); })()) {
  ccIncStdio = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdio = ccIncStdio;
  ccIncStdlib = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdlib = ccIncStdlib;
  ccIncString = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncString = ccIncString;
  return 0;
}
  return panicWithCode("E_EXTERN_UNKNOWN_SOURCE", (() => { const __recv = (() => { const __recv = "Unknown extern source attribution: '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(source); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, source) : strConcat(__recv, source); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "The C backend only supports a built-in set of extern source aliases for header mapping.", "Use a supported source alias (stdio, stdlib, string/strings, stdint, stddef, errno, direct, sys::stat, sys::types) or one of the runtime buckets (globalThis, substrate, host_c).");
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccMarkHeaderFromSource = ccMarkHeaderFromSource;

const __tuff_outer_for_ccRequireSubstrateHeaders = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccRequireSubstrateHeaders() {
  let __tuff_this = { this: __tuff_outer_for_ccRequireSubstrateHeaders };
  ccIncStddef = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStddef = ccIncStddef;
  ccIncStdio = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdio = ccIncStdio;
  ccIncStdlib = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdlib = ccIncStdlib;
  ccIncString = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncString = ccIncString;
  ccIncCtype = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncCtype = ccIncCtype;
  ccIncErrno = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncErrno = ccIncErrno;
  ccIncDirect = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncDirect = ccIncDirect;
  ccIncSysStat = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncSysStat = ccIncSysStat;
  ccIncSysTypes = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncSysTypes = ccIncSysTypes;
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccRequireSubstrateHeaders = ccRequireSubstrateHeaders;

const __tuff_outer_for_ccEmitMinimalRuntimePrelude = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitMinimalRuntimePrelude() {
  let __tuff_this = { this: __tuff_outer_for_ccEmitMinimalRuntimePrelude };
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "/* Built-in minimal runtime prelude (substrate-free path) */\n");
  sbAppend(sb, "static inline int64_t tuff_to_val(const void* p) { return (int64_t)(intptr_t)p; }\n");
  sbAppend(sb, "static inline void* tuff_from_val(int64_t v) { return (void*)(intptr_t)v; }\n");
  sbAppend(sb, "static inline const char* tuff_str(int64_t v) { return v == 0 ? NULL : (const char*)(intptr_t)v; }\n");
  sbAppend(sb, "static inline const char* tuff_str_or_empty(int64_t v) { const char* s = tuff_str(v); return s ? s : \"\"; }\n");
  sbAppend(sb, "typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\n");
  sbAppend(sb, "static void tuff_panic(const char* msg) { fprintf(stderr, \"[tuff panic] %s\\n\", msg); abort(); }\n");
  sbAppend(sb, "\n/* String runtime function declarations and minimal implementations */\n");
  sbAppend(sb, "int64_t str_length(int64_t this) { return (int64_t)strlen(tuff_str_or_empty(this)); }\n");
  sbAppend(sb, "int64_t str_char_at(int64_t this, int64_t index) { const char* s = tuff_str(this); if (!s || index < 0 || index >= (int64_t)strlen(s)) return 0; return (int64_t)s[index]; }\n");
  sbAppend(sb, "int64_t str_slice(int64_t this, int64_t start, int64_t end) { const char* s = tuff_str(this); if (!s || start < 0 || end < start) return 0; size_t len = strlen(s); if ((size_t)end > len) end = (int64_t)len; size_t n = (size_t)(end - start); char* out = (char*)malloc(n + 1); if (!out) return 0; strncpy(out, s + start, n); out[n] = '\\0'; return (int64_t)(intptr_t)out; }\n");
  sbAppend(sb, "int64_t str_concat(int64_t a, int64_t b) { const char* as = tuff_str_or_empty(a); const char* bs = tuff_str_or_empty(b); size_t alen = strlen(as); size_t blen = strlen(bs); char* out = (char*)malloc(alen + blen + 1); if (!out) return 0; strcpy(out, as); strcat(out, bs); return (int64_t)(intptr_t)out; }\n");
  sbAppend(sb, "int64_t str_eq(int64_t a, int64_t b) { const char* as = tuff_str_or_empty(a); const char* bs = tuff_str_or_empty(b); return strcmp(as, bs) == 0 ? 1 : 0; }\n");
  sbAppend(sb, "int64_t str_from_char_code(int64_t code) { char* out = (char*)malloc(2); if (!out) return 0; out[0] = (char)(code & 0xFF); out[1] = '\\0'; return (int64_t)(intptr_t)out; }\n");
  sbAppend(sb, "int64_t str_index_of(int64_t s, int64_t needle) { const char* str = tuff_str(s); const char* ndl = tuff_str(needle); if (!str || !ndl) return -1; const char* found = strstr(str, ndl); if (!found) return -1; return (int64_t)(found - str); }\n");
  sbAppend(sb, "int64_t str_trim(int64_t s) { const char* str = tuff_str_or_empty(s); while (isspace(*str)) str++; const char* end = str + strlen(str); while (end > str && isspace(*(end - 1))) end--; size_t len = end - str; if (len == 0) return (int64_t)(intptr_t)\"\"; char* out = (char*)malloc(len + 1); if (!out) return 0; strncpy(out, str, len); out[len] = '\\0'; return (int64_t)(intptr_t)out; }\n");
  sbAppend(sb, "int64_t str_replace_all(int64_t s, int64_t from, int64_t to) { const char* str = tuff_str_or_empty(s); const char* f = tuff_str_or_empty(from); const char* t = tuff_str_or_empty(to); if (strlen(f) == 0) return s; size_t buf_size = strlen(str) * 2 + 1; char* out = (char*)malloc(buf_size); if (!out) return 0; char* p = out; const char* q = str; while ((q = strstr(q, f)) != NULL) { strncat(p, str, q - str); strncat(p, t, strlen(t)); str = q + strlen(f); q = str; } strcat(p, str); return (int64_t)(intptr_t)out; }\n");
  sbAppend(sb, "int64_t char_code(int64_t ch) { const char* s = tuff_str(ch); return s && *s ? (int64_t)*s : 0; }\n");
  sbAppend(sb, "int64_t int_to_string(int64_t n) { char* out = (char*)malloc(32); if (!out) return 0; snprintf(out, 32, \"%lld\", (long long)n); return (int64_t)(intptr_t)out; }\n");
  sbAppend(sb, "int64_t parse_int(int64_t s) { const char* str = tuff_str_or_empty(s); return (int64_t)atoll(str); }\n");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitMinimalRuntimePrelude = ccEmitMinimalRuntimePrelude;

const __tuff_outer_for_ccTypeToC = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccTypeToC(typeNode) {
  let __tuff_this = { typeNode: typeNode, this: __tuff_outer_for_ccTypeToC };
  if ((typeNode === 0)) {
  return "int64_t";
}
  let kind = nodeKind(typeNode); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_POINTER_TYPE)) {
  let inner = nodeGetData2(typeNode); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  if (((inner !== 0) && (nodeKind(inner) === NK_ARRAY_TYPE))) {
  return "TuffVec*";
}
  return "int64_t";
}
  if ((kind === NK_NAMED_TYPE)) {
  let name = getInternedStr(nodeGetData1(typeNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Void"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Void") : strEq(__recv, "Void"); })()) {
  return "void";
}
  if ((() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Alloc"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Alloc") : strEq(__recv, "Alloc"); })()) {
  let generics = nodeGetData2(typeNode); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  if (((generics !== 0) && ((() => { const __recv = generics; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > 0))) {
  return ccTypeToC((() => { const __recv = generics; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })());
}
  return "int64_t";
}
  if ((() => { const __recv = ccUnionAliasInfo; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  return name;
}
  if ((() => { const __recv = ccStructFields; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  return name;
}
  if ((() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  return (() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })();
}
  return "int64_t";
}
  if ((kind === 44)) {
  return ccTypeToC(nodeGetData1(typeNode));
}
  if ((kind === 71)) {
  let base = getInternedStr(nodeGetData1(typeNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  if ((() => { const __recv = ccUnionAliasInfo; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, base) : mapHas(__recv, base); })()) {
  return base;
}
  if ((() => { const __recv = ccStructFields; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, base) : mapHas(__recv, base); })()) {
  return base;
}
  if ((() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, base) : mapHas(__recv, base); })()) {
  return (() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(base); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, base) : mapGet(__recv, base); })();
}
  return "int64_t";
}
  return "int64_t";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccTypeToC = ccTypeToC;

const __tuff_outer_for_ccInferExprCtype = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccInferExprCtype(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_ccInferExprCtype };
  if ((n === 0)) {
  return "int64_t";
}
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_STRUCT_INIT)) {
  let vname = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.vname = vname;
  if ((() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(vname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, vname) : mapHas(__recv, vname); })()) {
  return (() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(vname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, vname) : mapGet(__recv, vname); })();
}
  return vname;
}
  if ((kind === NK_CALL_EXPR)) {
  let callee = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  if ((nodeKind(callee) === NK_IDENTIFIER)) {
  let cname = getInternedStr(nodeGetData1(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.cname = cname;
  if (((() => { const __recv = cname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("malloc"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "malloc") : strEq(__recv, "malloc"); })() || (() => { const __recv = cname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("realloc"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "realloc") : strEq(__recv, "realloc"); })())) {
  return "TuffVec*";
}
  if ((() => { const __recv = ccFnReturnTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, cname) : mapHas(__recv, cname); })()) {
  return (() => { const __recv = ccFnReturnTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(cname); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, cname) : mapGet(__recv, cname); })();
}
}
}
  return "int64_t";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccInferExprCtype = ccInferExprCtype;

const __tuff_outer_for_ccIsStdlibBuiltin = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccIsStdlibBuiltin(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_ccIsStdlibBuiltin };
  return ((((((((((((((((((((((((((() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("malloc"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "malloc") : strEq(__recv, "malloc"); })() || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("free"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "free") : strEq(__recv, "free"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("realloc"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "realloc") : strEq(__recv, "realloc"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("calloc"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "calloc") : strEq(__recv, "calloc"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("memcpy"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "memcpy") : strEq(__recv, "memcpy"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("memmove"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "memmove") : strEq(__recv, "memmove"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("memset"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "memset") : strEq(__recv, "memset"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("printf"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "printf") : strEq(__recv, "printf"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("fprintf"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "fprintf") : strEq(__recv, "fprintf"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("fopen"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "fopen") : strEq(__recv, "fopen"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("fclose"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "fclose") : strEq(__recv, "fclose"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("fwrite"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "fwrite") : strEq(__recv, "fwrite"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("fread"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "fread") : strEq(__recv, "fread"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("fseek"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "fseek") : strEq(__recv, "fseek"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("ftell"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "ftell") : strEq(__recv, "ftell"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("strlen"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "strlen") : strEq(__recv, "strlen"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("strdup"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "strdup") : strEq(__recv, "strdup"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("strcpy"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "strcpy") : strEq(__recv, "strcpy"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("strcat"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "strcat") : strEq(__recv, "strcat"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("strncpy"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "strncpy") : strEq(__recv, "strncpy"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("strncat"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "strncat") : strEq(__recv, "strncat"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("strcmp"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "strcmp") : strEq(__recv, "strcmp"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("strstr"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "strstr") : strEq(__recv, "strstr"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("strrchr"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "strrchr") : strEq(__recv, "strrchr"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("exit"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "exit") : strEq(__recv, "exit"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("abort"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "abort") : strEq(__recv, "abort"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccIsStdlibBuiltin = ccIsStdlibBuiltin;

const __tuff_outer_for_ccFlattenUnionVariants = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccFlattenUnionVariants(typeNode, namesVec) {
  let __tuff_this = { typeNode: typeNode, namesVec: namesVec, this: __tuff_outer_for_ccFlattenUnionVariants };
  if ((typeNode === 0)) {
  return 0;
}
  let kind = nodeKind(typeNode); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_NAMED_TYPE)) {
  (() => { const __recv = namesVec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(typeNode))); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(typeNode))) : vecPush(__recv, getInternedStr(nodeGetData1(typeNode))); })();
  return 0;
}
  if ((kind === NK_UNION_TYPE)) {
  ccFlattenUnionVariants(nodeGetData1(typeNode), namesVec);
  ccFlattenUnionVariants(nodeGetData2(typeNode), namesVec);
  return 0;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccFlattenUnionVariants = ccFlattenUnionVariants;

const __tuff_outer_for_ccInitContext = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccInitContext(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_ccInitContext };
  let stmts = nodeGetData1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let n = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_ENUM_DECL)) {
  let enumName = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.enumName = enumName;
  (() => { const __recv = ccEnumNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(enumName); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, enumName) : setAdd(__recv, enumName); })();
  let variants = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.variants = variants;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let vlen = (() => { const __recv = variants; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.vlen = vlen;
  while ((j < vlen)) {
  let v = getInternedStr((() => { const __recv = variants; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  (() => { const __recv = ccEnumVariantConsts; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(v, (() => { const __recv = (() => { const __recv = enumName; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "_") : strConcat(__recv, "_"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, v) : strConcat(__recv, v); })()); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, v, (() => { const __recv = (() => { const __recv = enumName; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "_") : strConcat(__recv, "_"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, v) : strConcat(__recv, v); })()) : mapSet(__recv, v, (() => { const __recv = (() => { const __recv = enumName; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "_") : strConcat(__recv, "_"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, v) : strConcat(__recv, v); })()); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
}
  if ((kind === NK_STRUCT_DECL)) {
  let structName = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.structName = structName;
  let fields = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let fieldNames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fieldNames = fieldNames;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let flen = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.flen = flen;
  while ((j < flen)) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  (() => { const __recv = fieldNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(getInternedStr((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })())); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, getInternedStr((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })())) : vecPush(__recv, getInternedStr((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })())); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  (() => { const __recv = ccStructFields; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(structName, fieldNames); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, structName, fieldNames) : mapSet(__recv, structName, fieldNames); })();
}
  if ((kind === NK_TYPE_ALIAS)) {
  let aliasName = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  let aliased = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.aliased = aliased;
  if (((aliased !== 0) && (nodeKind(aliased) === NK_UNION_TYPE))) {
  let variants = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.variants = variants;
  ccFlattenUnionVariants(aliased, variants);
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let vlen = (() => { const __recv = variants; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.vlen = vlen;
  while ((j < vlen)) {
  let v = (() => { const __recv = variants; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  (() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(v, aliasName); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, v, aliasName) : mapSet(__recv, v, aliasName); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  (() => { const __recv = ccUnionAliasInfo; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(aliasName, variants); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, aliasName, variants) : mapSet(__recv, aliasName, variants); })();
}
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  let names = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let nlen = (() => { const __recv = names; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.nlen = nlen;
  while ((j < nlen)) {
  (() => { const __recv = ccCoveredExternFns; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(getInternedStr((() => { const __recv = names; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })())); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, getInternedStr((() => { const __recv = names; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })())) : setAdd(__recv, getInternedStr((() => { const __recv = names; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })())); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  ccMarkHeaderFromSource(ccJoinParts(nodeGetData2(n)));
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let n = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  let sourceName = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.sourceName = sourceName;
  let cName = ccToName(sourceName); if (typeof __tuff_this !== 'undefined') __tuff_this.cName = cName;
  let retCtype = ccTypeToC(nodeGetData4(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.retCtype = retCtype;
  (() => { const __recv = ccFnReturnTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(sourceName, retCtype); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, sourceName, retCtype) : mapSet(__recv, sourceName, retCtype); })();
  (() => { const __recv = ccFnReturnTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(cName, retCtype); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, cName, retCtype) : mapSet(__recv, cName, retCtype); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccInitContext = ccInitContext;

const __tuff_outer_for_ccEmitPatternGuard = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitPatternGuard(target, pat) {
  let __tuff_this = { target: target, pat: pat, this: __tuff_outer_for_ccEmitPatternGuard };
  let kind = nodeKind(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_WILDCARD_PAT)) {
  return "1";
}
  if ((kind === NK_LITERAL_PAT)) {
  let val = getInternedStr(nodeGetData1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, target) : strConcat(__recv, target); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" == "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " == ") : strConcat(__recv, " == "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(val); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, val) : strConcat(__recv, val); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  if ((kind === NK_NAME_PAT)) {
  let name = getInternedStr(nodeGetData1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = ccEnumVariantConsts; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, target) : strConcat(__recv, target); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" == "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " == ") : strConcat(__recv, " == "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = ccEnumVariantConsts; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = ccEnumVariantConsts; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })()) : strConcat(__recv, (() => { const __recv = ccEnumVariantConsts; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  if ((() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  let alias = (() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias = alias;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, target) : strConcat(__recv, target); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(".__tag == "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".__tag == ") : strConcat(__recv, ".__tag == "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(alias); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, alias) : strConcat(__recv, alias); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "_") : strConcat(__recv, "_"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  return "1";
}
  if ((kind === NK_STRUCT_PAT)) {
  let name = getInternedStr(nodeGetData1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  let alias = (() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias = alias;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, target) : strConcat(__recv, target); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(".__tag == "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".__tag == ") : strConcat(__recv, ".__tag == "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(alias); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, alias) : strConcat(__recv, alias); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "_") : strConcat(__recv, "_"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  return "1";
}
  return "1";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitPatternGuard = ccEmitPatternGuard;

const __tuff_outer_for_ccEmitBlockToAssign = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitBlockToAssign(blockNode, tmpVar) {
  let __tuff_this = { blockNode: blockNode, tmpVar: tmpVar, this: __tuff_outer_for_ccEmitBlockToAssign };
  let stmts = nodeGetData1(blockNode); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return (() => { const __recv = tmpVar; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = 0;"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = 0;") : strConcat(__recv, " = 0;"); })();
}
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let isLast = (i === (len - 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.isLast = isLast;
  let skind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.skind = skind;
  if ((isLast && (skind === NK_EXPR_STMT))) {
  sbAppend(sb, tmpVar);
  sbAppend(sb, " = ");
  sbAppend(sb, ccEmitExpr(nodeGetData1(stmt)));
  sbAppend(sb, ";");
} else { if ((isLast && ((skind === NK_IF_STMT) || (skind === NK_IF_EXPR)))) {
  sbAppend(sb, tmpVar);
  sbAppend(sb, " = ");
  sbAppend(sb, ccEmitIfAsCExpr(stmt));
  sbAppend(sb, ";");
} else { if ((isLast && (skind === NK_RETURN_STMT))) {
  let val = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  let valCode = "0"; if (typeof __tuff_this !== 'undefined') __tuff_this.valCode = valCode;
  if ((val !== 0)) {
  valCode = ccEmitExpr(val); if (typeof __tuff_this !== 'undefined') __tuff_this.valCode = valCode;
}
  sbAppend(sb, tmpVar);
  sbAppend(sb, " = ");
  sbAppend(sb, valCode);
  sbAppend(sb, ";");
} else {
  sbAppend(sb, ccEmitStmt(stmt));
  sbAppend(sb, " ");
} } }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitBlockToAssign = ccEmitBlockToAssign;

const __tuff_outer_for_ccEmitBlockAsExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitBlockAsExpr(blockNode) {
  let __tuff_this = { blockNode: blockNode, this: __tuff_outer_for_ccEmitBlockAsExpr };
  let tmp = ccNextTemp("blk"); if (typeof __tuff_this !== 'undefined') __tuff_this.tmp = tmp;
  let inner = ccEmitBlockToAssign(blockNode, tmp); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "({ int64_t "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(tmp); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, tmp) : strConcat(__recv, tmp); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = 0; "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = 0; ") : strConcat(__recv, " = 0; "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(tmp); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, tmp) : strConcat(__recv, tmp); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; })"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; })") : strConcat(__recv, "; })"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitBlockAsExpr = ccEmitBlockAsExpr;

const __tuff_outer_for_ccEmitIfAsCExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitIfAsCExpr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_ccEmitIfAsCExpr };
  let cond = ccEmitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let thenB = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.thenB = thenB;
  let elseB = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.elseB = elseB;
  let tmp = ccNextTemp("ifexpr"); if (typeof __tuff_this !== 'undefined') __tuff_this.tmp = tmp;
  let thenBody = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.thenBody = thenBody;
  if ((nodeKind(thenB) === NK_BLOCK)) {
  thenBody = ccEmitBlockToAssign(thenB, tmp); if (typeof __tuff_this !== 'undefined') __tuff_this.thenBody = thenBody;
} else { if (((nodeKind(thenB) === NK_IF_STMT) || (nodeKind(thenB) === NK_IF_EXPR))) {
  thenBody = (() => { const __recv = (() => { const __recv = (() => { const __recv = tmp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitIfAsCExpr(thenB)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitIfAsCExpr(thenB)) : strConcat(__recv, ccEmitIfAsCExpr(thenB)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.thenBody = thenBody;
} else {
  thenBody = (() => { const __recv = (() => { const __recv = (() => { const __recv = tmp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitExpr(thenB)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitExpr(thenB)) : strConcat(__recv, ccEmitExpr(thenB)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.thenBody = thenBody;
} }
  let elseBody = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.elseBody = elseBody;
  if ((elseB === 0)) {
  elseBody = (() => { const __recv = tmp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = 0;"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = 0;") : strConcat(__recv, " = 0;"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.elseBody = elseBody;
} else { if ((nodeKind(elseB) === NK_BLOCK)) {
  elseBody = ccEmitBlockToAssign(elseB, tmp); if (typeof __tuff_this !== 'undefined') __tuff_this.elseBody = elseBody;
} else { if (((nodeKind(elseB) === NK_IF_STMT) || (nodeKind(elseB) === NK_IF_EXPR))) {
  elseBody = (() => { const __recv = (() => { const __recv = (() => { const __recv = tmp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitIfAsCExpr(elseB)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitIfAsCExpr(elseB)) : strConcat(__recv, ccEmitIfAsCExpr(elseB)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.elseBody = elseBody;
} else {
  elseBody = (() => { const __recv = (() => { const __recv = (() => { const __recv = tmp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitExpr(elseB)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitExpr(elseB)) : strConcat(__recv, ccEmitExpr(elseB)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.elseBody = elseBody;
} } }
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "({ int64_t "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(tmp); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, tmp) : strConcat(__recv, tmp); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = 0; if ("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = 0; if (") : strConcat(__recv, " = 0; if ("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cond) : strConcat(__recv, cond); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") { "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") { ") : strConcat(__recv, ") { "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(thenBody); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, thenBody) : strConcat(__recv, thenBody); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" } else { "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " } else { ") : strConcat(__recv, " } else { "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(elseBody); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, elseBody) : strConcat(__recv, elseBody); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" } "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " } ") : strConcat(__recv, " } "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(tmp); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, tmp) : strConcat(__recv, tmp); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; })"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; })") : strConcat(__recv, "; })"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitIfAsCExpr = ccEmitIfAsCExpr;

const __tuff_outer_for_ccEscapeUnicodeInString = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEscapeUnicodeInString(raw) {
  let __tuff_this = { raw: raw, this: __tuff_outer_for_ccEscapeUnicodeInString };
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = raw; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0000", "\\000"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0000", "\\000") : strReplaceAll(__recv, "\\u0000", "\\000"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0001", "\\001"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0001", "\\001") : strReplaceAll(__recv, "\\u0001", "\\001"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0002", "\\002"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0002", "\\002") : strReplaceAll(__recv, "\\u0002", "\\002"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0003", "\\003"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0003", "\\003") : strReplaceAll(__recv, "\\u0003", "\\003"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0004", "\\004"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0004", "\\004") : strReplaceAll(__recv, "\\u0004", "\\004"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0005", "\\005"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0005", "\\005") : strReplaceAll(__recv, "\\u0005", "\\005"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0006", "\\006"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0006", "\\006") : strReplaceAll(__recv, "\\u0006", "\\006"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0007", "\\007"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0007", "\\007") : strReplaceAll(__recv, "\\u0007", "\\007"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0008", "\\010"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0008", "\\010") : strReplaceAll(__recv, "\\u0008", "\\010"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0009", "\\011"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0009", "\\011") : strReplaceAll(__recv, "\\u0009", "\\011"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u000a", "\\012"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u000a", "\\012") : strReplaceAll(__recv, "\\u000a", "\\012"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u000A", "\\012"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u000A", "\\012") : strReplaceAll(__recv, "\\u000A", "\\012"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u000b", "\\013"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u000b", "\\013") : strReplaceAll(__recv, "\\u000b", "\\013"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u000B", "\\013"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u000B", "\\013") : strReplaceAll(__recv, "\\u000B", "\\013"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u000c", "\\014"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u000c", "\\014") : strReplaceAll(__recv, "\\u000c", "\\014"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u000C", "\\014"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u000C", "\\014") : strReplaceAll(__recv, "\\u000C", "\\014"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u000d", "\\015"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u000d", "\\015") : strReplaceAll(__recv, "\\u000d", "\\015"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u000D", "\\015"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u000D", "\\015") : strReplaceAll(__recv, "\\u000D", "\\015"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u000e", "\\016"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u000e", "\\016") : strReplaceAll(__recv, "\\u000e", "\\016"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u000E", "\\016"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u000E", "\\016") : strReplaceAll(__recv, "\\u000E", "\\016"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u000f", "\\017"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u000f", "\\017") : strReplaceAll(__recv, "\\u000f", "\\017"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u000F", "\\017"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u000F", "\\017") : strReplaceAll(__recv, "\\u000F", "\\017"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0010", "\\020"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0010", "\\020") : strReplaceAll(__recv, "\\u0010", "\\020"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0011", "\\021"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0011", "\\021") : strReplaceAll(__recv, "\\u0011", "\\021"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0012", "\\022"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0012", "\\022") : strReplaceAll(__recv, "\\u0012", "\\022"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0013", "\\023"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0013", "\\023") : strReplaceAll(__recv, "\\u0013", "\\023"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0014", "\\024"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0014", "\\024") : strReplaceAll(__recv, "\\u0014", "\\024"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0015", "\\025"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0015", "\\025") : strReplaceAll(__recv, "\\u0015", "\\025"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0016", "\\026"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0016", "\\026") : strReplaceAll(__recv, "\\u0016", "\\026"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0017", "\\027"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0017", "\\027") : strReplaceAll(__recv, "\\u0017", "\\027"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0018", "\\030"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0018", "\\030") : strReplaceAll(__recv, "\\u0018", "\\030"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u0019", "\\031"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u0019", "\\031") : strReplaceAll(__recv, "\\u0019", "\\031"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u001a", "\\032"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u001a", "\\032") : strReplaceAll(__recv, "\\u001a", "\\032"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u001A", "\\032"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u001A", "\\032") : strReplaceAll(__recv, "\\u001A", "\\032"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u001b", "\\033"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u001b", "\\033") : strReplaceAll(__recv, "\\u001b", "\\033"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u001B", "\\033"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u001B", "\\033") : strReplaceAll(__recv, "\\u001B", "\\033"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u001c", "\\034"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u001c", "\\034") : strReplaceAll(__recv, "\\u001c", "\\034"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u001C", "\\034"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u001C", "\\034") : strReplaceAll(__recv, "\\u001C", "\\034"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u001d", "\\035"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u001d", "\\035") : strReplaceAll(__recv, "\\u001d", "\\035"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u001D", "\\035"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u001D", "\\035") : strReplaceAll(__recv, "\\u001D", "\\035"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u001e", "\\036"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u001e", "\\036") : strReplaceAll(__recv, "\\u001e", "\\036"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u001E", "\\036"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u001E", "\\036") : strReplaceAll(__recv, "\\u001E", "\\036"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u001f", "\\037"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u001f", "\\037") : strReplaceAll(__recv, "\\u001f", "\\037"); })(); const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\u001F", "\\037"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\u001F", "\\037") : strReplaceAll(__recv, "\\u001F", "\\037"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEscapeUnicodeInString = ccEscapeUnicodeInString;

const __tuff_outer_for_ccEmitExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitExpr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_ccEmitExpr };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_NUMBER_LIT)) {
  return getInternedStr(nodeGetData1(n));
}
  if ((kind === NK_BOOL_LIT)) {
  if ((nodeGetData1(n) === 1)) {
  return "1";
}
  return "0";
}
  if ((kind === NK_STRING_LIT)) {
  let s = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  let sC = s; if (typeof __tuff_this !== 'undefined') __tuff_this.sC = sC;
  if ((ccDisableUnicodeEscape !== 1)) {
  sC = ccEscapeUnicodeInString(s); if (typeof __tuff_this !== 'undefined') __tuff_this.sC = sC;
}
  return (() => { const __recv = (() => { const __recv = "((int64_t)(intptr_t)\""; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(sC); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, sC) : strConcat(__recv, sC); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\")") : strConcat(__recv, "\")"); })();
}
  if ((kind === NK_CHAR_LIT)) {
  let s = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  if (((() => { const __recv = s; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() === 1)) {
  return intToString(charCode(s));
}
  if ((() => { const __recv = s; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("\\n"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "\\n") : strEq(__recv, "\\n"); })()) {
  return "10";
}
  if ((() => { const __recv = s; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("\\r"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "\\r") : strEq(__recv, "\\r"); })()) {
  return "13";
}
  if ((() => { const __recv = s; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("\\t"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "\\t") : strEq(__recv, "\\t"); })()) {
  return "9";
}
  if ((() => { const __recv = s; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("\\0"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "\\0") : strEq(__recv, "\\0"); })()) {
  return "0";
}
  return "0";
}
  if ((kind === NK_IDENTIFIER)) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = ccEnumVariantConsts; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  return (() => { const __recv = ccEnumVariantConsts; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })();
}
  return ccToName(name);
}
  if ((kind === NK_UNARY_EXPR)) {
  let op = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&") : strEq(__recv, "&"); })() || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&mut"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&mut") : strEq(__recv, "&mut"); })())) {
  return ccEmitExpr(nodeGetData2(n));
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, op) : strConcat(__recv, op); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitExpr(nodeGetData2(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitExpr(nodeGetData2(n))) : strConcat(__recv, ccEmitExpr(nodeGetData2(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  if ((kind === NK_BINARY_EXPR)) {
  let op = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let left = ccEmitExpr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  let right = ccEmitExpr(nodeGetData3(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(left); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, left) : strConcat(__recv, left); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, op) : strConcat(__recv, op); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, right) : strConcat(__recv, right); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  if ((kind === NK_CALL_EXPR)) {
  let calleeNode = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.calleeNode = calleeNode;
  if ((nodeKind(calleeNode) === NK_IDENTIFIER)) {
  let calleeName = getInternedStr(nodeGetData1(calleeNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.calleeName = calleeName;
  if ((() => { const __recv = calleeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("drop"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "drop") : strEq(__recv, "drop"); })()) {
  return "0";
}
  if ((() => { const __recv = calleeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("sizeOf"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "sizeOf") : strEq(__recv, "sizeOf"); })()) {
  let typeArgs = nodeGetData4(n); if (typeof __tuff_this !== 'undefined') __tuff_this.typeArgs = typeArgs;
  if (((() => { const __recv = typeArgs; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > 0)) {
  let ctype = ccTypeToC((() => { const __recv = typeArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.ctype = ctype;
  return (() => { const __recv = (() => { const __recv = "(int64_t)sizeof("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ctype); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ctype) : strConcat(__recv, ctype); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  return "0";
}
  if ((() => { const __recv = calleeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("malloc"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "malloc") : strEq(__recv, "malloc"); })()) {
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() >= 1)) {
  let bytesStr = ccEmitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.bytesStr = bytesStr;
  let nbytes = ccNextTemp("malloc_nbytes"); if (typeof __tuff_this !== 'undefined') __tuff_this.nbytes = nbytes;
  let vec = ccNextTemp("malloc_vec"); if (typeof __tuff_this !== 'undefined') __tuff_this.vec = vec;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "({ size_t ");
  sbAppend(sb, nbytes);
  sbAppend(sb, " = (size_t)(");
  sbAppend(sb, bytesStr);
  sbAppend(sb, "); TuffVec* ");
  sbAppend(sb, vec);
  sbAppend(sb, " = (TuffVec*)malloc(sizeof(TuffVec)); if (");
  sbAppend(sb, vec);
  sbAppend(sb, ") { ");
  sbAppend(sb, vec);
  sbAppend(sb, "->data = (int64_t*)malloc(");
  sbAppend(sb, nbytes);
  sbAppend(sb, "); ");
  sbAppend(sb, vec);
  sbAppend(sb, "->init = 0; ");
  sbAppend(sb, vec);
  sbAppend(sb, "->length = ");
  sbAppend(sb, nbytes);
  sbAppend(sb, " / sizeof(int64_t); if (!");
  sbAppend(sb, vec);
  sbAppend(sb, "->data) { free(");
  sbAppend(sb, vec);
  sbAppend(sb, "); ");
  sbAppend(sb, vec);
  sbAppend(sb, " = NULL; } } ");
  sbAppend(sb, vec);
  sbAppend(sb, "; })");
  return sbBuild(sb);
}
  return "0";
}
  if ((() => { const __recv = calleeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("realloc"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "realloc") : strEq(__recv, "realloc"); })()) {
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() >= 2)) {
  let ptrStr = ccEmitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.ptrStr = ptrStr;
  let bytesStr = ccEmitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.bytesStr = bytesStr;
  let nbytes = ccNextTemp("realloc_nbytes"); if (typeof __tuff_this !== 'undefined') __tuff_this.nbytes = nbytes;
  let vec = ccNextTemp("realloc_vec"); if (typeof __tuff_this !== 'undefined') __tuff_this.vec = vec;
  let data = ccNextTemp("realloc_data"); if (typeof __tuff_this !== 'undefined') __tuff_this.data = data;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "({ size_t ");
  sbAppend(sb, nbytes);
  sbAppend(sb, " = (size_t)(");
  sbAppend(sb, bytesStr);
  sbAppend(sb, "); TuffVec* ");
  sbAppend(sb, vec);
  sbAppend(sb, " = (TuffVec*)(");
  sbAppend(sb, ptrStr);
  sbAppend(sb, "); if (");
  sbAppend(sb, vec);
  sbAppend(sb, ") { int64_t* ");
  sbAppend(sb, data);
  sbAppend(sb, " = (int64_t*)realloc(");
  sbAppend(sb, vec);
  sbAppend(sb, "->data, ");
  sbAppend(sb, nbytes);
  sbAppend(sb, "); if (");
  sbAppend(sb, data);
  sbAppend(sb, ") { ");
  sbAppend(sb, vec);
  sbAppend(sb, "->data = ");
  sbAppend(sb, data);
  sbAppend(sb, "; ");
  sbAppend(sb, vec);
  sbAppend(sb, "->length = ");
  sbAppend(sb, nbytes);
  sbAppend(sb, " / sizeof(int64_t); } else { ");
  sbAppend(sb, vec);
  sbAppend(sb, " = NULL; } } ");
  sbAppend(sb, vec);
  sbAppend(sb, "; })");
  return sbBuild(sb);
}
  return "0";
}
  if ((() => { const __recv = calleeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("free"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "free") : strEq(__recv, "free"); })()) {
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() >= 1)) {
  let ptrStr = ccEmitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.ptrStr = ptrStr;
  let vec = ccNextTemp("free_vec"); if (typeof __tuff_this !== 'undefined') __tuff_this.vec = vec;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "({ TuffVec* "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(vec); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, vec) : strConcat(__recv, vec); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = (TuffVec*)("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = (TuffVec*)(") : strConcat(__recv, " = (TuffVec*)("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ptrStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ptrStr) : strConcat(__recv, ptrStr); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("); if ("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "); if (") : strConcat(__recv, "); if ("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(vec); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, vec) : strConcat(__recv, vec); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") { free("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") { free(") : strConcat(__recv, ") { free("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(vec); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, vec) : strConcat(__recv, vec); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("->data); free("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "->data); free(") : strConcat(__recv, "->data); free("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(vec); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, vec) : strConcat(__recv, vec); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("); } 0; })"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "); } 0; })") : strConcat(__recv, "); } 0; })"); })();
}
  return "0";
}
}
  let callee = ccEmitExpr(calleeNode); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let argStrs = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.argStrs = argStrs;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let alen = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alen = alen;
  while ((i < alen)) {
  (() => { const __recv = argStrs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(ccEmitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, ccEmitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())) : vecPush(__recv, ccEmitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let argsStr = (() => { const __recv = argStrs; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.argsStr = argsStr;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = callee; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(argsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, argsStr) : strConcat(__recv, argsStr); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  if ((kind === NK_MEMBER_EXPR)) {
  let objNode = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.objNode = objNode;
  let prop = getInternedStr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  if ((nodeKind(objNode) === NK_IDENTIFIER)) {
  let objName = getInternedStr(nodeGetData1(objNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.objName = objName;
  if ((() => { const __recv = ccEnumNames; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(objName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, objName) : setHas(__recv, objName); })()) {
  return (() => { const __recv = (() => { const __recv = objName; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "_") : strConcat(__recv, "_"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prop) : strConcat(__recv, prop); })();
}
  if (((() => { const __recv = ccLocalTypes; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(objName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, objName) : mapHas(__recv, objName); })() && (() => { const __recv = (() => { const __recv = ccLocalTypes; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(objName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, objName) : mapGet(__recv, objName); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("TuffVec*"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "TuffVec*") : strEq(__recv, "TuffVec*"); })())) {
  return (() => { const __recv = (() => { const __recv = ccToName(objName); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("->"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "->") : strConcat(__recv, "->"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prop) : strConcat(__recv, prop); })();
}
}
  let obj = ccEmitExpr(objNode); if (typeof __tuff_this !== 'undefined') __tuff_this.obj = obj;
  return (() => { const __recv = (() => { const __recv = obj; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prop) : strConcat(__recv, prop); })();
}
  if ((kind === NK_INDEX_EXPR)) {
  let target = ccEmitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let idx = ccEmitExpr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.idx = idx;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = target; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("["); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "[") : strConcat(__recv, "["); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, idx) : strConcat(__recv, idx); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "]") : strConcat(__recv, "]"); })();
}
  if ((kind === NK_IF_EXPR)) {
  let cond = ccEmitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let thenB = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.thenB = thenB;
  let elseB = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.elseB = elseB;
  if (((nodeKind(thenB) === NK_BLOCK) || ((elseB !== 0) && (nodeKind(elseB) === NK_BLOCK)))) {
  return ccEmitIfAsCExpr(n);
}
  let thenStr = ccEmitExpr(thenB); if (typeof __tuff_this !== 'undefined') __tuff_this.thenStr = thenStr;
  let elseStr = "0"; if (typeof __tuff_this !== 'undefined') __tuff_this.elseStr = elseStr;
  if ((elseB !== 0)) {
  elseStr = ccEmitExpr(elseB); if (typeof __tuff_this !== 'undefined') __tuff_this.elseStr = elseStr;
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cond) : strConcat(__recv, cond); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") ? ("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") ? (") : strConcat(__recv, ") ? ("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(thenStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, thenStr) : strConcat(__recv, thenStr); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") : ("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") : (") : strConcat(__recv, ") : ("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(elseStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, elseStr) : strConcat(__recv, elseStr); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("))"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "))") : strConcat(__recv, "))"); })();
}
  if ((kind === NK_UNWRAP_EXPR)) {
  let innerNode = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.innerNode = innerNode;
  let inner = ccEmitExpr(innerNode); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let rtype = ccInferExprCtype(innerNode); if (typeof __tuff_this !== 'undefined') __tuff_this.rtype = rtype;
  if ((() => { const __recv = rtype; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("int64_t"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "int64_t") : strEq(__recv, "int64_t"); })()) {
  return inner;
}
  let tmp = ccNextTemp("unwrap"); if (typeof __tuff_this !== 'undefined') __tuff_this.tmp = tmp;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "({ "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(rtype); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, rtype) : strConcat(__recv, rtype); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(tmp); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, tmp) : strConcat(__recv, tmp); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; if ("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; if (") : strConcat(__recv, "; if ("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(tmp); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, tmp) : strConcat(__recv, tmp); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(".__tag == "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".__tag == ") : strConcat(__recv, ".__tag == "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(rtype); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, rtype) : strConcat(__recv, rtype); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("_Err) { return "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "_Err) { return ") : strConcat(__recv, "_Err) { return "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(tmp); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, tmp) : strConcat(__recv, tmp); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; } "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; } ") : strConcat(__recv, "; } "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(tmp); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, tmp) : strConcat(__recv, tmp); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(".value; })"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".value; })") : strConcat(__recv, ".value; })"); })();
}
  if ((kind === NK_MATCH_EXPR)) {
  return ccEmitMatchExpr(n);
}
  if ((kind === NK_IS_EXPR)) {
  let inner = ccEmitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let pat = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  if ((nodeKind(pat) === NK_NAME_PAT)) {
  let name = getInternedStr(nodeGetData1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  let alias = (() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias = alias;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(".__tag == "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".__tag == ") : strConcat(__recv, ".__tag == "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(alias); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, alias) : strConcat(__recv, alias); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "_") : strConcat(__recv, "_"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  return (() => { const __recv = (() => { const __recv = "((int64_t)("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") != 0)"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") != 0)") : strConcat(__recv, ") != 0)"); })();
}
  if ((nodeKind(pat) === NK_STRUCT_PAT)) {
  let name = getInternedStr(nodeGetData1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  let alias = (() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias = alias;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inner); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inner) : strConcat(__recv, inner); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(".__tag == "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".__tag == ") : strConcat(__recv, ".__tag == "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(alias); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, alias) : strConcat(__recv, alias); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "_") : strConcat(__recv, "_"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
}
  return "0";
}
  if ((kind === NK_STRUCT_INIT)) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, name) : mapHas(__recv, name); })()) {
  let alias = (() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, name) : mapGet(__recv, name); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alias = alias;
  let fields = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "((");
  sbAppend(sb, alias);
  sbAppend(sb, "){ .__tag = ");
  sbAppend(sb, alias);
  sbAppend(sb, "_");
  sbAppend(sb, name);
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let flen = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.flen = flen;
  while ((i < flen)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  let key = getInternedStr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  let valStr = ccEmitExpr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.valStr = valStr;
  sbAppend(sb, ", .");
  sbAppend(sb, key);
  sbAppend(sb, " = ");
  sbAppend(sb, valStr);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, " })");
  return sbBuild(sb);
}
  let fields = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "((");
  sbAppend(sb, name);
  sbAppend(sb, "){ ");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let flen = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.flen = flen;
  while ((i < flen)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  let key = getInternedStr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  let valStr = ccEmitExpr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.valStr = valStr;
  if ((i > 0)) {
  sbAppend(sb, ", ");
}
  sbAppend(sb, ".");
  sbAppend(sb, key);
  sbAppend(sb, " = ");
  sbAppend(sb, valStr);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, " })");
  return sbBuild(sb);
}
  if (((kind === NK_LAMBDA_EXPR) || (kind === NK_FN_EXPR))) {
  return "/* lambda/fn_expr unsupported in C */ 0";
}
  if ((kind === NK_TUPLE_EXPR)) {
  return "/* tuple_expr unsupported in C */ 0";
}
  return "/* unknown_expr */ 0";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitExpr = ccEmitExpr;

const __tuff_outer_for_ccEmitMatchExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitMatchExpr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_ccEmitMatchExpr };
  let targetStr = ccEmitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.targetStr = targetStr;
  let cases = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let chain = "(tuff_panic(\"Non-exhaustive match\"), 0)"; if (typeof __tuff_this !== 'undefined') __tuff_this.chain = chain;
  let i = (len - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i >= 0)) {
  let caseNode = (() => { const __recv = cases; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.caseNode = caseNode;
  let pat = (() => { const __recv = caseNode; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  let body = (() => { const __recv = caseNode; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let guard = ccEmitPatternGuard(targetStr, pat); if (typeof __tuff_this !== 'undefined') __tuff_this.guard = guard;
  let bodyStr = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.bodyStr = bodyStr;
  if ((nodeKind(body) === NK_BLOCK)) {
  bodyStr = ccEmitBlockAsExpr(body); if (typeof __tuff_this !== 'undefined') __tuff_this.bodyStr = bodyStr;
} else {
  if (((nodeKind(pat) === NK_STRUCT_PAT) && (nodeKind(body) === NK_IDENTIFIER))) {
  let pfields = nodeGetData2(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.pfields = pfields;
  if (((pfields !== 0) && ((() => { const __recv = pfields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 1))) {
  let pfield = (() => { const __recv = pfields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pfield = pfield;
  let fieldName = getInternedStr(pfield); if (typeof __tuff_this !== 'undefined') __tuff_this.fieldName = fieldName;
  let bindName = fieldName; if (typeof __tuff_this !== 'undefined') __tuff_this.bindName = bindName;
  let bodyName = getInternedStr(nodeGetData1(body)); if (typeof __tuff_this !== 'undefined') __tuff_this.bodyName = bodyName;
  if ((() => { const __recv = bodyName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(bindName); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, bindName) : strEq(__recv, bindName); })()) {
  bodyStr = (() => { const __recv = (() => { const __recv = targetStr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fieldName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fieldName) : strConcat(__recv, fieldName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.bodyStr = bodyStr;
} else {
  bodyStr = ccEmitExpr(body); if (typeof __tuff_this !== 'undefined') __tuff_this.bodyStr = bodyStr;
}
} else {
  bodyStr = ccEmitExpr(body); if (typeof __tuff_this !== 'undefined') __tuff_this.bodyStr = bodyStr;
}
} else {
  bodyStr = ccEmitExpr(body); if (typeof __tuff_this !== 'undefined') __tuff_this.bodyStr = bodyStr;
}
}
  chain = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(guard); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, guard) : strConcat(__recv, guard); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") ? ("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") ? (") : strConcat(__recv, ") ? ("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(bodyStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, bodyStr) : strConcat(__recv, bodyStr); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") : ("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") : (") : strConcat(__recv, ") : ("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(chain); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, chain) : strConcat(__recv, chain); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("))"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "))") : strConcat(__recv, "))"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.chain = chain;
  i = (i - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return chain;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitMatchExpr = ccEmitMatchExpr;

const __tuff_outer_for_ccEmitBlock = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitBlock(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_ccEmitBlock };
  let stmts = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "{\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  sbAppend(sb, "  ");
  sbAppend(sb, ccEmitStmt((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()));
  sbAppend(sb, "\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "}");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitBlock = ccEmitBlock;

const __tuff_outer_for_ccEmitStmtOrBlock = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitStmtOrBlock(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_ccEmitStmtOrBlock };
  if ((nodeKind(n) === NK_BLOCK)) {
  return ccEmitBlock(n);
}
  return (() => { const __recv = (() => { const __recv = "{ "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitStmt(n)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitStmt(n)) : strConcat(__recv, ccEmitStmt(n)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" }"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " }") : strConcat(__recv, " }"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitStmtOrBlock = ccEmitStmtOrBlock;

const __tuff_outer_for_ccEmitFnBlock = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitFnBlock(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_ccEmitFnBlock };
  ccLocalTypes = (() => { const __recv = ccLocalTypes; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccLocalTypes = ccLocalTypes;
  let stmts = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return "{\n  return 0;\n}";
}
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "{\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let isLast = (i === (len - 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.isLast = isLast;
  let skind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.skind = skind;
  if ((isLast && (skind === NK_EXPR_STMT))) {
  sbAppend(sb, "  return ");
  sbAppend(sb, ccEmitExpr(nodeGetData1(stmt)));
  sbAppend(sb, ";\n");
} else { if ((isLast && ((skind === NK_IF_STMT) || (skind === NK_IF_EXPR)))) {
  sbAppend(sb, "  return ");
  sbAppend(sb, ccEmitIfAsCExpr(stmt));
  sbAppend(sb, ";\n");
} else {
  sbAppend(sb, "  ");
  sbAppend(sb, ccEmitStmt(stmt));
  sbAppend(sb, "\n");
} }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "}");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitFnBlock = ccEmitFnBlock;

const __tuff_outer_for_ccEmitParamList = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitParamList(params) {
  let __tuff_this = { params: params, this: __tuff_outer_for_ccEmitParamList };
  let parts = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.parts = parts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let param = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  let pname = getInternedStr((() => { const __recv = param; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = (() => { const __recv = param; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  let ptypeStr = ccTypeToC(ptype); if (typeof __tuff_this !== 'undefined') __tuff_this.ptypeStr = ptypeStr;
  (() => { const __recv = parts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = ptypeStr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, pname) : strConcat(__recv, pname); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = ptypeStr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, pname) : strConcat(__recv, pname); })()) : vecPush(__recv, (() => { const __recv = (() => { const __recv = ptypeStr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, pname) : strConcat(__recv, pname); })()); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = parts; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitParamList = ccEmitParamList;

const __tuff_outer_for_ccEmitPrototype = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitPrototype(retType, name, params) {
  let __tuff_this = { retType: retType, name: name, params: params, this: __tuff_outer_for_ccEmitPrototype };
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = retType; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(params); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, params) : strConcat(__recv, params); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(");"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ");") : strConcat(__recv, ");"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitPrototype = ccEmitPrototype;

const __tuff_outer_for_ccEmitTypeAlias = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitTypeAlias(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_ccEmitTypeAlias };
  let aliasName = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.aliasName = aliasName;
  let aliased = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.aliased = aliased;
  if (((aliased === 0) || (nodeKind(aliased) !== NK_UNION_TYPE))) {
  return (() => { const __recv = (() => { const __recv = "/* type "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, aliasName) : strConcat(__recv, aliasName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = ... */"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ... */") : strConcat(__recv, " = ... */"); })();
}
  if ((!(() => { const __recv = ccUnionAliasInfo; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, aliasName) : mapHas(__recv, aliasName); })())) {
  return (() => { const __recv = (() => { const __recv = "/* union "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, aliasName) : strConcat(__recv, aliasName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" not in context */"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " not in context */") : strConcat(__recv, " not in context */"); })();
}
  let variants = (() => { const __recv = ccUnionAliasInfo; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(aliasName); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, aliasName) : mapGet(__recv, aliasName); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.variants = variants;
  let vlen = (() => { const __recv = variants; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.vlen = vlen;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "typedef enum ");
  sbAppend(sb, aliasName);
  sbAppend(sb, "_Tag { ");
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < vlen)) {
  if ((j > 0)) {
  sbAppend(sb, ", ");
}
  sbAppend(sb, aliasName);
  sbAppend(sb, "_");
  sbAppend(sb, (() => { const __recv = variants; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })());
  sbAppend(sb, " = ");
  sbAppend(sb, intToString((j + 1)));
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  sbAppend(sb, " } ");
  sbAppend(sb, aliasName);
  sbAppend(sb, "_Tag;\n");
  let allFieldNames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.allFieldNames = allFieldNames;
  let seenFields = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.seenFields = seenFields;
  j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < vlen)) {
  let v = (() => { const __recv = variants; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  if ((() => { const __recv = ccStructFields; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, v) : mapHas(__recv, v); })()) {
  let fields = (() => { const __recv = ccStructFields; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, v) : mapGet(__recv, v); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let m = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.m = m;
  let flen = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.flen = flen;
  while ((m < flen)) {
  let fname = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(m); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, m) : vecGet(__recv, m); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if ((!(() => { const __recv = seenFields; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, fname) : setHas(__recv, fname); })())) {
  (() => { const __recv = seenFields; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, fname) : setAdd(__recv, fname); })();
  (() => { const __recv = allFieldNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, fname) : vecPush(__recv, fname); })();
}
  m = (m + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.m = m;
}
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  sbAppend(sb, "typedef struct ");
  sbAppend(sb, aliasName);
  sbAppend(sb, " { int32_t __tag;");
  let m = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.m = m;
  let flen = (() => { const __recv = allFieldNames; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.flen = flen;
  while ((m < flen)) {
  let fname = (() => { const __recv = allFieldNames; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(m); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, m) : vecGet(__recv, m); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  let ftype = "int64_t"; if (typeof __tuff_this !== 'undefined') __tuff_this.ftype = ftype;
  if (((() => { const __recv = aliasName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Result"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Result") : strEq(__recv, "Result"); })() && (() => { const __recv = fname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("error"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "error") : strEq(__recv, "error"); })())) {
  ftype = "TuffError"; if (typeof __tuff_this !== 'undefined') __tuff_this.ftype = ftype;
}
  sbAppend(sb, " ");
  sbAppend(sb, ftype);
  sbAppend(sb, " ");
  sbAppend(sb, fname);
  sbAppend(sb, ";");
  m = (m + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.m = m;
}
  sbAppend(sb, " } ");
  sbAppend(sb, aliasName);
  sbAppend(sb, ";\n");
  j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  while ((j < vlen)) {
  let v = (() => { const __recv = variants; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  let vfields = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.vfields = vfields;
  if ((() => { const __recv = ccStructFields; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, v) : mapHas(__recv, v); })()) {
  vfields = (() => { const __recv = ccStructFields; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, v) : mapGet(__recv, v); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.vfields = vfields;
}
  let paramsSb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.paramsSb = paramsSb;
  let assignsSb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.assignsSb = assignsSb;
  let k = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  let klen = (() => { const __recv = vfields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.klen = klen;
  while ((k < klen)) {
  let fname = (() => { const __recv = vfields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, k) : vecGet(__recv, k); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  let ptype = "int64_t"; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (((() => { const __recv = aliasName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("Result"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "Result") : strEq(__recv, "Result"); })() && (() => { const __recv = fname; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("error"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "error") : strEq(__recv, "error"); })())) {
  ptype = "TuffError"; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
  if ((k > 0)) {
  sbAppend(paramsSb, ", ");
}
  sbAppend(paramsSb, ptype);
  sbAppend(paramsSb, " ");
  sbAppend(paramsSb, fname);
  sbAppend(assignsSb, " out.");
  sbAppend(assignsSb, fname);
  sbAppend(assignsSb, " = ");
  sbAppend(assignsSb, fname);
  sbAppend(assignsSb, ";");
  k = (k + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
}
  sbAppend(sb, "static inline ");
  sbAppend(sb, aliasName);
  sbAppend(sb, " ");
  sbAppend(sb, aliasName);
  sbAppend(sb, "_make_");
  sbAppend(sb, v);
  sbAppend(sb, "(");
  sbAppend(sb, sbBuild(paramsSb));
  sbAppend(sb, ") { ");
  sbAppend(sb, aliasName);
  sbAppend(sb, " out = {0}; out.__tag = ");
  sbAppend(sb, aliasName);
  sbAppend(sb, "_");
  sbAppend(sb, v);
  sbAppend(sb, ";");
  sbAppend(sb, sbBuild(assignsSb));
  sbAppend(sb, " return out; }\n");
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitTypeAlias = ccEmitTypeAlias;

const __tuff_outer_for_ccIsExternFnDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccIsExternFnDecl(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_ccIsExternFnDecl };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  return ((kind === NK_FN_DECL) && (nodeGetData5(n) === 0));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccIsExternFnDecl = ccIsExternFnDecl;

const __tuff_outer_for_ccEmitStmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitStmt(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_ccEmitStmt };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LET_DECL)) {
  let name = ccToName(getInternedStr(nodeGetData1(n))); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let valNode = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.valNode = valNode;
  let ctype = ccInferExprCtype(valNode); if (typeof __tuff_this !== 'undefined') __tuff_this.ctype = ctype;
  let value = ccEmitExpr(valNode); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  (() => { const __recv = ccLocalTypes; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(name, ctype); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, name, ctype) : mapSet(__recv, name, ctype); })();
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = ctype; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, value) : strConcat(__recv, value); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })();
}
  if ((kind === NK_IMPORT_DECL)) {
  return "/* import placeholder */";
}
  if ((kind === NK_EXPR_STMT)) {
  return (() => { const __recv = ccEmitExpr(nodeGetData1(n)); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })();
}
  if ((kind === NK_ASSIGN_STMT)) {
  let target = ccEmitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let value = ccEmitExpr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.value = value;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = target; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(value); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, value) : strConcat(__recv, value); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })();
}
  if ((kind === NK_RETURN_STMT)) {
  let val = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  if ((val === 0)) {
  return "return 0;";
}
  return (() => { const __recv = (() => { const __recv = "return "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitExpr(val)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitExpr(val)) : strConcat(__recv, ccEmitExpr(val)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })();
}
  if (((kind === NK_IF_STMT) || (kind === NK_IF_EXPR))) {
  let cond = ccEmitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let thenB = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.thenB = thenB;
  let elseB = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.elseB = elseB;
  let thenStr = ccEmitStmtOrBlock(thenB); if (typeof __tuff_this !== 'undefined') __tuff_this.thenStr = thenStr;
  if ((elseB === 0)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "if ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cond) : strConcat(__recv, cond); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") ") : strConcat(__recv, ") "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(thenStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, thenStr) : strConcat(__recv, thenStr); })();
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "if ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cond) : strConcat(__recv, cond); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") ") : strConcat(__recv, ") "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(thenStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, thenStr) : strConcat(__recv, thenStr); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" else "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " else ") : strConcat(__recv, " else "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitStmtOrBlock(elseB)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitStmtOrBlock(elseB)) : strConcat(__recv, ccEmitStmtOrBlock(elseB)); })();
}
  if ((kind === NK_WHILE_STMT)) {
  let cond = ccEmitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let body = ccEmitBlock(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "while ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cond) : strConcat(__recv, cond); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") ") : strConcat(__recv, ") "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(body); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, body) : strConcat(__recv, body); })();
}
  if ((kind === NK_FOR_STMT)) {
  let iter = ccToName(getInternedStr(nodeGetData1(n))); if (typeof __tuff_this !== 'undefined') __tuff_this.iter = iter;
  let start = ccEmitExpr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.start = start;
  let end = ccEmitExpr(nodeGetData3(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
  let body = ccEmitBlock(nodeGetData4(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "for (int64_t "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(iter); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, iter) : strConcat(__recv, iter); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(start); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, start) : strConcat(__recv, start); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; ") : strConcat(__recv, "; "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(iter); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, iter) : strConcat(__recv, iter); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" < "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " < ") : strConcat(__recv, " < "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(end); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, end) : strConcat(__recv, end); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; ") : strConcat(__recv, "; "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(iter); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, iter) : strConcat(__recv, iter); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("++) "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "++) ") : strConcat(__recv, "++) "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(body); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, body) : strConcat(__recv, body); })();
}
  if ((kind === NK_LOOP_STMT)) {
  let body = ccEmitBlock(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  return (() => { const __recv = "while (1) "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(body); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, body) : strConcat(__recv, body); })();
}
  if ((kind === NK_BREAK_STMT)) {
  return "break;";
}
  if ((kind === NK_CONTINUE_STMT)) {
  return "continue;";
}
  if ((kind === NK_INTO_STMT)) {
  return (() => { const __recv = (() => { const __recv = "/* into "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" */"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " */") : strConcat(__recv, " */"); })();
}
  if ((kind === NK_LIFETIME_STMT)) {
  let body = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if (((body === 0) || (nodeKind(body) !== NK_BLOCK))) {
  return "";
}
  let stmts = nodeGetData1(body); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let row = ccEmitStmt((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.row = row;
  if ((!(() => { const __recv = row; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  sbAppend(sb, row);
  if (((i + 1) < len)) {
  sbAppend(sb, "\n");
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sbBuild(sb);
}
  if ((kind === NK_BLOCK)) {
  return ccEmitBlock(n);
}
  if ((kind === NK_EXPECT_FN_DECL)) {
  return (() => { const __recv = (() => { const __recv = "/* expect fn "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" */"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " */") : strConcat(__recv, " */"); })();
}
  if (ccIsExternFnDecl(n)) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if (ccIsStdlibBuiltin(name)) {
  return (() => { const __recv = (() => { const __recv = "/* extern "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("  declared via C stdlib headers */"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "  declared via C stdlib headers */") : strConcat(__recv, "  declared via C stdlib headers */"); })();
}
  let params = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let retType = ccTypeToC(nodeGetData4(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.retType = retType;
  let paramsStr = ccEmitParamList(params); if (typeof __tuff_this !== 'undefined') __tuff_this.paramsStr = paramsStr;
  return ccEmitPrototype((() => { const __recv = "extern "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(retType); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, retType) : strConcat(__recv, retType); })(), name, paramsStr);
}
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  let sourceName = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.sourceName = sourceName;
  let name = ccToName(sourceName); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let params = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let retType = ccTypeToC(nodeGetData4(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.retType = retType;
  let body = nodeGetData5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let paramsStr = ccEmitParamList(params); if (typeof __tuff_this !== 'undefined') __tuff_this.paramsStr = paramsStr;
  if ((body === 0)) {
  return (() => { const __recv = (() => { const __recv = "/* fn "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" has no body */"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " has no body */") : strConcat(__recv, " has no body */"); })();
}
  let prevDisableEscape = ccDisableUnicodeEscape; if (typeof __tuff_this !== 'undefined') __tuff_this.prevDisableEscape = prevDisableEscape;
  if ((() => { const __recv = sourceName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("cc_escape_unicode_in_string"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "cc_escape_unicode_in_string") : strEq(__recv, "cc_escape_unicode_in_string"); })()) {
  ccDisableUnicodeEscape = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccDisableUnicodeEscape = ccDisableUnicodeEscape;
}
  let emitted = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.emitted = emitted;
  if ((nodeKind(body) === NK_BLOCK)) {
  emitted = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = retType; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") ") : strConcat(__recv, ") "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitFnBlock(body)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitFnBlock(body)) : strConcat(__recv, ccEmitFnBlock(body)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.emitted = emitted;
} else {
  emitted = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = retType; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(paramsStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, paramsStr) : strConcat(__recv, paramsStr); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") { return "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") { return ") : strConcat(__recv, ") { return "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitExpr(body)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitExpr(body)) : strConcat(__recv, ccEmitExpr(body)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; }"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; }") : strConcat(__recv, "; }"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.emitted = emitted;
}
  ccDisableUnicodeEscape = prevDisableEscape; if (typeof __tuff_this !== 'undefined') __tuff_this.ccDisableUnicodeEscape = ccDisableUnicodeEscape;
  return emitted;
}
  if ((kind === NK_STRUCT_DECL)) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let fields = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  if (((((() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("ParseError"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "ParseError") : strEq(__recv, "ParseError"); })() || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("ResolveError"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "ResolveError") : strEq(__recv, "ResolveError"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("TypeError"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "TypeError") : strEq(__recv, "TypeError"); })()) || (() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("CodegenError"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "CodegenError") : strEq(__recv, "CodegenError"); })())) {
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  if ((ccEmittedTuffError === 0)) {
  sbAppend(sb, "typedef struct TuffError { ");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let flen = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.flen = flen;
  while ((i < flen)) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  let fname = getInternedStr((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  let ftype = (() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ftype = ftype;
  let ctype = ccTypeToC(ftype); if (typeof __tuff_this !== 'undefined') __tuff_this.ctype = ctype;
  sbAppend(sb, ctype);
  sbAppend(sb, " ");
  sbAppend(sb, fname);
  sbAppend(sb, "; ");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "} TuffError;\n");
  ccEmittedTuffError = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmittedTuffError = ccEmittedTuffError;
}
  sbAppend(sb, "typedef TuffError ");
  sbAppend(sb, name);
  sbAppend(sb, ";");
  return sbBuild(sb);
}
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "typedef struct ");
  sbAppend(sb, name);
  sbAppend(sb, " { ");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let flen = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.flen = flen;
  while ((i < flen)) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  let fname = getInternedStr((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  let ftype = (() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ftype = ftype;
  let ctype = ccTypeToC(ftype); if (typeof __tuff_this !== 'undefined') __tuff_this.ctype = ctype;
  sbAppend(sb, ctype);
  sbAppend(sb, " ");
  sbAppend(sb, fname);
  sbAppend(sb, "; ");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "} ");
  sbAppend(sb, name);
  sbAppend(sb, ";");
  return sbBuild(sb);
}
  if ((kind === NK_TYPE_ALIAS)) {
  return ccEmitTypeAlias(n);
}
  if ((kind === NK_DEP_TYPE_ALIAS)) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = (() => { const __recv = "/* type "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(...) = ... */"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(...) = ... */") : strConcat(__recv, "(...) = ... */"); })();
}
  if ((kind === NK_ENUM_DECL)) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let variants = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.variants = variants;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "typedef enum ");
  sbAppend(sb, name);
  sbAppend(sb, " { ");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let vlen = (() => { const __recv = variants; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.vlen = vlen;
  while ((i < vlen)) {
  if ((i > 0)) {
  sbAppend(sb, ", ");
}
  sbAppend(sb, name);
  sbAppend(sb, "_");
  sbAppend(sb, getInternedStr((() => { const __recv = variants; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()));
  sbAppend(sb, " = ");
  sbAppend(sb, intToString(i));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, " } ");
  sbAppend(sb, name);
  sbAppend(sb, ";");
  return sbBuild(sb);
}
  if ((kind === NK_OBJECT_DECL)) {
  return (() => { const __recv = (() => { const __recv = "/* object "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" */"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " */") : strConcat(__recv, " */"); })();
}
  if ((kind === NK_CONTRACT_DECL)) {
  return (() => { const __recv = (() => { const __recv = "/* contract "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" */"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " */") : strConcat(__recv, " */"); })();
}
  if ((kind === NK_EXTERN_LET_DECL)) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = (() => { const __recv = "/* extern let "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" */"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " */") : strConcat(__recv, " */"); })();
}
  if ((kind === NK_EXTERN_TYPE_DECL)) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = (() => { const __recv = "/* extern type "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" */"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " */") : strConcat(__recv, " */"); })();
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  return "";
}
  if ((kind === NK_STMT_LIST)) {
  return "";
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitStmt = ccEmitStmt;

const __tuff_outer_for_generateCImpl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function generateCImpl(typed, substrate) {
  let __tuff_this = { typed: typed, substrate: substrate, this: __tuff_outer_for_generateCImpl };
  ccTempCounter = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccTempCounter = ccTempCounter;
  ccDisableUnicodeEscape = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccDisableUnicodeEscape = ccDisableUnicodeEscape;
  ccEnumNames = (() => { const __recv = ccEnumNames; const __prop = __recv?.["setClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.setClear; return __dyn ? __dyn(__recv.ref) : setClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccEnumNames = ccEnumNames;
  ccEnumVariantConsts = (() => { const __recv = ccEnumVariantConsts; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccEnumVariantConsts = ccEnumVariantConsts;
  ccStructFields = (() => { const __recv = ccStructFields; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccStructFields = ccStructFields;
  ccAliasByVariant = (() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccAliasByVariant = ccAliasByVariant;
  ccUnionAliasInfo = (() => { const __recv = ccUnionAliasInfo; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccUnionAliasInfo = ccUnionAliasInfo;
  ccCoveredExternFns = (() => { const __recv = ccCoveredExternFns; const __prop = __recv?.["setClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.setClear; return __dyn ? __dyn(__recv.ref) : setClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccCoveredExternFns = ccCoveredExternFns;
  ccFnReturnTypes = (() => { const __recv = ccFnReturnTypes; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccFnReturnTypes = ccFnReturnTypes;
  ccLocalTypes = (() => { const __recv = ccLocalTypes; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccLocalTypes = ccLocalTypes;
  ccEmittedTuffError = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmittedTuffError = ccEmittedTuffError;
  ccIncStdint = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdint = ccIncStdint;
  ccIncStddef = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStddef = ccIncStddef;
  ccIncStdio = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdio = ccIncStdio;
  ccIncStdlib = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdlib = ccIncStdlib;
  ccIncString = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncString = ccIncString;
  ccIncCtype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncCtype = ccIncCtype;
  ccIncErrno = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncErrno = ccIncErrno;
  ccIncDirect = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncDirect = ccIncDirect;
  ccIncSysStat = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncSysStat = ccIncSysStat;
  ccIncSysTypes = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncSysTypes = ccIncSysTypes;
  ccInitContext(typed);
  if ((!(() => { const __recv = substrate; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  ccRequireSubstrateHeaders();
} else {
  ccIncStddef = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStddef = ccIncStddef;
  ccIncStdio = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdio = ccIncStdio;
  ccIncStdlib = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdlib = ccIncStdlib;
  ccIncString = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncString = ccIncString;
  ccIncCtype = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncCtype = ccIncCtype;
}
  let stmts = nodeGetData1(typed); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let cvi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cvi = cvi;
  while ((cvi < len)) {
  let cvn = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(cvi); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, cvi) : vecGet(__recv, cvi); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cvn = cvn;
  if (ccIsExternFnDecl(cvn)) {
  let fname = getInternedStr(nodeGetData1(cvn)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if ((!(() => { const __recv = ccCoveredExternFns; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, fname) : setHas(__recv, fname); })())) {
  panicWithCode("E_EXTERN_NO_SOURCE", (() => { const __recv = (() => { const __recv = "extern fn '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' has no source attribution"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' has no source attribution") : strConcat(__recv, "' has no source attribution"); })(), "C codegen requires each extern function to be attributed to a source via extern let destructuring.", (() => { const __recv = (() => { const __recv = "Add 'extern let { "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" } = <header>;' before the declaration."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " } = <header>;' before the declaration.") : strConcat(__recv, " } = <header>;' before the declaration."); })());
}
}
  cvi = (cvi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cvi = cvi;
}
  let fnNodes = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnNodes = fnNodes;
  let initRows = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.initRows = initRows;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  if ((ccIncStdint === 1)) {
  sbAppend(sb, "#include <stdint.h>\n");
}
  if ((ccIncStddef === 1)) {
  sbAppend(sb, "#include <stddef.h>\n");
}
  if ((ccIncStdio === 1)) {
  sbAppend(sb, "#include <stdio.h>\n");
}
  if ((ccIncStdlib === 1)) {
  sbAppend(sb, "#include <stdlib.h>\n");
}
  if ((ccIncString === 1)) {
  sbAppend(sb, "#include <string.h>\n");
}
  if ((ccIncCtype === 1)) {
  sbAppend(sb, "#include <ctype.h>\n");
}
  if ((ccIncErrno === 1)) {
  sbAppend(sb, "#include <errno.h>\n");
}
  sbAppend(sb, "#ifdef _WIN32\n");
  if ((ccIncDirect === 1)) {
  sbAppend(sb, "#include <direct.h>\n");
}
  sbAppend(sb, "#else\n");
  if ((ccIncSysStat === 1)) {
  sbAppend(sb, "#include <sys/stat.h>\n");
}
  if ((ccIncSysTypes === 1)) {
  sbAppend(sb, "#include <sys/types.h>\n");
}
  sbAppend(sb, "#endif\n\n");
  sbAppend(sb, "/* Generated by Tuff selfhost C backend. */\n\n");
  if ((!(() => { const __recv = substrate; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  sbAppend(sb, "/* Embedded C substrate support */\n");
  sbAppend(sb, substrate);
} else {
  sbAppend(sb, ccEmitMinimalRuntimePrelude());
}
  sbAppend(sb, "\n\n");
  sbAppend(sb, "typedef struct TuffError { int64_t code; int64_t message; int64_t reason; int64_t fix; int64_t line; int64_t col; } TuffError;\n\n");
  ccEmittedTuffError = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmittedTuffError = ccEmittedTuffError;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let node = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  let kind = nodeKind(node); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  (() => { const __recv = fnNodes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(node); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, node) : vecPush(__recv, node); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((kind === NK_EXPECT_FN_DECL)) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((kind === NK_LET_DECL)) {
  let name = ccToName(getInternedStr(nodeGetData1(node))); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  sbAppend(sb, "int64_t ");
  sbAppend(sb, name);
  sbAppend(sb, ";\n");
  (() => { const __recv = initRows; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = (() => { const __recv = (() => { const __recv = name; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitExpr(nodeGetData3(node))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitExpr(nodeGetData3(node))) : strConcat(__recv, ccEmitExpr(nodeGetData3(node))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = (() => { const __recv = (() => { const __recv = name; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitExpr(nodeGetData3(node))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitExpr(nodeGetData3(node))) : strConcat(__recv, ccEmitExpr(nodeGetData3(node))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })()) : vecPush(__recv, (() => { const __recv = (() => { const __recv = (() => { const __recv = name; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(ccEmitExpr(nodeGetData3(node))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ccEmitExpr(nodeGetData3(node))) : strConcat(__recv, ccEmitExpr(nodeGetData3(node))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(";"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ";") : strConcat(__recv, ";"); })()); })();
  sbAppend(sb, "\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  let stmtStr = ccEmitStmt(node); if (typeof __tuff_this !== 'undefined') __tuff_this.stmtStr = stmtStr;
  if ((!(() => { const __recv = stmtStr; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  sbAppend(sb, stmtStr);
  sbAppend(sb, "\n");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "\n");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let fnLen = (() => { const __recv = fnNodes; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnLen = fnLen;
  while ((i < fnLen)) {
  let fnNode = (() => { const __recv = fnNodes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnNode = fnNode;
  let fnName = ccToName(getInternedStr(nodeGetData1(fnNode))); if (typeof __tuff_this !== 'undefined') __tuff_this.fnName = fnName;
  let paramsStr = ccEmitParamList(nodeGetData3(fnNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.paramsStr = paramsStr;
  let retType = ccTypeToC(nodeGetData4(fnNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.retType = retType;
  sbAppend(sb, ccEmitPrototype(retType, fnName, paramsStr));
  sbAppend(sb, "\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "\n");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < fnLen)) {
  let fnNode = (() => { const __recv = fnNodes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnNode = fnNode;
  sbAppend(sb, ccEmitStmt(fnNode));
  sbAppend(sb, "\n\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "static void tuff_init_globals(void) {\n");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let initLen = (() => { const __recv = initRows; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.initLen = initLen;
  while ((i < initLen)) {
  sbAppend(sb, "  ");
  sbAppend(sb, (() => { const __recv = initRows; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })());
  sbAppend(sb, "\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "}\n\n");
  sbAppend(sb, "void tuff_set_argv(int argc, char** argv);\n\n");
  sbAppend(sb, "int main(int argc, char** argv) {\n");
  sbAppend(sb, "  tuff_set_argv(argc, argv);\n");
  sbAppend(sb, "  tuff_init_globals();\n");
  sbAppend(sb, "  return (int)tuff_main();\n");
  sbAppend(sb, "}\n");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.generateCImpl = generateCImpl;

const __tuff_outer_for_ccPushFile = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccPushFile(artifacts, relPath, content) {
  let __tuff_this = { artifacts: artifacts, relPath: relPath, content: content, this: __tuff_outer_for_ccPushFile };
  let rec = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.rec = rec;
  (() => { const __recv = rec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(relPath); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, relPath) : vecPush(__recv, relPath); })();
  (() => { const __recv = rec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(content); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, content) : vecPush(__recv, content); })();
  return (() => { const __recv = artifacts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(rec); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, rec) : vecPush(__recv, rec); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccPushFile = ccPushFile;

const __tuff_outer_for_ccOwnerKeyForIndex = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccOwnerKeyForIndex(stmtOwners, idx, fallback) {
  let __tuff_this = { stmtOwners: stmtOwners, idx: idx, fallback: fallback, this: __tuff_outer_for_ccOwnerKeyForIndex };
  if ((idx < (() => { const __recv = stmtOwners; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) {
  return (() => { const __recv = stmtOwners; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(idx); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, idx) : vecGet(__recv, idx); })();
}
  return fallback;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccOwnerKeyForIndex = ccOwnerKeyForIndex;

const __tuff_outer_for_ccEmitSplitSharedHeader = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitSplitSharedHeader(typed, moduleKeys) {
  let __tuff_this = { typed: typed, moduleKeys: moduleKeys, this: __tuff_outer_for_ccEmitSplitSharedHeader };
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "#ifndef TUFF_SHARED_H\n");
  sbAppend(sb, "#define TUFF_SHARED_H\n\n");
  if ((ccIncStdint === 1)) {
  sbAppend(sb, "#include <stdint.h>\n");
}
  if ((ccIncStddef === 1)) {
  sbAppend(sb, "#include <stddef.h>\n");
}
  if ((ccIncStdio === 1)) {
  sbAppend(sb, "#include <stdio.h>\n");
}
  if ((ccIncStdlib === 1)) {
  sbAppend(sb, "#include <stdlib.h>\n");
}
  if ((ccIncString === 1)) {
  sbAppend(sb, "#include <string.h>\n");
}
  if ((ccIncCtype === 1)) {
  sbAppend(sb, "#include <ctype.h>\n");
}
  if ((ccIncErrno === 1)) {
  sbAppend(sb, "#include <errno.h>\n");
}
  sbAppend(sb, "#ifdef _WIN32\n");
  if ((ccIncDirect === 1)) {
  sbAppend(sb, "#include <direct.h>\n");
}
  sbAppend(sb, "#else\n");
  if ((ccIncSysStat === 1)) {
  sbAppend(sb, "#include <sys/stat.h>\n");
}
  if ((ccIncSysTypes === 1)) {
  sbAppend(sb, "#include <sys/types.h>\n");
}
  sbAppend(sb, "#endif\n\n");
  sbAppend(sb, "typedef struct TuffError { int64_t code; int64_t message; int64_t reason; int64_t fix; int64_t line; int64_t col; } TuffError;\n");
  sbAppend(sb, "typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\n");
  sbAppend(sb, "\n");
  ccEmittedTuffError = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmittedTuffError = ccEmittedTuffError;
  sbAppend(sb, "/* Runtime/host declarations required across split translation units. */\n");
  sbAppend(sb, "int64_t str_length();\n");
  sbAppend(sb, "int64_t str_char_at();\n");
  sbAppend(sb, "int64_t str_slice();\n");
  sbAppend(sb, "int64_t str_slice_window();\n");
  sbAppend(sb, "int64_t str_copy();\n");
  sbAppend(sb, "int64_t str_mut_slice();\n");
  sbAppend(sb, "int64_t str_concat();\n");
  sbAppend(sb, "int64_t str_eq();\n");
  sbAppend(sb, "int64_t str_from_char_code();\n");
  sbAppend(sb, "int64_t __str_index_of();\n");
  sbAppend(sb, "int64_t str_trim();\n");
  sbAppend(sb, "int64_t str_replace_all();\n");
  sbAppend(sb, "int64_t char_code();\n");
  sbAppend(sb, "int64_t __int_to_string();\n");
  sbAppend(sb, "int64_t parse_int();\n");
  sbAppend(sb, "int64_t sb_new();\n");
  sbAppend(sb, "int64_t sb_append();\n");
  sbAppend(sb, "int64_t sb_append_char();\n");
  sbAppend(sb, "int64_t sb_build();\n");
  sbAppend(sb, "int64_t __vec_new();\n");
  sbAppend(sb, "int64_t __vec_push();\n");
  sbAppend(sb, "int64_t __vec_pop();\n");
  sbAppend(sb, "int64_t __vec_get();\n");
  sbAppend(sb, "int64_t __vec_set();\n");
  sbAppend(sb, "int64_t __vec_length();\n");
  sbAppend(sb, "int64_t __vec_init();\n");
  sbAppend(sb, "int64_t __vec_capacity();\n");
  sbAppend(sb, "int64_t __vec_clear();\n");
  sbAppend(sb, "int64_t __vec_join();\n");
  sbAppend(sb, "int64_t __vec_includes();\n");
  sbAppend(sb, "int64_t __map_new();\n");
  sbAppend(sb, "int64_t map_set();\n");
  sbAppend(sb, "int64_t map_get();\n");
  sbAppend(sb, "int64_t map_has();\n");
  sbAppend(sb, "int64_t map_delete();\n");
  sbAppend(sb, "int64_t __set_new();\n");
  sbAppend(sb, "int64_t set_add();\n");
  sbAppend(sb, "int64_t set_has();\n");
  sbAppend(sb, "int64_t set_delete();\n");
  sbAppend(sb, "int64_t read_file();\n");
  sbAppend(sb, "int64_t write_file();\n");
  sbAppend(sb, "int64_t path_join();\n");
  sbAppend(sb, "int64_t path_dirname();\n");
  sbAppend(sb, "int64_t print();\n");
  sbAppend(sb, "int64_t __print_error();\n");
  sbAppend(sb, "int64_t panic();\n");
  sbAppend(sb, "int64_t panic_with_code();\n");
  sbAppend(sb, "int64_t panic_with_code_loc();\n");
  sbAppend(sb, "int64_t get_argc();\n");
  sbAppend(sb, "int64_t get_argv();\n");
  sbAppend(sb, "void tuff_set_argv(int argc, char** argv);\n");
  sbAppend(sb, "int64_t __perf_now();\n");
  sbAppend(sb, "int64_t profile_mark();\n");
  sbAppend(sb, "int64_t __profile_take_json();\n");
  sbAppend(sb, "int64_t __host_get_c_substrate();\n");
  sbAppend(sb, "int64_t __host_get_c_runtime_prelude_source();\n");
  sbAppend(sb, "int64_t __host_emit_target_from_source();\n\n");
  let stmts = nodeGetData1(typed); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let node = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  let kind = nodeKind(node); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL)) || (kind === NK_EXPECT_FN_DECL)) || (kind === NK_LET_DECL))) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  let row = ccEmitStmt(node); if (typeof __tuff_this !== 'undefined') __tuff_this.row = row;
  if ((!(() => { const __recv = row; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  if ((() => { const __recv = row; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("typedef struct TuffError { int64_t code; int64_t message; int64_t reason; int64_t fix; int64_t line; int64_t col; } TuffError;"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "typedef struct TuffError { int64_t code; int64_t message; int64_t reason; int64_t fix; int64_t line; int64_t col; } TuffError;") : strEq(__recv, "typedef struct TuffError { int64_t code; int64_t message; int64_t reason; int64_t fix; int64_t line; int64_t col; } TuffError;"); })()) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  sbAppend(sb, row);
  sbAppend(sb, "\n");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "\n");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let node = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if ((nodeKind(node) === NK_LET_DECL)) {
  let name = ccToName(getInternedStr(nodeGetData1(node))); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  sbAppend(sb, "extern int64_t ");
  sbAppend(sb, name);
  sbAppend(sb, ";\n");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "\n");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let fnNode = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnNode = fnNode;
  let kind = nodeKind(fnNode); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if (((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL)) || (kind === NK_EXPECT_FN_DECL))) {
  let fnName = ccToName(getInternedStr(nodeGetData1(fnNode))); if (typeof __tuff_this !== 'undefined') __tuff_this.fnName = fnName;
  let paramsStr = ccEmitParamList(nodeGetData3(fnNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.paramsStr = paramsStr;
  let retType = ccTypeToC(nodeGetData4(fnNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.retType = retType;
  sbAppend(sb, ccEmitPrototype(retType, fnName, paramsStr));
  sbAppend(sb, "\n");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "\n");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let mlen = (() => { const __recv = moduleKeys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.mlen = mlen;
  while ((i < mlen)) {
  let key = (() => { const __recv = moduleKeys; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  sbAppend(sb, "void tuff_init_globals_");
  sbAppend(sb, key);
  sbAppend(sb, "(void);\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "\n#endif\n");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitSplitSharedHeader = ccEmitSplitSharedHeader;

const __tuff_outer_for_ccEmitSplitModuleHeader = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitSplitModuleHeader(moduleKey) {
  let __tuff_this = { moduleKey: moduleKey, this: __tuff_outer_for_ccEmitSplitModuleHeader };
  let guard = (() => { const __recv = (() => { const __recv = "TUFF_MOD_"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(moduleKey); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, moduleKey) : strConcat(__recv, moduleKey); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("_H"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "_H") : strConcat(__recv, "_H"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.guard = guard;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "#ifndef ");
  sbAppend(sb, guard);
  sbAppend(sb, "\n#define ");
  sbAppend(sb, guard);
  sbAppend(sb, "\n\n#include \"tuff_shared.h\"\n\n");
  sbAppend(sb, "void tuff_init_globals_");
  sbAppend(sb, moduleKey);
  sbAppend(sb, "(void);\n\n#endif\n");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitSplitModuleHeader = ccEmitSplitModuleHeader;

const __tuff_outer_for_ccEmitSplitModuleSource = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitSplitModuleSource(typed, moduleKey, stmtOwners, fallbackKey) {
  let __tuff_this = { typed: typed, moduleKey: moduleKey, stmtOwners: stmtOwners, fallbackKey: fallbackKey, this: __tuff_outer_for_ccEmitSplitModuleSource };
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "#include \"");
  sbAppend(sb, moduleKey);
  sbAppend(sb, ".h\"\n\n");
  let stmts = nodeGetData1(typed); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let owner = ccOwnerKeyForIndex(stmtOwners, i, fallbackKey); if (typeof __tuff_this !== 'undefined') __tuff_this.owner = owner;
  let node = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (((() => { const __recv = owner; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(moduleKey); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, moduleKey) : strEq(__recv, moduleKey); })() && (nodeKind(node) === NK_LET_DECL))) {
  let name = ccToName(getInternedStr(nodeGetData1(node))); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  sbAppend(sb, "int64_t ");
  sbAppend(sb, name);
  sbAppend(sb, ";\n");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "\nvoid tuff_init_globals_");
  sbAppend(sb, moduleKey);
  sbAppend(sb, "(void) {\n");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let owner = ccOwnerKeyForIndex(stmtOwners, i, fallbackKey); if (typeof __tuff_this !== 'undefined') __tuff_this.owner = owner;
  let node = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (((() => { const __recv = owner; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(moduleKey); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, moduleKey) : strEq(__recv, moduleKey); })() && (nodeKind(node) === NK_LET_DECL))) {
  let name = ccToName(getInternedStr(nodeGetData1(node))); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  sbAppend(sb, "  ");
  sbAppend(sb, name);
  sbAppend(sb, " = ");
  sbAppend(sb, ccEmitExpr(nodeGetData3(node)));
  sbAppend(sb, ";\n");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "}\n\n");
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let owner = ccOwnerKeyForIndex(stmtOwners, i, fallbackKey); if (typeof __tuff_this !== 'undefined') __tuff_this.owner = owner;
  let fnNode = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnNode = fnNode;
  let kind = nodeKind(fnNode); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if (((() => { const __recv = owner; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(moduleKey); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, moduleKey) : strEq(__recv, moduleKey); })() && (((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL)))) {
  if ((nodeGetData5(fnNode) !== 0)) {
  sbAppend(sb, ccEmitStmt(fnNode));
  sbAppend(sb, "\n\n");
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitSplitModuleSource = ccEmitSplitModuleSource;

const __tuff_outer_for_ccEmitSplitRuntimeSource = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitSplitRuntimeSource(substrate) {
  let __tuff_this = { substrate: substrate, this: __tuff_outer_for_ccEmitSplitRuntimeSource };
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "#include \"tuff_shared.h\"\n\n");
  let runtimeSrc = substrate; if (typeof __tuff_this !== 'undefined') __tuff_this.runtimeSrc = runtimeSrc;
  if ((() => { const __recv = runtimeSrc; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) {
  runtimeSrc = ccEmitMinimalRuntimePrelude(); if (typeof __tuff_this !== 'undefined') __tuff_this.runtimeSrc = runtimeSrc;
}
  runtimeSrc = (() => { const __recv = runtimeSrc; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\n", ""); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\n", "") : strReplaceAll(__recv, "typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\n", ""); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.runtimeSrc = runtimeSrc;
  runtimeSrc = (() => { const __recv = runtimeSrc; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\r\n", ""); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\r\n", "") : strReplaceAll(__recv, "typedef struct TuffVec { int64_t* data; int64_t init; int64_t length; } TuffVec;\r\n", ""); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.runtimeSrc = runtimeSrc;
  runtimeSrc = (() => { const __recv = runtimeSrc; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("typedef struct\n{\n    int64_t *data;\n    size_t init;\n    size_t length;\n} TuffVec;\n", ""); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "typedef struct\n{\n    int64_t *data;\n    size_t init;\n    size_t length;\n} TuffVec;\n", "") : strReplaceAll(__recv, "typedef struct\n{\n    int64_t *data;\n    size_t init;\n    size_t length;\n} TuffVec;\n", ""); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.runtimeSrc = runtimeSrc;
  runtimeSrc = (() => { const __recv = runtimeSrc; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("typedef struct\r\n{\r\n    int64_t *data;\r\n    size_t init;\r\n    size_t length;\r\n} TuffVec;\r\n", ""); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "typedef struct\r\n{\r\n    int64_t *data;\r\n    size_t init;\r\n    size_t length;\r\n} TuffVec;\r\n", "") : strReplaceAll(__recv, "typedef struct\r\n{\r\n    int64_t *data;\r\n    size_t init;\r\n    size_t length;\r\n} TuffVec;\r\n", ""); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.runtimeSrc = runtimeSrc;
  if ((!(() => { const __recv = substrate; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  sbAppend(sb, runtimeSrc);
} else {
  sbAppend(sb, runtimeSrc);
}
  sbAppend(sb, "\n");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitSplitRuntimeSource = ccEmitSplitRuntimeSource;

const __tuff_outer_for_ccEmitSplitMainSource = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ccEmitSplitMainSource(initOrder) {
  let __tuff_this = { initOrder: initOrder, this: __tuff_outer_for_ccEmitSplitMainSource };
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "#include \"tuff_shared.h\"\n\n");
  sbAppend(sb, "int main(int argc, char** argv) {\n");
  sbAppend(sb, "  tuff_set_argv(argc, argv);\n");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = initOrder; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let key = (() => { const __recv = initOrder; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  sbAppend(sb, "  tuff_init_globals_");
  sbAppend(sb, key);
  sbAppend(sb, "();\n");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "  return (int)tuff_main();\n");
  sbAppend(sb, "}\n");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmitSplitMainSource = ccEmitSplitMainSource;

const __tuff_outer_for_generateCSplitFilesImpl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function generateCSplitFilesImpl(typed, substrate, moduleKeys, stmtOwners, initOrder) {
  let __tuff_this = { typed: typed, substrate: substrate, moduleKeys: moduleKeys, stmtOwners: stmtOwners, initOrder: initOrder, this: __tuff_outer_for_generateCSplitFilesImpl };
  ccTempCounter = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccTempCounter = ccTempCounter;
  ccDisableUnicodeEscape = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccDisableUnicodeEscape = ccDisableUnicodeEscape;
  ccEnumNames = (() => { const __recv = ccEnumNames; const __prop = __recv?.["setClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.setClear; return __dyn ? __dyn(__recv.ref) : setClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccEnumNames = ccEnumNames;
  ccEnumVariantConsts = (() => { const __recv = ccEnumVariantConsts; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccEnumVariantConsts = ccEnumVariantConsts;
  ccStructFields = (() => { const __recv = ccStructFields; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccStructFields = ccStructFields;
  ccAliasByVariant = (() => { const __recv = ccAliasByVariant; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccAliasByVariant = ccAliasByVariant;
  ccUnionAliasInfo = (() => { const __recv = ccUnionAliasInfo; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccUnionAliasInfo = ccUnionAliasInfo;
  ccCoveredExternFns = (() => { const __recv = ccCoveredExternFns; const __prop = __recv?.["setClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.setClear; return __dyn ? __dyn(__recv.ref) : setClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccCoveredExternFns = ccCoveredExternFns;
  ccFnReturnTypes = (() => { const __recv = ccFnReturnTypes; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccFnReturnTypes = ccFnReturnTypes;
  ccLocalTypes = (() => { const __recv = ccLocalTypes; const __prop = __recv?.["mapClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.mapClear; return __dyn ? __dyn(__recv.ref) : mapClear(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ccLocalTypes = ccLocalTypes;
  ccEmittedTuffError = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccEmittedTuffError = ccEmittedTuffError;
  ccIncStdint = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdint = ccIncStdint;
  ccIncStddef = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStddef = ccIncStddef;
  ccIncStdio = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdio = ccIncStdio;
  ccIncStdlib = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdlib = ccIncStdlib;
  ccIncString = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncString = ccIncString;
  ccIncCtype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncCtype = ccIncCtype;
  ccIncErrno = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncErrno = ccIncErrno;
  ccIncDirect = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncDirect = ccIncDirect;
  ccIncSysStat = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncSysStat = ccIncSysStat;
  ccIncSysTypes = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncSysTypes = ccIncSysTypes;
  ccInitContext(typed);
  if ((!(() => { const __recv = substrate; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  ccRequireSubstrateHeaders();
} else {
  ccIncStddef = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStddef = ccIncStddef;
  ccIncStdio = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdio = ccIncStdio;
  ccIncStdlib = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncStdlib = ccIncStdlib;
  ccIncString = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncString = ccIncString;
  ccIncCtype = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.ccIncCtype = ccIncCtype;
}
  let stmts = nodeGetData1(typed); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let cvi = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cvi = cvi;
  while ((cvi < len)) {
  let cvn = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(cvi); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, cvi) : vecGet(__recv, cvi); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.cvn = cvn;
  if (ccIsExternFnDecl(cvn)) {
  let fname = getInternedStr(nodeGetData1(cvn)); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if ((!(() => { const __recv = ccCoveredExternFns; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, fname) : setHas(__recv, fname); })())) {
  panicWithCode("E_EXTERN_NO_SOURCE", (() => { const __recv = (() => { const __recv = "extern fn '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' has no source attribution"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' has no source attribution") : strConcat(__recv, "' has no source attribution"); })(), "C codegen requires each extern function to be attributed to a source via extern let destructuring.", (() => { const __recv = (() => { const __recv = "Add 'extern let { "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fname); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fname) : strConcat(__recv, fname); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" } = <header>;' before the declaration."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " } = <header>;' before the declaration.") : strConcat(__recv, " } = <header>;' before the declaration."); })());
}
}
  cvi = (cvi + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cvi = cvi;
}
  let artifacts = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.artifacts = artifacts;
  ccPushFile(artifacts, "tuff_shared.h", ccEmitSplitSharedHeader(typed, moduleKeys));
  ccPushFile(artifacts, "tuff_runtime.c", ccEmitSplitRuntimeSource(substrate));
  let fallbackKey = "main"; if (typeof __tuff_this !== 'undefined') __tuff_this.fallbackKey = fallbackKey;
  if (((() => { const __recv = moduleKeys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > 0)) {
  fallbackKey = (() => { const __recv = moduleKeys; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(((() => { const __recv = moduleKeys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() - 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, ((() => { const __recv = moduleKeys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() - 1)) : vecGet(__recv, ((() => { const __recv = moduleKeys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() - 1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fallbackKey = fallbackKey;
}
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let mlen = (() => { const __recv = moduleKeys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.mlen = mlen;
  while ((i < mlen)) {
  let key = (() => { const __recv = moduleKeys; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  ccPushFile(artifacts, (() => { const __recv = key; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(".h"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".h") : strConcat(__recv, ".h"); })(), ccEmitSplitModuleHeader(key));
  ccPushFile(artifacts, (() => { const __recv = key; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(".c"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".c") : strConcat(__recv, ".c"); })(), ccEmitSplitModuleSource(typed, key, stmtOwners, fallbackKey));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  ccPushFile(artifacts, "tuff_main.c", ccEmitSplitMainSource(initOrder));
  return artifacts;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.generateCSplitFilesImpl = generateCSplitFilesImpl;

const __tuff_outer_for_selfhostCodegenCImplMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostCodegenCImplMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostCodegenCImplMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostCodegenCImplMarker = selfhostCodegenCImplMarker;

const __tuff_outer_for_generateC = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function generateC(typed, substrate) {
  let __tuff_this = { typed: typed, substrate: substrate, this: __tuff_outer_for_generateC };
  return generateCImpl(typed, substrate);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.generateC = generateC;

const __tuff_outer_for_generateCSplitFiles = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function generateCSplitFiles(typed, substrate, moduleKeys, stmtOwners, initOrder) {
  let __tuff_this = { typed: typed, substrate: substrate, moduleKeys: moduleKeys, stmtOwners: stmtOwners, initOrder: initOrder, this: __tuff_outer_for_generateCSplitFiles };
  return generateCSplitFilesImpl(typed, substrate, moduleKeys, stmtOwners, initOrder);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.generateCSplitFiles = generateCSplitFiles;

const __tuff_outer_for_selfhostCodegenCMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostCodegenCMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostCodegenCMarker };
  return selfhostCodegenCImplMarker();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostCodegenCMarker = selfhostCodegenCMarker;

const __tuff_outer_for_ensureTrailingNewline = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function ensureTrailingNewline(text) {
  let __tuff_this = { text: text, this: __tuff_outer_for_ensureTrailingNewline };
  if (((() => { const __recv = text; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() === 0)) {
  return "\n";
}
  if (((() => { const __recv = text; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(((() => { const __recv = text; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() - 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, ((() => { const __recv = text; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() - 1)) : strCharAt(__recv, ((() => { const __recv = text; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() - 1)); })() === 10)) {
  return text;
}
  return (() => { const __recv = text; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\n") : strConcat(__recv, "\n"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.ensureTrailingNewline = ensureTrailingNewline;

const __tuff_outer_for_emitTuffFromTypedImpl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitTuffFromTypedImpl(typed, source, triviaPayload) {
  let __tuff_this = { typed: typed, source: source, triviaPayload: triviaPayload, this: __tuff_outer_for_emitTuffFromTypedImpl };
  let _typed_guard = typed; if (typeof __tuff_this !== 'undefined') __tuff_this._typed_guard = _typed_guard;
  let _trivia_guard = (() => { const __recv = triviaPayload; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this._trivia_guard = _trivia_guard;
  let _source_guard = (() => { const __recv = source; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this._source_guard = _source_guard;
  return ensureTrailingNewline(source);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitTuffFromTypedImpl = emitTuffFromTypedImpl;

const __tuff_outer_for_selfhostTuffPrinterImplMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostTuffPrinterImplMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostTuffPrinterImplMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostTuffPrinterImplMarker = selfhostTuffPrinterImplMarker;

const __tuff_outer_for_emitTuffFromTyped = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitTuffFromTyped(typed, source, triviaPayload) {
  let __tuff_this = { typed: typed, source: source, triviaPayload: triviaPayload, this: __tuff_outer_for_emitTuffFromTyped };
  return emitTuffFromTypedImpl(typed, source, triviaPayload);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitTuffFromTyped = emitTuffFromTyped;

const __tuff_outer_for_selfhostTuffPrinterMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostTuffPrinterMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostTuffPrinterMarker };
  return selfhostTuffPrinterImplMarker();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostTuffPrinterMarker = selfhostTuffPrinterMarker;

let smPaths = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.smPaths = smPaths;

let smStartLines = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.smStartLines = smStartLines;

const __tuff_outer_for_sourcemapInit = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function sourcemapInit() {
  let __tuff_this = { this: __tuff_outer_for_sourcemapInit };
  while (((() => { const __recv = smPaths; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > 0)) {
  (() => { const __recv = smPaths; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })();
  (() => { const __recv = smStartLines; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })();
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.sourcemapInit = sourcemapInit;

const __tuff_outer_for_sourcemapAdd = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function sourcemapAdd(path, startLine) {
  let __tuff_this = { path: path, startLine: startLine, this: __tuff_outer_for_sourcemapAdd };
  (() => { const __recv = smPaths; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(path); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, path) : vecPush(__recv, path); })();
  (() => { const __recv = smStartLines; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(startLine); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, startLine) : vecPush(__recv, startLine); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.sourcemapAdd = sourcemapAdd;

const __tuff_outer_for_sourcemapCountLines = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function sourcemapCountLines(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_sourcemapCountLines };
  let count = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  let found = (() => { const __recv = s; const __prop = __recv?.["strIndexOf"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.strIndexOf; return __dyn ? __dyn(__recv.ref, "\n") : strIndexOf(__recv, "\n"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  while ((found >= 0)) {
  count = (count + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  s = (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((found + 1), (() => { const __recv = s; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (found + 1), (() => { const __recv = s; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()) : strSliceWindow(__recv, (found + 1), (() => { const __recv = s; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })()); })(); const __prop = __recv?.["strCopy"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strCopy; return __dyn ? __dyn(__recv.ref) : strCopy(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  found = (() => { const __recv = s; const __prop = __recv?.["strIndexOf"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.strIndexOf; return __dyn ? __dyn(__recv.ref, "\n") : strIndexOf(__recv, "\n"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
}
  return count;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.sourcemapCountLines = sourcemapCountLines;

const __tuff_outer_for_sourcemapLookup = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function sourcemapLookup(mergedLine) {
  let __tuff_this = { mergedLine: mergedLine, this: __tuff_outer_for_sourcemapLookup };
  let len = (() => { const __recv = smPaths; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len === 0)) {
  return "<unknown>";
}
  let bestI = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.bestI = bestI;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  if (((() => { const __recv = smStartLines; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })() <= mergedLine)) {
  bestI = i; if (typeof __tuff_this !== 'undefined') __tuff_this.bestI = bestI;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let path = (() => { const __recv = smPaths; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(bestI); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, bestI) : vecGet(__recv, bestI); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.path = path;
  let start = (() => { const __recv = smStartLines; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(bestI); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, bestI) : vecGet(__recv, bestI); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.start = start;
  let localLine = ((mergedLine - start) + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.localLine = localLine;
  return (() => { const __recv = (() => { const __recv = path; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":L"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":L") : strConcat(__recv, ":L"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(localLine)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(localLine)) : strConcat(__recv, intToString(localLine)); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.sourcemapLookup = sourcemapLookup;

const __tuff_outer_for_selfhostModuleSourcemapMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostModuleSourcemapMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostModuleSourcemapMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostModuleSourcemapMarker = selfhostModuleSourcemapMarker;

let lintIssueRecords = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.lintIssueRecords = lintIssueRecords;

const __tuff_outer_for_lintIssueSepField = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintIssueSepField() {
  let __tuff_this = { this: __tuff_outer_for_lintIssueSepField };
  return "\u001f";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintIssueSepField = lintIssueSepField;

const __tuff_outer_for_lintIssueSepRecord = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintIssueSepRecord() {
  let __tuff_this = { this: __tuff_outer_for_lintIssueSepRecord };
  return "\u001e";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintIssueSepRecord = lintIssueSepRecord;

const __tuff_outer_for_lintIssueEncode = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintIssueEncode(code, message, reason, fix) {
  let __tuff_this = { code: code, message: message, reason: reason, fix: fix, this: __tuff_outer_for_lintIssueEncode };
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = code; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintIssueSepField()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintIssueSepField()) : strConcat(__recv, lintIssueSepField()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(message); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, message) : strConcat(__recv, message); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintIssueSepField()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintIssueSepField()) : strConcat(__recv, lintIssueSepField()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(reason); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, reason) : strConcat(__recv, reason); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintIssueSepField()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintIssueSepField()) : strConcat(__recv, lintIssueSepField()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fix); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fix) : strConcat(__recv, fix); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintIssueEncode = lintIssueEncode;

const __tuff_outer_for_lintAddIssue = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAddIssue(code, message, reason, fix) {
  let __tuff_this = { code: code, message: message, reason: reason, fix: fix, this: __tuff_outer_for_lintAddIssue };
  (() => { const __recv = lintIssueRecords; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(lintIssueEncode(code, message, reason, fix)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, lintIssueEncode(code, message, reason, fix)) : vecPush(__recv, lintIssueEncode(code, message, reason, fix)); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAddIssue = lintAddIssue;

const __tuff_outer_for_lintReset = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintReset() {
  let __tuff_this = { this: __tuff_outer_for_lintReset };
  (() => { const __recv = lintIssueRecords; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintReset = lintReset;

const __tuff_outer_for_lintTakeIssues = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintTakeIssues() {
  let __tuff_this = { this: __tuff_outer_for_lintTakeIssues };
  let s = (() => { const __recv = lintIssueRecords; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(lintIssueSepRecord()); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, lintIssueSepRecord()) : vecJoin(__recv, lintIssueSepRecord()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  (() => { const __recv = lintIssueRecords; const __prop = __recv?.["vecClear"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecClear; return __dyn ? __dyn(__recv.ref) : vecClear(__recv); })();
  return s;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintTakeIssues = lintTakeIssues;

const __tuff_outer_for_lintCheckFileLength = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintCheckFileLength(filePath, maxEffectiveLines) {
  let __tuff_this = { filePath: filePath, maxEffectiveLines: maxEffectiveLines, this: __tuff_outer_for_lintCheckFileLength };
  let count = lintEffectiveLineCount(); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  if ((count > maxEffectiveLines)) {
  lintAddIssue("E_LINT_FILE_TOO_LONG", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "File '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, filePath) : strConcat(__recv, filePath); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' exceeds "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' exceeds ") : strConcat(__recv, "' exceeds "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(maxEffectiveLines)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(maxEffectiveLines)) : strConcat(__recv, intToString(maxEffectiveLines)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" effective lines ("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " effective lines (") : strConcat(__recv, " effective lines ("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(count)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(count)) : strConcat(__recv, intToString(count)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(), "Large files are harder to review and maintain; this file exceeds the maximum effective line budget after excluding comments and blank lines.", (() => { const __recv = (() => { const __recv = "Split this file into smaller modules so each file has at most "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(maxEffectiveLines)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(maxEffectiveLines)) : strConcat(__recv, intToString(maxEffectiveLines)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" non-comment, non-whitespace lines."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " non-comment, non-whitespace lines.") : strConcat(__recv, " non-comment, non-whitespace lines."); })());
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintCheckFileLength = lintCheckFileLength;

const __tuff_outer_for_lintCheckCurrentFileLength = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintCheckCurrentFileLength(filePath, maxEffectiveLines) {
  let __tuff_this = { filePath: filePath, maxEffectiveLines: maxEffectiveLines, this: __tuff_outer_for_lintCheckCurrentFileLength };
  return lintCheckFileLength(filePath, maxEffectiveLines);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintCheckCurrentFileLength = lintCheckCurrentFileLength;

const __tuff_outer_for_lintIsExternFnDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintIsExternFnDecl(stmt) {
  let __tuff_this = { stmt: stmt, this: __tuff_outer_for_lintIsExternFnDecl };
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  return ((kind === NK_FN_DECL) && (nodeGetData5(stmt) === 0));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintIsExternFnDecl = lintIsExternFnDecl;

const __tuff_outer_for_lintMarkLine = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintMarkLine(lines, line) {
  let __tuff_this = { lines: lines, line: line, this: __tuff_outer_for_lintMarkLine };
  let key = intToString(line); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  if ((!(() => { const __recv = lines; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(key); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, key) : setHas(__recv, key); })())) {
  (() => { const __recv = lines; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(key); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, key) : setAdd(__recv, key); })();
  return 1;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintMarkLine = lintMarkLine;

const __tuff_outer_for_lintCollectEffectiveLinesExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintCollectEffectiveLinesExpr(expr, lines) {
  let __tuff_this = { expr: expr, lines: lines, this: __tuff_outer_for_lintCollectEffectiveLinesExpr };
  if ((expr === 0)) {
  return 0;
}
  let added = lintMarkLine(lines, nodeGetLine(expr)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  let kind = nodeKind(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if (((kind === NK_UNARY_EXPR) || (kind === NK_UNWRAP_EXPR))) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData2(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  if ((kind === NK_UNWRAP_EXPR)) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
}
  return added;
}
  if ((kind === NK_BINARY_EXPR)) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData2(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData3(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_CALL_EXPR)) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  let args = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len25 = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len25 = __len25;
  while ((i < __len25)) {
  added = (added + lintCollectEffectiveLinesExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return added;
}
  if ((kind === NK_MEMBER_EXPR)) {
  return (added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines));
}
  if ((kind === NK_INDEX_EXPR)) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData2(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_STRUCT_INIT)) {
  let fields = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len24 = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len24 = __len24;
  while ((i < __len24)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  added = (added + lintCollectEffectiveLinesExpr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return added;
}
  if ((kind === NK_IF_EXPR)) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lintCollectEffectiveLinesStmt(nodeGetData2(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  if ((nodeGetData3(expr) !== 0)) {
  added = (added + lintCollectEffectiveLinesStmt(nodeGetData3(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
}
  return added;
}
  if ((kind === NK_MATCH_EXPR)) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  let cases = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len23 = (() => { const __recv = cases; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len23 = __len23;
  while ((i < __len23)) {
  let c = (() => { const __recv = cases; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.c = c;
  added = (added + lintCollectEffectiveLinesStmt((() => { const __recv = c; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return added;
}
  if ((kind === NK_IS_EXPR)) {
  return (added + lintCollectEffectiveLinesExpr(nodeGetData1(expr), lines));
}
  if ((kind === NK_FN_EXPR)) {
  return (added + lintCollectEffectiveLinesStmt(nodeGetData5(expr), lines));
}
  if ((kind === NK_LAMBDA_EXPR)) {
  return (added + lintCollectEffectiveLinesStmt(nodeGetData2(expr), lines));
}
  if ((kind === NK_TUPLE_EXPR)) {
  let items = nodeGetData1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len22 = (() => { const __recv = items; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len22 = __len22;
  while ((i < __len22)) {
  added = (added + lintCollectEffectiveLinesExpr((() => { const __recv = items; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return added;
}
  return added;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintCollectEffectiveLinesExpr = lintCollectEffectiveLinesExpr;

const __tuff_outer_for_lintCollectEffectiveLinesStmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintCollectEffectiveLinesStmt(stmt, lines) {
  let __tuff_this = { stmt: stmt, lines: lines, this: __tuff_outer_for_lintCollectEffectiveLinesStmt };
  if ((stmt === 0)) {
  return 0;
}
  let added = lintMarkLine(lines, nodeGetLine(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LET_DECL)) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData2(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData3(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_BLOCK)) {
  let stmts = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len21 = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len21 = __len21;
  while ((i < __len21)) {
  added = (added + lintCollectEffectiveLinesStmt((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return added;
}
  if ((kind === NK_EXPR_STMT)) {
  return (added + lintCollectEffectiveLinesExpr(nodeGetData1(stmt), lines));
}
  if ((kind === NK_ASSIGN_STMT)) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData1(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData2(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_RETURN_STMT)) {
  return (added + lintCollectEffectiveLinesExpr(nodeGetData1(stmt), lines));
}
  if ((kind === NK_IF_STMT)) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData1(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lintCollectEffectiveLinesStmt(nodeGetData2(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lintCollectEffectiveLinesStmt(nodeGetData3(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_FOR_STMT)) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData2(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData3(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lintCollectEffectiveLinesStmt(nodeGetData4(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_WHILE_STMT)) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData1(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lintCollectEffectiveLinesStmt(nodeGetData2(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_LOOP_STMT)) {
  return (added + lintCollectEffectiveLinesStmt(nodeGetData1(stmt), lines));
}
  if ((kind === NK_LIFETIME_STMT)) {
  return (added + lintCollectEffectiveLinesStmt(nodeGetData2(stmt), lines));
}
  if ((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL))) {
  added = (added + lintCollectEffectiveLinesExpr(nodeGetData4(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  added = (added + lintCollectEffectiveLinesStmt(nodeGetData5(stmt), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  return added;
}
  if ((kind === NK_STMT_LIST)) {
  let items = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len20 = (() => { const __recv = items; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len20 = __len20;
  while ((i < __len20)) {
  added = (added + lintCollectEffectiveLinesStmt((() => { const __recv = items; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.added = added;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return added;
}
  if ((((((((kind === NK_INTO_STMT) || (kind === NK_BREAK_STMT)) || (kind === NK_CONTINUE_STMT)) || (kind === NK_EXTERN_IMPORT_DECL)) || lintIsExternFnDecl(stmt)) || (kind === NK_EXTERN_LET_DECL)) || (kind === NK_EXTERN_TYPE_DECL))) {
  return added;
}
  return (added + lintCollectEffectiveLinesExpr(stmt, lines));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintCollectEffectiveLinesStmt = lintCollectEffectiveLinesStmt;

const __tuff_outer_for_lintCheckFunctionLength = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintCheckFunctionLength(stmt, maxEffectiveLines) {
  let __tuff_this = { stmt: stmt, maxEffectiveLines: maxEffectiveLines, this: __tuff_outer_for_lintCheckFunctionLength };
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((!(((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL)))) {
  return 0;
}
  let body = nodeGetData5(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if ((body === 0)) {
  return 0;
}
  let lines = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.lines = lines;
  let count = lintMarkLine(lines, nodeGetLine(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  count = (count + lintCollectEffectiveLinesStmt(body, lines)); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  if ((count >= maxEffectiveLines)) {
  let fnName = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.fnName = fnName;
  lintAddIssue("E_LINT_FUNCTION_TOO_LONG", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Function '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fnName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fnName) : strConcat(__recv, fnName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' has "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' has ") : strConcat(__recv, "' has "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(maxEffectiveLines)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(maxEffectiveLines)) : strConcat(__recv, intToString(maxEffectiveLines)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" or more effective lines ("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " or more effective lines (") : strConcat(__recv, " or more effective lines ("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(count)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(count)) : strConcat(__recv, intToString(count)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(), (() => { const __recv = (() => { const __recv = "This function has at least "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(maxEffectiveLines)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(maxEffectiveLines)) : strConcat(__recv, intToString(maxEffectiveLines)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" non-comment, non-whitespace lines, which increases complexity and reduces readability."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " non-comment, non-whitespace lines, which increases complexity and reduces readability.") : strConcat(__recv, " non-comment, non-whitespace lines, which increases complexity and reduces readability."); })(), (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Split function '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(fnName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, fnName) : strConcat(__recv, fnName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' into smaller helper functions so each function stays below "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' into smaller helper functions so each function stays below ") : strConcat(__recv, "' into smaller helper functions so each function stays below "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(maxEffectiveLines)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(maxEffectiveLines)) : strConcat(__recv, intToString(maxEffectiveLines)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" effective lines."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " effective lines.") : strConcat(__recv, " effective lines."); })());
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintCheckFunctionLength = lintCheckFunctionLength;

const __tuff_outer_for_lintCollectExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintCollectExpr(expr, receiverExternFns, reads) {
  let __tuff_this = { expr: expr, receiverExternFns: receiverExternFns, reads: reads, this: __tuff_outer_for_lintCollectExpr };
  if ((expr === 0)) {
  return 0;
}
  let kind = nodeKind(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_IDENTIFIER)) {
  (() => { const __recv = reads; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(expr))); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(expr))) : setAdd(__recv, getInternedStr(nodeGetData1(expr))); })();
  return 0;
}
  if (((kind === NK_UNARY_EXPR) || (kind === NK_UNWRAP_EXPR))) {
  lintCollectExpr(nodeGetData2(expr), receiverExternFns, reads);
  if ((kind === NK_UNWRAP_EXPR)) {
  lintCollectExpr(nodeGetData1(expr), receiverExternFns, reads);
}
  return 0;
}
  if ((kind === NK_BINARY_EXPR)) {
  lintCollectExpr(nodeGetData2(expr), receiverExternFns, reads);
  lintCollectExpr(nodeGetData3(expr), receiverExternFns, reads);
  return 0;
}
  if ((kind === NK_CALL_EXPR)) {
  let callee = nodeGetData1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  let args = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((nodeKind(callee) === NK_IDENTIFIER) && ((() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > 0))) {
  let name = getInternedStr(nodeGetData1(callee)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let callStyle = nodeGetData3(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.callStyle = callStyle;
  if (((() => { const __recv = receiverExternFns; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })() && (callStyle !== 1))) {
  lintAddIssue("E_LINT_PREFER_RECEIVER_CALL", (() => { const __recv = (() => { const __recv = "Prefer receiver-call syntax for '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "This extern function declares a receiver as its first 'this' parameter, so calling it as a free function is less idiomatic.", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Rewrite '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(x, ...)' as 'x."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(x, ...)' as 'x.") : strConcat(__recv, "(x, ...)' as 'x."); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(...)'."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(...)'.") : strConcat(__recv, "(...)'."); })());
}
}
  lintCollectExpr(callee, receiverExternFns, reads);
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  lintCollectExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), receiverExternFns, reads);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_MEMBER_EXPR)) {
  lintCollectExpr(nodeGetData1(expr), receiverExternFns, reads);
  return 0;
}
  if ((kind === NK_INDEX_EXPR)) {
  lintCollectExpr(nodeGetData1(expr), receiverExternFns, reads);
  lintCollectExpr(nodeGetData2(expr), receiverExternFns, reads);
  return 0;
}
  if ((kind === NK_STRUCT_INIT)) {
  let fields = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  lintCollectExpr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), receiverExternFns, reads);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_IF_EXPR)) {
  let cond = nodeGetData1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  if ((nodeKind(cond) === NK_BOOL_LIT)) {
  lintAddIssue("E_LINT_CONSTANT_CONDITION", "Constant condition in if-expression/statement", "A constant condition means one branch is unreachable, which usually indicates dead or unintended code.", "Use a non-constant condition, or simplify by keeping only the branch that will execute.");
}
  lintCollectExpr(cond, receiverExternFns, reads);
  lintCollectStmt(nodeGetData2(expr), receiverExternFns, reads, setNew(), vecNew());
  if ((nodeGetData3(expr) !== 0)) {
  lintCollectStmt(nodeGetData3(expr), receiverExternFns, reads, setNew(), vecNew());
}
  return 0;
}
  if ((kind === NK_MATCH_EXPR)) {
  lintCollectExpr(nodeGetData1(expr), receiverExternFns, reads);
  let cases = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let c = (() => { const __recv = cases; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.c = c;
  lintCollectStmt((() => { const __recv = c; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), receiverExternFns, reads, setNew(), vecNew());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_IS_EXPR)) {
  lintCollectExpr(nodeGetData1(expr), receiverExternFns, reads);
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintCollectExpr = lintCollectExpr;

const __tuff_outer_for_lintCollectStmt = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintCollectStmt(stmt, receiverExternFns, reads, declaredSet, declaredNames) {
  let __tuff_this = { stmt: stmt, receiverExternFns: receiverExternFns, reads: reads, declaredSet: declaredSet, declaredNames: declaredNames, this: __tuff_outer_for_lintCollectStmt };
  if ((stmt === 0)) {
  return 0;
}
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_LET_DECL)) {
  let name = getInternedStr(nodeGetData1(stmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((!(() => { const __recv = declaredSet; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })())) {
  (() => { const __recv = declaredSet; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, name) : setAdd(__recv, name); })();
  (() => { const __recv = declaredNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, name) : vecPush(__recv, name); })();
}
  lintCollectExpr(nodeGetData3(stmt), receiverExternFns, reads);
  return 0;
}
  if ((kind === NK_BLOCK)) {
  let stmts = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  if (((() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 0)) {
  lintAddIssue("E_LINT_EMPTY_BLOCK", "Empty block has no effect", "An empty block executes no statements, which is often accidental and can hide incomplete logic.", "Add the intended statements to the block, or remove the block if it is unnecessary.");
}
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  lintCollectStmt((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), receiverExternFns, reads, declaredSet, declaredNames);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === NK_EXPR_STMT)) {
  lintCollectExpr(nodeGetData1(stmt), receiverExternFns, reads);
  return 0;
}
  if ((kind === NK_EXTERN_IMPORT_DECL)) {
  return 0;
}
  if ((kind === NK_ASSIGN_STMT)) {
  lintCollectExpr(nodeGetData1(stmt), receiverExternFns, reads);
  lintCollectExpr(nodeGetData2(stmt), receiverExternFns, reads);
  return 0;
}
  if ((kind === NK_RETURN_STMT)) {
  lintCollectExpr(nodeGetData1(stmt), receiverExternFns, reads);
  return 0;
}
  if ((kind === NK_IF_STMT)) {
  let cond = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  if ((nodeKind(cond) === NK_BOOL_LIT)) {
  lintAddIssue("E_LINT_CONSTANT_CONDITION", "Constant condition in if-expression/statement", "A constant condition means one branch is unreachable, which usually indicates dead or unintended code.", "Use a non-constant condition, or simplify by keeping only the branch that will execute.");
}
  lintCollectExpr(cond, receiverExternFns, reads);
  lintCollectStmt(nodeGetData2(stmt), receiverExternFns, reads, declaredSet, declaredNames);
  lintCollectStmt(nodeGetData3(stmt), receiverExternFns, reads, declaredSet, declaredNames);
  return 0;
}
  if ((kind === NK_FOR_STMT)) {
  lintCollectExpr(nodeGetData2(stmt), receiverExternFns, reads);
  lintCollectExpr(nodeGetData3(stmt), receiverExternFns, reads);
  lintCollectStmt(nodeGetData4(stmt), receiverExternFns, reads, declaredSet, declaredNames);
  return 0;
}
  if ((kind === NK_WHILE_STMT)) {
  lintCollectExpr(nodeGetData1(stmt), receiverExternFns, reads);
  lintCollectStmt(nodeGetData2(stmt), receiverExternFns, reads, declaredSet, declaredNames);
  return 0;
}
  if (((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL))) {
  lintCollectStmt(nodeGetData5(stmt), receiverExternFns, reads, declaredSet, declaredNames);
  return 0;
}
  lintCollectExpr(stmt, receiverExternFns, reads);
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintCollectStmt = lintCollectStmt;

const __tuff_outer_for_lintAddCircularImportIssue = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAddCircularImportIssue(cycleText) {
  let __tuff_this = { cycleText: cycleText, this: __tuff_outer_for_lintAddCircularImportIssue };
  return lintAddIssue("E_LINT_CIRCULAR_IMPORT", (() => { const __recv = "Circular import detected: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cycleText); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cycleText) : strConcat(__recv, cycleText); })(), "Circular dependencies between modules make dependency flow harder to understand and maintain.", "Refactor shared declarations into a third module and have each side import that shared module instead.");
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAddCircularImportIssue = lintAddCircularImportIssue;

const __tuff_outer_for_lintAstdupKindName = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupKindName(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_lintAstdupKindName };
  if ((kind === NK_BLOCK)) {
  return "block";
}
  if ((kind === NK_IF_STMT)) {
  return "if-stmt";
}
  if ((kind === NK_WHILE_STMT)) {
  return "while-stmt";
}
  if ((kind === NK_FOR_STMT)) {
  return "for-stmt";
}
  if ((kind === NK_LOOP_STMT)) {
  return "loop-stmt";
}
  if ((kind === NK_ASSIGN_STMT)) {
  return "assign-stmt";
}
  if ((kind === NK_RETURN_STMT)) {
  return "return-stmt";
}
  if ((kind === NK_BINARY_EXPR)) {
  return "binary-expr";
}
  if ((kind === NK_CALL_EXPR)) {
  return "call-expr";
}
  if ((kind === NK_IF_EXPR)) {
  return "if-expr";
}
  if ((kind === NK_MATCH_EXPR)) {
  return "match-expr";
}
  if ((kind === NK_STRUCT_INIT)) {
  return "struct-init";
}
  if ((kind === NK_LAMBDA_EXPR)) {
  return "lambda-expr";
}
  return (() => { const __recv = "node-kind-"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(kind)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(kind)) : strConcat(__recv, intToString(kind)); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupKindName = lintAstdupKindName;

const __tuff_outer_for_lintAstdupLoc = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupLoc(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_lintAstdupLoc };
  return (() => { const __recv = (() => { const __recv = sourcemapLookup(nodeGetLine(n)); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetCol(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetCol(n))) : strConcat(__recv, intToString(nodeGetCol(n))); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupLoc = lintAstdupLoc;

const __tuff_outer_for_lintAstdupPreview = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupPreview(fp) {
  let __tuff_this = { fp: fp, this: __tuff_outer_for_lintAstdupPreview };
  let maxLen = 120; if (typeof __tuff_this !== 'undefined') __tuff_this.maxLen = maxLen;
  if (((() => { const __recv = fp; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() <= maxLen)) {
  return fp;
}
  return (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, maxLen); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, maxLen) : strSliceWindow(__recv, 0, maxLen); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("..."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "...") : strConcat(__recv, "..."); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupPreview = lintAstdupPreview;

const __tuff_outer_for_lintAstdupReportableKind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupReportableKind(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_lintAstdupReportableKind };
  return (((((((((((((((((((((kind === NK_BLOCK) || (kind === NK_IF_STMT)) || (kind === NK_WHILE_STMT)) || (kind === NK_FOR_STMT)) || (kind === NK_LOOP_STMT)) || (kind === NK_ASSIGN_STMT)) || (kind === NK_EXPR_STMT)) || (kind === NK_RETURN_STMT)) || (kind === NK_BINARY_EXPR)) || (kind === NK_UNARY_EXPR)) || (kind === NK_CALL_EXPR)) || (kind === NK_MEMBER_EXPR)) || (kind === NK_INDEX_EXPR)) || (kind === NK_STRUCT_INIT)) || (kind === NK_IF_EXPR)) || (kind === NK_MATCH_EXPR)) || (kind === NK_IS_EXPR)) || (kind === NK_UNWRAP_EXPR)) || (kind === NK_TUPLE_EXPR)) || (kind === NK_LAMBDA_EXPR)) || (kind === NK_FN_EXPR));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupReportableKind = lintAstdupReportableKind;

const __tuff_outer_for_lintAstdupVecFp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupVecFp(vecNodes, fpCache, sizeCache, seenNodes) {
  let __tuff_this = { vecNodes: vecNodes, fpCache: fpCache, sizeCache: sizeCache, seenNodes: seenNodes, this: __tuff_outer_for_lintAstdupVecFp };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let acc = "["; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  let __len19 = (() => { const __recv = vecNodes; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len19 = __len19;
  while ((i < __len19)) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp((() => { const __recv = vecNodes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp((() => { const __recv = vecNodes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp((() => { const __recv = vecNodes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), fpCache, sizeCache, seenNodes)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((i + 1) < (() => { const __recv = vecNodes; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ",") : strConcat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "]") : strConcat(__recv, "]"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupVecFp = lintAstdupVecFp;

const __tuff_outer_for_lintAstdupVecSize = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupVecSize(vecNodes, sizeCache) {
  let __tuff_this = { vecNodes: vecNodes, sizeCache: sizeCache, this: __tuff_outer_for_lintAstdupVecSize };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  let __len18 = (() => { const __recv = vecNodes; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len18 = __len18;
  while ((i < __len18)) {
  let node = (() => { const __recv = vecNodes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  if (((node !== 0) && (() => { const __recv = sizeCache; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(node); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, node) : mapHas(__recv, node); })())) {
  total = (total + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(node); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, node) : mapGet(__recv, node); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return total;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupVecSize = lintAstdupVecSize;

const __tuff_outer_for_lintAstdupParamsFp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupParamsFp(params, fpCache, sizeCache, seenNodes) {
  let __tuff_this = { params: params, fpCache: fpCache, sizeCache: sizeCache, seenNodes: seenNodes, this: __tuff_outer_for_lintAstdupParamsFp };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let acc = "("; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  let __len17 = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len17 = __len17;
  while ((i < __len17)) {
  let p = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let ptype = (() => { const __recv = p; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  acc = (() => { const __recv = (() => { const __recv = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("{p:ID:t:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "{p:ID:t:") : strConcat(__recv, "{p:ID:t:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(ptype, fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(ptype, fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(ptype, fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "}") : strConcat(__recv, "}"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((i + 1) < (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ",") : strConcat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupParamsFp = lintAstdupParamsFp;

const __tuff_outer_for_lintAstdupParamsSize = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupParamsSize(params, sizeCache) {
  let __tuff_this = { params: params, sizeCache: sizeCache, this: __tuff_outer_for_lintAstdupParamsSize };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  let __len16 = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len16 = __len16;
  while ((i < __len16)) {
  let p = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let ptype = (() => { const __recv = p; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (((ptype !== 0) && (() => { const __recv = sizeCache; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, ptype) : mapHas(__recv, ptype); })())) {
  total = (total + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, ptype) : mapGet(__recv, ptype); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return total;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupParamsSize = lintAstdupParamsSize;

const __tuff_outer_for_lintAstdupNamedTypeFieldsFp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupNamedTypeFieldsFp(fields, fpCache, sizeCache, seenNodes) {
  let __tuff_this = { fields: fields, fpCache: fpCache, sizeCache: sizeCache, seenNodes: seenNodes, this: __tuff_outer_for_lintAstdupNamedTypeFieldsFp };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let acc = "{"; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  let __len15 = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len15 = __len15;
  while ((i < __len15)) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  acc = (() => { const __recv = (() => { const __recv = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("{n:ID:t:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "{n:ID:t:") : strConcat(__recv, "{n:ID:t:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "}") : strConcat(__recv, "}"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((i + 1) < (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ",") : strConcat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "}") : strConcat(__recv, "}"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupNamedTypeFieldsFp = lintAstdupNamedTypeFieldsFp;

const __tuff_outer_for_lintAstdupNamedTypeFieldsSize = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupNamedTypeFieldsSize(fields, sizeCache) {
  let __tuff_this = { fields: fields, sizeCache: sizeCache, this: __tuff_outer_for_lintAstdupNamedTypeFieldsSize };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  let __len14 = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len14 = __len14;
  while ((i < __len14)) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  let t = (() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  if (((t !== 0) && (() => { const __recv = sizeCache; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(t); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, t) : mapHas(__recv, t); })())) {
  total = (total + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(t); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, t) : mapGet(__recv, t); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return total;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupNamedTypeFieldsSize = lintAstdupNamedTypeFieldsSize;

const __tuff_outer_for_lintAstdupStructInitFieldsFp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupStructInitFieldsFp(fields, fpCache, sizeCache, seenNodes) {
  let __tuff_this = { fields: fields, fpCache: fpCache, sizeCache: sizeCache, seenNodes: seenNodes, this: __tuff_outer_for_lintAstdupStructInitFieldsFp };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let acc = "{"; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  let __len13 = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len13 = __len13;
  while ((i < __len13)) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  acc = (() => { const __recv = (() => { const __recv = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("{n:ID:v:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "{n:ID:v:") : strConcat(__recv, "{n:ID:v:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "}") : strConcat(__recv, "}"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((i + 1) < (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ",") : strConcat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "}") : strConcat(__recv, "}"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupStructInitFieldsFp = lintAstdupStructInitFieldsFp;

const __tuff_outer_for_lintAstdupStructInitFieldsSize = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupStructInitFieldsSize(fields, sizeCache) {
  let __tuff_this = { fields: fields, sizeCache: sizeCache, this: __tuff_outer_for_lintAstdupStructInitFieldsSize };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  let __len12 = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len12 = __len12;
  while ((i < __len12)) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  let v = (() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.v = v;
  if (((v !== 0) && (() => { const __recv = sizeCache; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, v) : mapHas(__recv, v); })())) {
  total = (total + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(v); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, v) : mapGet(__recv, v); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return total;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupStructInitFieldsSize = lintAstdupStructInitFieldsSize;

const __tuff_outer_for_lintAstdupCasesFp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupCasesFp(cases, fpCache, sizeCache, seenNodes) {
  let __tuff_this = { cases: cases, fpCache: fpCache, sizeCache: sizeCache, seenNodes: seenNodes, this: __tuff_outer_for_lintAstdupCasesFp };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let acc = "["; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  let __len11 = (() => { const __recv = cases; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len11 = __len11;
  while ((i < __len11)) {
  let c = (() => { const __recv = cases; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.c = c;
  acc = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("{p:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "{p:") : strConcat(__recv, "{p:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp((() => { const __recv = c; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp((() => { const __recv = c; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp((() => { const __recv = c; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":b:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":b:") : strConcat(__recv, ":b:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp((() => { const __recv = c; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp((() => { const __recv = c; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp((() => { const __recv = c; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "}") : strConcat(__recv, "}"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((i + 1) < (() => { const __recv = cases; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ",") : strConcat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "]") : strConcat(__recv, "]"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupCasesFp = lintAstdupCasesFp;

const __tuff_outer_for_lintAstdupCasesSize = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupCasesSize(cases, sizeCache) {
  let __tuff_this = { cases: cases, sizeCache: sizeCache, this: __tuff_outer_for_lintAstdupCasesSize };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  let __len10 = (() => { const __recv = cases; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len10 = __len10;
  while ((i < __len10)) {
  let c = (() => { const __recv = cases; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.c = c;
  let p = (() => { const __recv = c; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  let b = (() => { const __recv = c; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.b = b;
  if (((p !== 0) && (() => { const __recv = sizeCache; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(p); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, p) : mapHas(__recv, p); })())) {
  total = (total + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(p); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, p) : mapGet(__recv, p); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  if (((b !== 0) && (() => { const __recv = sizeCache; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(b); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, b) : mapHas(__recv, b); })())) {
  total = (total + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(b); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, b) : mapGet(__recv, b); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return total;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupCasesSize = lintAstdupCasesSize;

const __tuff_outer_for_lintAstdupContractMethodsFp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupContractMethodsFp(methods, fpCache, sizeCache, seenNodes) {
  let __tuff_this = { methods: methods, fpCache: fpCache, sizeCache: sizeCache, seenNodes: seenNodes, this: __tuff_outer_for_lintAstdupContractMethodsFp };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let acc = "["; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  let __len9 = (() => { const __recv = methods; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len9 = __len9;
  while ((i < __len9)) {
  let m = (() => { const __recv = methods; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.m = m;
  acc = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("{m:ID:g:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "{m:ID:g:") : strConcat(__recv, "{m:ID:g:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = (() => { const __recv = m; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = (() => { const __recv = m; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = (() => { const __recv = m; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":p:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":p:") : strConcat(__recv, ":p:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupParamsFp((() => { const __recv = m; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 2) : vecGet(__recv, 2); })(), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupParamsFp((() => { const __recv = m; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 2) : vecGet(__recv, 2); })(), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupParamsFp((() => { const __recv = m; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 2) : vecGet(__recv, 2); })(), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":r:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":r:") : strConcat(__recv, ":r:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp((() => { const __recv = m; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(3); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 3) : vecGet(__recv, 3); })(), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp((() => { const __recv = m; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(3); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 3) : vecGet(__recv, 3); })(), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp((() => { const __recv = m; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(3); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 3) : vecGet(__recv, 3); })(), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("}"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "}") : strConcat(__recv, "}"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((i + 1) < (() => { const __recv = methods; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ",") : strConcat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "]") : strConcat(__recv, "]"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupContractMethodsFp = lintAstdupContractMethodsFp;

const __tuff_outer_for_lintAstdupContractMethodsSize = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupContractMethodsSize(methods, sizeCache) {
  let __tuff_this = { methods: methods, sizeCache: sizeCache, this: __tuff_outer_for_lintAstdupContractMethodsSize };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let total = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  let __len8 = (() => { const __recv = methods; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len8 = __len8;
  while ((i < __len8)) {
  let m = (() => { const __recv = methods; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.m = m;
  total = (total + lintAstdupParamsSize((() => { const __recv = m; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(2); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 2) : vecGet(__recv, 2); })(), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
  let ret = (() => { const __recv = m; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(3); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 3) : vecGet(__recv, 3); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
  if (((ret !== 0) && (() => { const __recv = sizeCache; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(ret); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, ret) : mapHas(__recv, ret); })())) {
  total = (total + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(ret); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, ret) : mapGet(__recv, ret); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.total = total;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return total;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupContractMethodsSize = lintAstdupContractMethodsSize;

const __tuff_outer_for_lintAstdupFp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupFp(n, fpCache, sizeCache, seenNodes) {
  let __tuff_this = { n: n, fpCache: fpCache, sizeCache: sizeCache, seenNodes: seenNodes, this: __tuff_outer_for_lintAstdupFp };
  if ((n === 0)) {
  return "0";
}
  if ((() => { const __recv = fpCache; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, n) : mapHas(__recv, n); })()) {
  return (() => { const __recv = fpCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, n) : mapGet(__recv, n); })();
}
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  let fp = (() => { const __recv = "K"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(kind)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(kind)) : strConcat(__recv, intToString(kind)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  let size = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  if ((((kind === NK_IDENTIFIER) || (kind === NK_NAME_PAT)) || (kind === NK_NAMED_TYPE))) {
  fp = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(ID)"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(ID)") : strConcat(__recv, "(ID)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if (((((kind === NK_NUMBER_LIT) || (kind === NK_STRING_LIT)) || (kind === NK_CHAR_LIT)) || (kind === NK_LITERAL_PAT))) {
  fp = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(LIT)"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(LIT)") : strConcat(__recv, "(LIT)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if ((kind === NK_BOOL_LIT)) {
  fp = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(BOOL)"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(BOOL)") : strConcat(__recv, "(BOOL)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if ((((kind === NK_WILDCARD_PAT) || (kind === NK_BREAK_STMT)) || (kind === NK_CONTINUE_STMT))) {
  fp = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("()"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "()") : strConcat(__recv, "()"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if ((kind === NK_UNARY_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_UNWRAP_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : mapGet(__recv, nodeGetData1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_BINARY_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(n))) : strConcat(__recv, getInternedStr(nodeGetData1(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = ((size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()) + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData3(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData3(n)) : mapGet(__recv, nodeGetData3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_CALL_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(callee:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(callee:") : strConcat(__recv, "(callee:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":args:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":args:") : strConcat(__recv, ":args:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupVecFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupVecFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupVecFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":style:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":style:") : strConcat(__recv, ":style:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetData3(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetData3(n))) : strConcat(__recv, intToString(nodeGetData3(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":targs:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":targs:") : strConcat(__recv, ":targs:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupVecFp(nodeGetData4(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupVecFp(nodeGetData4(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupVecFp(nodeGetData4(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : mapGet(__recv, nodeGetData1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + lintAstdupVecSize(nodeGetData2(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + lintAstdupVecSize(nodeGetData4(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_MEMBER_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(obj:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(obj:") : strConcat(__recv, "(obj:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":member:ID)"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":member:ID)") : strConcat(__recv, ":member:ID)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : mapGet(__recv, nodeGetData1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_INDEX_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(target:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(target:") : strConcat(__recv, "(target:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":index:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":index:") : strConcat(__recv, ":index:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = ((size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : mapGet(__recv, nodeGetData1(n)); })()) + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_STRUCT_INIT)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:fields:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:fields:") : strConcat(__recv, "(name:ID:fields:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupStructInitFieldsFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupStructInitFieldsFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupStructInitFieldsFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":targs:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":targs:") : strConcat(__recv, ":targs:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupVecFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupVecFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupVecFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lintAstdupStructInitFieldsSize(nodeGetData2(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + lintAstdupVecSize(nodeGetData3(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if (((kind === NK_IF_EXPR) || (kind === NK_IF_STMT))) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(c:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(c:") : strConcat(__recv, "(c:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":t:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":t:") : strConcat(__recv, ":t:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":e:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":e:") : strConcat(__recv, ":e:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : mapGet(__recv, nodeGetData1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  if ((nodeGetData3(n) !== 0)) {
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData3(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData3(n)) : mapGet(__recv, nodeGetData3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
} else { if ((kind === NK_MATCH_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(target:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(target:") : strConcat(__recv, "(target:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":cases:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":cases:") : strConcat(__recv, ":cases:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupCasesFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupCasesFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupCasesFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : mapGet(__recv, nodeGetData1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + lintAstdupCasesSize(nodeGetData2(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_IS_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(subject:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(subject:") : strConcat(__recv, "(subject:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":pat:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":pat:") : strConcat(__recv, ":pat:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = ((size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : mapGet(__recv, nodeGetData1(n)); })()) + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((((((kind === NK_TUPLE_EXPR) || (kind === NK_TUPLE_TYPE)) || (kind === NK_BLOCK)) || (kind === NK_STMT_LIST)) || (kind === NK_PROGRAM))) {
  fp = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupVecFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupVecFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupVecFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lintAstdupVecSize(nodeGetData1(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_FN_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:g:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:g:") : strConcat(__recv, "(name:ID:g:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":p:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":p:") : strConcat(__recv, ":p:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupParamsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupParamsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupParamsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":r:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":r:") : strConcat(__recv, ":r:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData4(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData4(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData4(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":b:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":b:") : strConcat(__recv, ":b:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData5(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData5(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData5(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lintAstdupParamsSize(nodeGetData3(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  if ((nodeGetData4(n) !== 0)) {
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData4(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData4(n)) : mapGet(__recv, nodeGetData4(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData5(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData5(n)) : mapGet(__recv, nodeGetData5(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_LAMBDA_EXPR)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(p:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(p:") : strConcat(__recv, "(p:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupParamsFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupParamsFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupParamsFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":b:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":b:") : strConcat(__recv, ":b:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lintAstdupParamsSize(nodeGetData1(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if (((((kind === NK_FN_DECL) || (kind === NK_CLASS_FN_DECL)) || (kind === NK_ACTUAL_FN_DECL)) || (kind === NK_EXPECT_FN_DECL))) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:g:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:g:") : strConcat(__recv, "(name:ID:g:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":p:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":p:") : strConcat(__recv, ":p:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupParamsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupParamsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupParamsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":r:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":r:") : strConcat(__recv, ":r:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData4(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData4(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData4(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":b:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":b:") : strConcat(__recv, ":b:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData5(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData5(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData5(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lintAstdupParamsSize(nodeGetData3(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  if ((nodeGetData4(n) !== 0)) {
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData4(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData4(n)) : mapGet(__recv, nodeGetData4(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
  if ((nodeGetData5(n) !== 0)) {
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData5(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData5(n)) : mapGet(__recv, nodeGetData5(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
} else { if (((kind === NK_LET_DECL) || (kind === NK_EXTERN_LET_DECL))) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:t:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:t:") : strConcat(__recv, "(name:ID:t:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":v:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":v:") : strConcat(__recv, ":v:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  if ((nodeGetData2(n) !== 0)) {
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
  if ((nodeGetData3(n) !== 0)) {
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData3(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData3(n)) : mapGet(__recv, nodeGetData3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
} else { if ((kind === NK_FOR_STMT)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(iter:ID:s:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(iter:ID:s:") : strConcat(__recv, "(iter:ID:s:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":e:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":e:") : strConcat(__recv, ":e:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":b:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":b:") : strConcat(__recv, ":b:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData4(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData4(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData4(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData3(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData3(n)) : mapGet(__recv, nodeGetData3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData4(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData4(n)) : mapGet(__recv, nodeGetData4(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if (((((kind === NK_WHILE_STMT) || (kind === NK_LOOP_STMT)) || (kind === NK_RETURN_STMT)) || (kind === NK_EXPR_STMT))) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  if ((nodeGetData1(n) !== 0)) {
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : mapGet(__recv, nodeGetData1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
} else { if ((kind === NK_ASSIGN_STMT)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(t:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(t:") : strConcat(__recv, "(t:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":v:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":v:") : strConcat(__recv, ":v:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = ((size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : mapGet(__recv, nodeGetData1(n)); })()) + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_LIFETIME_STMT)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(names:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(names:") : strConcat(__recv, "(names:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = nodeGetData1(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = nodeGetData1(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = nodeGetData1(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":b:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":b:") : strConcat(__recv, ":b:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_POINTER_TYPE)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(mut:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(mut:") : strConcat(__recv, "(mut:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetData1(n))) : strConcat(__recv, intToString(nodeGetData1(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":inner:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":inner:") : strConcat(__recv, ":inner:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":move:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":move:") : strConcat(__recv, ":move:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetData3(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetData3(n))) : strConcat(__recv, intToString(nodeGetData3(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":life:ID)"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":life:ID)") : strConcat(__recv, ":life:ID)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_ARRAY_TYPE)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(e:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(e:") : strConcat(__recv, "(e:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":i:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":i:") : strConcat(__recv, ":i:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":t:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":t:") : strConcat(__recv, ":t:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : mapGet(__recv, nodeGetData1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  if ((nodeGetData2(n) !== 0)) {
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
  if ((nodeGetData3(n) !== 0)) {
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData3(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData3(n)) : mapGet(__recv, nodeGetData3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
}
} else { if ((kind === NK_REFINEMENT_TYPE)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(b:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(b:") : strConcat(__recv, "(b:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":op:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":op:") : strConcat(__recv, ":op:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData2(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData2(n))) : strConcat(__recv, getInternedStr(nodeGetData2(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":v:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":v:") : strConcat(__recv, ":v:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : mapGet(__recv, nodeGetData1(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData3(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData3(n)) : mapGet(__recv, nodeGetData3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_UNION_TYPE)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(l:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(l:") : strConcat(__recv, "(l:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":r:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":r:") : strConcat(__recv, ":r:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":x:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":x:") : strConcat(__recv, ":x:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetData3(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetData3(n))) : strConcat(__recv, intToString(nodeGetData3(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = ((size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : mapGet(__recv, nodeGetData1(n)); })()) + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_FUNCTION_TYPE)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(p:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(p:") : strConcat(__recv, "(p:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupVecFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupVecFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupVecFp(nodeGetData1(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":r:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":r:") : strConcat(__recv, ":r:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lintAstdupVecSize(nodeGetData1(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : mapGet(__recv, nodeGetData2(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_APPLIED_TYPE)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:args:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:args:") : strConcat(__recv, "(name:ID:args:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupVecFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupVecFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupVecFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lintAstdupVecSize(nodeGetData2(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if (((kind === NK_IMPORT_DECL) || (kind === NK_EXTERN_IMPORT_DECL))) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(names:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(names:") : strConcat(__recv, "(names:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = nodeGetData1(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = nodeGetData1(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = nodeGetData1(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":parts:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":parts:") : strConcat(__recv, ":parts:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if ((kind === NK_STRUCT_DECL)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:g:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:g:") : strConcat(__recv, "(name:ID:g:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":f:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":f:") : strConcat(__recv, ":f:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupNamedTypeFieldsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupNamedTypeFieldsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupNamedTypeFieldsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":copy:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":copy:") : strConcat(__recv, ":copy:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetData4(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetData4(n))) : strConcat(__recv, intToString(nodeGetData4(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lintAstdupNamedTypeFieldsSize(nodeGetData3(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_OBJECT_DECL)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:g:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:g:") : strConcat(__recv, "(name:ID:g:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":in:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":in:") : strConcat(__recv, ":in:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupNamedTypeFieldsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupNamedTypeFieldsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupNamedTypeFieldsFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lintAstdupNamedTypeFieldsSize(nodeGetData3(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_CONTRACT_DECL)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:m:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:m:") : strConcat(__recv, "(name:ID:m:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupContractMethodsFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupContractMethodsFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupContractMethodsFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lintAstdupContractMethodsSize(nodeGetData2(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_ENUM_DECL)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:v:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:v:") : strConcat(__recv, "(name:ID:v:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if ((kind === NK_TYPE_ALIAS)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:g:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:g:") : strConcat(__recv, "(name:ID:g:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":a:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":a:") : strConcat(__recv, ":a:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":copy:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":copy:") : strConcat(__recv, ":copy:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetData4(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetData4(n))) : strConcat(__recv, intToString(nodeGetData4(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":d:ID)"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":d:ID)") : strConcat(__recv, ":d:ID)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData3(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData3(n)) : mapGet(__recv, nodeGetData3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_DEP_TYPE_ALIAS)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:p:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:p:") : strConcat(__recv, "(name:ID:p:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupParamsFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupParamsFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupParamsFp(nodeGetData2(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":a:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":a:") : strConcat(__recv, ":a:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)) : strConcat(__recv, lintAstdupFp(nodeGetData3(n), fpCache, sizeCache, seenNodes)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":copy:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":copy:") : strConcat(__recv, ":copy:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetData4(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetData4(n))) : strConcat(__recv, intToString(nodeGetData4(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":d:ID)"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":d:ID)") : strConcat(__recv, ":d:ID)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  size = (size + lintAstdupParamsSize(nodeGetData2(n), sizeCache)); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  size = (size + (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(nodeGetData3(n)); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, nodeGetData3(n)) : mapGet(__recv, nodeGetData3(n)); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
} else { if ((kind === NK_EXTERN_TYPE_DECL)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:g:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:g:") : strConcat(__recv, "(name:ID:g:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":d:ID)"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":d:ID)") : strConcat(__recv, ":d:ID)"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else { if ((kind === NK_STRUCT_PAT)) {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(name:ID:fields:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(name:ID:fields:") : strConcat(__recv, "(name:ID:fields:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = nodeGetData2(n); const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })())); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} else {
  fp = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = fp; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("(d1:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(d1:") : strConcat(__recv, "(d1:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetData1(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetData1(n))) : strConcat(__recv, intToString(nodeGetData1(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":d2:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":d2:") : strConcat(__recv, ":d2:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetData2(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetData2(n))) : strConcat(__recv, intToString(nodeGetData2(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":d3:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":d3:") : strConcat(__recv, ":d3:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetData3(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetData3(n))) : strConcat(__recv, intToString(nodeGetData3(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":d4:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":d4:") : strConcat(__recv, ":d4:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetData4(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetData4(n))) : strConcat(__recv, intToString(nodeGetData4(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":d5:"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":d5:") : strConcat(__recv, ":d5:"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(nodeGetData5(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(nodeGetData5(n))) : strConcat(__recv, intToString(nodeGetData5(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
} } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }
  (() => { const __recv = fpCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(n, fp); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, n, fp) : mapSet(__recv, n, fp); })();
  (() => { const __recv = sizeCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(n, size); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, n, size) : mapSet(__recv, n, size); })();
  (() => { const __recv = seenNodes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, n) : vecPush(__recv, n); })();
  return fp;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupFp = lintAstdupFp;

const __tuff_outer_for_lintAstdupNormLeafKind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupNormLeafKind(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_lintAstdupNormLeafKind };
  if ((((kind === NK_IDENTIFIER) || (kind === NK_NAME_PAT)) || (kind === NK_NAMED_TYPE))) {
  return "ID";
}
  if (((((kind === NK_NUMBER_LIT) || (kind === NK_STRING_LIT)) || (kind === NK_CHAR_LIT)) || (kind === NK_LITERAL_PAT))) {
  return "LIT";
}
  if ((kind === NK_BOOL_LIT)) {
  return "BOOL";
}
  return intToString(kind);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupNormLeafKind = lintAstdupNormLeafKind;

const __tuff_outer_for_lintAstdupFallbackBinary = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintAstdupFallbackBinary(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_lintAstdupFallbackBinary };
  let body = nodeGetData1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let stack = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.stack = stack;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len7 = (() => { const __recv = body; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len7 = __len7;
  while ((i < __len7)) {
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()) : vecPush(__recv, (() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let keys = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.keys = keys;
  let counts = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.counts = counts;
  let firstNodes = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.firstNodes = firstNodes;
  let secondNodes = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.secondNodes = secondNodes;
  while (((() => { const __recv = stack; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > 0)) {
  let n = (() => { const __recv = stack; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(((() => { const __recv = stack; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() - 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, ((() => { const __recv = stack; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() - 1)) : vecGet(__recv, ((() => { const __recv = stack; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() - 1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  (() => { const __recv = stack; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })();
  if ((n === 0)) {
  continue;
}
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_BINARY_EXPR)) {
  let op = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let leftKind = lintAstdupNormLeafKind(nodeKind(nodeGetData2(n))); if (typeof __tuff_this !== 'undefined') __tuff_this.leftKind = leftKind;
  let rightKind = lintAstdupNormLeafKind(nodeKind(nodeGetData3(n))); if (typeof __tuff_this !== 'undefined') __tuff_this.rightKind = rightKind;
  let key = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = op; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(leftKind); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, leftKind) : strConcat(__recv, leftKind); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(":"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ":") : strConcat(__recv, ":"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(rightKind); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, rightKind) : strConcat(__recv, rightKind); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  let found = (-1); if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  let k = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  let __len6 = (() => { const __recv = keys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len6 = __len6;
  while ((k < __len6)) {
  if ((() => { const __recv = (() => { const __recv = keys; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, k) : vecGet(__recv, k); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(key); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, key) : strEq(__recv, key); })()) {
  found = k; if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  break;
}
  k = (k + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
}
  if ((found === (-1))) {
  (() => { const __recv = keys; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(key); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, key) : vecPush(__recv, key); })();
  (() => { const __recv = counts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 1) : vecPush(__recv, 1); })();
  (() => { const __recv = firstNodes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, n) : vecPush(__recv, n); })();
  (() => { const __recv = secondNodes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
} else {
  let nextCount = ((() => { const __recv = counts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(found); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, found) : vecGet(__recv, found); })() + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nextCount = nextCount;
  (() => { const __recv = counts; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(found, nextCount); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, found, nextCount) : vecSet(__recv, found, nextCount); })();
  if (((() => { const __recv = secondNodes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(found); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, found) : vecGet(__recv, found); })() === 0)) {
  (() => { const __recv = secondNodes; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(found, n); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, found, n) : vecSet(__recv, found, n); })();
}
}
}
  if ((((((kind === NK_PROGRAM) || (kind === NK_BLOCK)) || (kind === NK_STMT_LIST)) || (kind === NK_TUPLE_EXPR)) || (kind === NK_TUPLE_TYPE))) {
  let items = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let __len5 = (() => { const __recv = items; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len5 = __len5;
  while ((j < __len5)) {
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = items; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = items; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()) : vecPush(__recv, (() => { const __recv = items; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  continue;
}
  if ((((((kind === NK_LET_DECL) || (kind === NK_ASSIGN_STMT)) || (kind === NK_BINARY_EXPR)) || (kind === NK_INDEX_EXPR)) || (kind === NK_IS_EXPR))) {
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : vecPush(__recv, nodeGetData1(n)); })();
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : vecPush(__recv, nodeGetData2(n)); })();
  if (((kind === NK_LET_DECL) || (kind === NK_BINARY_EXPR))) {
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(nodeGetData3(n)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, nodeGetData3(n)) : vecPush(__recv, nodeGetData3(n)); })();
}
  continue;
}
  if ((((((((kind === NK_EXPR_STMT) || (kind === NK_RETURN_STMT)) || (kind === NK_WHILE_STMT)) || (kind === NK_LOOP_STMT)) || (kind === NK_UNARY_EXPR)) || (kind === NK_UNWRAP_EXPR)) || (kind === NK_MEMBER_EXPR))) {
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : vecPush(__recv, nodeGetData1(n)); })();
  if (((kind === NK_UNARY_EXPR) || (kind === NK_UNWRAP_EXPR))) {
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : vecPush(__recv, nodeGetData2(n)); })();
}
  continue;
}
  if (((kind === NK_IF_STMT) || (kind === NK_IF_EXPR))) {
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : vecPush(__recv, nodeGetData1(n)); })();
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : vecPush(__recv, nodeGetData2(n)); })();
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(nodeGetData3(n)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, nodeGetData3(n)) : vecPush(__recv, nodeGetData3(n)); })();
  continue;
}
  if ((kind === NK_FOR_STMT)) {
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(nodeGetData2(n)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, nodeGetData2(n)) : vecPush(__recv, nodeGetData2(n)); })();
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(nodeGetData3(n)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, nodeGetData3(n)) : vecPush(__recv, nodeGetData3(n)); })();
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(nodeGetData4(n)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, nodeGetData4(n)) : vecPush(__recv, nodeGetData4(n)); })();
  continue;
}
  if ((kind === NK_CALL_EXPR)) {
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(nodeGetData1(n)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, nodeGetData1(n)) : vecPush(__recv, nodeGetData1(n)); })();
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let a = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.a = a;
  let __len4 = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len4 = __len4;
  while ((a < __len4)) {
  (() => { const __recv = stack; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(a); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, a) : vecGet(__recv, a); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(a); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, a) : vecGet(__recv, a); })()) : vecPush(__recv, (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(a); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, a) : vecGet(__recv, a); })()); })();
  a = (a + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.a = a;
}
}
}
  let emitted = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.emitted = emitted;
  let k = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  while (((k < (() => { const __recv = keys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })()) && (emitted < 5))) {
  let count = (() => { const __recv = counts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, k) : vecGet(__recv, k); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  if ((count >= 3)) {
  let key = (() => { const __recv = keys; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, k) : vecGet(__recv, k); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  let first = (() => { const __recv = firstNodes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, k) : vecGet(__recv, k); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.first = first;
  let second = (() => { const __recv = secondNodes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(k); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, k) : vecGet(__recv, k); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.second = second;
  let firstLoc = lintAstdupLoc(first); if (typeof __tuff_this !== 'undefined') __tuff_this.firstLoc = firstLoc;
  let secondLoc = "unknown"; if (typeof __tuff_this !== 'undefined') __tuff_this.secondLoc = secondLoc;
  if ((second !== 0)) {
  secondLoc = lintAstdupLoc(second); if (typeof __tuff_this !== 'undefined') __tuff_this.secondLoc = secondLoc;
}
  lintAddIssue("E_LINT_AST_DUPLICATE_SUBTREE", (() => { const __recv = (() => { const __recv = "Duplicate AST subtree detected (binary-expr) with "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(count)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(count)) : strConcat(__recv, intToString(count)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" occurrences"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " occurrences") : strConcat(__recv, " occurrences"); })(), (() => { const __recv = (() => { const __recv = "Normalized shape '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(key); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, key) : strConcat(__recv, key); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' repeats (identifier/literal values normalized), indicating copy-paste structure that is likely extractable."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' repeats (identifier/literal values normalized), indicating copy-paste structure that is likely extractable.") : strConcat(__recv, "' repeats (identifier/literal values normalized), indicating copy-paste structure that is likely extractable."); })(), (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Consider extracting the repeated expression shape into a helper/local binding. Example locations: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(firstLoc); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, firstLoc) : strConcat(__recv, firstLoc); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" and "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " and ") : strConcat(__recv, " and "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(secondLoc); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, secondLoc) : strConcat(__recv, secondLoc); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })());
  emitted = (emitted + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.emitted = emitted;
}
  k = (k + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstdupFallbackBinary = lintAstdupFallbackBinary;

const __tuff_outer_for_lintCheckAstDuplicates = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintCheckAstDuplicates(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_lintCheckAstDuplicates };
  let fpCache = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fpCache = fpCache;
  let sizeCache = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sizeCache = sizeCache;
  let seenNodes = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.seenNodes = seenNodes;
  let body = nodeGetData1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let scanI = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.scanI = scanI;
  let __len3 = (() => { const __recv = body; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len3 = __len3;
  while ((scanI < __len3)) {
  lintAstdupFp((() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(scanI); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, scanI) : vecGet(__recv, scanI); })(), fpCache, sizeCache, seenNodes);
  scanI = (scanI + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.scanI = scanI;
}
  let keys = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.keys = keys;
  let buckets = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.buckets = buckets;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len2 = (() => { const __recv = seenNodes; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len2 = __len2;
  while ((i < __len2)) {
  let n = (() => { const __recv = seenNodes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  let size = (() => { const __recv = sizeCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, n) : mapGet(__recv, n); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.size = size;
  if (((size >= 6) && lintAstdupReportableKind(kind))) {
  let fp = (() => { const __recv = fpCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, n) : mapGet(__recv, n); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  let found = (-1); if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let __len1 = (() => { const __recv = keys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len1 = __len1;
  while ((j < __len1)) {
  if ((() => { const __recv = (() => { const __recv = keys; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(fp); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, fp) : strEq(__recv, fp); })()) {
  found = j; if (typeof __tuff_this !== 'undefined') __tuff_this.found = found;
  break;
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  if ((found === (-1))) {
  (() => { const __recv = keys; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(fp); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, fp) : vecPush(__recv, fp); })();
  let bucket = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.bucket = bucket;
  (() => { const __recv = bucket; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, n) : vecPush(__recv, n); })();
  (() => { const __recv = buckets; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(bucket); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, bucket) : vecPush(__recv, bucket); })();
} else {
  let bucket = (() => { const __recv = buckets; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(found); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, found) : vecGet(__recv, found); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.bucket = bucket;
  (() => { const __recv = bucket; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(n); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, n) : vecPush(__recv, n); })();
  (() => { const __recv = buckets; const __prop = __recv?.["vecSet"]; if (typeof __prop === "function") return __prop(found, bucket); const __dyn = __recv?.table?.vecSet; return __dyn ? __dyn(__recv.ref, found, bucket) : vecSet(__recv, found, bucket); })();
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len = (() => { const __recv = keys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len = __len;
  while ((i < __len)) {
  let fp = (() => { const __recv = keys; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fp = fp;
  let bucket = (() => { const __recv = buckets; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.bucket = bucket;
  if (((() => { const __recv = bucket; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > 1)) {
  let first = (() => { const __recv = bucket; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.first = first;
  let second = (() => { const __recv = bucket; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.second = second;
  let kindName = lintAstdupKindName(nodeKind(first)); if (typeof __tuff_this !== 'undefined') __tuff_this.kindName = kindName;
  let count = (() => { const __recv = bucket; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  let firstLoc = lintAstdupLoc(first); if (typeof __tuff_this !== 'undefined') __tuff_this.firstLoc = firstLoc;
  let secondLoc = lintAstdupLoc(second); if (typeof __tuff_this !== 'undefined') __tuff_this.secondLoc = secondLoc;
  let shape = lintAstdupPreview(fp); if (typeof __tuff_this !== 'undefined') __tuff_this.shape = shape;
  lintAddIssue("E_LINT_AST_DUPLICATE_SUBTREE", (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Duplicate AST subtree detected ("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(kindName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, kindName) : strConcat(__recv, kindName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") with "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") with ") : strConcat(__recv, ") with "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(count)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(count)) : strConcat(__recv, intToString(count)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" occurrences"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " occurrences") : strConcat(__recv, " occurrences"); })(), (() => { const __recv = (() => { const __recv = "A structurally identical subtree appears multiple times (identifier/literal values normalized). Shape preview: '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(shape); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, shape) : strConcat(__recv, shape); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'.") : strConcat(__recv, "'."); })(), (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "Extract shared logic into a helper function. Example locations: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(firstLoc); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, firstLoc) : strConcat(__recv, firstLoc); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" and "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " and ") : strConcat(__recv, " and "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(secondLoc); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, secondLoc) : strConcat(__recv, secondLoc); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })());
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  lintAstdupFallbackBinary(program);
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintCheckAstDuplicates = lintCheckAstDuplicates;

const __tuff_outer_for_lintProgram = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function lintProgram(program, filePath, maxEffectiveLines, enforceFileLength, astDupEnabled) {
  let __tuff_this = { program: program, filePath: filePath, maxEffectiveLines: maxEffectiveLines, enforceFileLength: enforceFileLength, astDupEnabled: astDupEnabled, this: __tuff_outer_for_lintProgram };
  if ((enforceFileLength === 1)) {
  lintCheckFileLength(filePath, maxEffectiveLines);
}
  let receiverExternFns = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.receiverExternFns = receiverExternFns;
  let reads = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.reads = reads;
  let declaredSet = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.declaredSet = declaredSet;
  let declaredNames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.declaredNames = declaredNames;
  let body = nodeGetData1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = body; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if (lintIsExternFnDecl(stmt)) {
  let params = nodeGetData3(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  if (((() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > 0)) {
  let p0 = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p0 = p0;
  let p0name = getInternedStr((() => { const __recv = p0; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.p0name = p0name;
  if ((() => { const __recv = p0name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })()) {
  (() => { const __recv = receiverExternFns; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(stmt))); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(stmt))) : setAdd(__recv, getInternedStr(nodeGetData1(stmt))); })();
}
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let stmt = (() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  lintCheckFunctionLength(stmt, 100);
  lintCollectStmt(stmt, receiverExternFns, reads, declaredSet, declaredNames);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let dlen = (() => { const __recv = declaredNames; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dlen = dlen;
  while ((i < dlen)) {
  let name = (() => { const __recv = declaredNames; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if (((!(() => { const __recv = name; const __prop = __recv?.["strStartsWith"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.strStartsWith; return __dyn ? __dyn(__recv.ref, "_") : strStartsWith(__recv, "_"); })()) && (!(() => { const __recv = reads; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })()))) {
  lintAddIssue("E_LINT_UNUSED_BINDING", (() => { const __recv = (() => { const __recv = "Unused binding '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "Unused bindings increase cognitive load and can indicate leftover or incomplete code paths.", "Remove the binding if unused, use it intentionally, or rename it to start with '_' to mark it as intentionally unused.");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  if ((astDupEnabled === 1)) {
  lintCheckAstDuplicates(program);
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.lintProgram = lintProgram;

const __tuff_outer_for_selfhostLinterMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostLinterMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostLinterMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostLinterMarker = selfhostLinterMarker;

const __tuff_outer_for_moduleLoaderSanitizeMaxEffectiveLines = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleLoaderSanitizeMaxEffectiveLines(maxEffectiveLines) {
  let __tuff_this = { maxEffectiveLines: maxEffectiveLines, this: __tuff_outer_for_moduleLoaderSanitizeMaxEffectiveLines };
  return (((maxEffectiveLines <= 0)) ? (() => {
    return 500;
  })() : (() => {
    return maxEffectiveLines;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleLoaderSanitizeMaxEffectiveLines = moduleLoaderSanitizeMaxEffectiveLines;

const __tuff_outer_for_moduleLoaderNormalizeFlag = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleLoaderNormalizeFlag(value) {
  let __tuff_this = { value: value, this: __tuff_outer_for_moduleLoaderNormalizeFlag };
  return (((value === 0)) ? (() => {
    return 0;
  })() : (() => {
    return 1;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleLoaderNormalizeFlag = moduleLoaderNormalizeFlag;

const __tuff_outer_for_modulePartsToRelativePath = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function modulePartsToRelativePath(parts) {
  let __tuff_this = { parts: parts, this: __tuff_outer_for_modulePartsToRelativePath };
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = parts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  if ((i > 0)) {
  sbAppend(sb, "/");
}
  sbAppend(sb, getInternedStr((() => { const __recv = parts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, ".tuff");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.modulePartsToRelativePath = modulePartsToRelativePath;

const __tuff_outer_for_moduleNormalizePath = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleNormalizePath(p) {
  let __tuff_this = { p: p, this: __tuff_outer_for_moduleNormalizePath };
  return (() => { const __recv = p; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\", "/"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\", "/") : strReplaceAll(__recv, "\\", "/"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleNormalizePath = moduleNormalizePath;

const __tuff_outer_for_joinSources = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function joinSources(sources) {
  let __tuff_this = { sources: sources, this: __tuff_outer_for_joinSources };
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = sources; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  if ((i > 0)) {
  sbAppend(sb, "\n\n");
}
  sbAppend(sb, (() => { const __recv = sources; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.joinSources = joinSources;

const __tuff_outer_for_moduleWithCRuntimePrelude = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleWithCRuntimePrelude(source, target) {
  let __tuff_this = { source: source, target: target, this: __tuff_outer_for_moduleWithCRuntimePrelude };
  if (((!(() => { const __recv = target; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("c"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "c") : strEq(__recv, "c"); })()) && (!(() => { const __recv = target; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("c-split"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "c-split") : strEq(__recv, "c-split"); })()))) {
  return source;
}
  if ((() => { const __recv = source; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop("fn tuff_runtime_panic("); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, "fn tuff_runtime_panic(") : strIncludes(__recv, "fn tuff_runtime_panic("); })()) {
  return source;
}
  let prelude = __host_get_c_runtime_prelude_source(); if (typeof __tuff_this !== 'undefined') __tuff_this.prelude = prelude;
  if ((() => { const __recv = prelude; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) {
  return source;
}
  return (() => { const __recv = (() => { const __recv = source; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\n\n"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\n\n") : strConcat(__recv, "\n\n"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prelude); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prelude) : strConcat(__recv, prelude); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleWithCRuntimePrelude = moduleWithCRuntimePrelude;

const __tuff_outer_for_selfhostModuleLoaderUtilsMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostModuleLoaderUtilsMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostModuleLoaderUtilsMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostModuleLoaderUtilsMarker = selfhostModuleLoaderUtilsMarker;

let MODULE_WATCHDOG_MAX_RECURSION_DEPTH = 2048; if (typeof __tuff_this !== 'undefined') __tuff_this.MODULE_WATCHDOG_MAX_RECURSION_DEPTH = MODULE_WATCHDOG_MAX_RECURSION_DEPTH;

let MODULE_WATCHDOG_MAX_IMPORTS_PER_MODULE = 200000; if (typeof __tuff_this !== 'undefined') __tuff_this.MODULE_WATCHDOG_MAX_IMPORTS_PER_MODULE = MODULE_WATCHDOG_MAX_IMPORTS_PER_MODULE;

let MODULE_WATCHDOG_MAX_SOURCEMAP_ENTRIES = 200000; if (typeof __tuff_this !== 'undefined') __tuff_this.MODULE_WATCHDOG_MAX_SOURCEMAP_ENTRIES = MODULE_WATCHDOG_MAX_SOURCEMAP_ENTRIES;

const __tuff_outer_for_moduleEmitTargetOutput = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleEmitTargetOutput(typed, mergedSource, target) {
  let __tuff_this = { typed: typed, mergedSource: mergedSource, target: target, this: __tuff_outer_for_moduleEmitTargetOutput };
  if ((() => { const __recv = target; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("js"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "js") : strEq(__recv, "js"); })()) {
  return generateJs(typed);
}
  if ((() => { const __recv = target; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("c"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "c") : strEq(__recv, "c"); })()) {
  return generateC(typed, __host_get_c_substrate());
}
  if ((() => { const __recv = target; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("tuff"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "tuff") : strEq(__recv, "tuff"); })()) {
  return emitTuffFromTyped(typed, mergedSource, lexTakeTrivia());
}
  panicWithCode("E_UNSUPPORTED_TARGET", (() => { const __recv = "Unsupported codegen target: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, target) : strConcat(__recv, target); })(), "The compiler was asked to emit code for a target that is not implemented.", "Use target 'js', target 'c', target 'c-split', or target 'tuff'.");
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleEmitTargetOutput = moduleEmitTargetOutput;

let gatherProfModules = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfModules = gatherProfModules;

let gatherProfImportEdges = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImportEdges = gatherProfImportEdges;

let gatherProfReadFileMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfReadFileMs = gatherProfReadFileMs;

let gatherProfLexParseMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfLexParseMs = gatherProfLexParseMs;

let gatherProfDeclCollectMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfDeclCollectMs = gatherProfDeclCollectMs;

let gatherProfImportSnapshotMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImportSnapshotMs = gatherProfImportSnapshotMs;

let gatherProfImportWalkMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImportWalkMs = gatherProfImportWalkMs;

let gatherProfImportRecurseMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImportRecurseMs = gatherProfImportRecurseMs;

let gatherProfImplicitCheckMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImplicitCheckMs = gatherProfImplicitCheckMs;

const __tuff_outer_for_gatherProfReset = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function gatherProfReset() {
  let __tuff_this = { this: __tuff_outer_for_gatherProfReset };
  gatherProfModules = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfModules = gatherProfModules;
  gatherProfImportEdges = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImportEdges = gatherProfImportEdges;
  gatherProfReadFileMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfReadFileMs = gatherProfReadFileMs;
  gatherProfLexParseMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfLexParseMs = gatherProfLexParseMs;
  gatherProfDeclCollectMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfDeclCollectMs = gatherProfDeclCollectMs;
  gatherProfImportSnapshotMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImportSnapshotMs = gatherProfImportSnapshotMs;
  gatherProfImportWalkMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImportWalkMs = gatherProfImportWalkMs;
  gatherProfImportRecurseMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImportRecurseMs = gatherProfImportRecurseMs;
  gatherProfImplicitCheckMs = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImplicitCheckMs = gatherProfImplicitCheckMs;
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfReset = gatherProfReset;

const __tuff_outer_for_stripImportDecls = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function stripImportDecls(program) {
  let __tuff_this = { program: program, this: __tuff_outer_for_stripImportDecls };
  let stmts = nodeGetData1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let filtered = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.filtered = filtered;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if ((nodeKind(stmt) !== 6)) {
  (() => { const __recv = filtered; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(stmt); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, stmt) : vecPush(__recv, stmt); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  nodeSetData1(program, filtered);
  return program;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.stripImportDecls = stripImportDecls;

const __tuff_outer_for_isModuleDeclKind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function isModuleDeclKind(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_isModuleDeclKind };
  return ((((((((((kind === 2) || (kind === 16)) || (kind === 3)) || (kind === 60)) || (kind === 63)) || (kind === 65)) || (kind === 4)) || (kind === 5)) || (kind === 18)) || (kind === 19));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.isModuleDeclKind = isModuleDeclKind;

const __tuff_outer_for_moduleIsExternDecl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleIsExternDecl(stmt) {
  let __tuff_this = { stmt: stmt, this: __tuff_outer_for_moduleIsExternDecl };
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  return ((((kind === 2) && (nodeGetData5(stmt) === 0)) || (kind === 18)) || (kind === 19));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleIsExternDecl = moduleIsExternDecl;

const __tuff_outer_for_collectModuleDeclarations = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function collectModuleDeclarations(stmts) {
  let __tuff_this = { stmts: stmts, this: __tuff_outer_for_collectModuleDeclarations };
  let declared = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.declared = declared;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if (isModuleDeclKind(kind)) {
  (() => { const __recv = declared; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(getInternedStr(nodeGetData1(stmt))); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, getInternedStr(nodeGetData1(stmt))) : setAdd(__recv, getInternedStr(nodeGetData1(stmt))); })();
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return declared;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.collectModuleDeclarations = collectModuleDeclarations;

const __tuff_outer_for_moduleScopeDefine = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleScopeDefine(scopes, depth, name) {
  let __tuff_this = { scopes: scopes, depth: depth, name: name, this: __tuff_outer_for_moduleScopeDefine };
  let scope = (() => { const __recv = scopes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(depth); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, depth) : vecGet(__recv, depth); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.scope = scope;
  (() => { const __recv = scope; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, name) : setAdd(__recv, name); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleScopeDefine = moduleScopeDefine;

const __tuff_outer_for_moduleScopeHas = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleScopeHas(scopes, depth, name) {
  let __tuff_this = { scopes: scopes, depth: depth, name: name, this: __tuff_outer_for_moduleScopeHas };
  let i = depth; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i >= 0)) {
  if ((() => { const __recv = (() => { const __recv = scopes; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })()) {
  return true;
}
  i = (i - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleScopeHas = moduleScopeHas;

const __tuff_outer_for_moduleCheckExprCallLike = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleCheckExprCallLike(n, declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet) {
  let __tuff_this = { n: n, declared: declared, imported: imported, scopes: scopes, depth: depth, implicitCandidates: implicitCandidates, implicitCandidateSet: implicitCandidateSet, this: __tuff_outer_for_moduleCheckExprCallLike };
  if ((nodeKind(n) === 27)) {
  moduleCheckExprImplicitImports(nodeGetData1(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  moduleCheckExprImplicitImports((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 1;
}
  if ((nodeKind(n) === 28)) {
  moduleCheckExprImplicitImports(nodeGetData1(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  return 1;
}
  if ((nodeKind(n) === 29)) {
  moduleCheckExprImplicitImports(nodeGetData1(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  moduleCheckExprImplicitImports(nodeGetData2(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  return 1;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleCheckExprCallLike = moduleCheckExprCallLike;

const __tuff_outer_for_moduleCheckExprComposites = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleCheckExprComposites(n, declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet) {
  let __tuff_this = { n: n, declared: declared, imported: imported, scopes: scopes, depth: depth, implicitCandidates: implicitCandidates, implicitCandidateSet: implicitCandidateSet, this: __tuff_outer_for_moduleCheckExprComposites };
  if ((nodeKind(n) === 30)) {
  let fields = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let f = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.f = f;
  moduleCheckExprImplicitImports((() => { const __recv = f; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 1;
}
  if ((nodeKind(n) === 33)) {
  moduleCheckExprImplicitImports(nodeGetData1(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  return 1;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleCheckExprComposites = moduleCheckExprComposites;

const __tuff_outer_for_moduleCheckExprMatch = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleCheckExprMatch(n, declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet) {
  let __tuff_this = { n: n, declared: declared, imported: imported, scopes: scopes, depth: depth, implicitCandidates: implicitCandidates, implicitCandidateSet: implicitCandidateSet, this: __tuff_outer_for_moduleCheckExprMatch };
  if ((nodeKind(n) !== 32)) {
  return 0;
}
  moduleCheckExprImplicitImports(nodeGetData1(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  let cases = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let caseNode = (() => { const __recv = cases; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.caseNode = caseNode;
  let pat = (() => { const __recv = caseNode; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  let body = (() => { const __recv = caseNode; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let nextDepth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nextDepth = nextDepth;
  (() => { const __recv = scopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(setNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, setNew()) : vecPush(__recv, setNew()); })();
  if ((nodeKind(pat) === 53)) {
  let fields = nodeGetData2(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let fLen = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fLen = fLen;
  while ((j < fLen)) {
  moduleScopeDefine(scopes, nextDepth, getInternedStr((() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()));
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
} else { if ((nodeKind(pat) === 52)) {
  let patName = getInternedStr(nodeGetData1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.patName = patName;
  if (((!(() => { const __recv = declared; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(patName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, patName) : setHas(__recv, patName); })()) && (!(() => { const __recv = imported; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(patName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, patName) : setHas(__recv, patName); })()))) {
  moduleScopeDefine(scopes, nextDepth, patName);
}
} }
  moduleCheckStmtImplicitImports(body, declared, imported, scopes, nextDepth, implicitCandidates, implicitCandidateSet);
  (() => { const __recv = scopes; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 1;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleCheckExprMatch = moduleCheckExprMatch;

const __tuff_outer_for_moduleCollectDeclaredSets = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleCollectDeclaredSets(source, program, moduleDeclaredMap, moduleExportedMap, filePath, allDeclaredNames, allExportedDeclaredNames, allExternDeclaredNames) {
  let __tuff_this = { source: source, program: program, moduleDeclaredMap: moduleDeclaredMap, moduleExportedMap: moduleExportedMap, filePath: filePath, allDeclaredNames: allDeclaredNames, allExportedDeclaredNames: allExportedDeclaredNames, allExternDeclaredNames: allExternDeclaredNames, this: __tuff_outer_for_moduleCollectDeclaredSets };
  let stmts = nodeGetData1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let declared = collectModuleDeclarations(stmts); if (typeof __tuff_this !== 'undefined') __tuff_this.declared = declared;
  let exported = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.exported = exported;
  (() => { const __recv = moduleDeclaredMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(filePath, declared); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, filePath, declared) : mapSet(__recv, filePath, declared); })();
  (() => { const __recv = moduleExportedMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(filePath, exported); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, filePath, exported) : mapSet(__recv, filePath, exported); })();
  let di = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.di = di;
  let dlen = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dlen = dlen;
  while ((di < dlen)) {
  let dstmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(di); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, di) : vecGet(__recv, di); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dstmt = dstmt;
  let dkind = nodeKind(dstmt); if (typeof __tuff_this !== 'undefined') __tuff_this.dkind = dkind;
  if (isModuleDeclKind(dkind)) {
  let dname = getInternedStr(nodeGetData1(dstmt)); if (typeof __tuff_this !== 'undefined') __tuff_this.dname = dname;
  (() => { const __recv = allDeclaredNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(dname); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, dname) : setAdd(__recv, dname); })();
  if (moduleIsExternDecl(dstmt)) {
  (() => { const __recv = allExternDeclaredNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(dname); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, dname) : setAdd(__recv, dname); })();
}
  if ((() => { const __recv = getParseExports(); const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(dname); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, dname) : setHas(__recv, dname); })()) {
  (() => { const __recv = exported; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(dname); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, dname) : setAdd(__recv, dname); })();
  (() => { const __recv = allExportedDeclaredNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(dname); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, dname) : setAdd(__recv, dname); })();
}
}
  di = (di + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.di = di;
}
  return declared;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleCollectDeclaredSets = moduleCollectDeclaredSets;

const __tuff_outer_for_moduleSnapshotImportSpecs = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleSnapshotImportSpecs(stmts, moduleBasePath, importPathCache) {
  let __tuff_this = { stmts: stmts, moduleBasePath: moduleBasePath, importPathCache: importPathCache, this: __tuff_outer_for_moduleSnapshotImportSpecs };
  let t0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t0 = t0;
  let imports = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.imports = imports;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let stmt = (() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  if ((nodeKind(stmt) === 6)) {
  let parts = nodeGetData2(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.parts = parts;
  let rel = modulePartsToRelativePath(parts); if (typeof __tuff_this !== 'undefined') __tuff_this.rel = rel;
  let depPath = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.depPath = depPath;
  if ((() => { const __recv = importPathCache; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(rel); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, rel) : mapHas(__recv, rel); })()) {
  depPath = (() => { const __recv = importPathCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(rel); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, rel) : mapGet(__recv, rel); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.depPath = depPath;
} else {
  depPath = moduleNormalizePath(pathJoin(moduleBasePath, rel)); if (typeof __tuff_this !== 'undefined') __tuff_this.depPath = depPath;
  (() => { const __recv = importPathCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(rel, depPath); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, rel, depPath) : mapSet(__recv, rel, depPath); })();
}
  let importNamesRaw = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.importNamesRaw = importNamesRaw;
  let importNames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.importNames = importNames;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let jLen = (() => { const __recv = importNamesRaw; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.jLen = jLen;
  while ((j < jLen)) {
  (() => { const __recv = importNames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(getInternedStr((() => { const __recv = importNamesRaw; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })())); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, getInternedStr((() => { const __recv = importNamesRaw; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })())) : vecPush(__recv, getInternedStr((() => { const __recv = importNamesRaw; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })())); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  let importSpec = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.importSpec = importSpec;
  (() => { const __recv = importSpec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(depPath); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, depPath) : vecPush(__recv, depPath); })();
  (() => { const __recv = importSpec; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(importNames); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, importNames) : vecPush(__recv, importNames); })();
  (() => { const __recv = imports; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(importSpec); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, importSpec) : vecPush(__recv, importSpec); })();
  gatherProfImportEdges = (gatherProfImportEdges + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImportEdges = gatherProfImportEdges;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  gatherProfImportSnapshotMs = (gatherProfImportSnapshotMs + (perfNow() - t0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImportSnapshotMs = gatherProfImportSnapshotMs;
  return imports;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleSnapshotImportSpecs = moduleSnapshotImportSpecs;

const __tuff_outer_for_moduleWalkImports = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleWalkImports(imports, moduleBasePath, seen, visiting, sources, modulePaths, moduleDeclaredMap, moduleExportedMap, moduleSourceCache, importPathCache, allDeclaredNames, allExportedDeclaredNames, allExternDeclaredNames, lintEnabled, maxEffectiveLines, moduleCycles, recursionDepth) {
  let __tuff_this = { imports: imports, moduleBasePath: moduleBasePath, seen: seen, visiting: visiting, sources: sources, modulePaths: modulePaths, moduleDeclaredMap: moduleDeclaredMap, moduleExportedMap: moduleExportedMap, moduleSourceCache: moduleSourceCache, importPathCache: importPathCache, allDeclaredNames: allDeclaredNames, allExportedDeclaredNames: allExportedDeclaredNames, allExternDeclaredNames: allExternDeclaredNames, lintEnabled: lintEnabled, maxEffectiveLines: maxEffectiveLines, moduleCycles: moduleCycles, recursionDepth: recursionDepth, this: __tuff_outer_for_moduleWalkImports };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = imports; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  if ((len > MODULE_WATCHDOG_MAX_IMPORTS_PER_MODULE)) {
  panicWithCode("E_MODULE_LOADER_WATCHDOG_IMPORTS", "Import fan-out exceeded safety limit while walking module imports", "A single module produced too many import edges, indicating malformed AST or a loader loop.", "Inspect the module import list and parser output for duplicate or non-terminating import expansion.");
}
  while ((i < len)) {
  let spec = (() => { const __recv = imports; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.spec = spec;
  let depPath = (() => { const __recv = spec; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.depPath = depPath;
  let importNames = (() => { const __recv = spec; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.importNames = importNames;
  if ((!(() => { const __recv = seen; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(depPath); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, depPath) : setHas(__recv, depPath); })())) {
  let tRecurse0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.tRecurse0 = tRecurse0;
  gatherModuleSources(depPath, moduleBasePath, seen, visiting, sources, modulePaths, moduleDeclaredMap, moduleExportedMap, moduleSourceCache, importPathCache, allDeclaredNames, allExportedDeclaredNames, allExternDeclaredNames, lintEnabled, maxEffectiveLines, moduleCycles, (recursionDepth + 1));
  if ((recursionDepth === 0)) {
  gatherProfImportRecurseMs = (gatherProfImportRecurseMs + (perfNow() - tRecurse0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImportRecurseMs = gatherProfImportRecurseMs;
}
}
  let tWalkLocal0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.tWalkLocal0 = tWalkLocal0;
  let depDeclared = (() => { const __recv = moduleDeclaredMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(depPath); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, depPath) : mapGet(__recv, depPath); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.depDeclared = depDeclared;
  let depExported = (() => { const __recv = moduleExportedMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(depPath); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, depPath) : mapGet(__recv, depPath); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.depExported = depExported;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let jLen = (() => { const __recv = importNames; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.jLen = jLen;
  while ((j < jLen)) {
  let importedName = (() => { const __recv = importNames; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.importedName = importedName;
  if ((!(() => { const __recv = depExported; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(importedName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, importedName) : setHas(__recv, importedName); })())) {
  if ((() => { const __recv = depDeclared; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(importedName); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, importedName) : setHas(__recv, importedName); })()) {
  panicWithCode("E_MODULE_PRIVATE_IMPORT", (() => { const __recv = (() => { const __recv = "Cannot import '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(importedName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, importedName) : strConcat(__recv, importedName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' from module: symbol is not exported with 'out'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' from module: symbol is not exported with 'out'") : strConcat(__recv, "' from module: symbol is not exported with 'out'"); })(), "A module import referenced a declaration that exists but is not visible outside its module.", "Mark the declaration with 'out' in the target module, or remove it from the import list.");
}
  panicWithCode("E_MODULE_UNKNOWN_EXPORT", (() => { const __recv = (() => { const __recv = "Cannot import '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(importedName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, importedName) : strConcat(__recv, importedName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("' from module: exported symbol not found"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "' from module: exported symbol not found") : strConcat(__recv, "' from module: exported symbol not found"); })(), "A module import requested a symbol that is not exported by the target module.", "Check the import list and add a matching 'out' declaration in the target module.");
}
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  gatherProfImportWalkMs = (gatherProfImportWalkMs + (perfNow() - tWalkLocal0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImportWalkMs = gatherProfImportWalkMs;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleWalkImports = moduleWalkImports;

const __tuff_outer_for_moduleCollectImportedNames = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleCollectImportedNames(imports) {
  let __tuff_this = { imports: imports, this: __tuff_outer_for_moduleCollectImportedNames };
  let importedNames = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.importedNames = importedNames;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = imports; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let spec = (() => { const __recv = imports; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.spec = spec;
  let importNames = (() => { const __recv = spec; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.importNames = importNames;
  let j = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
  let jLen = (() => { const __recv = importNames; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.jLen = jLen;
  while ((j < jLen)) {
  (() => { const __recv = importedNames; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop((() => { const __recv = importNames; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, (() => { const __recv = importNames; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()) : setAdd(__recv, (() => { const __recv = importNames; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(j); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, j) : vecGet(__recv, j); })()); })();
  j = (j + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.j = j;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return importedNames;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleCollectImportedNames = moduleCollectImportedNames;

const __tuff_outer_for_moduleCheckExprImplicitImports = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleCheckExprImplicitImports(n, declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet) {
  let __tuff_this = { n: n, declared: declared, imported: imported, scopes: scopes, depth: depth, implicitCandidates: implicitCandidates, implicitCandidateSet: implicitCandidateSet, this: __tuff_outer_for_moduleCheckExprImplicitImports };
  if ((n === 0)) {
  return 0;
}
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === 24)) {
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if ((((!moduleScopeHas(scopes, depth, name)) && (!(() => { const __recv = declared; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })())) && (!(() => { const __recv = imported; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })()))) {
  if ((!(() => { const __recv = implicitCandidateSet; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })())) {
  (() => { const __recv = implicitCandidateSet; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, name) : setAdd(__recv, name); })();
  (() => { const __recv = implicitCandidates; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, name) : vecPush(__recv, name); })();
}
}
  return 0;
}
  if ((kind === 25)) {
  moduleCheckExprImplicitImports(nodeGetData2(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  moduleCheckExprImplicitImports(nodeGetData3(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  return 0;
}
  if (((kind === 26) || (kind === 34))) {
  moduleCheckExprImplicitImports(nodeGetData2(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  if ((kind === 34)) {
  moduleCheckExprImplicitImports(nodeGetData1(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
}
  return 0;
}
  if ((moduleCheckExprCallLike(n, declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet) === 1)) {
  return 0;
}
  if ((moduleCheckExprComposites(n, declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet) === 1)) {
  return 0;
}
  if ((kind === 31)) {
  moduleCheckExprImplicitImports(nodeGetData1(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  moduleCheckStmtImplicitImports(nodeGetData2(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  if ((nodeGetData3(n) !== 0)) {
  moduleCheckStmtImplicitImports(nodeGetData3(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
}
  return 0;
}
  if ((moduleCheckExprMatch(n, declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet) === 1)) {
  return 0;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleCheckExprImplicitImports = moduleCheckExprImplicitImports;

const __tuff_outer_for_moduleCheckStmtImplicitImports = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleCheckStmtImplicitImports(n, declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet) {
  let __tuff_this = { n: n, declared: declared, imported: imported, scopes: scopes, depth: depth, implicitCandidates: implicitCandidates, implicitCandidateSet: implicitCandidateSet, this: __tuff_outer_for_moduleCheckStmtImplicitImports };
  if ((n === 0)) {
  return 0;
}
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === 12)) {
  let nextDepth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nextDepth = nextDepth;
  (() => { const __recv = scopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(setNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, setNew()) : vecPush(__recv, setNew()); })();
  let stmts = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  moduleCheckStmtImplicitImports((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), declared, imported, scopes, nextDepth, implicitCandidates, implicitCandidateSet);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  (() => { const __recv = scopes; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })();
  return 0;
}
  if (((kind === 2) || (kind === 16))) {
  let fnScopes = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnScopes = fnScopes;
  (() => { const __recv = fnScopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(setNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, setNew()) : vecPush(__recv, setNew()); })();
  let params = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let p = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.p = p;
  moduleScopeDefine(fnScopes, 0, getInternedStr((() => { const __recv = p; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  moduleCheckStmtImplicitImports(nodeGetData5(n), declared, imported, fnScopes, 0, implicitCandidates, implicitCandidateSet);
  return 0;
}
  if ((kind === 5)) {
  moduleCheckExprImplicitImports(nodeGetData3(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  moduleScopeDefine(scopes, depth, getInternedStr(nodeGetData1(n)));
  return 0;
}
  if ((kind === 6)) {
  let names = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.names = names;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = names; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  moduleScopeDefine(scopes, depth, getInternedStr((() => { const __recv = names; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
  if ((kind === 7)) {
  moduleCheckExprImplicitImports(nodeGetData1(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  return 0;
}
  if ((kind === 13)) {
  moduleCheckExprImplicitImports(nodeGetData1(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  moduleCheckExprImplicitImports(nodeGetData2(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  return 0;
}
  if ((kind === 8)) {
  moduleCheckExprImplicitImports(nodeGetData1(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  return 0;
}
  if ((kind === 9)) {
  moduleCheckExprImplicitImports(nodeGetData1(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  moduleCheckStmtImplicitImports(nodeGetData2(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  if ((nodeGetData3(n) !== 0)) {
  moduleCheckStmtImplicitImports(nodeGetData3(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
}
  return 0;
}
  if ((kind === 11)) {
  let nextDepth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.nextDepth = nextDepth;
  (() => { const __recv = scopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(setNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, setNew()) : vecPush(__recv, setNew()); })();
  moduleScopeDefine(scopes, nextDepth, getInternedStr(nodeGetData1(n)));
  moduleCheckExprImplicitImports(nodeGetData2(n), declared, imported, scopes, nextDepth, implicitCandidates, implicitCandidateSet);
  moduleCheckExprImplicitImports(nodeGetData3(n), declared, imported, scopes, nextDepth, implicitCandidates, implicitCandidateSet);
  moduleCheckStmtImplicitImports(nodeGetData4(n), declared, imported, scopes, nextDepth, implicitCandidates, implicitCandidateSet);
  (() => { const __recv = scopes; const __prop = __recv?.["vecPop"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecPop; return __dyn ? __dyn(__recv.ref) : vecPop(__recv); })();
  return 0;
}
  if ((kind === 10)) {
  moduleCheckExprImplicitImports(nodeGetData1(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  moduleCheckStmtImplicitImports(nodeGetData2(n), declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  return 0;
}
  moduleCheckExprImplicitImports(n, declared, imported, scopes, depth, implicitCandidates, implicitCandidateSet);
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleCheckStmtImplicitImports = moduleCheckStmtImplicitImports;

const __tuff_outer_for_moduleCollectImplicitImportCandidates = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleCollectImplicitImportCandidates(program, declared, imported) {
  let __tuff_this = { program: program, declared: declared, imported: imported, this: __tuff_outer_for_moduleCollectImplicitImportCandidates };
  let implicitCandidates = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.implicitCandidates = implicitCandidates;
  let implicitCandidateSet = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.implicitCandidateSet = implicitCandidateSet;
  let topScopes = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.topScopes = topScopes;
  (() => { const __recv = topScopes; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(setNew()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, setNew()) : vecPush(__recv, setNew()); })();
  let body = nodeGetData1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = body; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  moduleCheckStmtImplicitImports((() => { const __recv = body; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), declared, imported, topScopes, 0, implicitCandidates, implicitCandidateSet);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return implicitCandidates;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleCollectImplicitImportCandidates = moduleCollectImplicitImportCandidates;

const __tuff_outer_for_moduleAssertNoImplicitImports = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleAssertNoImplicitImports(implicitCandidates, allExportedDeclared, allExternDeclared) {
  let __tuff_this = { implicitCandidates: implicitCandidates, allExportedDeclared: allExportedDeclared, allExternDeclared: allExternDeclared, this: __tuff_outer_for_moduleAssertNoImplicitImports };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = implicitCandidates; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let name = (() => { const __recv = implicitCandidates; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  if (((() => { const __recv = allExportedDeclared; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })() && (!(() => { const __recv = allExternDeclared; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })()))) {
  panicWithCode("E_MODULE_IMPLICIT_IMPORT", (() => { const __recv = (() => { const __recv = "Strict module imports require explicit import for symbol '"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(), "A module referenced a symbol declared in another module without importing it explicitly.", "Add the symbol to the module import list (for example: let { symbol } = moduleName;).");
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleAssertNoImplicitImports = moduleAssertNoImplicitImports;

const __tuff_outer_for_modulePathToUnitKey = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function modulePathToUnitKey(p, fallbackIdx) {
  let __tuff_this = { p: p, fallbackIdx: fallbackIdx, this: __tuff_outer_for_modulePathToUnitKey };
  let key = moduleNormalizePath(p); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  key = (() => { const __recv = key; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop(":", "_"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, ":", "_") : strReplaceAll(__recv, ":", "_"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  key = (() => { const __recv = key; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("/", "_"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "/", "_") : strReplaceAll(__recv, "/", "_"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  key = (() => { const __recv = key; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("\\", "_"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "\\", "_") : strReplaceAll(__recv, "\\", "_"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  key = (() => { const __recv = key; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("-", "_"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "-", "_") : strReplaceAll(__recv, "-", "_"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  key = (() => { const __recv = key; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop(".", "_"); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, ".", "_") : strReplaceAll(__recv, ".", "_"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  key = (() => { const __recv = key; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop(".tuff", ""); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, ".tuff", "") : strReplaceAll(__recv, ".tuff", ""); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  if ((() => { const __recv = key; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) {
  return (() => { const __recv = "module_"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(fallbackIdx)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(fallbackIdx)) : strConcat(__recv, intToString(fallbackIdx)); })();
}
  return key;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.modulePathToUnitKey = modulePathToUnitKey;

const __tuff_outer_for_moduleBuildUnitKeys = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleBuildUnitKeys(modulePaths) {
  let __tuff_this = { modulePaths: modulePaths, this: __tuff_outer_for_moduleBuildUnitKeys };
  let keys = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.keys = keys;
  let seen = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.seen = seen;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = modulePaths; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let base = modulePathToUnitKey((() => { const __recv = modulePaths; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), i); if (typeof __tuff_this !== 'undefined') __tuff_this.base = base;
  let candidate = base; if (typeof __tuff_this !== 'undefined') __tuff_this.candidate = candidate;
  let suffix = 2; if (typeof __tuff_this !== 'undefined') __tuff_this.suffix = suffix;
  while ((() => { const __recv = seen; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(candidate); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, candidate) : setHas(__recv, candidate); })()) {
  candidate = (() => { const __recv = (() => { const __recv = base; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("_"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "_") : strConcat(__recv, "_"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(suffix)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(suffix)) : strConcat(__recv, intToString(suffix)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.candidate = candidate;
  suffix = (suffix + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.suffix = suffix;
}
  (() => { const __recv = seen; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(candidate); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, candidate) : setAdd(__recv, candidate); })();
  (() => { const __recv = keys; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(candidate); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, candidate) : vecPush(__recv, candidate); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return keys;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleBuildUnitKeys = moduleBuildUnitKeys;

const __tuff_outer_for_moduleFindOwnerKeyForName = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleFindOwnerKeyForName(name, modulePaths, moduleKeys, moduleDeclaredMap, fallbackKey) {
  let __tuff_this = { name: name, modulePaths: modulePaths, moduleKeys: moduleKeys, moduleDeclaredMap: moduleDeclaredMap, fallbackKey: fallbackKey, this: __tuff_outer_for_moduleFindOwnerKeyForName };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = modulePaths; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let path = (() => { const __recv = modulePaths; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.path = path;
  if ((() => { const __recv = moduleDeclaredMap; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(path); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, path) : mapHas(__recv, path); })()) {
  let declared = (() => { const __recv = moduleDeclaredMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(path); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, path) : mapGet(__recv, path); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.declared = declared;
  if ((() => { const __recv = declared; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, name) : setHas(__recv, name); })()) {
  return (() => { const __recv = moduleKeys; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })();
}
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return fallbackKey;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleFindOwnerKeyForName = moduleFindOwnerKeyForName;

const __tuff_outer_for_moduleStmtOwnerKey = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleStmtOwnerKey(stmt, modulePaths, moduleKeys, moduleDeclaredMap, fallbackKey) {
  let __tuff_this = { stmt: stmt, modulePaths: modulePaths, moduleKeys: moduleKeys, moduleDeclaredMap: moduleDeclaredMap, fallbackKey: fallbackKey, this: __tuff_outer_for_moduleStmtOwnerKey };
  let kind = nodeKind(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if (((((((((((kind === 2) || (kind === 16)) || (kind === 3)) || (kind === 60)) || (kind === 63)) || (kind === 65)) || (kind === 4)) || (kind === 5)) || (kind === 18)) || (kind === 19))) {
  return moduleFindOwnerKeyForName(getInternedStr(nodeGetData1(stmt)), modulePaths, moduleKeys, moduleDeclaredMap, fallbackKey);
}
  return fallbackKey;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleStmtOwnerKey = moduleStmtOwnerKey;

const __tuff_outer_for_moduleWriteCSplitOutputs = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function moduleWriteCSplitOutputs(typed, outputPath, modulePaths, moduleDeclaredMap) {
  let __tuff_this = { typed: typed, outputPath: outputPath, modulePaths: modulePaths, moduleDeclaredMap: moduleDeclaredMap, this: __tuff_outer_for_moduleWriteCSplitOutputs };
  let moduleKeys = moduleBuildUnitKeys(modulePaths); if (typeof __tuff_this !== 'undefined') __tuff_this.moduleKeys = moduleKeys;
  let fallbackKey = "main"; if (typeof __tuff_this !== 'undefined') __tuff_this.fallbackKey = fallbackKey;
  if (((() => { const __recv = moduleKeys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > 0)) {
  fallbackKey = (() => { const __recv = moduleKeys; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(((() => { const __recv = moduleKeys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() - 1)); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, ((() => { const __recv = moduleKeys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() - 1)) : vecGet(__recv, ((() => { const __recv = moduleKeys; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() - 1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fallbackKey = fallbackKey;
}
  let stmts = nodeGetData1(typed); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let stmtOwners = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmtOwners = stmtOwners;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stmts; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = stmtOwners; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(moduleStmtOwnerKey((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), modulePaths, moduleKeys, moduleDeclaredMap, fallbackKey)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, moduleStmtOwnerKey((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), modulePaths, moduleKeys, moduleDeclaredMap, fallbackKey)) : vecPush(__recv, moduleStmtOwnerKey((() => { const __recv = stmts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(), modulePaths, moduleKeys, moduleDeclaredMap, fallbackKey)); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let files = generateCSplitFiles(typed, __host_get_c_substrate(), moduleKeys, stmtOwners, moduleKeys); if (typeof __tuff_this !== 'undefined') __tuff_this.files = files;
  let manifestRows = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.manifestRows = manifestRows;
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let flen = (() => { const __recv = files; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.flen = flen;
  while ((i < flen)) {
  let rec = (() => { const __recv = files; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.rec = rec;
  let rel = (() => { const __recv = rec; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.rel = rel;
  let contents = (() => { const __recv = rec; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.contents = contents;
  let full = pathJoin(outputPath, rel); if (typeof __tuff_this !== 'undefined') __tuff_this.full = full;
  writeFile(full, contents);
  (() => { const __recv = manifestRows; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(rel); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, rel) : vecPush(__recv, rel); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return writeFile(pathJoin(outputPath, "manifest.txt"), (() => { const __recv = manifestRows; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, "\n") : vecJoin(__recv, "\n"); })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.moduleWriteCSplitOutputs = moduleWriteCSplitOutputs;

const __tuff_outer_for_gatherModuleSources = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function gatherModuleSources(filePath, moduleBasePath, seen, visiting, sources, modulePaths, moduleDeclaredMap, moduleExportedMap, moduleSourceCache, importPathCache, allDeclaredNames, allExportedDeclaredNames, allExternDeclaredNames, lintEnabled, maxEffectiveLines, moduleCycles, recursionDepth) {
  let __tuff_this = { filePath: filePath, moduleBasePath: moduleBasePath, seen: seen, visiting: visiting, sources: sources, modulePaths: modulePaths, moduleDeclaredMap: moduleDeclaredMap, moduleExportedMap: moduleExportedMap, moduleSourceCache: moduleSourceCache, importPathCache: importPathCache, allDeclaredNames: allDeclaredNames, allExportedDeclaredNames: allExportedDeclaredNames, allExternDeclaredNames: allExternDeclaredNames, lintEnabled: lintEnabled, maxEffectiveLines: maxEffectiveLines, moduleCycles: moduleCycles, recursionDepth: recursionDepth, this: __tuff_outer_for_gatherModuleSources };
  if ((recursionDepth > MODULE_WATCHDOG_MAX_RECURSION_DEPTH)) {
  panicWithCode("E_MODULE_LOADER_WATCHDOG_RECURSION", (() => { const __recv = "Module loader recursion depth exceeded while loading "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, filePath) : strConcat(__recv, filePath); })(), "The module graph walk did not converge and exceeded the recursion safety limit.", "Check import cycles and path normalization; ensure modules are de-duplicated by normalized absolute path.");
}
  filePath = moduleNormalizePath(filePath); if (typeof __tuff_this !== 'undefined') __tuff_this.filePath = filePath;
  moduleBasePath = moduleNormalizePath(moduleBasePath); if (typeof __tuff_this !== 'undefined') __tuff_this.moduleBasePath = moduleBasePath;
  if ((() => { const __recv = seen; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, filePath) : setHas(__recv, filePath); })()) {
  return 0;
}
  if ((() => { const __recv = visiting; const __prop = __recv?.["setHas"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.setHas; return __dyn ? __dyn(__recv.ref, filePath) : setHas(__recv, filePath); })()) {
  if ((lintEnabled === 1)) {
  (() => { const __recv = moduleCycles; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, filePath) : vecPush(__recv, filePath); })();
  return 0;
}
  panicWithCode("E_MODULE_CYCLE", (() => { const __recv = "Module import cycle detected at "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, filePath) : strConcat(__recv, filePath); })(), "A module was revisited while still being loaded, which means the import graph contains a cycle.", "Break the cycle by extracting shared declarations into a third module imported by both sides.");
}
  (() => { const __recv = visiting; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, filePath) : setAdd(__recv, filePath); })();
  let moduleT0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.moduleT0 = moduleT0;
  gatherProfModules = (gatherProfModules + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfModules = gatherProfModules;
  let source = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.source = source;
  if ((() => { const __recv = moduleSourceCache; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, filePath) : mapHas(__recv, filePath); })()) {
  source = (() => { const __recv = moduleSourceCache; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, filePath) : mapGet(__recv, filePath); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.source = source;
} else {
  let tRead0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.tRead0 = tRead0;
  source = readFile(filePath); if (typeof __tuff_this !== 'undefined') __tuff_this.source = source;
  gatherProfReadFileMs = (gatherProfReadFileMs + (perfNow() - tRead0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfReadFileMs = gatherProfReadFileMs;
  (() => { const __recv = moduleSourceCache; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(filePath, source); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, filePath, source) : mapSet(__recv, filePath, source); })();
}
  let tParse0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.tParse0 = tParse0;
  lexInit(source);
  lexAll();
  if ((lintEnabled === 1)) {
  lintCheckCurrentFileLength(filePath, maxEffectiveLines);
}
  parseInit();
  let program = pParseProgram(); if (typeof __tuff_this !== 'undefined') __tuff_this.program = program;
  gatherProfLexParseMs = (gatherProfLexParseMs + (perfNow() - tParse0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfLexParseMs = gatherProfLexParseMs;
  let stmts = nodeGetData1(program); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  let tDecl0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.tDecl0 = tDecl0;
  let declared = moduleCollectDeclaredSets(source, program, moduleDeclaredMap, moduleExportedMap, filePath, allDeclaredNames, allExportedDeclaredNames, allExternDeclaredNames); if (typeof __tuff_this !== 'undefined') __tuff_this.declared = declared;
  gatherProfDeclCollectMs = (gatherProfDeclCollectMs + (perfNow() - tDecl0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfDeclCollectMs = gatherProfDeclCollectMs;
  let imports = moduleSnapshotImportSpecs(stmts, moduleBasePath, importPathCache); if (typeof __tuff_this !== 'undefined') __tuff_this.imports = imports;
  let importedNames = moduleCollectImportedNames(imports); if (typeof __tuff_this !== 'undefined') __tuff_this.importedNames = importedNames;
  let implicitCandidates = moduleCollectImplicitImportCandidates(program, declared, importedNames); if (typeof __tuff_this !== 'undefined') __tuff_this.implicitCandidates = implicitCandidates;
  moduleWalkImports(imports, moduleBasePath, seen, visiting, sources, modulePaths, moduleDeclaredMap, moduleExportedMap, moduleSourceCache, importPathCache, allDeclaredNames, allExportedDeclaredNames, allExternDeclaredNames, lintEnabled, maxEffectiveLines, moduleCycles, recursionDepth);
  let tImplicit0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.tImplicit0 = tImplicit0;
  moduleAssertNoImplicitImports(implicitCandidates, allExportedDeclaredNames, allExternDeclaredNames);
  gatherProfImplicitCheckMs = (gatherProfImplicitCheckMs + (perfNow() - tImplicit0)); if (typeof __tuff_this !== 'undefined') __tuff_this.gatherProfImplicitCheckMs = gatherProfImplicitCheckMs;
  (() => { const __recv = visiting; const __prop = __recv?.["setDelete"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.setDelete; return __dyn ? __dyn(__recv.ref, filePath) : setDelete(__recv, filePath); })();
  (() => { const __recv = seen; const __prop = __recv?.["setAdd"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.setAdd; return __dyn ? __dyn(__recv.ref, filePath) : setAdd(__recv, filePath); })();
  (() => { const __recv = sources; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(source); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, source) : vecPush(__recv, source); })();
  (() => { const __recv = modulePaths; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(filePath); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, filePath) : vecPush(__recv, filePath); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.gatherModuleSources = gatherModuleSources;

const __tuff_outer_for_compileFile = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function compileFile(inputPath, outputPath) {
  let __tuff_this = { inputPath: inputPath, outputPath: outputPath, this: __tuff_outer_for_compileFile };
  return compileFileWithOptions(inputPath, outputPath, 0, 500, 1, "js", 0);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.compileFile = compileFile;

const __tuff_outer_for_compileFileWithOptions = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function compileFileWithOptions(inputPath, outputPath, lintEnabled, maxEffectiveLines, borrowEnabled, target, astDupEnabled) {
  let __tuff_this = { inputPath: inputPath, outputPath: outputPath, lintEnabled: lintEnabled, maxEffectiveLines: maxEffectiveLines, borrowEnabled: borrowEnabled, target: target, astDupEnabled: astDupEnabled, this: __tuff_outer_for_compileFileWithOptions };
  let maxLines = moduleLoaderSanitizeMaxEffectiveLines(maxEffectiveLines); if (typeof __tuff_this !== 'undefined') __tuff_this.maxLines = maxLines;
  let lint = moduleLoaderNormalizeFlag(lintEnabled); if (typeof __tuff_this !== 'undefined') __tuff_this.lint = lint;
  let borrow = moduleLoaderNormalizeFlag(borrowEnabled); if (typeof __tuff_this !== 'undefined') __tuff_this.borrow = borrow;
  inputPath = moduleNormalizePath(inputPath); if (typeof __tuff_this !== 'undefined') __tuff_this.inputPath = inputPath;
  let moduleBasePath = moduleNormalizePath(pathDirname(inputPath)); if (typeof __tuff_this !== 'undefined') __tuff_this.moduleBasePath = moduleBasePath;
  let seen = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.seen = seen;
  let visiting = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.visiting = visiting;
  let sources = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sources = sources;
  let modulePaths = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.modulePaths = modulePaths;
  let moduleDeclaredMap = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.moduleDeclaredMap = moduleDeclaredMap;
  let moduleExportedMap = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.moduleExportedMap = moduleExportedMap;
  let moduleSourceCache = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.moduleSourceCache = moduleSourceCache;
  let importPathCache = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.importPathCache = importPathCache;
  let allDeclaredNames = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.allDeclaredNames = allDeclaredNames;
  let allExportedDeclaredNames = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.allExportedDeclaredNames = allExportedDeclaredNames;
  let allExternDeclaredNames = setNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.allExternDeclaredNames = allExternDeclaredNames;
  let moduleCycles = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.moduleCycles = moduleCycles;
  gatherProfReset();
  lintReset();
  sourcemapInit();
  printError("[selfhost] phase: gather-modules:start");
  let t0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t0 = t0;
  gatherModuleSources(inputPath, moduleBasePath, seen, visiting, sources, modulePaths, moduleDeclaredMap, moduleExportedMap, moduleSourceCache, importPathCache, allDeclaredNames, allExportedDeclaredNames, allExternDeclaredNames, lint, maxLines, moduleCycles, 0);
  let t1 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t1 = t1;
  printError((() => { const __recv = (() => { const __recv = (() => { const __recv = "[selfhost] phase: gather-modules:done modules="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString(gatherProfModules)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString(gatherProfModules)) : strConcat(__recv, intToString(gatherProfModules)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" ms="); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ms=") : strConcat(__recv, " ms="); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((t1 - t0))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((t1 - t0))) : strConcat(__recv, intToString((t1 - t0))); })());
  let smI = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.smI = smI;
  let smLine = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.smLine = smLine;
  if (((() => { const __recv = modulePaths; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() > MODULE_WATCHDOG_MAX_SOURCEMAP_ENTRIES)) {
  panicWithCode("E_MODULE_LOADER_WATCHDOG_SOURCEMAP", "Sourcemap entry count exceeded safety limit", "Module collection produced an unexpectedly large number of source segments.", "Inspect module graph expansion and ensure duplicate modules are not repeatedly re-added.");
}
  let __len = (() => { const __recv = modulePaths; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len = __len;
  while ((smI < __len)) {
  let smPath = (() => { const __recv = modulePaths; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(smI); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, smI) : vecGet(__recv, smI); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.smPath = smPath;
  let smSrc = (() => { const __recv = sources; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(smI); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, smI) : vecGet(__recv, smI); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.smSrc = smSrc;
  sourcemapAdd(smPath, smLine);
  smLine = ((smLine + sourcemapCountLines(smSrc)) + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.smLine = smLine;
  smI = (smI + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.smI = smI;
}
  let joined = joinSources(sources); if (typeof __tuff_this !== 'undefined') __tuff_this.joined = joined;
  let merged = moduleWithCRuntimePrelude(joined, target); if (typeof __tuff_this !== 'undefined') __tuff_this.merged = merged;
  let t2 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2 = t2;
  printError((() => { const __recv = "[selfhost] phase: lex-parse-merged:start merged-bytes="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((() => { const __recv = merged; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })())); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((() => { const __recv = merged; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })())) : strConcat(__recv, intToString((() => { const __recv = merged; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })())); })());
  let t2LexInit0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2LexInit0 = t2LexInit0;
  printError("[selfhost] phase: lex-parse-merged:lex-init:start");
  lexInit(merged);
  let t2LexInit1 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2LexInit1 = t2LexInit1;
  printError((() => { const __recv = "[selfhost] phase: lex-parse-merged:lex-init:done ms="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((t2LexInit1 - t2LexInit0))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((t2LexInit1 - t2LexInit0))) : strConcat(__recv, intToString((t2LexInit1 - t2LexInit0))); })());
  let t2LexAll0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2LexAll0 = t2LexAll0;
  printError("[selfhost] phase: lex-parse-merged:lex-all:start");
  lexAll();
  let t2LexAll1 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2LexAll1 = t2LexAll1;
  printError((() => { const __recv = "[selfhost] phase: lex-parse-merged:lex-all:done ms="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((t2LexAll1 - t2LexAll0))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((t2LexAll1 - t2LexAll0))) : strConcat(__recv, intToString((t2LexAll1 - t2LexAll0))); })());
  let t2ParseInit0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2ParseInit0 = t2ParseInit0;
  printError("[selfhost] phase: lex-parse-merged:parse-init:start");
  parseInit();
  let t2ParseInit1 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2ParseInit1 = t2ParseInit1;
  printError((() => { const __recv = "[selfhost] phase: lex-parse-merged:parse-init:done ms="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((t2ParseInit1 - t2ParseInit0))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((t2ParseInit1 - t2ParseInit0))) : strConcat(__recv, intToString((t2ParseInit1 - t2ParseInit0))); })());
  let t2Parse0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2Parse0 = t2Parse0;
  printError("[selfhost] phase: lex-parse-merged:parse-program:start");
  let program = pParseProgram(); if (typeof __tuff_this !== 'undefined') __tuff_this.program = program;
  let t2Parse1 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2Parse1 = t2Parse1;
  printError((() => { const __recv = "[selfhost] phase: lex-parse-merged:parse-program:done ms="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((t2Parse1 - t2Parse0))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((t2Parse1 - t2Parse0))) : strConcat(__recv, intToString((t2Parse1 - t2Parse0))); })());
  let t2Strip0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2Strip0 = t2Strip0;
  printError("[selfhost] phase: lex-parse-merged:strip-imports:start");
  program = stripImportDecls(program); if (typeof __tuff_this !== 'undefined') __tuff_this.program = program;
  let t2Strip1 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2Strip1 = t2Strip1;
  printError((() => { const __recv = "[selfhost] phase: lex-parse-merged:strip-imports:done ms="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((t2Strip1 - t2Strip0))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((t2Strip1 - t2Strip0))) : strConcat(__recv, intToString((t2Strip1 - t2Strip0))); })());
  printError((() => { const __recv = "[selfhost] phase: lex-parse-merged:done total-ms="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((t2Strip1 - t2))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((t2Strip1 - t2))) : strConcat(__recv, intToString((t2Strip1 - t2))); })());
  let t3 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t3 = t3;
  printError("[selfhost] phase: desugar:start");
  let desugared = desugar(program); if (typeof __tuff_this !== 'undefined') __tuff_this.desugared = desugared;
  printError("[selfhost] phase: resolve:start");
  let resolvedResultAny = resolveNames(desugared); if (typeof __tuff_this !== 'undefined') __tuff_this.resolvedResultAny = resolvedResultAny;
  if ((resolvedResultAny && resolvedResultAny.__tag === "Err")) {
  panic((() => { const __recv = "Resolver error: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(resolvedResultAny.error.message); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, resolvedResultAny.error.message) : strConcat(__recv, resolvedResultAny.error.message); })());
}
  let resolved = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolved = resolved;
  if ((resolvedResultAny && resolvedResultAny.__tag === "Ok")) {
  resolved = resolvedResultAny.value; if (typeof __tuff_this !== 'undefined') __tuff_this.resolved = resolved;
} else {
  panic("Resolver returned unexpected result variant");
}
  let t4 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t4 = t4;
  printError("[selfhost] phase: typecheck:start");
  let typedResultAny = typecheckProgramWithOptions(resolved); if (typeof __tuff_this !== 'undefined') __tuff_this.typedResultAny = typedResultAny;
  if ((typedResultAny && typedResultAny.__tag === "Err")) {
  panic((() => { const __recv = "Typechecker error: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(typedResultAny.error.message); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, typedResultAny.error.message) : strConcat(__recv, typedResultAny.error.message); })());
}
  let typed = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.typed = typed;
  if ((typedResultAny && typedResultAny.__tag === "Ok")) {
  typed = typedResultAny.value; if (typeof __tuff_this !== 'undefined') __tuff_this.typed = typed;
} else {
  panic("Typechecker returned unexpected result variant");
}
  let t5 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t5 = t5;
  if ((borrow === 1)) {
  borrowcheckProgram(typed);
}
  let t6 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t6 = t6;
  if ((lint === 1)) {
  lintProgram(typed, inputPath, maxLines, 0, astDupEnabled);
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = moduleCycles; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  lintAddCircularImportIssue((() => { const __recv = moduleCycles; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })());
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
}
  let t7 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t7 = t7;
  printError((() => { const __recv = "[selfhost] phase: emit:start target="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, target) : strConcat(__recv, target); })());
  if ((() => { const __recv = target; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("c-split"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "c-split") : strEq(__recv, "c-split"); })()) {
  moduleWriteCSplitOutputs(typed, outputPath, modulePaths, moduleDeclaredMap);
  let t8Split = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t8Split = t8Split;
  printError((() => { const __recv = "[selfhost] phase: done total-ms="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((t8Split - t0))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((t8Split - t0))) : strConcat(__recv, intToString((t8Split - t0))); })());
  return 0;
}
  let emitted = moduleEmitTargetOutput(typed, merged, target); if (typeof __tuff_this !== 'undefined') __tuff_this.emitted = emitted;
  let t8 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t8 = t8;
  printError((() => { const __recv = "[selfhost] phase: done total-ms="; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(intToString((t8 - t0))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, intToString((t8 - t0))) : strConcat(__recv, intToString((t8 - t0))); })());
  return writeFile(outputPath, emitted);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.compileFileWithOptions = compileFileWithOptions;

let SYM_LT = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_LT = SYM_LT;

let SYM_GT = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_GT = SYM_GT;

let SYM_LPAREN = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_LPAREN = SYM_LPAREN;

let SYM_RPAREN = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_RPAREN = SYM_RPAREN;

let SYM_LBRACE = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_LBRACE = SYM_LBRACE;

let SYM_LBRACKET = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_LBRACKET = SYM_LBRACKET;

let SYM_RBRACKET = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_RBRACKET = SYM_RBRACKET;

let SYM_COMMA = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_COMMA = SYM_COMMA;

let SYM_DOT = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_DOT = SYM_DOT;

let SYM_PLUS = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_PLUS = SYM_PLUS;

let SYM_MINUS = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_MINUS = SYM_MINUS;

let SYM_STAR = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_STAR = SYM_STAR;

let SYM_SLASH = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_SLASH = SYM_SLASH;

let SYM_PERCENT = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_PERCENT = SYM_PERCENT;

const __tuff_outer_for_initSymbolCache = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function initSymbolCache() {
  let __tuff_this = { this: __tuff_outer_for_initSymbolCache };
  if ((SYM_LT === 0)) {
  SYM_LT = internStr("<"); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_LT = SYM_LT;
  SYM_GT = internStr(">"); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_GT = SYM_GT;
  SYM_LPAREN = internStr("("); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_LPAREN = SYM_LPAREN;
  SYM_RPAREN = internStr(")"); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_RPAREN = SYM_RPAREN;
  SYM_LBRACE = internStr("{"); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_LBRACE = SYM_LBRACE;
  SYM_LBRACKET = internStr("["); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_LBRACKET = SYM_LBRACKET;
  SYM_RBRACKET = internStr("]"); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_RBRACKET = SYM_RBRACKET;
  SYM_COMMA = internStr(","); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_COMMA = SYM_COMMA;
  SYM_DOT = internStr("."); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_DOT = SYM_DOT;
  SYM_PLUS = internStr("+"); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_PLUS = SYM_PLUS;
  SYM_MINUS = internStr("-"); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_MINUS = SYM_MINUS;
  SYM_STAR = internStr("*"); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_STAR = SYM_STAR;
  SYM_SLASH = internStr("/"); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_SLASH = SYM_SLASH;
  SYM_PERCENT = internStr("%"); if (typeof __tuff_this !== 'undefined') __tuff_this.SYM_PERCENT = SYM_PERCENT;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.initSymbolCache = initSymbolCache;

const __tuff_outer_for_pGenericSuffixKind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pGenericSuffixKind() {
  let __tuff_this = { this: __tuff_outer_for_pGenericSuffixKind };
  initSymbolCache();
  if ((!pAt(TK_SYMBOL, "<"))) {
  return 0;
}
  if ((!pCanStartTypeTokAt(1))) {
  return 0;
}
  let cursor = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cursor = cursor;
  let depth = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.depth = depth;
  while (true) {
  if ((cursor > 200000)) {
  pErrorWithTokenContext("Parser watchdog: generic suffix scan exceeded 200000 tokens");
}
  let ti = pPeek(cursor); if (typeof __tuff_this !== 'undefined') __tuff_this.ti = ti;
  let tk = tokKind(ti); if (typeof __tuff_this !== 'undefined') __tuff_this.tk = tk;
  if ((tk === TK_EOF)) {
  return 0;
}
  if ((tk === TK_SYMBOL)) {
  let val = tokValue(ti); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  if ((val === SYM_LT)) {
  depth = (depth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.depth = depth;
} else { if ((val === SYM_GT)) {
  depth = (depth - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.depth = depth;
  if ((depth === 0)) {
  let next = pPeek((cursor + 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((tokKind(next) === TK_SYMBOL)) {
  let nextVal = tokValue(next); if (typeof __tuff_this !== 'undefined') __tuff_this.nextVal = nextVal;
  if ((nextVal === SYM_LPAREN)) {
  return 1;
}
  if ((nextVal === SYM_LBRACE)) {
  return 2;
}
}
  return 3;
}
} }
}
  cursor = (cursor + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cursor = cursor;
}
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pGenericSuffixKind = pGenericSuffixKind;

const __tuff_outer_for_pHasGenericCallSuffix = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pHasGenericCallSuffix() {
  let __tuff_this = { this: __tuff_outer_for_pHasGenericCallSuffix };
  return (pGenericSuffixKind() === 1);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pHasGenericCallSuffix = pHasGenericCallSuffix;

const __tuff_outer_for_pHasGenericStructInitSuffix = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pHasGenericStructInitSuffix() {
  let __tuff_this = { this: __tuff_outer_for_pHasGenericStructInitSuffix };
  return (pGenericSuffixKind() === 2);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pHasGenericStructInitSuffix = pHasGenericStructInitSuffix;

const __tuff_outer_for_pHasGenericValueSuffix = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pHasGenericValueSuffix() {
  let __tuff_this = { this: __tuff_outer_for_pHasGenericValueSuffix };
  return (pGenericSuffixKind() === 3);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pHasGenericValueSuffix = pHasGenericValueSuffix;

const __tuff_outer_for_pParseGenericArgValueOrType = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseGenericArgValueOrType() {
  let __tuff_this = { this: __tuff_outer_for_pParseGenericArgValueOrType };
  initSymbolCache();
  let t0 = pPeek(0); if (typeof __tuff_this !== 'undefined') __tuff_this.t0 = t0;
  if (((tokKind(t0) === TK_IDENTIFIER) && (tokKind(pPeek(1)) === TK_SYMBOL))) {
  if ((tokValue(pPeek(1)) === SYM_DOT)) {
  return pParseExpression(5);
}
}
  let cursor = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.cursor = cursor;
  let parenDepth = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.parenDepth = parenDepth;
  let bracketDepth = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.bracketDepth = bracketDepth;
  while (true) {
  if ((cursor > 200000)) {
  pErrorWithTokenContext("Parser watchdog: generic-arg scan exceeded 200000 tokens");
}
  let ti = pPeek(cursor); if (typeof __tuff_this !== 'undefined') __tuff_this.ti = ti;
  let tk = tokKind(ti); if (typeof __tuff_this !== 'undefined') __tuff_this.tk = tk;
  if ((tk === TK_EOF)) {
  break;
}
  if ((tk === TK_SYMBOL)) {
  let val = tokValue(ti); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  if ((val === SYM_LPAREN)) {
  parenDepth = (parenDepth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.parenDepth = parenDepth;
} else { if ((val === SYM_RPAREN)) {
  if ((parenDepth > 0)) {
  parenDepth = (parenDepth - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.parenDepth = parenDepth;
}
} else { if ((val === SYM_LBRACKET)) {
  bracketDepth = (bracketDepth + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.bracketDepth = bracketDepth;
} else { if ((val === SYM_RBRACKET)) {
  if ((bracketDepth > 0)) {
  bracketDepth = (bracketDepth - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.bracketDepth = bracketDepth;
}
} else { if ((((parenDepth === 0) && (bracketDepth === 0)) && ((val === SYM_COMMA) || (val === SYM_GT)))) {
  break;
} else { if (((((parenDepth === 0) && (bracketDepth === 0)) && (cursor > 0)) && ((((((val === SYM_DOT) || (val === SYM_PLUS)) || (val === SYM_MINUS)) || (val === SYM_STAR)) || (val === SYM_SLASH)) || (val === SYM_PERCENT)))) {
  return pParseExpression(5);
} } } } } }
}
  cursor = (cursor + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.cursor = cursor;
}
  return pParseType();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseGenericArgValueOrType = pParseGenericArgValueOrType;

const __tuff_outer_for_pTryParseIntoGenericValueCall = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTryParseIntoGenericValueCall(expr) {
  let __tuff_this = { expr: expr, this: __tuff_outer_for_pTryParseIntoGenericValueCall };
  if ((!((((nodeKind(expr) === NK_MEMBER_EXPR) && (() => { const __recv = getInternedStr(nodeGetData2(expr)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "into") : strEq(__recv, "into"); })()) && pAt(TK_SYMBOL, "<")) && pHasGenericValueSuffix()))) {
  return 0;
}
  pEat();
  let typeArgs = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.typeArgs = typeArgs;
  if ((!pAt(TK_SYMBOL, ">"))) {
  (() => { const __recv = typeArgs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseGenericArgValueOrType()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseGenericArgValueOrType()) : vecPush(__recv, pParseGenericArgValueOrType()); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = typeArgs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseGenericArgValueOrType()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseGenericArgValueOrType()) : vecPush(__recv, pParseGenericArgValueOrType()); })();
}
}
  pExpect(TK_SYMBOL, ">", "Expected '>' after into type args");
  let recv = nodeGetData1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.recv = recv;
  let prop = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  let args = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  (() => { const __recv = args; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(recv); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, recv) : vecPush(__recv, recv); })();
  let callee = nodeNew(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  nodeSetData1(callee, prop);
  let intoValue = nodeNew(NK_CALL_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.intoValue = intoValue;
  nodeSetData1(intoValue, callee);
  nodeSetData2(intoValue, args);
  nodeSetData3(intoValue, 1);
  nodeSetData4(intoValue, typeArgs);
  nodeSetData5(intoValue, 1);
  return intoValue;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTryParseIntoGenericValueCall = pTryParseIntoGenericValueCall;

const __tuff_outer_for_pParseCallArgs = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseCallArgs() {
  let __tuff_this = { this: __tuff_outer_for_pParseCallArgs };
  let args = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if ((!pAt(TK_SYMBOL, ")"))) {
  (() => { const __recv = args; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseExpression(0)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseExpression(0)) : vecPush(__recv, pParseExpression(0)); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = args; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseExpression(0)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseExpression(0)) : vecPush(__recv, pParseExpression(0)); })();
}
}
  return args;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseCallArgs = pParseCallArgs;

const __tuff_outer_for_pLowerMemberCall = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pLowerMemberCall(expr, args, typeArgs, hasTypeArgs) {
  let __tuff_this = { expr: expr, args: args, typeArgs: typeArgs, hasTypeArgs: hasTypeArgs, this: __tuff_outer_for_pLowerMemberCall };
  let recv = nodeGetData1(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.recv = recv;
  let prop = nodeGetData2(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  let loweredArgs = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.loweredArgs = loweredArgs;
  (() => { const __recv = loweredArgs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(recv); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, recv) : vecPush(__recv, recv); })();
  let ai = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ai = ai;
  let alen = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.alen = alen;
  while ((ai < alen)) {
  (() => { const __recv = loweredArgs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(ai); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, ai) : vecGet(__recv, ai); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(ai); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, ai) : vecGet(__recv, ai); })()) : vecPush(__recv, (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(ai); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, ai) : vecGet(__recv, ai); })()); })();
  ai = (ai + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.ai = ai;
}
  let callee = nodeNew(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  nodeSetData1(callee, prop);
  let call = nodeNew(NK_CALL_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.call = call;
  nodeSetData1(call, callee);
  nodeSetData2(call, loweredArgs);
  nodeSetData3(call, 1);
  if ((hasTypeArgs === 1)) {
  nodeSetData4(call, typeArgs);
}
  return call;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pLowerMemberCall = pLowerMemberCall;

const __tuff_outer_for_pTryParseGenericCall = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTryParseGenericCall(expr) {
  let __tuff_this = { expr: expr, this: __tuff_outer_for_pTryParseGenericCall };
  if ((!(pAt(TK_SYMBOL, "<") && pHasGenericCallSuffix()))) {
  return 0;
}
  pEat();
  let typeArgs = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.typeArgs = typeArgs;
  if ((!pAt(TK_SYMBOL, ">"))) {
  (() => { const __recv = typeArgs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseGenericArgValueOrType()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseGenericArgValueOrType()) : vecPush(__recv, pParseGenericArgValueOrType()); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = typeArgs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseGenericArgValueOrType()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseGenericArgValueOrType()) : vecPush(__recv, pParseGenericArgValueOrType()); })();
}
}
  pExpect(TK_SYMBOL, ">", "Expected '>' after generic call type args");
  pExpect(TK_SYMBOL, "(", "Expected '(' after generic call type args");
  let args = pParseCallArgs(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  pExpect(TK_SYMBOL, ")", "Expected ')' after call args");
  if ((nodeKind(expr) === NK_MEMBER_EXPR)) {
  return pLowerMemberCall(expr, args, typeArgs, 1);
}
  let call = nodeNew(NK_CALL_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.call = call;
  nodeSetData1(call, expr);
  nodeSetData2(call, args);
  nodeSetData3(call, 0);
  nodeSetData4(call, typeArgs);
  return call;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTryParseGenericCall = pTryParseGenericCall;

const __tuff_outer_for_pTryParseCall = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTryParseCall(expr) {
  let __tuff_this = { expr: expr, this: __tuff_outer_for_pTryParseCall };
  if ((!pAt(TK_SYMBOL, "("))) {
  return 0;
}
  pEat();
  let args = pParseCallArgs(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  pExpect(TK_SYMBOL, ")", "Expected ')'");
  if ((nodeKind(expr) === NK_MEMBER_EXPR)) {
  return pLowerMemberCall(expr, args, vecNew(), 0);
}
  let call = nodeNew(NK_CALL_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.call = call;
  nodeSetData1(call, expr);
  nodeSetData2(call, args);
  nodeSetData3(call, 0);
  return call;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTryParseCall = pTryParseCall;

const __tuff_outer_for_pTryParseMember = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTryParseMember(expr) {
  let __tuff_this = { expr: expr, this: __tuff_outer_for_pTryParseMember };
  if ((!pAt(TK_SYMBOL, "."))) {
  return 0;
}
  pEat();
  let prop = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  if (pAtKind(TK_IDENTIFIER)) {
  prop = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
} else { if (pAtKind(TK_KEYWORD)) {
  prop = tokValue(pEat()); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
} else {
  pErrorWithTokenContext("Expected member name after '.'");
} }
  let member = nodeNew(NK_MEMBER_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.member = member;
  nodeSetData1(member, expr);
  nodeSetData2(member, prop);
  return member;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTryParseMember = pTryParseMember;

const __tuff_outer_for_pTryParseIndexOrUnwrap = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTryParseIndexOrUnwrap(expr) {
  let __tuff_this = { expr: expr, this: __tuff_outer_for_pTryParseIndexOrUnwrap };
  if (pAt(TK_SYMBOL, "[")) {
  pEat();
  let idxExpr = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.idxExpr = idxExpr;
  pExpect(TK_SYMBOL, "]", "Expected ']'");
  let idxNode = nodeNew(NK_INDEX_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.idxNode = idxNode;
  nodeSetData1(idxNode, expr);
  nodeSetData2(idxNode, idxExpr);
  return idxNode;
}
  if (pAt(TK_SYMBOL, "?")) {
  pEat();
  let unwrap = nodeNew(NK_UNWRAP_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.unwrap = unwrap;
  nodeSetData1(unwrap, expr);
  return unwrap;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTryParseIndexOrUnwrap = pTryParseIndexOrUnwrap;

const __tuff_outer_for_pParsePostfix = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParsePostfix(exprIn) {
  let __tuff_this = { exprIn: exprIn, this: __tuff_outer_for_pParsePostfix };
  let expr = exprIn; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  let postfixWatchdog = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.postfixWatchdog = postfixWatchdog;
  while (true) {
  postfixWatchdog = (postfixWatchdog + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.postfixWatchdog = postfixWatchdog;
  if ((postfixWatchdog > 10000)) {
  pErrorWithTokenContext("Parser watchdog: postfix loop exceeded 10000 iterations");
}
  let next = pTryParseIntoGenericValueCall(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((next !== 0)) {
  expr = next; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  continue;
}
  next = pTryParseGenericCall(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((next !== 0)) {
  expr = next; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  continue;
}
  next = pTryParseCall(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((next !== 0)) {
  expr = next; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  continue;
}
  next = pTryParseMember(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((next !== 0)) {
  expr = next; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  continue;
}
  next = pTryParseIndexOrUnwrap(expr); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if ((next !== 0)) {
  expr = next; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  continue;
}
  break;
}
  return expr;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParsePostfix = pParsePostfix;

const __tuff_outer_for_selfhostParserExprPostfixMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostParserExprPostfixMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostParserExprPostfixMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostParserExprPostfixMarker = selfhostParserExprPostfixMarker;

const __tuff_outer_for_pParsePrimaryArray = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParsePrimaryArray() {
  let __tuff_this = { this: __tuff_outer_for_pParsePrimaryArray };
  pEat();
  let items = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  if ((!pAt(TK_SYMBOL, "]"))) {
  (() => { const __recv = items; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseExpression(0)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseExpression(0)) : vecPush(__recv, pParseExpression(0)); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  if (pAt(TK_SYMBOL, "]")) {
  break;
}
  (() => { const __recv = items; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseExpression(0)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseExpression(0)) : vecPush(__recv, pParseExpression(0)); })();
}
}
  pExpect(TK_SYMBOL, "]", "Expected ']' in array literal");
  let node = nodeNew(NK_TUPLE_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, items);
  return pParsePostfix(node);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParsePrimaryArray = pParsePrimaryArray;

const __tuff_outer_for_pParsePrimaryBasicLiteral = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParsePrimaryBasicLiteral(kind) {
  let __tuff_this = { kind: kind, this: __tuff_outer_for_pParsePrimaryBasicLiteral };
  let t = pEat(); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let node = nodeNew(kind); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, tokValue(t));
  return pParsePostfix(node);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParsePrimaryBasicLiteral = pParsePrimaryBasicLiteral;

const __tuff_outer_for_pTryParseParenLambda = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTryParseParenLambda() {
  let __tuff_this = { this: __tuff_outer_for_pTryParseParenLambda };
  if ((!pAt(TK_SYMBOL, "("))) {
  return 0;
}
  let mark = pMark(); if (typeof __tuff_this !== 'undefined') __tuff_this.mark = mark;
  pEat();
  let params = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let valid = true; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
  if ((!pAt(TK_SYMBOL, ")"))) {
  while (true) {
  if ((!pAtKind(TK_IDENTIFIER))) {
  valid = false; if (typeof __tuff_this !== 'undefined') __tuff_this.valid = valid;
  break;
}
  let pname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  ptype = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
  let param = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pname) : vecPush(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, ptype) : vecPush(__recv, ptype); })();
  (() => { const __recv = params; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, param) : vecPush(__recv, param); })();
  if (pAt(TK_SYMBOL, ",")) {
  pEat();
  continue;
}
  break;
}
}
  if ((valid && pAt(TK_SYMBOL, ")"))) {
  pEat();
  if (pAt(TK_SYMBOL, "=>")) {
  pEat();
  let body = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if (pAt(TK_SYMBOL, "{")) {
  body = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
} else {
  body = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
}
  let lam = nodeNew(NK_LAMBDA_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.lam = lam;
  nodeSetData1(lam, params);
  nodeSetData2(lam, body);
  return pParsePostfix(lam);
}
}
  pRestore(mark);
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTryParseParenLambda = pTryParseParenLambda;

const __tuff_outer_for_pParsePrimaryFnExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParsePrimaryFnExpr() {
  let __tuff_this = { this: __tuff_outer_for_pParsePrimaryFnExpr };
  pEat();
  let fname = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  if (pAtKind(TK_IDENTIFIER)) {
  fname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
}
  let generics = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.generics = generics;
  if (pAt(TK_SYMBOL, "<")) {
  pEat();
  if ((!pAt(TK_SYMBOL, ">"))) {
  while (true) {
  (() => { const __recv = generics; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseIdentifier()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseIdentifier()) : vecPush(__recv, pParseIdentifier()); })();
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  pParseType();
}
  if ((!pAt(TK_SYMBOL, ","))) {
  break;
}
  pEat();
}
}
  pExpect(TK_SYMBOL, ">", "Expected '>'");
}
  pExpect(TK_SYMBOL, "(", "Expected '(' in function expression");
  let params = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  if ((!pAt(TK_SYMBOL, ")"))) {
  while (true) {
  let pname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  let ptype = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  ptype = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.ptype = ptype;
}
  let param = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pname) : vecPush(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(ptype); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, ptype) : vecPush(__recv, ptype); })();
  (() => { const __recv = params; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, param) : vecPush(__recv, param); })();
  if ((!pAt(TK_SYMBOL, ","))) {
  break;
}
  pEat();
}
}
  pExpect(TK_SYMBOL, ")", "Expected ')' after params");
  let ret = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
  if (pAt(TK_SYMBOL, ":")) {
  pEat();
  ret = pParseType(); if (typeof __tuff_this !== 'undefined') __tuff_this.ret = ret;
}
  pExpect(TK_SYMBOL, "=>", "Expected '=>' in function expression");
  let body = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if (pAt(TK_SYMBOL, "{")) {
  body = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
} else {
  body = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
}
  let fnexpr = nodeNew(NK_FN_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.fnexpr = fnexpr;
  nodeSetData1(fnexpr, fname);
  nodeSetData2(fnexpr, generics);
  nodeSetData3(fnexpr, params);
  nodeSetData4(fnexpr, ret);
  nodeSetData5(fnexpr, body);
  return pParsePostfix(fnexpr);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParsePrimaryFnExpr = pParsePrimaryFnExpr;

const __tuff_outer_for_pTryParseIdentifierLambda = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pTryParseIdentifierLambda() {
  let __tuff_this = { this: __tuff_outer_for_pTryParseIdentifierLambda };
  if ((!((pAtKind(TK_IDENTIFIER) && (tokKind(pPeek(1)) === TK_SYMBOL)) && (() => { const __recv = getInternedStr(tokValue(pPeek(1))); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("=>"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "=>") : strEq(__recv, "=>"); })()))) {
  return 0;
}
  let pname = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.pname = pname;
  pExpect(TK_SYMBOL, "=>", "Expected '=>' in lambda expression");
  let param = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.param = param;
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pname); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pname) : vecPush(__recv, pname); })();
  (() => { const __recv = param; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, 0) : vecPush(__recv, 0); })();
  let params = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  (() => { const __recv = params; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(param); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, param) : vecPush(__recv, param); })();
  let body = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if (pAt(TK_SYMBOL, "{")) {
  body = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
} else {
  body = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
}
  let lam = nodeNew(NK_LAMBDA_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.lam = lam;
  nodeSetData1(lam, params);
  nodeSetData2(lam, body);
  return pParsePostfix(lam);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pTryParseIdentifierLambda = pTryParseIdentifierLambda;

const __tuff_outer_for_pParsePrimaryParenOrTuple = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParsePrimaryParenOrTuple() {
  let __tuff_this = { this: __tuff_outer_for_pParsePrimaryParenOrTuple };
  pEat();
  let first = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.first = first;
  if (pAt(TK_SYMBOL, ",")) {
  let items = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  (() => { const __recv = items; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(first); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, first) : vecPush(__recv, first); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = items; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseExpression(0)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseExpression(0)) : vecPush(__recv, pParseExpression(0)); })();
}
  pExpect(TK_SYMBOL, ")", "Expected ')' after tuple expression");
  let tuple = nodeNew(NK_TUPLE_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.tuple = tuple;
  nodeSetData1(tuple, items);
  return pParsePostfix(tuple);
}
  pExpect(TK_SYMBOL, ")", "Expected ')'");
  return pParsePostfix(first);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParsePrimaryParenOrTuple = pParsePrimaryParenOrTuple;

const __tuff_outer_for_pParsePrimaryIfExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParsePrimaryIfExpr() {
  let __tuff_this = { this: __tuff_outer_for_pParsePrimaryIfExpr };
  pEat();
  pExpect(TK_SYMBOL, "(", "Expected '(' after if");
  let cond = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  pExpect(TK_SYMBOL, ")", "Expected ')' after condition");
  let thenBranch = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.thenBranch = thenBranch;
  if (pAt(TK_SYMBOL, "{")) {
  thenBranch = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.thenBranch = thenBranch;
} else {
  thenBranch = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.thenBranch = thenBranch;
}
  let elseBranch = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.elseBranch = elseBranch;
  if (pAt(TK_KEYWORD, "else")) {
  pEat();
  if (pAt(TK_SYMBOL, "{")) {
  elseBranch = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.elseBranch = elseBranch;
} else {
  elseBranch = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.elseBranch = elseBranch;
}
}
  let node = nodeNew(NK_IF_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, cond);
  nodeSetData2(node, thenBranch);
  nodeSetData3(node, elseBranch);
  return pParsePostfix(node);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParsePrimaryIfExpr = pParsePrimaryIfExpr;

const __tuff_outer_for_pParsePrimaryMatchExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParsePrimaryMatchExpr() {
  let __tuff_this = { this: __tuff_outer_for_pParsePrimaryMatchExpr };
  pEat();
  pExpect(TK_SYMBOL, "(", "Expected '(' after match");
  let target = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  pExpect(TK_SYMBOL, ")", "Expected ')' after match target");
  pExpect(TK_SYMBOL, "{", "Expected '{'");
  let cases = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  while ((!pAt(TK_SYMBOL, "}"))) {
  pExpect(TK_KEYWORD, "case", "Expected 'case'");
  let pat = pParsePattern(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  pExpect(TK_SYMBOL, "=", "Expected '='");
  let body = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  if (pAt(TK_SYMBOL, "{")) {
  body = pParseBlock(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
} else {
  body = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
}
  pExpect(TK_SYMBOL, ";", "Expected ';' after case");
  let caseNode = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.caseNode = caseNode;
  (() => { const __recv = caseNode; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pat); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pat) : vecPush(__recv, pat); })();
  (() => { const __recv = caseNode; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(body); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, body) : vecPush(__recv, body); })();
  (() => { const __recv = cases; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(caseNode); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, caseNode) : vecPush(__recv, caseNode); })();
}
  pExpect(TK_SYMBOL, "}", "Expected '}'");
  let node = nodeNew(NK_MATCH_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, target);
  nodeSetData2(node, cases);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParsePrimaryMatchExpr = pParsePrimaryMatchExpr;

const __tuff_outer_for_pParsePrimaryIdentifierExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParsePrimaryIdentifierExpr() {
  let __tuff_this = { this: __tuff_outer_for_pParsePrimaryIdentifierExpr };
  let name = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let expr = nodeNew(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
  nodeSetData1(expr, name);
  let genericArgs = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.genericArgs = genericArgs;
  let isTypeLike = false; if (typeof __tuff_this !== 'undefined') __tuff_this.isTypeLike = isTypeLike;
  let nameText = getInternedStr(name); if (typeof __tuff_this !== 'undefined') __tuff_this.nameText = nameText;
  if (((() => { const __recv = nameText; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() > 0)) {
  let c0 = (() => { const __recv = nameText; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, 0) : strCharAt(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.c0 = c0;
  if (((c0 >= 65) && (c0 <= 90))) {
  isTypeLike = true; if (typeof __tuff_this !== 'undefined') __tuff_this.isTypeLike = isTypeLike;
}
}
  if ((isTypeLike && pAt(TK_SYMBOL, "<"))) {
  let gsk = pGenericSuffixKind(); if (typeof __tuff_this !== 'undefined') __tuff_this.gsk = gsk;
  if (((gsk === 2) || (gsk === 3))) {
  pEat();
  if ((!pAt(TK_SYMBOL, ">"))) {
  (() => { const __recv = genericArgs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseGenericArgValueOrType()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseGenericArgValueOrType()) : vecPush(__recv, pParseGenericArgValueOrType()); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = genericArgs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseGenericArgValueOrType()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseGenericArgValueOrType()) : vecPush(__recv, pParseGenericArgValueOrType()); })();
}
}
  pExpect(TK_SYMBOL, ">", "Expected '>' in generic struct initializer");
  nodeSetData2(expr, genericArgs);
}
}
  if (pAt(TK_SYMBOL, "{")) {
  pEat();
  let fields = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  if ((!pAt(TK_SYMBOL, "}"))) {
  let key = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.key = key;
  pExpect(TK_SYMBOL, ":", "Expected ':' in struct init");
  let val = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  let field = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  (() => { const __recv = field; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(key); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, key) : vecPush(__recv, key); })();
  (() => { const __recv = field; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(val); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, val) : vecPush(__recv, val); })();
  (() => { const __recv = fields; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(field); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, field) : vecPush(__recv, field); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  let key2 = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.key2 = key2;
  pExpect(TK_SYMBOL, ":", "Expected ':'");
  let val2 = pParseExpression(0); if (typeof __tuff_this !== 'undefined') __tuff_this.val2 = val2;
  let field2 = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.field2 = field2;
  (() => { const __recv = field2; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(key2); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, key2) : vecPush(__recv, key2); })();
  (() => { const __recv = field2; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(val2); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, val2) : vecPush(__recv, val2); })();
  (() => { const __recv = fields; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(field2); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, field2) : vecPush(__recv, field2); })();
}
}
  pExpect(TK_SYMBOL, "}", "Expected '}'");
  let initNode = nodeNew(NK_STRUCT_INIT); if (typeof __tuff_this !== 'undefined') __tuff_this.initNode = initNode;
  nodeSetData1(initNode, name);
  nodeSetData2(initNode, fields);
  nodeSetData3(initNode, genericArgs);
  expr = initNode; if (typeof __tuff_this !== 'undefined') __tuff_this.expr = expr;
}
  return pParsePostfix(expr);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParsePrimaryIdentifierExpr = pParsePrimaryIdentifierExpr;

const __tuff_outer_for_pParsePrimary = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParsePrimary() {
  let __tuff_this = { this: __tuff_outer_for_pParsePrimary };
  if (pAt(TK_SYMBOL, "[")) {
  return pParsePrimaryArray();
}
  if (pAtKind(TK_NUMBER)) {
  return pParsePrimaryBasicLiteral(NK_NUMBER_LIT);
}
  if (pAtKind(TK_BOOL)) {
  return pParsePrimaryBasicLiteral(NK_BOOL_LIT);
}
  if (pAtKind(TK_STRING)) {
  return pParsePrimaryBasicLiteral(NK_STRING_LIT);
}
  if (pAtKind(TK_CHAR)) {
  return pParsePrimaryBasicLiteral(NK_CHAR_LIT);
}
  let parenLambda = pTryParseParenLambda(); if (typeof __tuff_this !== 'undefined') __tuff_this.parenLambda = parenLambda;
  if ((parenLambda !== 0)) {
  return parenLambda;
}
  if (pAt(TK_KEYWORD, "fn")) {
  return pParsePrimaryFnExpr();
}
  let idLambda = pTryParseIdentifierLambda(); if (typeof __tuff_this !== 'undefined') __tuff_this.idLambda = idLambda;
  if ((idLambda !== 0)) {
  return idLambda;
}
  if (pAt(TK_SYMBOL, "(")) {
  return pParsePrimaryParenOrTuple();
}
  if (pAt(TK_KEYWORD, "if")) {
  return pParsePrimaryIfExpr();
}
  if (pAt(TK_KEYWORD, "match")) {
  return pParsePrimaryMatchExpr();
}
  if (pAtKind(TK_IDENTIFIER)) {
  return pParsePrimaryIdentifierExpr();
}
  pErrorWithTokenContext("Expected expression start (identifier, literal, '(', '[', 'if', 'match', or 'fn')");
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParsePrimary = pParsePrimary;

const __tuff_outer_for_selfhostParserExprPrimaryMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostParserExprPrimaryMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostParserExprPrimaryMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostParserExprPrimaryMarker = selfhostParserExprPrimaryMarker;

const __tuff_outer_for_pParseUnary = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseUnary() {
  let __tuff_this = { this: __tuff_outer_for_pParseUnary };
  if (((pAt(TK_SYMBOL, "!") || pAt(TK_SYMBOL, "-")) || pAt(TK_SYMBOL, "&"))) {
  let t = pEat(); if (typeof __tuff_this !== 'undefined') __tuff_this.t = t;
  let op = tokValue(t); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((() => { const __recv = getInternedStr(op); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&") : strEq(__recv, "&"); })() && pAt(TK_KEYWORD, "mut"))) {
  pEat();
  op = intern("&mut"); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
}
  let inner = pParseUnary(); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let node = nodeNew(NK_UNARY_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, op);
  nodeSetData2(node, inner);
  return node;
}
  return pParsePrimary();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseUnary = pParseUnary;

let precedenceMap = mapNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.precedenceMap = precedenceMap;

let precedenceMapInit = false; if (typeof __tuff_this !== 'undefined') __tuff_this.precedenceMapInit = precedenceMapInit;

const __tuff_outer_for_initPrecedenceMap = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function initPrecedenceMap() {
  let __tuff_this = { this: __tuff_outer_for_initPrecedenceMap };
  if (precedenceMapInit) {
  return 0;
}
  precedenceMapInit = true; if (typeof __tuff_this !== 'undefined') __tuff_this.precedenceMapInit = precedenceMapInit;
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern("||"), 1); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern("||"), 1) : mapSet(__recv, intern("||"), 1); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern("&&"), 2); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern("&&"), 2) : mapSet(__recv, intern("&&"), 2); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern("=="), 3); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern("=="), 3) : mapSet(__recv, intern("=="), 3); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern("!="), 3); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern("!="), 3) : mapSet(__recv, intern("!="), 3); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern("<"), 4); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern("<"), 4) : mapSet(__recv, intern("<"), 4); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern("<="), 4); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern("<="), 4) : mapSet(__recv, intern("<="), 4); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern(">"), 4); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern(">"), 4) : mapSet(__recv, intern(">"), 4); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern(">="), 4); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern(">="), 4) : mapSet(__recv, intern(">="), 4); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern(".."), 4); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern(".."), 4) : mapSet(__recv, intern(".."), 4); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern("+"), 5); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern("+"), 5) : mapSet(__recv, intern("+"), 5); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern("-"), 5); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern("-"), 5) : mapSet(__recv, intern("-"), 5); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern("*"), 6); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern("*"), 6) : mapSet(__recv, intern("*"), 6); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern("/"), 6); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern("/"), 6) : mapSet(__recv, intern("/"), 6); })();
  (() => { const __recv = precedenceMap; const __prop = __recv?.["mapSet"]; if (typeof __prop === "function") return __prop(intern("%"), 6); const __dyn = __recv?.table?.mapSet; return __dyn ? __dyn(__recv.ref, intern("%"), 6) : mapSet(__recv, intern("%"), 6); })();
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.initPrecedenceMap = initPrecedenceMap;

const __tuff_outer_for_pGetPrecedence = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pGetPrecedence(op) {
  let __tuff_this = { op: op, this: __tuff_outer_for_pGetPrecedence };
  initPrecedenceMap();
  if ((() => { const __recv = precedenceMap; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, op) : mapHas(__recv, op); })()) {
  return (() => { const __recv = precedenceMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, op) : mapGet(__recv, op); })();
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pGetPrecedence = pGetPrecedence;

const __tuff_outer_for_pIsBinaryOp = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pIsBinaryOp() {
  let __tuff_this = { this: __tuff_outer_for_pIsBinaryOp };
  if (pAt(TK_SYMBOL, "+")) {
  return true;
}
  if (pAt(TK_SYMBOL, "-")) {
  return true;
}
  if (pAt(TK_SYMBOL, "*")) {
  return true;
}
  if (pAt(TK_SYMBOL, "/")) {
  return true;
}
  if (pAt(TK_SYMBOL, "%")) {
  return true;
}
  if (pAt(TK_SYMBOL, "==")) {
  return true;
}
  if (pAt(TK_SYMBOL, "!=")) {
  return true;
}
  if (pAt(TK_SYMBOL, "<")) {
  return true;
}
  if (pAt(TK_SYMBOL, "<=")) {
  return true;
}
  if (pAt(TK_SYMBOL, ">")) {
  return true;
}
  if (pAt(TK_SYMBOL, ">=")) {
  return true;
}
  if (pAt(TK_SYMBOL, "..")) {
  return true;
}
  if (pAt(TK_SYMBOL, "&&")) {
  return true;
}
  if (pAt(TK_SYMBOL, "||")) {
  return true;
}
  if (pAt(TK_KEYWORD, "is")) {
  return true;
}
  if (pAt(TK_KEYWORD, "into")) {
  return true;
}
  return false;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pIsBinaryOp = pIsBinaryOp;

const __tuff_outer_for_pParseExpression = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseExpression(minPrec) {
  let __tuff_this = { minPrec: minPrec, this: __tuff_outer_for_pParseExpression };
  let left = pParseUnary(); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  let watchdog = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.watchdog = watchdog;
  while (pIsBinaryOp()) {
  watchdog = (watchdog + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.watchdog = watchdog;
  if ((watchdog > 200000)) {
  pErrorWithTokenContext("Parser watchdog: binary-expression loop exceeded 200000 iterations");
}
  if (((minPrec <= 0) && pAt(TK_KEYWORD, "into"))) {
  pEat();
  let contractName = pParseIdentifier(); if (typeof __tuff_this !== 'undefined') __tuff_this.contractName = contractName;
  let typeArgs = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.typeArgs = typeArgs;
  let contractType = nodeNew(NK_NAMED_TYPE); if (typeof __tuff_this !== 'undefined') __tuff_this.contractType = contractType;
  nodeSetData1(contractType, contractName);
  nodeSetData2(contractType, vecNew());
  (() => { const __recv = typeArgs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(contractType); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, contractType) : vecPush(__recv, contractType); })();
  let args = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  (() => { const __recv = args; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(left); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, left) : vecPush(__recv, left); })();
  if (pAt(TK_SYMBOL, "(")) {
  pEat();
  if ((!pAt(TK_SYMBOL, ")"))) {
  (() => { const __recv = args; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseExpression(0)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseExpression(0)) : vecPush(__recv, pParseExpression(0)); })();
  while (pAt(TK_SYMBOL, ",")) {
  pEat();
  (() => { const __recv = args; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(pParseExpression(0)); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, pParseExpression(0)) : vecPush(__recv, pParseExpression(0)); })();
}
}
  pExpect(TK_SYMBOL, ")", "Expected ')' after into arguments");
}
  let call = nodeNew(NK_CALL_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.call = call;
  let callee = nodeNew(NK_IDENTIFIER); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  nodeSetData1(callee, intern("into"));
  nodeSetData1(call, callee);
  nodeSetData2(call, args);
  nodeSetData3(call, 1);
  nodeSetData4(call, typeArgs);
  left = call; if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  continue;
}
  let op = tokValue(pPeek(0)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  let prec = pGetPrecedence(op); if (typeof __tuff_this !== 'undefined') __tuff_this.prec = prec;
  if (pAt(TK_KEYWORD, "is")) {
  pEat();
  let pat = pParsePattern(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  let isNode = nodeNew(NK_IS_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.isNode = isNode;
  nodeSetData1(isNode, left);
  nodeSetData2(isNode, pat);
  left = isNode; if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  continue;
}
  if ((prec < minPrec)) {
  break;
}
  if ((((((((((() => { const __recv = internMap; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop("+"); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, "+") : mapHas(__recv, "+"); })() && (op === (() => { const __recv = internMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop("+"); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, "+") : mapGet(__recv, "+"); })())) || ((() => { const __recv = internMap; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, "-") : mapHas(__recv, "-"); })() && (op === (() => { const __recv = internMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop("-"); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, "-") : mapGet(__recv, "-"); })()))) || ((() => { const __recv = internMap; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, "*") : mapHas(__recv, "*"); })() && (op === (() => { const __recv = internMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop("*"); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, "*") : mapGet(__recv, "*"); })()))) || ((() => { const __recv = internMap; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop("/"); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, "/") : mapHas(__recv, "/"); })() && (op === (() => { const __recv = internMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop("/"); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, "/") : mapGet(__recv, "/"); })()))) || ((() => { const __recv = internMap; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop("%"); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, "%") : mapHas(__recv, "%"); })() && (op === (() => { const __recv = internMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop("%"); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, "%") : mapGet(__recv, "%"); })()))) || ((() => { const __recv = internMap; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, "&") : mapHas(__recv, "&"); })() && (op === (() => { const __recv = internMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, "&") : mapGet(__recv, "&"); })()))) || ((() => { const __recv = internMap; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, "|") : mapHas(__recv, "|"); })() && (op === (() => { const __recv = internMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop("|"); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, "|") : mapGet(__recv, "|"); })()))) || ((() => { const __recv = internMap; const __prop = __recv?.["mapHas"]; if (typeof __prop === "function") return __prop("^"); const __dyn = __recv?.table?.mapHas; return __dyn ? __dyn(__recv.ref, "^") : mapHas(__recv, "^"); })() && (op === (() => { const __recv = internMap; const __prop = __recv?.["mapGet"]; if (typeof __prop === "function") return __prop("^"); const __dyn = __recv?.table?.mapGet; return __dyn ? __dyn(__recv.ref, "^") : mapGet(__recv, "^"); })())))) {
  let next = pPeek(1); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if (((tokKind(next) === TK_SYMBOL) && (() => { const __recv = getInternedStr(tokValue(next)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "=") : strEq(__recv, "="); })())) {
  break;
}
}
  pEat();
  let right = pParseExpression((prec + 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  let bin = nodeNew(NK_BINARY_EXPR); if (typeof __tuff_this !== 'undefined') __tuff_this.bin = bin;
  nodeSetData1(bin, op);
  nodeSetData2(bin, left);
  nodeSetData3(bin, right);
  left = bin; if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
}
  return left;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseExpression = pParseExpression;

const __tuff_outer_for_pParseBlock = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function pParseBlock() {
  let __tuff_this = { this: __tuff_outer_for_pParseBlock };
  pExpect(TK_SYMBOL, "{", "Expected '{'");
  let stmts = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmts = stmts;
  while (((!pAt(TK_SYMBOL, "}")) && (!pAtKind(TK_EOF)))) {
  let before = pMark(); if (typeof __tuff_this !== 'undefined') __tuff_this.before = before;
  let stmt = pParseStatement(); if (typeof __tuff_this !== 'undefined') __tuff_this.stmt = stmt;
  let after = pMark(); if (typeof __tuff_this !== 'undefined') __tuff_this.after = after;
  if ((after === before)) {
  pErrorWithTokenContext("Parser made no progress while parsing block statement");
}
  if ((nodeKind(stmt) === NK_STMT_LIST)) {
  let inner = nodeGetData1(stmt); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let __len = (() => { const __recv = inner; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.__len = __len;
  while ((i < __len)) {
  (() => { const __recv = stmts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop((() => { const __recv = inner; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, (() => { const __recv = inner; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()) : vecPush(__recv, (() => { const __recv = inner; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })()); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
} else {
  (() => { const __recv = stmts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(stmt); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, stmt) : vecPush(__recv, stmt); })();
}
}
  pExpect(TK_SYMBOL, "}", "Expected '}'");
  let node = nodeNew(NK_BLOCK); if (typeof __tuff_this !== 'undefined') __tuff_this.node = node;
  nodeSetData1(node, stmts);
  return node;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.pParseBlock = pParseBlock;

const __tuff_outer_for_selfhostParserExprMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostParserExprMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostParserExprMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostParserExprMarker = selfhostParserExprMarker;

const __tuff_outer_for_jsIdentExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function jsIdentExpr(name) {
  let __tuff_this = { name: name, this: __tuff_outer_for_jsIdentExpr };
  if ((() => { const __recv = name; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("this"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "this") : strEq(__recv, "this"); })()) {
  return "(typeof __this_param !== 'undefined' ? __this_param : (typeof __tuff_this !== 'undefined' ? __tuff_this : this))";
}
  return name;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.jsIdentExpr = jsIdentExpr;

const __tuff_outer_for_cgStripNumSuffix = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cgStripNumSuffix(s) {
  let __tuff_this = { s: s, this: __tuff_outer_for_cgStripNumSuffix };
  let n = (() => { const __recv = s; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.n = n;
  if (((n > 5) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((n - 5), n); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (n - 5), n) : strSliceWindow(__recv, (n - 5), n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("USize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "USize") : strEq(__recv, "USize"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, (n - 5)); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, (n - 5)) : strSliceWindow(__recv, 0, (n - 5)); })();
}
  if (((n > 5) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((n - 5), n); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (n - 5), n) : strSliceWindow(__recv, (n - 5), n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("ISize"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "ISize") : strEq(__recv, "ISize"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, (n - 5)); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, (n - 5)) : strSliceWindow(__recv, 0, (n - 5)); })();
}
  if (((n > 4) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((n - 4), n); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (n - 4), n) : strSliceWindow(__recv, (n - 4), n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U128"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U128") : strEq(__recv, "U128"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, (n - 4)); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, (n - 4)) : strSliceWindow(__recv, 0, (n - 4)); })();
}
  if (((n > 4) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((n - 4), n); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (n - 4), n) : strSliceWindow(__recv, (n - 4), n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I128"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I128") : strEq(__recv, "I128"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, (n - 4)); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, (n - 4)) : strSliceWindow(__recv, 0, (n - 4)); })();
}
  if (((n > 3) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((n - 3), n); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (n - 3), n) : strSliceWindow(__recv, (n - 3), n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U64"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U64") : strEq(__recv, "U64"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, (n - 3)); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, (n - 3)) : strSliceWindow(__recv, 0, (n - 3)); })();
}
  if (((n > 3) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((n - 3), n); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (n - 3), n) : strSliceWindow(__recv, (n - 3), n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I64"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I64") : strEq(__recv, "I64"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, (n - 3)); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, (n - 3)) : strSliceWindow(__recv, 0, (n - 3)); })();
}
  if (((n > 3) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((n - 3), n); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (n - 3), n) : strSliceWindow(__recv, (n - 3), n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U32") : strEq(__recv, "U32"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, (n - 3)); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, (n - 3)) : strSliceWindow(__recv, 0, (n - 3)); })();
}
  if (((n > 3) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((n - 3), n); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (n - 3), n) : strSliceWindow(__recv, (n - 3), n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I32"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I32") : strEq(__recv, "I32"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, (n - 3)); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, (n - 3)) : strSliceWindow(__recv, 0, (n - 3)); })();
}
  if (((n > 3) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((n - 3), n); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (n - 3), n) : strSliceWindow(__recv, (n - 3), n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U16"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U16") : strEq(__recv, "U16"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, (n - 3)); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, (n - 3)) : strSliceWindow(__recv, 0, (n - 3)); })();
}
  if (((n > 3) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((n - 3), n); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (n - 3), n) : strSliceWindow(__recv, (n - 3), n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I16"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I16") : strEq(__recv, "I16"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, (n - 3)); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, (n - 3)) : strSliceWindow(__recv, 0, (n - 3)); })();
}
  if (((n > 2) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((n - 2), n); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (n - 2), n) : strSliceWindow(__recv, (n - 2), n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("U8"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "U8") : strEq(__recv, "U8"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, (n - 2)); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, (n - 2)) : strSliceWindow(__recv, 0, (n - 2)); })();
}
  if (((n > 2) && (() => { const __recv = (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop((n - 2), n); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, (n - 2), n) : strSliceWindow(__recv, (n - 2), n); })(); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("I8"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "I8") : strEq(__recv, "I8"); })())) {
  return (() => { const __recv = s; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, (n - 2)); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, (n - 2)) : strSliceWindow(__recv, 0, (n - 2)); })();
}
  return s;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cgStripNumSuffix = cgStripNumSuffix;

const __tuff_outer_for_emitExprCallInto = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitExprCallInto(n, calleeNode) {
  let __tuff_this = { n: n, calleeNode: calleeNode, this: __tuff_outer_for_emitExprCallInto };
  let calleeName = getInternedStr(nodeGetData1(calleeNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.calleeName = calleeName;
  if ((!((() => { const __recv = calleeName; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("into"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "into") : strEq(__recv, "into"); })() && (nodeGetData3(n) === 1)))) {
  return "";
}
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() < 1)) {
  return "undefined";
}
  let typeArgs = nodeGetData4(n); if (typeof __tuff_this !== 'undefined') __tuff_this.typeArgs = typeArgs;
  let contractName = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.contractName = contractName;
  if ((((() => { const __recv = typeArgs; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() === 1) && (nodeKind((() => { const __recv = typeArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()) === NK_NAMED_TYPE))) {
  contractName = getInternedStr(nodeGetData1((() => { const __recv = typeArgs; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })())); if (typeof __tuff_this !== 'undefined') __tuff_this.contractName = contractName;
}
  let srcNode = (() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.srcNode = srcNode;
  let src = emitExpr(srcNode); if (typeof __tuff_this !== 'undefined') __tuff_this.src = src;
  let consumeSource = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.consumeSource = consumeSource;
  let contractLabel = contractName; if (typeof __tuff_this !== 'undefined') __tuff_this.contractLabel = contractLabel;
  if ((() => { const __recv = contractLabel; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) {
  contractLabel = "<unknown>"; if (typeof __tuff_this !== 'undefined') __tuff_this.contractLabel = contractLabel;
}
  if ((nodeKind(srcNode) === NK_IDENTIFIER)) {
  consumeSource = (() => { const __recv = getInternedStr(nodeGetData1(srcNode)); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = undefined;"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = undefined;") : strConcat(__recv, " = undefined;"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.consumeSource = consumeSource;
}
  if ((nodeGetData5(n) === 1)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(() => { const __src = "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(src); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, src) : strConcat(__recv, src); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; const __conv = __src?.__into?.["); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; const __conv = __src?.__into?.[") : strConcat(__recv, "; const __conv = __src?.__into?.["); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"") : strConcat(__recv, "\""); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(contractName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, contractName) : strConcat(__recv, contractName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"") : strConcat(__recv, "\""); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("]; if (!__conv) { throw new Error(\"Missing into converter for "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "]; if (!__conv) { throw new Error(\"Missing into converter for ") : strConcat(__recv, "]; if (!__conv) { throw new Error(\"Missing into converter for "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(contractLabel); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, contractLabel) : strConcat(__recv, contractLabel); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\"); } "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"); } ") : strConcat(__recv, "\"); } "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(consumeSource); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, consumeSource) : strConcat(__recv, consumeSource); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" let __used = false; return (...__intoArgs) => { if (__used) { throw new Error(\"Into converter already consumed for "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " let __used = false; return (...__intoArgs) => { if (__used) { throw new Error(\"Into converter already consumed for ") : strConcat(__recv, " let __used = false; return (...__intoArgs) => { if (__used) { throw new Error(\"Into converter already consumed for "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(contractLabel); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, contractLabel) : strConcat(__recv, contractLabel); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\"); } __used = true; return __conv(...__intoArgs); }; })()"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"); } __used = true; return __conv(...__intoArgs); }; })()") : strConcat(__recv, "\"); } __used = true; return __conv(...__intoArgs); }; })()"); })();
}
  let argStrs = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.argStrs = argStrs;
  let i = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = argStrs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(emitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, emitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())) : vecPush(__recv, emitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let restArgs = (() => { const __recv = argStrs; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.restArgs = restArgs;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(() => { const __src = "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(src); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, src) : strConcat(__recv, src); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; const __conv = __src?.__into?.["); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; const __conv = __src?.__into?.[") : strConcat(__recv, "; const __conv = __src?.__into?.["); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"") : strConcat(__recv, "\""); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(contractName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, contractName) : strConcat(__recv, contractName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"") : strConcat(__recv, "\""); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("]; if (!__conv) { throw new Error(\"Missing into converter for "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "]; if (!__conv) { throw new Error(\"Missing into converter for ") : strConcat(__recv, "]; if (!__conv) { throw new Error(\"Missing into converter for "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(contractLabel); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, contractLabel) : strConcat(__recv, contractLabel); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\"); } const __out = __conv("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"); } const __out = __conv(") : strConcat(__recv, "\"); } const __out = __conv("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(restArgs); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, restArgs) : strConcat(__recv, restArgs); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("); "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "); ") : strConcat(__recv, "); "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(consumeSource); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, consumeSource) : strConcat(__recv, consumeSource); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" return __out; })()"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " return __out; })()") : strConcat(__recv, " return __out; })()"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitExprCallInto = emitExprCallInto;

const __tuff_outer_for_emitExprCallMethod = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitExprCallMethod(n, calleeNode) {
  let __tuff_this = { n: n, calleeNode: calleeNode, this: __tuff_outer_for_emitExprCallMethod };
  if ((!((nodeGetData3(n) === 1) && (nodeKind(calleeNode) === NK_IDENTIFIER)))) {
  return "";
}
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if (((() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })() < 1)) {
  return "";
}
  let calleeName = getInternedStr(nodeGetData1(calleeNode)); if (typeof __tuff_this !== 'undefined') __tuff_this.calleeName = calleeName;
  let receiver = emitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()); if (typeof __tuff_this !== 'undefined') __tuff_this.receiver = receiver;
  let restArgs = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.restArgs = restArgs;
  let i = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = restArgs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(emitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, emitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())) : vecPush(__recv, emitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let restStr = (() => { const __recv = restArgs; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.restStr = restStr;
  let dynArgs = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.dynArgs = dynArgs;
  if ((() => { const __recv = restStr; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) {
  dynArgs = "__recv.ref"; if (typeof __tuff_this !== 'undefined') __tuff_this.dynArgs = dynArgs;
} else {
  dynArgs = (() => { const __recv = "__recv.ref, "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(restStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, restStr) : strConcat(__recv, restStr); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.dynArgs = dynArgs;
}
  let staticArgs = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.staticArgs = staticArgs;
  if ((() => { const __recv = restStr; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) {
  staticArgs = "__recv"; if (typeof __tuff_this !== 'undefined') __tuff_this.staticArgs = staticArgs;
} else {
  staticArgs = (() => { const __recv = "__recv, "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(restStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, restStr) : strConcat(__recv, restStr); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.staticArgs = staticArgs;
}
  let methodKey = (() => { const __recv = (() => { const __recv = "\""; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(calleeName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, calleeName) : strConcat(__recv, calleeName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"") : strConcat(__recv, "\""); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.methodKey = methodKey;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(() => { const __recv = "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(receiver); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, receiver) : strConcat(__recv, receiver); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; const __prop = __recv?.["); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; const __prop = __recv?.[") : strConcat(__recv, "; const __prop = __recv?.["); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(methodKey); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, methodKey) : strConcat(__recv, methodKey); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("]; if (typeof __prop === \"function\") return __prop("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "]; if (typeof __prop === \"function\") return __prop(") : strConcat(__recv, "]; if (typeof __prop === \"function\") return __prop("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(restStr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, restStr) : strConcat(__recv, restStr); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("); const __dyn = __recv?.table?."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "); const __dyn = __recv?.table?.") : strConcat(__recv, "); const __dyn = __recv?.table?."); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(calleeName); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, calleeName) : strConcat(__recv, calleeName); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; return __dyn ? __dyn("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; return __dyn ? __dyn(") : strConcat(__recv, "; return __dyn ? __dyn("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(dynArgs); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, dynArgs) : strConcat(__recv, dynArgs); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") : "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") : ") : strConcat(__recv, ") : "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitExpr(calleeNode)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitExpr(calleeNode)) : strConcat(__recv, emitExpr(calleeNode)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(staticArgs); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, staticArgs) : strConcat(__recv, staticArgs); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("); })()"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "); })()") : strConcat(__recv, "); })()"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitExprCallMethod = emitExprCallMethod;

const __tuff_outer_for_emitExprCallExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitExprCallExpr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitExprCallExpr };
  let calleeNode = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.calleeNode = calleeNode;
  if (((nodeKind(calleeNode) === NK_IDENTIFIER) && (() => { const __recv = getInternedStr(nodeGetData1(calleeNode)); const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("drop"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "drop") : strEq(__recv, "drop"); })())) {
  return "undefined";
}
  let intoCall = emitExprCallInto(n, calleeNode); if (typeof __tuff_this !== 'undefined') __tuff_this.intoCall = intoCall;
  if ((!(() => { const __recv = intoCall; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  return intoCall;
}
  let method = emitExprCallMethod(n, calleeNode); if (typeof __tuff_this !== 'undefined') __tuff_this.method = method;
  if ((!(() => { const __recv = method; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  return method;
}
  let callee = emitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.callee = callee;
  let args = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let argStrs = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.argStrs = argStrs;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = args; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = argStrs; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(emitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, emitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())) : vecPush(__recv, emitExpr((() => { const __recv = args; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let argsStr = (() => { const __recv = argStrs; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.argsStr = argsStr;
  return (() => { const __recv = (() => { const __recv = callee; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = argsStr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = argsStr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })()) : strConcat(__recv, (() => { const __recv = argsStr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })()); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitExprCallExpr = emitExprCallExpr;

const __tuff_outer_for_emitExprStructInit = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitExprStructInit(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitExprStructInit };
  let name = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  let fields = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "((typeof ");
  sbAppend(sb, name);
  sbAppend(sb, " === \"function\") ? ");
  sbAppend(sb, name);
  sbAppend(sb, "({");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  if ((i > 0)) {
  sbAppend(sb, ", ");
}
  sbAppend(sb, getInternedStr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()));
  sbAppend(sb, ": ");
  sbAppend(sb, emitExpr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })()));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "}) : ({ __tag: ");
  sbAppend(sb, (() => { const __recv = (() => { const __recv = "\""; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"") : strConcat(__recv, "\""); })());
  i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < len)) {
  let field = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.field = field;
  sbAppend(sb, ", ");
  sbAppend(sb, getInternedStr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()));
  sbAppend(sb, ": ");
  sbAppend(sb, emitExpr((() => { const __recv = field; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })()));
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, " }))");
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitExprStructInit = emitExprStructInit;

const __tuff_outer_for_emitExprComplex = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitExprComplex(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitExprComplex };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_IF_EXPR)) {
  let cond = emitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.cond = cond;
  let thenB = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.thenB = thenB;
  let elseB = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.elseB = elseB;
  let thenStr = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.thenStr = thenStr;
  if ((nodeKind(thenB) === NK_BLOCK)) {
  thenStr = emitBlockAsIife(thenB); if (typeof __tuff_this !== 'undefined') __tuff_this.thenStr = thenStr;
} else {
  thenStr = emitExpr(thenB); if (typeof __tuff_this !== 'undefined') __tuff_this.thenStr = thenStr;
}
  let elseStr = "undefined"; if (typeof __tuff_this !== 'undefined') __tuff_this.elseStr = elseStr;
  if ((elseB !== 0)) {
  if ((nodeKind(elseB) === NK_BLOCK)) {
  elseStr = emitBlockAsIife(elseB); if (typeof __tuff_this !== 'undefined') __tuff_this.elseStr = elseStr;
} else {
  elseStr = emitExpr(elseB); if (typeof __tuff_this !== 'undefined') __tuff_this.elseStr = elseStr;
}
}
  return strConcat((() => { const __recv = (() => { const __recv = (() => { const __recv = "(("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(cond); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, cond) : strConcat(__recv, cond); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") ? "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") ? ") : strConcat(__recv, ") ? "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = thenStr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" : "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " : ") : strConcat(__recv, " : "); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = thenStr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" : "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " : ") : strConcat(__recv, " : "); })()) : strConcat(__recv, (() => { const __recv = thenStr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" : "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " : ") : strConcat(__recv, " : "); })()); })(), (() => { const __recv = elseStr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })());
}
  if ((kind === NK_MATCH_EXPR)) {
  let target = emitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let cases = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.cases = cases;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  sbAppend(sb, "(() => { const __m = ");
  sbAppend(sb, target);
  sbAppend(sb, "; ");
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = cases; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let caseNode = (() => { const __recv = cases; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.caseNode = caseNode;
  let pat = (() => { const __recv = caseNode; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.pat = pat;
  let body = (() => { const __recv = caseNode; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let guard = emitPatternGuard("__m", pat); if (typeof __tuff_this !== 'undefined') __tuff_this.guard = guard;
  if ((i === 0)) {
  sbAppend(sb, "if (");
} else {
  sbAppend(sb, "else if (");
}
  sbAppend(sb, guard);
  sbAppend(sb, ") { ");
  sbAppend(sb, emitPatternBindings("__m", pat));
  sbAppend(sb, "return ");
  let bodyJs = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.bodyJs = bodyJs;
  if ((nodeKind(body) === NK_BLOCK)) {
  bodyJs = emitBlock(body); if (typeof __tuff_this !== 'undefined') __tuff_this.bodyJs = bodyJs;
} else {
  bodyJs = emitExpr(body); if (typeof __tuff_this !== 'undefined') __tuff_this.bodyJs = bodyJs;
}
  sbAppend(sb, bodyJs);
  sbAppend(sb, "; } ");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  sbAppend(sb, "else { throw new Error(\"Non-exhaustive match\"); } })()");
  return sbBuild(sb);
}
  if ((kind === NK_IS_EXPR)) {
  return (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitPatternGuard(emitExpr(nodeGetData1(n)), nodeGetData2(n))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitPatternGuard(emitExpr(nodeGetData1(n)), nodeGetData2(n))) : strConcat(__recv, emitPatternGuard(emitExpr(nodeGetData1(n)), nodeGetData2(n))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  if ((kind === NK_UNWRAP_EXPR)) {
  return emitExpr(nodeGetData1(n));
}
  if ((kind === NK_LAMBDA_EXPR)) {
  let params = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let body = nodeGetData2(n); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let pnames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.pnames = pnames;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = pnames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(jsIdentExpr(getInternedStr((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, jsIdentExpr(getInternedStr((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))) : vecPush(__recv, jsIdentExpr(getInternedStr((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let args = (() => { const __recv = pnames; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  if ((nodeKind(body) === NK_BLOCK)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(args); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, args) : strConcat(__recv, args); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") => "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") => ") : strConcat(__recv, ") => "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitFnBlock(body)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitFnBlock(body)) : strConcat(__recv, emitFnBlock(body)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(args); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, args) : strConcat(__recv, args); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") => "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") => ") : strConcat(__recv, ") => "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitExpr(body)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitExpr(body)) : strConcat(__recv, emitExpr(body)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  if ((kind === NK_FN_EXPR)) {
  let fnameIdx = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.fnameIdx = fnameIdx;
  let params = nodeGetData3(n); if (typeof __tuff_this !== 'undefined') __tuff_this.params = params;
  let body = nodeGetData5(n); if (typeof __tuff_this !== 'undefined') __tuff_this.body = body;
  let pnames = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.pnames = pnames;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = params; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = pnames; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(jsIdentExpr(getInternedStr((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, jsIdentExpr(getInternedStr((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))) : vecPush(__recv, jsIdentExpr(getInternedStr((() => { const __recv = (() => { const __recv = params; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })()))); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let args = (() => { const __recv = pnames; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.args = args;
  let namePart = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.namePart = namePart;
  if ((fnameIdx !== 0)) {
  namePart = (() => { const __recv = " "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(getInternedStr(fnameIdx)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, getInternedStr(fnameIdx)) : strConcat(__recv, getInternedStr(fnameIdx)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.namePart = namePart;
}
  if ((nodeKind(body) === NK_BLOCK)) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(function"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(namePart); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, namePart) : strConcat(__recv, namePart); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(args); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, args) : strConcat(__recv, args); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") ") : strConcat(__recv, ") "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitFnBlock(body)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitFnBlock(body)) : strConcat(__recv, emitFnBlock(body)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })();
}
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(function"; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(namePart); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, namePart) : strConcat(__recv, namePart); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("("); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "(") : strConcat(__recv, "("); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(args); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, args) : strConcat(__recv, args); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(") { return "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ") { return ") : strConcat(__recv, ") { return "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(emitExpr(body)); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, emitExpr(body)) : strConcat(__recv, emitExpr(body)); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; })"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; })") : strConcat(__recv, "; })"); })();
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitExprComplex = emitExprComplex;

const __tuff_outer_for_emitExpr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitExpr(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_emitExpr };
  let kind = nodeKind(n); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_NUMBER_LIT)) {
  let val = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  return cgStripNumSuffix(getInternedStr(val));
}
  if ((kind === NK_BOOL_LIT)) {
  let val = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  if ((val === 1)) {
  return "true";
}
  return "false";
}
  if ((kind === NK_STRING_LIT)) {
  let val = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  let s = getInternedStr(val); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  return (() => { const __recv = (() => { const __recv = "\""; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(s); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, s) : strConcat(__recv, s); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"") : strConcat(__recv, "\""); })();
}
  if ((kind === NK_CHAR_LIT)) {
  let val = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  let s = getInternedStr(val); if (typeof __tuff_this !== 'undefined') __tuff_this.s = s;
  return (() => { const __recv = (() => { const __recv = "\""; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(s); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, s) : strConcat(__recv, s); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"") : strConcat(__recv, "\""); })();
}
  if ((kind === NK_IDENTIFIER)) {
  let nameIdx = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.nameIdx = nameIdx;
  return jsIdentExpr(getInternedStr(nameIdx));
}
  if ((kind === NK_UNARY_EXPR)) {
  let op = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if (((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&") : strEq(__recv, "&"); })() || (() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("&mut"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "&mut") : strEq(__recv, "&mut"); })())) {
  return emitExpr(nodeGetData2(n));
}
  let inner = emitExpr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.inner = inner;
  return (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, op) : strConcat(__recv, op); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = inner; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = inner; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })()) : strConcat(__recv, (() => { const __recv = inner; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(")"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ")") : strConcat(__recv, ")"); })()); })();
}
  if ((kind === NK_BINARY_EXPR)) {
  let op = getInternedStr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("=="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "==") : strEq(__recv, "=="); })()) {
  op = "==="; if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
}
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("!="); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "!=") : strEq(__recv, "!="); })()) {
  op = "!=="; if (typeof __tuff_this !== 'undefined') __tuff_this.op = op;
}
  let left = emitExpr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.left = left;
  let right = emitExpr(nodeGetData3(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.right = right;
  if ((() => { const __recv = op; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(".."); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "..") : strEq(__recv, ".."); })()) {
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = (() => { const __recv = "(function() { let __cur = "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(left); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, left) : strConcat(__recv, left); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(", __hi = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ", __hi = ") : strConcat(__recv, ", __hi = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, right) : strConcat(__recv, right); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; return function() { if (__cur > __hi) return [true, __hi]; let __val = __cur++; return [false, __val]; }; })()"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; return function() { if (__cur > __hi) return [true, __hi]; let __val = __cur++; return [false, __val]; }; })()") : strConcat(__recv, "; return function() { if (__cur > __hi) return [true, __hi]; let __val = __cur++; return [false, __val]; }; })()"); })();
}
  return strConcat((() => { const __recv = (() => { const __recv = (() => { const __recv = "("; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(left); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, left) : strConcat(__recv, left); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = " "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, op) : strConcat(__recv, op); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = " "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, op) : strConcat(__recv, op); })()) : strConcat(__recv, (() => { const __recv = " "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(op); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, op) : strConcat(__recv, op); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = " "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, right) : strConcat(__recv, right); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = " "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, right) : strConcat(__recv, right); })()) : strConcat(__recv, (() => { const __recv = " "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(right); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, right) : strConcat(__recv, right); })()); })(), ")");
}
  if ((kind === NK_CALL_EXPR)) {
  return emitExprCallExpr(n);
}
  if ((kind === NK_MEMBER_EXPR)) {
  let obj = emitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.obj = obj;
  let prop = getInternedStr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.prop = prop;
  if ((() => { const __recv = prop; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("init"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "init") : strEq(__recv, "init"); })()) {
  return (() => { const __recv = obj; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(".length"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".length") : strConcat(__recv, ".length"); })();
}
  return (() => { const __recv = (() => { const __recv = obj; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".") : strConcat(__recv, "."); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prop); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prop) : strConcat(__recv, prop); })();
}
  if ((kind === NK_INDEX_EXPR)) {
  let target = emitExpr(nodeGetData1(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let idxExpr = emitExpr(nodeGetData2(n)); if (typeof __tuff_this !== 'undefined') __tuff_this.idxExpr = idxExpr;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = target; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("["); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "[") : strConcat(__recv, "["); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(idxExpr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, idxExpr) : strConcat(__recv, idxExpr); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "]") : strConcat(__recv, "]"); })();
}
  if ((kind === NK_STRUCT_INIT)) {
  return emitExprStructInit(n);
}
  if ((kind === NK_TUPLE_EXPR)) {
  let items = nodeGetData1(n); if (typeof __tuff_this !== 'undefined') __tuff_this.items = items;
  let parts = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.parts = parts;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = items; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  (() => { const __recv = parts; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(emitExpr((() => { const __recv = items; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, emitExpr((() => { const __recv = items; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())) : vecPush(__recv, emitExpr((() => { const __recv = items; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })())); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = (() => { const __recv = "["; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = parts; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = parts; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })()) : strConcat(__recv, (() => { const __recv = parts; const __prop = __recv?.["vecJoin"]; if (typeof __prop === "function") return __prop(", "); const __dyn = __recv?.table?.vecJoin; return __dyn ? __dyn(__recv.ref, ", ") : vecJoin(__recv, ", "); })()); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("]"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "]") : strConcat(__recv, "]"); })();
}
  let complex = emitExprComplex(n); if (typeof __tuff_this !== 'undefined') __tuff_this.complex = complex;
  if ((!(() => { const __recv = complex; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })())) {
  return complex;
}
  return "undefined";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitExpr = emitExpr;

const __tuff_outer_for_emitPatternGuard = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitPatternGuard(valueExpr, pat) {
  let __tuff_this = { valueExpr: valueExpr, pat: pat, this: __tuff_outer_for_emitPatternGuard };
  let kind = nodeKind(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_WILDCARD_PAT)) {
  return "true";
}
  if ((kind === NK_LITERAL_PAT)) {
  let val = getInternedStr(nodeGetData1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.val = val;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = valueExpr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" === "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " === ") : strConcat(__recv, " === "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(val); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, val) : strConcat(__recv, val); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "") : strConcat(__recv, ""); })();
}
  if ((kind === NK_NAME_PAT)) {
  let name = getInternedStr(nodeGetData1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return strConcat((() => { const __recv = (() => { const __recv = (() => { const __recv = valueExpr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" && "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " && ") : strConcat(__recv, " && "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(valueExpr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, valueExpr) : strConcat(__recv, valueExpr); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(".__tag === \""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".__tag === \"") : strConcat(__recv, ".__tag === \""); })(), (() => { const __recv = name; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"") : strConcat(__recv, "\""); })());
}
  if ((kind === NK_STRUCT_PAT)) {
  let name = getInternedStr(nodeGetData1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return strConcat((() => { const __recv = (() => { const __recv = (() => { const __recv = valueExpr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" && "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " && ") : strConcat(__recv, " && "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(valueExpr); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, valueExpr) : strConcat(__recv, valueExpr); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(".__tag === \""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ".__tag === \"") : strConcat(__recv, ".__tag === \""); })(), (() => { const __recv = name; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"") : strConcat(__recv, "\""); })());
}
  return "false";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitPatternGuard = emitPatternGuard;

const __tuff_outer_for_emitPatternBindings = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitPatternBindings(valueExpr, pat) {
  let __tuff_this = { valueExpr: valueExpr, pat: pat, this: __tuff_outer_for_emitPatternBindings };
  let kind = nodeKind(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.kind = kind;
  if ((kind === NK_STRUCT_PAT)) {
  let fields = nodeGetData2(pat); if (typeof __tuff_this !== 'undefined') __tuff_this.fields = fields;
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = fields; const __prop = __recv?.["vecLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.vecLength; return __dyn ? __dyn(__recv.ref) : vecLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let fnameIdx = (() => { const __recv = fields; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, i) : vecGet(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.fnameIdx = fnameIdx;
  let fname = getInternedStr(fnameIdx); if (typeof __tuff_this !== 'undefined') __tuff_this.fname = fname;
  sbAppend(sb, "const ");
  sbAppend(sb, fname);
  sbAppend(sb, " = ");
  sbAppend(sb, valueExpr);
  sbAppend(sb, ".");
  sbAppend(sb, fname);
  sbAppend(sb, "; ");
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sbBuild(sb);
}
  if ((kind === NK_NAME_PAT)) {
  let name = getInternedStr(nodeGetData1(pat)); if (typeof __tuff_this !== 'undefined') __tuff_this.name = name;
  return (() => { const __recv = (() => { const __recv = (() => { const __recv = "const "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(name); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, name) : strConcat(__recv, name); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = valueExpr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; ") : strConcat(__recv, "; "); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = valueExpr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; ") : strConcat(__recv, "; "); })()) : strConcat(__recv, (() => { const __recv = valueExpr; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("; "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "; ") : strConcat(__recv, "; "); })()); })();
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitPatternBindings = emitPatternBindings;

const __tuff_outer_for_selfhostCodegenExprMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostCodegenExprMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostCodegenExprMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostCodegenExprMarker = selfhostCodegenExprMarker;

const __tuff_outer_for_fmtSpaces = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtSpaces(n) {
  let __tuff_this = { n: n, this: __tuff_outer_for_fmtSpaces };
  let sb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sb = sb;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i < n)) {
  sbAppendChar(sb, 32);
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return sbBuild(sb);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtSpaces = fmtSpaces;

const __tuff_outer_for_fmtTrimRight = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtTrimRight(line) {
  let __tuff_this = { line: line, this: __tuff_outer_for_fmtTrimRight };
  let end = (() => { const __recv = line; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
  while ((end > 0)) {
  let ch = (() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((end - 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (end - 1)) : strCharAt(__recv, (end - 1)); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((((ch === 32) || (ch === 9)) || (ch === 13))) {
  end = (end - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
} else {
  return (() => { const __recv = line; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, end); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, end) : strSliceWindow(__recv, 0, end); })();
}
}
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtTrimRight = fmtTrimRight;

const __tuff_outer_for_fmtCountLeadingCloses = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtCountLeadingCloses(line) {
  let __tuff_this = { line: line, this: __tuff_outer_for_fmtCountLeadingCloses };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = line; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while (((i < len) && ((() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })() === 125))) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return i;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtCountLeadingCloses = fmtCountLeadingCloses;

const __tuff_outer_for_fmtCountChar = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtCountChar(line, target) {
  let __tuff_this = { line: line, target: target, this: __tuff_outer_for_fmtCountChar };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = line; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let count = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
  while ((i < len)) {
  if (((() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })() === target)) {
  count = (count + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.count = count;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return count;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtCountChar = fmtCountChar;

const __tuff_outer_for_fmtCountStructuralBraces = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtCountStructuralBraces(line) {
  let __tuff_this = { line: line, this: __tuff_outer_for_fmtCountStructuralBraces };
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = line; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let opens = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.opens = opens;
  let closes = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.closes = closes;
  let inString = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inString = inString;
  let inChar = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inChar = inChar;
  while ((i < len)) {
  let ch = (() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((inString === 1)) {
  if (((ch === 92) && ((i + 1) < len))) {
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 34)) {
  inString = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inString = inString;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((inChar === 1)) {
  if (((ch === 92) && ((i + 1) < len))) {
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 39)) {
  inChar = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inChar = inChar;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((((ch === 47) && ((i + 1) < len)) && ((() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })() === 47))) {
  break;
}
  if ((ch === 34)) {
  inString = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.inString = inString;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 39)) {
  inChar = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.inChar = inChar;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 123)) {
  opens = (opens + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.opens = opens;
}
  if ((ch === 125)) {
  closes = (closes + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.closes = closes;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let r = vecNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.r = r;
  (() => { const __recv = r; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(opens); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, opens) : vecPush(__recv, opens); })();
  (() => { const __recv = r; const __prop = __recv?.["vecPush"]; if (typeof __prop === "function") return __prop(closes); const __dyn = __recv?.table?.vecPush; return __dyn ? __dyn(__recv.ref, closes) : vecPush(__recv, closes); })();
  return r;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtCountStructuralBraces = fmtCountStructuralBraces;

const __tuff_outer_for_fmtIsSpace = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtIsSpace(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_fmtIsSpace };
  return ((ch === 32) || (ch === 9));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtIsSpace = fmtIsSpace;

const __tuff_outer_for_fmtIsIdentChar = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtIsIdentChar(ch) {
  let __tuff_this = { ch: ch, this: __tuff_outer_for_fmtIsIdentChar };
  return (((((ch >= 65) && (ch <= 90)) || ((ch >= 97) && (ch <= 122))) || ((ch >= 48) && (ch <= 57))) || (ch === 95));
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtIsIdentChar = fmtIsIdentChar;

const __tuff_outer_for_fmtPrevNonSpaceChar = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtPrevNonSpaceChar(text) {
  let __tuff_this = { text: text, this: __tuff_outer_for_fmtPrevNonSpaceChar };
  let i = ((() => { const __recv = text; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while ((i >= 0)) {
  let ch = (() => { const __recv = text; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((!fmtIsSpace((0 + ch)))) {
  return (0 + ch);
}
  i = (i - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtPrevNonSpaceChar = fmtPrevNonSpaceChar;

const __tuff_outer_for_fmtNextNonSpaceChar = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtNextNonSpaceChar(text, start) {
  let __tuff_this = { text: text, start: start, this: __tuff_outer_for_fmtNextNonSpaceChar };
  let i = start; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = text; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let ch = (() => { const __recv = text; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((!fmtIsSpace((0 + ch)))) {
  return (0 + ch);
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtNextNonSpaceChar = fmtNextNonSpaceChar;

const __tuff_outer_for_fmtTrimRightSpacesText = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtTrimRightSpacesText(text) {
  let __tuff_this = { text: text, this: __tuff_outer_for_fmtTrimRightSpacesText };
  let end = (() => { const __recv = text; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
  while (((end > 0) && fmtIsSpace((0 + (() => { const __recv = text; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((end - 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (end - 1)) : strCharAt(__recv, (end - 1)); })())))) {
  end = (end - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.end = end;
}
  return (() => { const __recv = text; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(0, end); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, 0, end) : strSliceWindow(__recv, 0, end); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtTrimRightSpacesText = fmtTrimRightSpacesText;

const __tuff_outer_for_fmtNormalizeLineSpacing = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtNormalizeLineSpacing(line) {
  let __tuff_this = { line: line, this: __tuff_outer_for_fmtNormalizeLineSpacing };
  let acc = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = line; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let inString = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inString = inString;
  let inChar = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inChar = inChar;
  while ((i < len)) {
  let ch = (() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((inString === 1)) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(strFromCharCode((0 + ch))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, strFromCharCode((0 + ch))) : strConcat(__recv, strFromCharCode((0 + ch))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((ch === 92) && ((i + 1) < len))) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(strFromCharCode((0 + (() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })()))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, strFromCharCode((0 + (() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })()))) : strConcat(__recv, strFromCharCode((0 + (() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })()))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 34)) {
  inString = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inString = inString;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((inChar === 1)) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(strFromCharCode((0 + ch))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, strFromCharCode((0 + ch))) : strConcat(__recv, strFromCharCode((0 + ch))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((ch === 92) && ((i + 1) < len))) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(strFromCharCode((0 + (() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })()))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, strFromCharCode((0 + (() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })()))) : strConcat(__recv, strFromCharCode((0 + (() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })()))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 39)) {
  inChar = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inChar = inChar;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((((ch === 47) && ((i + 1) < len)) && ((() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })() === 47))) {
  acc = (() => { const __recv = (() => { const __recv = fmtTrimRightSpacesText(acc); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop((() => { const __recv = line; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(i, len); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, i, len) : strSliceWindow(__recv, i, len); })()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, (() => { const __recv = line; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(i, len); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, i, len) : strSliceWindow(__recv, i, len); })()) : strConcat(__recv, (() => { const __recv = line; const __prop = __recv?.["strSliceWindow"]; if (typeof __prop === "function") return __prop(i, len); const __dyn = __recv?.table?.strSliceWindow; return __dyn ? __dyn(__recv.ref, i, len) : strSliceWindow(__recv, i, len); })()); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  break;
}
  if ((ch === 34)) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\""); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\"") : strConcat(__recv, "\""); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  inString = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.inString = inString;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 39)) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("'"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "'") : strConcat(__recv, "'"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  inChar = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.inChar = inChar;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 44)) {
  acc = (() => { const __recv = fmtTrimRightSpacesText(acc); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(","); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ",") : strConcat(__recv, ","); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  let next = fmtNextNonSpaceChar(line, (i + 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  if (((((next !== 0) && (next !== 41)) && (next !== 93)) && (next !== 125))) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 123)) {
  let prev = fmtPrevNonSpaceChar(acc); if (typeof __tuff_this !== 'undefined') __tuff_this.prev = prev;
  acc = fmtTrimRightSpacesText(acc); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  if (((((prev !== 0) && (prev !== 123)) && (prev !== 40)) && (prev !== 91))) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("{"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "{") : strConcat(__recv, "{"); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((((ch === 61) && (!(((i + 1) < len) && (((() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })() === 61) || ((() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })() === 62))))) && (!((i > 0) && ((((() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i - 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i - 1)) : strCharAt(__recv, (i - 1)); })() === 33) || ((() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i - 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i - 1)) : strCharAt(__recv, (i - 1)); })() === 60)) || ((() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i - 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i - 1)) : strCharAt(__recv, (i - 1)); })() === 62)))))) {
  acc = (() => { const __recv = fmtTrimRightSpacesText(acc); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" = "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " = ") : strConcat(__recv, " = "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while (((i < len) && fmtIsSpace((0 + (() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })())))) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  continue;
}
  if (((((ch === 43) || (ch === 45)) || (ch === 47)) || (ch === 37))) {
  let prev = fmtPrevNonSpaceChar(acc); if (typeof __tuff_this !== 'undefined') __tuff_this.prev = prev;
  let next = fmtNextNonSpaceChar(line, (i + 1)); if (typeof __tuff_this !== 'undefined') __tuff_this.next = next;
  let binary = ((((((fmtIsIdentChar(prev) || (prev === 41)) || (prev === 93)) || (prev === 125)) || (prev === 34)) || (prev === 39)) && ((((fmtIsIdentChar(next) || (next === 40)) || (next === 91)) || (next === 34)) || (next === 39))); if (typeof __tuff_this !== 'undefined') __tuff_this.binary = binary;
  if (binary) {
  acc = (() => { const __recv = (() => { const __recv = (() => { const __recv = fmtTrimRightSpacesText(acc); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(strFromCharCode((0 + ch))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, strFromCharCode((0 + ch))) : strConcat(__recv, strFromCharCode((0 + ch))); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  while (((i < len) && fmtIsSpace((0 + (() => { const __recv = line; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })())))) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  continue;
}
}
  if (fmtIsSpace((0 + ch))) {
  if ((((() => { const __recv = acc; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() > 0) && (!fmtIsSpace((0 + (() => { const __recv = acc; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(((() => { const __recv = acc; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() - 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, ((() => { const __recv = acc; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() - 1)) : strCharAt(__recv, ((() => { const __recv = acc; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() - 1)); })()))))) {
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " ") : strConcat(__recv, " "); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  acc = (() => { const __recv = acc; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(strFromCharCode((0 + ch))); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, strFromCharCode((0 + ch))) : strConcat(__recv, strFromCharCode((0 + ch))); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  acc = fmtTrimRightSpacesText(acc); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  acc = (() => { const __recv = acc; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("if (", "if ("); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "if (", "if (") : strReplaceAll(__recv, "if (", "if ("); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  acc = (() => { const __recv = acc; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("while (", "while ("); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "while (", "while (") : strReplaceAll(__recv, "while (", "while ("); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  acc = (() => { const __recv = acc; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("match (", "match ("); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "match (", "match (") : strReplaceAll(__recv, "match (", "match ("); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  acc = (() => { const __recv = acc; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("for (", "for ("); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "for (", "for (") : strReplaceAll(__recv, "for (", "for ("); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  acc = (() => { const __recv = acc; const __prop = __recv?.["strReplaceAll"]; if (typeof __prop === "function") return __prop("return (", "return ("); const __dyn = __recv?.table?.strReplaceAll; return __dyn ? __dyn(__recv.ref, "return (", "return (") : strReplaceAll(__recv, "return (", "return ("); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.acc = acc;
  return acc;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtNormalizeLineSpacing = fmtNormalizeLineSpacing;

const __tuff_outer_for_fmtEmitProcessedLine = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtEmitProcessedLine(sink, raw, indent) {
  let __tuff_this = { sink: sink, raw: raw, indent: indent, this: __tuff_outer_for_fmtEmitProcessedLine };
  let trimmed = (() => { const __recv = fmtTrimRight(raw); const __prop = __recv?.["strTrim"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strTrim; return __dyn ? __dyn(__recv.ref) : strTrim(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.trimmed = trimmed;
  if ((() => { const __recv = trimmed; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) {
  return indent;
}
  let normalized = fmtNormalizeLineSpacing(trimmed); if (typeof __tuff_this !== 'undefined') __tuff_this.normalized = normalized;
  let leadingCloses = fmtCountLeadingCloses(normalized); if (typeof __tuff_this !== 'undefined') __tuff_this.leadingCloses = leadingCloses;
  let effectiveIndent = indent; if (typeof __tuff_this !== 'undefined') __tuff_this.effectiveIndent = effectiveIndent;
  if (((effectiveIndent > 0) && (leadingCloses > 0))) {
  let k = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
  while (((k < leadingCloses) && (effectiveIndent > 0))) {
  effectiveIndent = (effectiveIndent - 1); if (typeof __tuff_this !== 'undefined') __tuff_this.effectiveIndent = effectiveIndent;
  k = (k + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.k = k;
}
}
  let line = (() => { const __recv = fmtSpaces((effectiveIndent * 4)); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(normalized); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, normalized) : strConcat(__recv, normalized); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.line = line;
  (() => { const __recv = sink; const __prop = __recv?.["sbAppend"]; if (typeof __prop === "function") return __prop(line); const __dyn = __recv?.table?.sbAppend; return __dyn ? __dyn(__recv.ref, line) : sbAppend(__recv, line); })();
  (() => { const __recv = sink; const __prop = __recv?.["sbAppend"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.sbAppend; return __dyn ? __dyn(__recv.ref, "\n") : sbAppend(__recv, "\n"); })();
  let braceCounts = fmtCountStructuralBraces(normalized); if (typeof __tuff_this !== 'undefined') __tuff_this.braceCounts = braceCounts;
  let opens = (() => { const __recv = braceCounts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(0); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 0) : vecGet(__recv, 0); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.opens = opens;
  let closes = (() => { const __recv = braceCounts; const __prop = __recv?.["vecGet"]; if (typeof __prop === "function") return __prop(1); const __dyn = __recv?.table?.vecGet; return __dyn ? __dyn(__recv.ref, 1) : vecGet(__recv, 1); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.closes = closes;
  let closesAfterPrefix = (closes - leadingCloses); if (typeof __tuff_this !== 'undefined') __tuff_this.closesAfterPrefix = closesAfterPrefix;
  if ((closesAfterPrefix < 0)) {
  closesAfterPrefix = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.closesAfterPrefix = closesAfterPrefix;
}
  let nextIndent = ((effectiveIndent + opens) - closesAfterPrefix); if (typeof __tuff_this !== 'undefined') __tuff_this.nextIndent = nextIndent;
  if ((nextIndent < 0)) {
  nextIndent = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.nextIndent = nextIndent;
}
  return nextIndent;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtEmitProcessedLine = fmtEmitProcessedLine;

const __tuff_outer_for_fmtStage1Split = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function fmtStage1Split(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_fmtStage1Split };
  let sink = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sink = sink;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = source; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  let inLineComment = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inLineComment = inLineComment;
  let inBlockComment = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inBlockComment = inBlockComment;
  let inString = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inString = inString;
  let inChar = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inChar = inChar;
  while ((i < len)) {
  let ch = (() => { const __recv = source; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((inLineComment === 1)) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sbAppendChar(__recv, (0 + ch)); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((ch === 10)) {
  inLineComment = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inLineComment = inLineComment;
}
  continue;
}
  if ((inBlockComment === 1)) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sbAppendChar(__recv, (0 + ch)); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((((ch === 42) && (i < len)) && ((() => { const __recv = source; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })() === 47))) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop(47); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, 47) : sbAppendChar(__recv, 47); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  inBlockComment = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inBlockComment = inBlockComment;
}
  continue;
}
  if ((inString === 1)) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sbAppendChar(__recv, (0 + ch)); })();
  if (((ch === 92) && ((i + 1) < len))) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + (() => { const __recv = source; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })())); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + (() => { const __recv = source; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })())) : sbAppendChar(__recv, (0 + (() => { const __recv = source; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })())); })();
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((ch === 34)) {
  inString = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inString = inString;
}
  continue;
}
  if ((inChar === 1)) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sbAppendChar(__recv, (0 + ch)); })();
  if (((ch === 92) && ((i + 1) < len))) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + (() => { const __recv = source; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })())); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + (() => { const __recv = source; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })())) : sbAppendChar(__recv, (0 + (() => { const __recv = source; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })())); })();
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((ch === 39)) {
  inChar = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.inChar = inChar;
}
  continue;
}
  if ((((ch === 47) && ((i + 1) < len)) && ((() => { const __recv = source; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })() === 47))) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppend"]; if (typeof __prop === "function") return __prop("//"); const __dyn = __recv?.table?.sbAppend; return __dyn ? __dyn(__recv.ref, "//") : sbAppend(__recv, "//"); })();
  inLineComment = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.inLineComment = inLineComment;
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((((ch === 47) && ((i + 1) < len)) && ((() => { const __recv = source; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop((i + 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, (i + 1)) : strCharAt(__recv, (i + 1)); })() === 42))) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppend"]; if (typeof __prop === "function") return __prop("/*"); const __dyn = __recv?.table?.sbAppend; return __dyn ? __dyn(__recv.ref, "/*") : sbAppend(__recv, "/*"); })();
  inBlockComment = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.inBlockComment = inBlockComment;
  i = (i + 2); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 34)) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sbAppendChar(__recv, (0 + ch)); })();
  inString = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.inString = inString;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 39)) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sbAppendChar(__recv, (0 + ch)); })();
  inChar = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.inChar = inChar;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 13)) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 59)) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sbAppendChar(__recv, (0 + ch)); })();
  (() => { const __recv = sink; const __prop = __recv?.["sbAppend"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.sbAppend; return __dyn ? __dyn(__recv.ref, "\n") : sbAppend(__recv, "\n"); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 123)) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sbAppendChar(__recv, (0 + ch)); })();
  (() => { const __recv = sink; const __prop = __recv?.["sbAppend"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.sbAppend; return __dyn ? __dyn(__recv.ref, "\n") : sbAppend(__recv, "\n"); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 125)) {
  (() => { const __recv = sink; const __prop = __recv?.["sbAppend"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.sbAppend; return __dyn ? __dyn(__recv.ref, "\n") : sbAppend(__recv, "\n"); })();
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sbAppendChar(__recv, (0 + ch)); })();
  (() => { const __recv = sink; const __prop = __recv?.["sbAppend"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.sbAppend; return __dyn ? __dyn(__recv.ref, "\n") : sbAppend(__recv, "\n"); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  (() => { const __recv = sink; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sbAppendChar(__recv, (0 + ch)); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  return (() => { const __recv = sink; const __prop = __recv?.["sbBuild"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.sbBuild; return __dyn ? __dyn(__recv.ref) : sbBuild(__recv); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.fmtStage1Split = fmtStage1Split;

const __tuff_outer_for_formatTuffSourceImpl = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function formatTuffSourceImpl(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_formatTuffSourceImpl };
  let stage1 = fmtStage1Split(source); if (typeof __tuff_this !== 'undefined') __tuff_this.stage1 = stage1;
  let sink = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.sink = sink;
  let lineSb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.lineSb = lineSb;
  let indent = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.indent = indent;
  let i = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let len = (() => { const __recv = stage1; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.len = len;
  while ((i < len)) {
  let ch = (() => { const __recv = stage1; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(i); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, i) : strCharAt(__recv, i); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.ch = ch;
  if ((ch === 13)) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  if ((ch === 10)) {
  let line = (() => { const __recv = lineSb; const __prop = __recv?.["sbBuild"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.sbBuild; return __dyn ? __dyn(__recv.ref) : sbBuild(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.line = line;
  lineSb = sbNew(); if (typeof __tuff_this !== 'undefined') __tuff_this.lineSb = lineSb;
  indent = fmtEmitProcessedLine(sink, line, indent); if (typeof __tuff_this !== 'undefined') __tuff_this.indent = indent;
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  continue;
}
  (() => { const __recv = lineSb; const __prop = __recv?.["sbAppendChar"]; if (typeof __prop === "function") return __prop((0 + ch)); const __dyn = __recv?.table?.sbAppendChar; return __dyn ? __dyn(__recv.ref, (0 + ch)) : sbAppendChar(__recv, (0 + ch)); })();
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  let tail = (() => { const __recv = lineSb; const __prop = __recv?.["sbBuild"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.sbBuild; return __dyn ? __dyn(__recv.ref) : sbBuild(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.tail = tail;
  fmtEmitProcessedLine(sink, tail, indent);
  let result = (() => { const __recv = sink; const __prop = __recv?.["sbBuild"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.sbBuild; return __dyn ? __dyn(__recv.ref) : sbBuild(__recv); })(); if (typeof __tuff_this !== 'undefined') __tuff_this.result = result;
  if ((((() => { const __recv = result; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() > 0) && ((() => { const __recv = result; const __prop = __recv?.["strCharAt"]; if (typeof __prop === "function") return __prop(((() => { const __recv = result; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() - 1)); const __dyn = __recv?.table?.strCharAt; return __dyn ? __dyn(__recv.ref, ((() => { const __recv = result; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() - 1)) : strCharAt(__recv, ((() => { const __recv = result; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() - 1)); })() === 10))) {
  return result;
}
  return (() => { const __recv = result; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\n"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\n") : strConcat(__recv, "\n"); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.formatTuffSourceImpl = formatTuffSourceImpl;

const __tuff_outer_for_selfhostFormatterImplMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostFormatterImplMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostFormatterImplMarker };
  return 0;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostFormatterImplMarker = selfhostFormatterImplMarker;

const __tuff_outer_for_formatTuffSource = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function formatTuffSource(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_formatTuffSource };
  return formatTuffSourceImpl(source);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.formatTuffSource = formatTuffSource;

const __tuff_outer_for_selfhostFormatterMarker = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function selfhostFormatterMarker() {
  let __tuff_this = { this: __tuff_outer_for_selfhostFormatterMarker };
  return selfhostFormatterImplMarker();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.selfhostFormatterMarker = selfhostFormatterMarker;













const __tuff_outer_for_sanitizeMaxEffectiveLines = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function sanitizeMaxEffectiveLines(maxEffectiveLines) {
  let __tuff_this = { maxEffectiveLines: maxEffectiveLines, this: __tuff_outer_for_sanitizeMaxEffectiveLines };
  return (((maxEffectiveLines <= 0)) ? (() => {
    return 500;
  })() : (() => {
    return maxEffectiveLines;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.sanitizeMaxEffectiveLines = sanitizeMaxEffectiveLines;

const __tuff_outer_for_normalizeFlag = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function normalizeFlag(value) {
  let __tuff_this = { value: value, this: __tuff_outer_for_normalizeFlag };
  return (((value === 0)) ? (() => {
    return 0;
  })() : (() => {
    return 1;
  })());
}
if (typeof __tuff_this !== 'undefined') __tuff_this.normalizeFlag = normalizeFlag;

const __tuff_outer_for_withCRuntimePrelude = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function withCRuntimePrelude(source, target) {
  let __tuff_this = { source: source, target: target, this: __tuff_outer_for_withCRuntimePrelude };
  if (((!(() => { const __recv = target; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("c"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "c") : strEq(__recv, "c"); })()) && (!(() => { const __recv = target; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("c-split"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "c-split") : strEq(__recv, "c-split"); })()))) {
  return source;
}
  if ((() => { const __recv = source; const __prop = __recv?.["strIncludes"]; if (typeof __prop === "function") return __prop("fn tuff_runtime_panic("); const __dyn = __recv?.table?.strIncludes; return __dyn ? __dyn(__recv.ref, "fn tuff_runtime_panic(") : strIncludes(__recv, "fn tuff_runtime_panic("); })()) {
  return source;
}
  let prelude = __host_get_c_runtime_prelude_source(); if (typeof __tuff_this !== 'undefined') __tuff_this.prelude = prelude;
  if ((() => { const __recv = prelude; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) {
  return source;
}
  return (() => { const __recv = (() => { const __recv = source; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop("\n\n"); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, "\n\n") : strConcat(__recv, "\n\n"); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(prelude); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, prelude) : strConcat(__recv, prelude); })();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.withCRuntimePrelude = withCRuntimePrelude;

const __tuff_outer_for_emitTargetOutput = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function emitTargetOutput(typed, source, target) {
  let __tuff_this = { typed: typed, source: source, target: target, this: __tuff_outer_for_emitTargetOutput };
  if ((() => { const __recv = target; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("js"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "js") : strEq(__recv, "js"); })()) {
  return generateJs(typed);
}
  if ((() => { const __recv = target; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("c"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "c") : strEq(__recv, "c"); })()) {
  return generateC(typed, __host_get_c_substrate());
}
  if ((() => { const __recv = target; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("c-split"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "c-split") : strEq(__recv, "c-split"); })()) {
  return generateC(typed, __host_get_c_substrate());
}
  if ((() => { const __recv = target; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("tuff"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "tuff") : strEq(__recv, "tuff"); })()) {
  return emitTuffFromTyped(typed, source, lexTakeTrivia());
}
  panicWithCode("E_UNSUPPORTED_TARGET", (() => { const __recv = "Unsupported codegen target: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(target); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, target) : strConcat(__recv, target); })(), "The compiler was asked to emit code for a target that is not implemented.", "Use target 'js', target 'c', target 'c-split', or target 'tuff'.");
  return "";
}
if (typeof __tuff_this !== 'undefined') __tuff_this.emitTargetOutput = emitTargetOutput;

const __tuff_outer_for_compileSourceWithOptions = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function compileSourceWithOptions(source, lintEnabled, maxEffectiveLines, borrowEnabled, target, astDupEnabled) {
  let __tuff_this = { source: source, lintEnabled: lintEnabled, maxEffectiveLines: maxEffectiveLines, borrowEnabled: borrowEnabled, target: target, astDupEnabled: astDupEnabled, this: __tuff_outer_for_compileSourceWithOptions };
  let tStart = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.tStart = tStart;
  let effectiveSource = withCRuntimePrelude(source, target); if (typeof __tuff_this !== 'undefined') __tuff_this.effectiveSource = effectiveSource;
  let maxLines = sanitizeMaxEffectiveLines(maxEffectiveLines); if (typeof __tuff_this !== 'undefined') __tuff_this.maxLines = maxLines;
  let lint = normalizeFlag(lintEnabled); if (typeof __tuff_this !== 'undefined') __tuff_this.lint = lint;
  let borrow = normalizeFlag(borrowEnabled); if (typeof __tuff_this !== 'undefined') __tuff_this.borrow = borrow;
  lintReset();
  let t0 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t0 = t0;
  lexInit(effectiveSource);
  lexAll();
  let t1 = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t1 = t1;
  profileMark("lex", (t1 - t0));
  let t1Parse = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t1Parse = t1Parse;
  parseInit();
  let program = pParseProgram(); if (typeof __tuff_this !== 'undefined') __tuff_this.program = program;
  let t2Parse = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2Parse = t2Parse;
  profileMark("parse", (t2Parse - t1Parse));
  let t2Desugar = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t2Desugar = t2Desugar;
  let desugared = desugar(program); if (typeof __tuff_this !== 'undefined') __tuff_this.desugared = desugared;
  let t3Desugar = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t3Desugar = t3Desugar;
  profileMark("desugar", (t3Desugar - t2Desugar));
  let t3Resolve = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t3Resolve = t3Resolve;
  let resolvedResultAny = resolveNames(desugared); if (typeof __tuff_this !== 'undefined') __tuff_this.resolvedResultAny = resolvedResultAny;
  if ((resolvedResultAny && resolvedResultAny.__tag === "Err")) {
  panic((() => { const __recv = "Resolver error: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(resolvedResultAny.error.message); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, resolvedResultAny.error.message) : strConcat(__recv, resolvedResultAny.error.message); })());
}
  let resolved = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.resolved = resolved;
  if ((resolvedResultAny && resolvedResultAny.__tag === "Ok")) {
  resolved = resolvedResultAny.value; if (typeof __tuff_this !== 'undefined') __tuff_this.resolved = resolved;
} else {
  panic("Resolver returned unexpected result variant");
}
  let t4Resolve = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t4Resolve = t4Resolve;
  profileMark("resolve", (t4Resolve - t3Resolve));
  let t4Typecheck = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t4Typecheck = t4Typecheck;
  let typedResultAny = typecheckProgramWithOptions(resolved); if (typeof __tuff_this !== 'undefined') __tuff_this.typedResultAny = typedResultAny;
  if ((typedResultAny && typedResultAny.__tag === "Err")) {
  panic((() => { const __recv = "Typechecker error: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(typedResultAny.error.message); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, typedResultAny.error.message) : strConcat(__recv, typedResultAny.error.message); })());
}
  let typed = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.typed = typed;
  if ((typedResultAny && typedResultAny.__tag === "Ok")) {
  typed = typedResultAny.value; if (typeof __tuff_this !== 'undefined') __tuff_this.typed = typed;
} else {
  panic("Typechecker returned unexpected result variant");
}
  let t5Typecheck = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t5Typecheck = t5Typecheck;
  profileMark("typecheck", (t5Typecheck - t4Typecheck));
  let t5Borrow = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t5Borrow = t5Borrow;
  if ((borrow === 1)) {
  borrowcheckProgram(typed);
}
  let t6Borrow = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t6Borrow = t6Borrow;
  profileMark("borrowcheck", (t6Borrow - t5Borrow));
  if ((lint === 1)) {
  lintProgram(typed, "<memory>", maxLines, 1, astDupEnabled);
}
  let t6Emit = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t6Emit = t6Emit;
  let output = emitTargetOutput(typed, effectiveSource, target); if (typeof __tuff_this !== 'undefined') __tuff_this.output = output;
  let t7Emit = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.t7Emit = t7Emit;
  profileMark("emit", (t7Emit - t6Emit));
  let tEnd = perfNow(); if (typeof __tuff_this !== 'undefined') __tuff_this.tEnd = tEnd;
  profileMark("total", (tEnd - tStart));
  return output;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.compileSourceWithOptions = compileSourceWithOptions;

const __tuff_outer_for_takeLintIssues = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function takeLintIssues() {
  let __tuff_this = { this: __tuff_outer_for_takeLintIssues };
  return lintTakeIssues();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.takeLintIssues = takeLintIssues;

const __tuff_outer_for_formatSourceTuff = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function formatSourceTuff(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_formatSourceTuff };
  return formatTuffSource(source);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.formatSourceTuff = formatSourceTuff;

const __tuff_outer_for_cpdLexInit = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpdLexInit(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_cpdLexInit };
  return lexInit(source);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpdLexInit = cpdLexInit;

const __tuff_outer_for_cpdLexAll = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpdLexAll() {
  let __tuff_this = { this: __tuff_outer_for_cpdLexAll };
  return lexAll();
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpdLexAll = cpdLexAll;

const __tuff_outer_for_cpdTokKind = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpdTokKind(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_cpdTokKind };
  return tokKind(idx);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpdTokKind = cpdTokKind;

const __tuff_outer_for_cpdTokValue = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpdTokValue(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_cpdTokValue };
  return tokValue(idx);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpdTokValue = cpdTokValue;

const __tuff_outer_for_cpdTokLine = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpdTokLine(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_cpdTokLine };
  return tokLine(idx);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpdTokLine = cpdTokLine;

const __tuff_outer_for_cpdTokCol = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpdTokCol(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_cpdTokCol };
  return tokCol(idx);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpdTokCol = cpdTokCol;

const __tuff_outer_for_cpdGetInternedStr = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function cpdGetInternedStr(idx) {
  let __tuff_this = { idx: idx, this: __tuff_outer_for_cpdGetInternedStr };
  return getInternedStr(idx);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.cpdGetInternedStr = cpdGetInternedStr;

const __tuff_outer_for_compileSource = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function compileSource(source) {
  let __tuff_this = { source: source, this: __tuff_outer_for_compileSource };
  return compileSourceWithOptions(source, 0, 500, 1, "js", 0);
}
if (typeof __tuff_this !== 'undefined') __tuff_this.compileSource = compileSource;

const __tuff_outer_for_mainLint = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function mainLint() {
  let __tuff_this = { this: __tuff_outer_for_mainLint };
  let argc = getArgc(); if (typeof __tuff_this !== 'undefined') __tuff_this.argc = argc;
  if ((argc < 3)) {
  printError("Usage: tuffc lint <input.tuff> [--strict] [--ast-dup|--no-ast-dup] [--max-lines <n>] [--target <js|c>]");
  return 1;
}
  let inputFile = getArgv(2); if (typeof __tuff_this !== 'undefined') __tuff_this.inputFile = inputFile;
  let target = "js"; if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let maxLines = 500; if (typeof __tuff_this !== 'undefined') __tuff_this.maxLines = maxLines;
  let astDupEnabled = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.astDupEnabled = astDupEnabled;
  let strict = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.strict = strict;
  let borrowEnabled = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.borrowEnabled = borrowEnabled;
  let i = 3; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let hadError = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.hadError = hadError;
  while ((i < argc)) {
  let arg = getArgv(i); if (typeof __tuff_this !== 'undefined') __tuff_this.arg = arg;
  if ((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--strict"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--strict") : strEq(__recv, "--strict"); })()) {
  strict = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.strict = strict;
} else { if ((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--ast-dup"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--ast-dup") : strEq(__recv, "--ast-dup"); })()) {
  astDupEnabled = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.astDupEnabled = astDupEnabled;
} else { if ((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--no-ast-dup"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--no-ast-dup") : strEq(__recv, "--no-ast-dup"); })()) {
  astDupEnabled = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.astDupEnabled = astDupEnabled;
} else { if ((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--max-lines"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--max-lines") : strEq(__recv, "--max-lines"); })()) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((i < argc)) {
  maxLines = parseInt(getArgv(i)); if (typeof __tuff_this !== 'undefined') __tuff_this.maxLines = maxLines;
  if ((maxLines <= 0)) {
  printError("Invalid value for --max-lines");
  hadError = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.hadError = hadError;
}
} else {
  printError("Missing value for --max-lines");
  hadError = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.hadError = hadError;
}
} else { if ((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--target"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--target") : strEq(__recv, "--target"); })()) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((i < argc)) {
  target = getArgv(i); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
} else {
  printError("Missing value for --target");
  hadError = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.hadError = hadError;
}
} else {
  printError((() => { const __recv = "Unknown lint option: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(arg); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, arg) : strConcat(__recv, arg); })());
  hadError = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.hadError = hadError;
} } } } }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  if ((hadError === 1)) {
  return 1;
}
  let scratchOutput = "C:\\\\Windows\\\\Temp\\\\tuff-lint-scratch.js"; if (typeof __tuff_this !== 'undefined') __tuff_this.scratchOutput = scratchOutput;
  let resultCode = compileFileWithOptions(inputFile, scratchOutput, 1, maxLines, borrowEnabled, target, astDupEnabled); if (typeof __tuff_this !== 'undefined') __tuff_this.resultCode = resultCode;
  let issues = takeLintIssues(); if (typeof __tuff_this !== 'undefined') __tuff_this.issues = issues;
  if (((() => { const __recv = issues; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() > 0)) {
  printError((() => { const __recv = "[lint] "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(issues); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, issues) : strConcat(__recv, issues); })());
  if ((strict === 1)) {
  resultCode = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.resultCode = resultCode;
}
} else {
  print("No lint issues found.");
}
  return resultCode;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.mainLint = mainLint;

const __tuff_outer_for_main = typeof __tuff_this !== 'undefined' ? __tuff_this : undefined;
function main() {
  let __tuff_this = { this: __tuff_outer_for_main };
  let argc = getArgc(); if (typeof __tuff_this !== 'undefined') __tuff_this.argc = argc;
  if ((argc < 2)) {
  printError("Usage: tuffc <input.tuff> -o <output> [--target <js|c|c-split|tuff>] [--module-base <dir> (legacy)]");
  return 1;
}
  let firstArg = getArgv(1); if (typeof __tuff_this !== 'undefined') __tuff_this.firstArg = firstArg;
  if ((() => { const __recv = firstArg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("lint"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "lint") : strEq(__recv, "lint"); })()) {
  return mainLint();
}
  if ((() => { const __recv = firstArg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--version"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--version") : strEq(__recv, "--version"); })()) {
  print("tuffc (stage3 native)");
  return 0;
}
  if (((() => { const __recv = firstArg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("-h"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "-h") : strEq(__recv, "-h"); })() || (() => { const __recv = firstArg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--help"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--help") : strEq(__recv, "--help"); })())) {
  print("Usage: tuffc <input.tuff> -o <output> [--target <js|c|c-split|tuff>] [--module-base <dir> (legacy)] [--version]");
  return 0;
}
  let inputFile = firstArg; if (typeof __tuff_this !== 'undefined') __tuff_this.inputFile = inputFile;
  let outputFile = ""; if (typeof __tuff_this !== 'undefined') __tuff_this.outputFile = outputFile;
  let target = "js"; if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
  let lintEnabled = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.lintEnabled = lintEnabled;
  let lintAstDupEnabled = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstDupEnabled = lintAstDupEnabled;
  let borrowEnabled = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.borrowEnabled = borrowEnabled;
  let profileEnabled = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.profileEnabled = profileEnabled;
  let i = 2; if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  let hadError = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.hadError = hadError;
  while ((i < argc)) {
  let arg = getArgv(i); if (typeof __tuff_this !== 'undefined') __tuff_this.arg = arg;
  if (((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("-o"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "-o") : strEq(__recv, "-o"); })() || (() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--out"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--out") : strEq(__recv, "--out"); })())) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((i < argc)) {
  outputFile = getArgv(i); if (typeof __tuff_this !== 'undefined') __tuff_this.outputFile = outputFile;
} else {
  printError("Missing value for -o/--out");
  hadError = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.hadError = hadError;
}
} else { if ((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--target"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--target") : strEq(__recv, "--target"); })()) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((i < argc)) {
  target = getArgv(i); if (typeof __tuff_this !== 'undefined') __tuff_this.target = target;
} else {
  printError("Missing value for --target");
  hadError = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.hadError = hadError;
}
} else { if ((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--lint"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--lint") : strEq(__recv, "--lint"); })()) {
  lintEnabled = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.lintEnabled = lintEnabled;
} else { if ((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--no-lint-ast-dup"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--no-lint-ast-dup") : strEq(__recv, "--no-lint-ast-dup"); })()) {
  lintAstDupEnabled = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.lintAstDupEnabled = lintAstDupEnabled;
} else { if ((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--profile"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--profile") : strEq(__recv, "--profile"); })()) {
  profileEnabled = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.profileEnabled = profileEnabled;
} else { if ((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--no-borrowcheck"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--no-borrowcheck") : strEq(__recv, "--no-borrowcheck"); })()) {
  borrowEnabled = 0; if (typeof __tuff_this !== 'undefined') __tuff_this.borrowEnabled = borrowEnabled;
} else { if (((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--modules"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--modules") : strEq(__recv, "--modules"); })() || (() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--no-modules"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--no-modules") : strEq(__recv, "--no-modules"); })())) {
  printError((() => { const __recv = (() => { const __recv = "Legacy option: "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(arg); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, arg) : strConcat(__recv, arg); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(". Module graph loading is always enabled for file compilation; remove this option."); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, ". Module graph loading is always enabled for file compilation; remove this option.") : strConcat(__recv, ". Module graph loading is always enabled for file compilation; remove this option."); })());
  hadError = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.hadError = hadError;
} else { if ((() => { const __recv = arg; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop("--module-base"); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "--module-base") : strEq(__recv, "--module-base"); })()) {
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
  if ((i >= argc)) {
  printError("Missing value for --module-base");
  hadError = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.hadError = hadError;
}
} } } } } } } }
  i = (i + 1); if (typeof __tuff_this !== 'undefined') __tuff_this.i = i;
}
  if ((hadError === 1)) {
  return 1;
}
  if ((() => { const __recv = outputFile; const __prop = __recv?.["strEq"]; if (typeof __prop === "function") return __prop(""); const __dyn = __recv?.table?.strEq; return __dyn ? __dyn(__recv.ref, "") : strEq(__recv, ""); })()) {
  printError("Missing required -o/--out <output_file>. Native selfhost CLI writes compiled output to a file.");
  return 1;
}
  let resultCode = compileFileWithOptions(inputFile, outputFile, lintEnabled, 500, borrowEnabled, target, lintAstDupEnabled); if (typeof __tuff_this !== 'undefined') __tuff_this.resultCode = resultCode;
  if ((resultCode === 0)) {
  print((() => { const __recv = (() => { const __recv = (() => { const __recv = "Compiled "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(inputFile); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, inputFile) : strConcat(__recv, inputFile); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(" -> "); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, " -> ") : strConcat(__recv, " -> "); })(); const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(outputFile); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, outputFile) : strConcat(__recv, outputFile); })());
}
  if ((lintEnabled === 1)) {
  let issues = takeLintIssues(); if (typeof __tuff_this !== 'undefined') __tuff_this.issues = issues;
  if (((() => { const __recv = issues; const __prop = __recv?.["strLength"]; if (typeof __prop === "function") return __prop(); const __dyn = __recv?.table?.strLength; return __dyn ? __dyn(__recv.ref) : strLength(__recv); })() > 0)) {
  printError((() => { const __recv = "[lint] "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(issues); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, issues) : strConcat(__recv, issues); })());
  resultCode = 1; if (typeof __tuff_this !== 'undefined') __tuff_this.resultCode = resultCode;
}
}
  if ((profileEnabled === 1)) {
  printError((() => { const __recv = "[profile] "; const __prop = __recv?.["strConcat"]; if (typeof __prop === "function") return __prop(profileTakeJson()); const __dyn = __recv?.table?.strConcat; return __dyn ? __dyn(__recv.ref, profileTakeJson()) : strConcat(__recv, profileTakeJson()); })());
}
  return resultCode;
}
if (typeof __tuff_this !== 'undefined') __tuff_this.main = main;

