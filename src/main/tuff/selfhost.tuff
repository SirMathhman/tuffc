/**
 * Self-hosted Tuff compiler.
 * Compiles Tuff source to JavaScript.
 *
 * Uses extern functions for string/array/map operations.
 */

// ============================================================================
// Extern declarations - these come from runtime.js
// ============================================================================

extern fn str_length(this: *Str) : USize;

// Why do we have two of these?
extern fn str_char_at(this: *Str, i: I32) : Char;

extern fn str_slice(this: *Str, start: I32, end: I32) : *Str;
extern fn str_concat(this: *Str, b: *Str) : *Str;
extern fn str_eq(this: *Str, b: *Str) : Bool;
extern fn str_from_char_code(code: I32) : *Str;
extern fn str_index_of(this: *Str, needle: *Str) : I32;
extern fn str_includes(this: *Str, needle: *Str) : Bool;
extern fn str_starts_with(this: *Str, prefix: *Str) : Bool;
extern fn str_trim(this: *Str) : *Str;
extern fn str_replace_all(this: *Str, from: *Str, to: *Str) : *Str;
extern fn char_code(ch: *Str) : I32;
extern fn int_to_string(n: I32) : *Str;
extern fn parse_int(s: *Str) : I32;

extern type StringBuilder;
extern fn sb_new() : StringBuilder;
extern fn sb_append(sb: StringBuilder, s: *Str) : StringBuilder;
extern fn sb_append_char(sb: StringBuilder, code: Char) : StringBuilder;
extern fn sb_build(sb: StringBuilder) : *Str;

extern type Vec<T>;
extern fn vec_new() : Vec<T>;
extern fn vec_push(this: Vec<T>, item: T) : Vec<T>;
extern fn vec_pop(this: Vec<T>) : I32;
extern fn vec_get(this: Vec<T>, i: I32) : T;
extern fn vec_set(this: Vec<T>, i: I32, v: T) : Vec<T>;
extern fn vec_length(this: Vec<T>) : I32;
extern fn vec_clear(this: Vec<T>) : Vec<T>;
extern fn vec_join(this: Vec<T>, sep: *Str) : *Str;
extern fn vec_includes(this: Vec<T>, item: T) : Bool;

extern type Map<K, V>;
extern fn map_new() : Map<K, V>;
extern fn map_set(this: Map<K, V>, k: K, v: V) : Map<K, V>;
extern fn map_get(this: Map<K, V>, k: K) : I32;
extern fn map_has(this: Map<K, V>, k: K) : Bool;

extern type Set<T>;
extern fn set_new() : Set<T>;
extern fn set_add(this: Set<T>, item: T) : Set<T>;
extern fn set_has(this: Set<T>, item: T) : Bool;
extern fn set_delete(this: Set<T>, item: T) : Bool;

extern fn read_file(filePath: *Str) : *Str;
extern fn write_file(filePath: *Str, contents: *Str) : I32;
extern fn path_join(a: *Str, b: *Str) : *Str;
extern fn path_dirname(p: *Str) : *Str;

extern fn print(s: *Str) : I32;
extern fn print_error(s: *Str) : I32;
extern fn panic(msg: *Str) : I32;
extern fn panic_with_code(code: *Str, msg: *Str, reason: *Str, fix: *Str) : I32;

// ============================================================================
// Token Kinds
// ============================================================================

let TK_EOF : I32 = 0;
let TK_KEYWORD : I32 = 1;
let TK_IDENTIFIER : I32 = 2;
let TK_NUMBER : I32 = 3;
let TK_STRING : I32 = 4;
let TK_BOOL : I32 = 5;
let TK_SYMBOL : I32 = 6;
let TK_CHAR : I32 = 7;

// ============================================================================
// Token structure - array-based representation
// Tokens are stored as indices into arrays.
// tok_kinds[i], tok_values[i], tok_lines[i], tok_cols[i]
// ============================================================================

let tok_kinds : Vec<I32> = vec_new();
let tok_values : Vec<I32> = vec_new();
let tok_lines : Vec<I32> = vec_new();
let tok_cols : Vec<I32> = vec_new();
let tok_count : I32 = 0;

fn tok_add(kind: I32, value: I32, line: I32, col: I32) : I32 => {
    let idx = tok_count;
    tok_kinds.vec_push(kind);
    tok_values.vec_push(value);
    tok_lines.vec_push(line);
    tok_cols.vec_push(col);
    tok_count = tok_count + 1;
    idx
}

fn tok_kind(idx: I32) : I32 => tok_kinds.vec_get(idx);
fn tok_value(idx: I32) : I32 => tok_values.vec_get(idx);

// String intern table - stores strings by index for reverse lookup
let intern_table : Vec<*Str> = vec_new();
let intern_map : Map = map_new();

fn intern(s: *Str) : I32 => {
    if (intern_map.map_has(s)) {
        intern_map.map_get(s)
    } else {
        let idx = intern_table.vec_length();
        intern_table.vec_push(s);
        intern_map.map_set(s, idx);
        idx
    }
}

fn get_intern(idx: I32) : *Str => {
    intern_table.vec_get(idx)
}

// Keywords set
let keywords : Set = set_new();

fn init_keywords() : I32 => {
    keywords.set_add("fn");
    keywords.set_add("let");
    keywords.set_add("struct");
    keywords.set_add("enum");
    keywords.set_add("type");
    keywords.set_add("match");
    keywords.set_add("case");
    keywords.set_add("if");
    keywords.set_add("else");
    keywords.set_add("for");
    keywords.set_add("while");
    keywords.set_add("loop");
    keywords.set_add("in");
    keywords.set_add("return");
    keywords.set_add("break");
    keywords.set_add("continue");
    keywords.set_add("is");
    keywords.set_add("class");
    keywords.set_add("object");
    keywords.set_add("impl");
    keywords.set_add("with");
    keywords.set_add("out");
    keywords.set_add("module");
    keywords.set_add("extern");
    keywords.set_add("async");
    0
}

fn is_keyword(s: *Str) : Bool => keywords.set_has(s);

// ============================================================================
// Lexer
// ============================================================================

let lex_source : *Str = "";
let lex_pos : I32 = 0;
let lex_line : I32 = 1;
let lex_col : I32 = 1;
let lex_len : USize = 0;

fn lex_init(source: *Str) : I32 => {
    lex_source = source;
    lex_pos = 0;
    lex_line = 1;
    lex_col = 1;
    lex_len = source.str_length();
    // Clear token arrays for fresh compilation
    tok_kinds.vec_clear();
    tok_values.vec_clear();
    tok_lines.vec_clear();
    tok_cols.vec_clear();
    tok_count = 0;
    0
}

fn lex_peek(offset: I32) : I32 => {
    let p = lex_pos + offset;
    if (p >= lex_len) {
        0
    } else {
        lex_source.str_char_at(p)
    }
}

fn lex_advance() : I32 => {
    let ch = lex_peek(0);
    lex_pos = lex_pos + 1;
    if (ch == 10) {
        lex_line = lex_line + 1;
        lex_col = 1;
        ch
    } else {
        lex_col = lex_col + 1;
        ch
    }
}

fn is_alpha(ch: I32) : Bool => {
    if (ch >= 65 && ch <= 90) { true }
    else if (ch >= 97 && ch <= 122) { true }
    else if (ch == 95) { true }
    else { false }
}

fn is_digit(ch: I32) : Bool => ch >= 48 && ch <= 57;

fn is_alnum(ch: I32) : Bool => is_alpha(ch) || is_digit(ch);

fn is_whitespace(ch: I32) : Bool => {
    ch == 32 || ch == 9 || ch == 13 || ch == 10
}

fn lex_read_ident() : *Str => {
    let sb = sb_new();
    while (is_alnum(lex_peek(0))) {
        sb_append_char(sb, lex_advance());
    }
    sb_build(sb)
}

fn lex_read_number() : *Str => {
    let sb = sb_new();
    // Handle 0x, 0b, 0o
    if (lex_peek(0) == 48) {
        let next = lex_peek(1);
        if (next == 120 || next == 98 || next == 111) {
            sb_append_char(sb, lex_advance());
            sb_append_char(sb, lex_advance());
            while (is_alnum(lex_peek(0)) || lex_peek(0) == 95) {
                let ch = lex_advance();
                if (ch != 95) {
                    sb_append_char(sb, ch);
                }
            }
            return sb_build(sb);
        }
    }
    while (is_digit(lex_peek(0)) || lex_peek(0) == 95) {
        let ch = lex_advance();
        if (ch != 95) {
            sb_append_char(sb, ch);
        }
    }
    if (lex_peek(0) == 46 && is_digit(lex_peek(1))) {
        sb_append_char(sb, lex_advance());
        while (is_digit(lex_peek(0)) || lex_peek(0) == 95) {
            let ch = lex_advance();
            if (ch != 95) {
                sb_append_char(sb, ch);
            }
        }
    }
    sb_build(sb)
}

fn lex_read_string() : *Str => {
    lex_advance();  // skip opening "
    let sb = sb_new();
    while (lex_pos < lex_len && lex_peek(0) != 34) {
        if (lex_peek(0) == 92) {
            sb_append_char(sb, lex_advance());
            sb_append_char(sb, lex_advance());
        } else {
            sb_append_char(sb, lex_advance());
        }
    }
    if (lex_peek(0) != 34) {
        panic("Unterminated string");
    }
    lex_advance();  // skip closing "
    sb_build(sb)
}

fn lex_read_char() : *Str => {
    lex_advance();  // skip opening '
    let sb = sb_new();
    while (lex_pos < lex_len && lex_peek(0) != 39) {
        sb_append_char(sb, lex_advance());
    }
    if (lex_peek(0) != 39) {
        panic("Unterminated char");
    }
    lex_advance();  // skip closing '
    sb_build(sb)
}

fn lex_check_two(a: I32, b: I32) : Bool => {
    lex_peek(0) == a && lex_peek(1) == b
}

fn lex_all() : I32 => {
    init_keywords();
    
    while (lex_pos < lex_len) {
        let ch = lex_peek(0);
        
        // Skip whitespace
        if (is_whitespace(ch)) {
            lex_advance();
            continue;
        }
        
        // Line comment
        if (ch == 47 && lex_peek(1) == 47) {
            while (lex_pos < lex_len && lex_peek(0) != 10) {
                lex_advance();
            }
            continue;
        }
        
        // Block comment
        if (ch == 47 && lex_peek(1) == 42) {
            lex_advance();
            lex_advance();
            while (lex_pos < lex_len && !(lex_peek(0) == 42 && lex_peek(1) == 47)) {
                lex_advance();
            }
            if (lex_pos >= lex_len) {
                panic("Unterminated block comment");
            }
            lex_advance();
            lex_advance();
            continue;
        }
        
        let start_line = lex_line;
        let start_col = lex_col;
        
        // Three-char operators
        if (lex_peek(0) == 46 && lex_peek(1) == 46 && lex_peek(2) == 46) {
            lex_advance();
            lex_advance();
            lex_advance();
            tok_add(TK_SYMBOL, intern("..."), start_line, start_col);
            continue;
        }
        
        // Two-char operators
        if (lex_check_two(61, 62)) { lex_advance(); lex_advance(); tok_add(TK_SYMBOL, intern("=>"), start_line, start_col); continue; }
        if (lex_check_two(61, 61)) { lex_advance(); lex_advance(); tok_add(TK_SYMBOL, intern("=="), start_line, start_col); continue; }
        if (lex_check_two(33, 61)) { lex_advance(); lex_advance(); tok_add(TK_SYMBOL, intern("!="), start_line, start_col); continue; }
        if (lex_check_two(60, 61)) { lex_advance(); lex_advance(); tok_add(TK_SYMBOL, intern("<="), start_line, start_col); continue; }
        if (lex_check_two(62, 61)) { lex_advance(); lex_advance(); tok_add(TK_SYMBOL, intern(">="), start_line, start_col); continue; }
        if (lex_check_two(38, 38)) { lex_advance(); lex_advance(); tok_add(TK_SYMBOL, intern("&&"), start_line, start_col); continue; }
        if (lex_check_two(124, 124)) { lex_advance(); lex_advance(); tok_add(TK_SYMBOL, intern("||"), start_line, start_col); continue; }
        if (lex_check_two(58, 58)) { lex_advance(); lex_advance(); tok_add(TK_SYMBOL, intern("::"), start_line, start_col); continue; }
        if (lex_check_two(46, 46)) { lex_advance(); lex_advance(); tok_add(TK_SYMBOL, intern(".."), start_line, start_col); continue; }
        if (lex_check_two(124, 62)) { lex_advance(); lex_advance(); tok_add(TK_SYMBOL, intern("|>"), start_line, start_col); continue; }
        
        // Identifier or keyword
        if (is_alpha(ch)) {
            let text = lex_read_ident();
            if (text.str_eq("true")) {
                tok_add(TK_BOOL, 1, start_line, start_col);
            } else if (text.str_eq("false")) {
                tok_add(TK_BOOL, 0, start_line, start_col);
            } else if (is_keyword(text)) {
                tok_add(TK_KEYWORD, intern(text), start_line, start_col);
            } else {
                tok_add(TK_IDENTIFIER, intern(text), start_line, start_col);
            }
            continue;
        }
        
        // Number
        if (is_digit(ch)) {
            let text = lex_read_number();
            tok_add(TK_NUMBER, intern(text), start_line, start_col);
            continue;
        }
        
        // String
        if (ch == 34) {
            let text = lex_read_string();
            tok_add(TK_STRING, intern(text), start_line, start_col);
            continue;
        }
        
        // Char
        if (ch == 39) {
            let text = lex_read_char();
            tok_add(TK_CHAR, intern(text), start_line, start_col);
            continue;
        }
        
        // Single-char symbols
        if ("(){}[],:;+-*/%<>=.!?|&".str_includes(str_from_char_code(ch))) {
            lex_advance();
            tok_add(TK_SYMBOL, intern(str_from_char_code(ch)), start_line, start_col);
            continue;
        }
        
        panic("Unexpected character: ".str_concat(str_from_char_code(ch)));
    }
    
    tok_add(TK_EOF, intern("<eof>"), lex_line, lex_col);
    tok_count
}

// ============================================================================
// AST Node Kinds
// ============================================================================

let NK_PROGRAM : I32 = 1;
let NK_FN_DECL : I32 = 2;
let NK_STRUCT_DECL : I32 = 3;
let NK_TYPE_ALIAS : I32 = 4;
let NK_LET_DECL : I32 = 5;
let NK_IMPORT_DECL : I32 = 6;
let NK_EXPR_STMT : I32 = 7;
let NK_RETURN_STMT : I32 = 8;
let NK_IF_STMT : I32 = 9;
let NK_WHILE_STMT : I32 = 10;
let NK_FOR_STMT : I32 = 11;
let NK_BLOCK : I32 = 12;
let NK_ASSIGN_STMT : I32 = 13;
let NK_BREAK_STMT : I32 = 14;
let NK_CONTINUE_STMT : I32 = 15;
let NK_CLASS_FN_DECL : I32 = 16;
let NK_EXTERN_FN_DECL : I32 = 17;
let NK_EXTERN_LET_DECL : I32 = 18;
let NK_EXTERN_TYPE_DECL : I32 = 19;
let NK_ENUM_DECL : I32 = 60;

let NK_NUMBER_LIT : I32 = 20;
let NK_BOOL_LIT : I32 = 21;
let NK_STRING_LIT : I32 = 22;
let NK_CHAR_LIT : I32 = 23;
let NK_IDENTIFIER : I32 = 24;
let NK_BINARY_EXPR : I32 = 25;
let NK_UNARY_EXPR : I32 = 26;
let NK_CALL_EXPR : I32 = 27;
let NK_MEMBER_EXPR : I32 = 28;
let NK_INDEX_EXPR : I32 = 29;
let NK_STRUCT_INIT : I32 = 30;
let NK_IF_EXPR : I32 = 31;
let NK_MATCH_EXPR : I32 = 32;
let NK_IS_EXPR : I32 = 33;
let NK_UNWRAP_EXPR : I32 = 34;

let NK_NAMED_TYPE : I32 = 40;
let NK_POINTER_TYPE : I32 = 41;
let NK_ARRAY_TYPE : I32 = 42;
let NK_TUPLE_TYPE : I32 = 43;
let NK_REFINEMENT_TYPE : I32 = 44;
let NK_UNION_TYPE : I32 = 45;

let NK_WILDCARD_PAT : I32 = 50;
let NK_LITERAL_PAT : I32 = 51;
let NK_NAME_PAT : I32 = 52;
let NK_STRUCT_PAT : I32 = 53;

// ============================================================================
// AST Storage (array-based)
// ============================================================================

let node_kinds : Vec<I32> = vec_new();
let node_data1 : Vec<I32> = vec_new();  // Generic data slot 1
let node_data2 : Vec<I32> = vec_new();  // Generic data slot 2
let node_data3 : Vec<I32> = vec_new();  // Generic data slot 3
let node_data4 : Vec<I32> = vec_new();  // Generic data slot 4
let node_data5 : Vec<I32> = vec_new();  // Generic data slot 5
let node_count : I32 = 0;

fn node_new(kind: I32) : I32 => {
    let idx = node_count;
    node_kinds.vec_push(kind);
    node_data1.vec_push(0);
    node_data2.vec_push(0);
    node_data3.vec_push(0);
    node_data4.vec_push(0);
    node_data5.vec_push(0);
    node_count = node_count + 1;
    idx
}

fn node_kind(idx: I32) : I32 => node_kinds.vec_get(idx);

extern type AnyValue;
fn node_set_data1(idx: I32, v: AnyValue) : I32 => { node_data1.vec_set(idx, v); 0 }
fn node_set_data2(idx: I32, v: AnyValue) : I32 => { node_data2.vec_set(idx, v); 0 }
fn node_set_data3(idx: I32, v: AnyValue) : I32 => { node_data3.vec_set(idx, v); 0 }
fn node_set_data4(idx: I32, v: AnyValue) : I32 => { node_data4.vec_set(idx, v); 0 }
fn node_set_data5(idx: I32, v: AnyValue) : I32 => { node_data5.vec_set(idx, v); 0 }
fn node_get_data1(idx: I32) : I32 => node_data1.vec_get(idx);
fn node_get_data2(idx: I32) : I32 => node_data2.vec_get(idx);
fn node_get_data3(idx: I32) : I32 => node_data3.vec_get(idx);
fn node_get_data4(idx: I32) : I32 => node_data4.vec_get(idx);
fn node_get_data5(idx: I32) : I32 => node_data5.vec_get(idx);

// ============================================================================
// Parser
// ============================================================================

let parse_pos : I32 = 0;

fn parse_init() : I32 => {
    parse_pos = 0;
    // Clear node arrays for fresh compilation
    node_kinds.vec_clear();
    node_data1.vec_clear();
    node_data2.vec_clear();
    node_data3.vec_clear();
    node_data4.vec_clear();
    node_data5.vec_clear();
    node_count = 0;
    0
}

fn p_peek(offset: I32) : I32 => {
    let idx = parse_pos + offset;
    if (idx >= tok_count) {
        tok_count - 1
    } else {
        idx
    }
}

fn p_at_kind(kind: I32) : Bool => tok_kind(p_peek(0)) == kind;

fn p_at_value(val: *Str) : Bool => {
    let v = tok_value(p_peek(0));
    intern_map.map_has(val) && intern_map.map_get(val) == v
}

fn p_at(kind: I32, val: *Str) : Bool => p_at_kind(kind) && p_at_value(val);

fn p_eat() : I32 => {
    let t = p_peek(0);
    parse_pos = parse_pos + 1;
    t
}

fn p_expect_kind(kind: I32, msg: *Str) : I32 => {
    if (!p_at_kind(kind)) {
        panic(msg);
    }
    p_eat()
}

fn p_expect(kind: I32, val: *Str, msg: *Str) : I32 => {
    if (!p_at(kind, val)) {
        panic(msg);
    }
    p_eat()
}

fn p_parse_identifier() : I32 => {
    let t = p_expect_kind(TK_IDENTIFIER, "Expected identifier");
    tok_value(t)
}

// Note: No forward declarations needed - JS hoists functions

fn p_can_start_type_tok() : Bool => {
    if (p_at_kind(TK_IDENTIFIER)) { return true; }
    if (p_at(TK_SYMBOL, "*")) { return true; }
    if (p_at(TK_SYMBOL, "[")) { return true; }
    if (p_at(TK_SYMBOL, "(")) { return true; }
    false
}

fn p_can_start_type_tok_at(offset: I32) : Bool => {
    let idx = p_peek(offset);
    let k = tok_kind(idx);
    if (k == TK_IDENTIFIER) {
        return true;
    }
    if (k == TK_SYMBOL) {
        let s = get_intern(tok_value(idx));
        if (s.str_eq("*") || s.str_eq("[") || s.str_eq("(")) {
            return true;
        }
    }
    false
}

fn p_can_start_refinement_expr() : Bool => {
    if (p_at_kind(TK_NUMBER)) { return true; }
    if (p_at_kind(TK_IDENTIFIER)) { return true; }
    if (p_at_kind(TK_BOOL)) { return true; }
    if (p_at_kind(TK_STRING)) { return true; }
    if (p_at(TK_SYMBOL, "(")) { return true; }
    if (p_at(TK_SYMBOL, "-")) { return true; }
    if (p_at(TK_SYMBOL, "!")) { return true; }
    false
}

fn p_parse_type() : I32 => {
    // Pointer type
    if (p_at(TK_SYMBOL, "*")) {
        p_eat();
        let mutable = 0;
        if (p_at(TK_KEYWORD, "mut")) {
            p_eat();
            mutable = 1;
        }
        let inner = p_parse_type();
        let node = node_new(NK_POINTER_TYPE);
        node_set_data1(node, mutable);
        node_set_data2(node, inner);
        return node;
    }
    
    // Array type
    if (p_at(TK_SYMBOL, "[")) {
        p_eat();
        let elem = p_parse_type();
        let init = 0;
        let total = 0;
        if (p_at(TK_SYMBOL, ";")) {
            p_eat();
            init = p_parse_expression(0);
            p_expect(TK_SYMBOL, ";", "Expected ';' in array type");
            total = p_parse_expression(0);
        }
        p_expect(TK_SYMBOL, "]", "Expected ']'");
        let node = node_new(NK_ARRAY_TYPE);
        node_set_data1(node, elem);
        node_set_data2(node, init);
        node_set_data3(node, total);
        return node;
    }
    
    // Tuple type
    if (p_at(TK_SYMBOL, "(")) {
        p_eat();
        let members = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            members.vec_push(p_parse_type());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                members.vec_push(p_parse_type());
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')' in tuple type");
        let node = node_new(NK_TUPLE_TYPE);
        node_set_data1(node, members);
        return node;
    }
    
    // Named type with optional generics
    let name = p_parse_identifier();
    let generics = vec_new();
    
    // Handle :: path
    while (p_at(TK_SYMBOL, "::")) {
        p_eat();
        let part = p_parse_identifier();
        // Combine names - for now just track them
    }
    
    // Generic args
    if (p_at(TK_SYMBOL, "<") && p_can_start_type_tok_at(1)) {
        p_eat();
        if (!p_at(TK_SYMBOL, ">")) {
            generics.vec_push(p_parse_type());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                generics.vec_push(p_parse_type());
            }
        }
        p_expect(TK_SYMBOL, ">", "Expected '>' in generic args");
    }
    
    let type_node = node_new(NK_NAMED_TYPE);
    node_set_data1(type_node, name);
    node_set_data2(type_node, generics);
    
    // Refinement predicate
    let has_refine = p_at(TK_SYMBOL, "!=") || p_at(TK_SYMBOL, "<") || p_at(TK_SYMBOL, ">") || p_at(TK_SYMBOL, "<=") || p_at(TK_SYMBOL, ">=");
    if (has_refine && p_can_start_refinement_expr()) {
        let op = tok_value(p_eat());
        let val_expr = p_parse_expression(0);
        let refine = node_new(NK_REFINEMENT_TYPE);
        node_set_data1(refine, type_node);
        node_set_data2(refine, op);
        node_set_data3(refine, val_expr);
        type_node = refine;
    }
    
    // Union types
    while (p_at(TK_SYMBOL, "|") || p_at(TK_SYMBOL, "|>")) {
        let is_extract = 0;
        if (p_at(TK_SYMBOL, "|>")) {
            is_extract = 1;
        }
        p_eat();
        let right = p_parse_type();
        let union_node = node_new(NK_UNION_TYPE);
        node_set_data1(union_node, type_node);
        node_set_data2(union_node, right);
        node_set_data3(union_node, is_extract);
        type_node = union_node;
    }
    
    type_node
}

fn p_parse_pattern() : I32 => {
    // Wildcard
    if (p_at(TK_SYMBOL, "_") || p_at(TK_IDENTIFIER, "_")) {
        p_eat();
        return node_new(NK_WILDCARD_PAT);
    }
    
    // Number literal
    if (p_at_kind(TK_NUMBER)) {
        let t = p_eat();
        let node = node_new(NK_LITERAL_PAT);
        node_set_data1(node, tok_value(t));
        return node;
    }
    
    // Bool literal
    if (p_at_kind(TK_BOOL)) {
        let t = p_eat();
        let node = node_new(NK_LITERAL_PAT);
        node_set_data1(node, tok_value(t));
        return node;
    }
    
    // Name or struct pattern
    let name = p_parse_identifier();
    
    if (p_at(TK_SYMBOL, "{")) {
        p_eat();
        let fields = vec_new();
        if (!p_at(TK_SYMBOL, "}")) {
            fields.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                fields.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, "}", "Expected '}' in pattern");
        let node = node_new(NK_STRUCT_PAT);
        node_set_data1(node, name);
        node_set_data2(node, fields);
        return node;
    }
    
    let node = node_new(NK_NAME_PAT);
    node_set_data1(node, name);
    node
}

fn p_parse_postfix(exprIn: I32) : I32 => {
    let expr = exprIn;
    while (true) {
        if (p_at(TK_SYMBOL, "(")) {
            p_eat();
            let args = vec_new();
            if (!p_at(TK_SYMBOL, ")")) {
                args.vec_push(p_parse_expression(0));
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    args.vec_push(p_parse_expression(0));
                }
            }
            p_expect(TK_SYMBOL, ")", "Expected ')'");

            if (node_kind(expr) == NK_MEMBER_EXPR) {
                // Receiver-call sugar: value.method(a, b) => method(value, a, b)
                let recv = node_get_data1(expr);
                let prop = node_get_data2(expr);
                let lowered_args = vec_new();
                lowered_args.vec_push(recv);
                let ai = 0;
                let alen = args.vec_length();
                while (ai < alen) {
                    lowered_args.vec_push(args.vec_get(ai));
                    ai = ai + 1;
                }
                let callee = node_new(NK_IDENTIFIER);
                node_set_data1(callee, prop);
                let call = node_new(NK_CALL_EXPR);
                node_set_data1(call, callee);
                node_set_data2(call, lowered_args);
                expr = call;
            } else {
                let call = node_new(NK_CALL_EXPR);
                node_set_data1(call, expr);
                node_set_data2(call, args);
                expr = call;
            }
            continue;
        }
        if (p_at(TK_SYMBOL, ".")) {
            p_eat();
            let prop = p_parse_identifier();
            let member = node_new(NK_MEMBER_EXPR);
            node_set_data1(member, expr);
            node_set_data2(member, prop);
            expr = member;
            continue;
        }
        if (p_at(TK_SYMBOL, "[")) {
            p_eat();
            let idx_expr = p_parse_expression(0);
            p_expect(TK_SYMBOL, "]", "Expected ']'");
            let idx_node = node_new(NK_INDEX_EXPR);
            node_set_data1(idx_node, expr);
            node_set_data2(idx_node, idx_expr);
            expr = idx_node;
            continue;
        }
        break;
    }
    expr
}

fn p_parse_primary() : I32 => {
    // Number
    if (p_at_kind(TK_NUMBER)) {
        let t = p_eat();
        let node = node_new(NK_NUMBER_LIT);
        node_set_data1(node, tok_value(t));
        return p_parse_postfix(node);
    }
    
    // Bool
    if (p_at_kind(TK_BOOL)) {
        let t = p_eat();
        let node = node_new(NK_BOOL_LIT);
        node_set_data1(node, tok_value(t));
        return p_parse_postfix(node);
    }
    
    // String
    if (p_at_kind(TK_STRING)) {
        let t = p_eat();
        let node = node_new(NK_STRING_LIT);
        node_set_data1(node, tok_value(t));
        return p_parse_postfix(node);
    }
    
    // Char
    if (p_at_kind(TK_CHAR)) {
        let t = p_eat();
        let node = node_new(NK_CHAR_LIT);
        node_set_data1(node, tok_value(t));
        return p_parse_postfix(node);
    }
    
    // Parenthesized expression
    if (p_at(TK_SYMBOL, "(")) {
        p_eat();
        let expr = p_parse_expression(0);
        p_expect(TK_SYMBOL, ")", "Expected ')'");
        return p_parse_postfix(expr);
    }
    
    // If expression
    if (p_at(TK_KEYWORD, "if")) {
        p_eat();
        p_expect(TK_SYMBOL, "(", "Expected '(' after if");
        let cond = p_parse_expression(0);
        p_expect(TK_SYMBOL, ")", "Expected ')' after condition");
        let then_branch = if (p_at(TK_SYMBOL, "{")) { p_parse_block() } else { p_parse_expression(0) };
        let else_branch = 0;
        if (p_at(TK_KEYWORD, "else")) {
            p_eat();
            else_branch = if (p_at(TK_SYMBOL, "{")) { p_parse_block() } else { p_parse_expression(0) };
        }
        let node = node_new(NK_IF_EXPR);
        node_set_data1(node, cond);
        node_set_data2(node, then_branch);
        node_set_data3(node, else_branch);
        return p_parse_postfix(node);
    }
    
    // Match expression
    if (p_at(TK_KEYWORD, "match")) {
        p_eat();
        p_expect(TK_SYMBOL, "(", "Expected '(' after match");
        let target = p_parse_expression(0);
        p_expect(TK_SYMBOL, ")", "Expected ')' after match target");
        p_expect(TK_SYMBOL, "{", "Expected '{'");
        let cases = vec_new();
        while (!p_at(TK_SYMBOL, "}")) {
            p_expect(TK_KEYWORD, "case", "Expected 'case'");
            let pat = p_parse_pattern();
            p_expect(TK_SYMBOL, "=", "Expected '='");
            let body = if (p_at(TK_SYMBOL, "{")) { p_parse_block() } else { p_parse_expression(0) };
            p_expect(TK_SYMBOL, ";", "Expected ';' after case");
            let case_node = vec_new();
            case_node.vec_push(pat);
            case_node.vec_push(body);
            cases.vec_push(case_node);
        }
        p_expect(TK_SYMBOL, "}", "Expected '}'");
        let node = node_new(NK_MATCH_EXPR);
        node_set_data1(node, target);
        node_set_data2(node, cases);
        return node;
    }
    
    // Identifier (possibly struct init or call)
    if (p_at_kind(TK_IDENTIFIER)) {
        let name = p_parse_identifier();
        let expr = node_new(NK_IDENTIFIER);
        node_set_data1(expr, name);
        
        // Struct init
        if (p_at(TK_SYMBOL, "{")) {
            p_eat();
            let fields = vec_new();
            if (!p_at(TK_SYMBOL, "}")) {
                let key = p_parse_identifier();
                p_expect(TK_SYMBOL, ":", "Expected ':' in struct init");
                let val = p_parse_expression(0);
                let field = vec_new();
                field.vec_push(key);
                field.vec_push(val);
                fields.vec_push(field);
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    let key2 = p_parse_identifier();
                    p_expect(TK_SYMBOL, ":", "Expected ':'");
                    let val2 = p_parse_expression(0);
                    let field2 = vec_new();
                    field2.vec_push(key2);
                    field2.vec_push(val2);
                    fields.vec_push(field2);
                }
            }
            p_expect(TK_SYMBOL, "}", "Expected '}'");
            let init_node = node_new(NK_STRUCT_INIT);
            node_set_data1(init_node, name);
            node_set_data2(init_node, fields);
            expr = init_node;
        }
        
        return p_parse_postfix(expr);
    }
    
    panic("Unexpected token in expression");
    0
}

fn p_parse_unary() : I32 => {
    if (p_at(TK_SYMBOL, "!") || p_at(TK_SYMBOL, "-")) {
        let op = tok_value(p_eat());
        let inner = p_parse_unary();
        let node = node_new(NK_UNARY_EXPR);
        node_set_data1(node, op);
        node_set_data2(node, inner);
        return node;
    }
    p_parse_primary()
}

fn p_get_precedence(op: I32) : I32 => {
    // Map operator to precedence
    // We use intern indices, so we need to check against known values
    if (intern_map.map_has("||") && op == intern_map.map_get("||")) { return 1; }
    if (intern_map.map_has("&&") && op == intern_map.map_get("&&")) { return 2; }
    if (intern_map.map_has("==") && op == intern_map.map_get("==")) { return 3; }
    if (intern_map.map_has("!=") && op == intern_map.map_get("!=")) { return 3; }
    if (intern_map.map_has("<") && op == intern_map.map_get("<")) { return 4; }
    if (intern_map.map_has("<=") && op == intern_map.map_get("<=")) { return 4; }
    if (intern_map.map_has(">") && op == intern_map.map_get(">")) { return 4; }
    if (intern_map.map_has(">=") && op == intern_map.map_get(">=")) { return 4; }
    if (intern_map.map_has("+") && op == intern_map.map_get("+")) { return 5; }
    if (intern_map.map_has("-") && op == intern_map.map_get("-")) { return 5; }
    if (intern_map.map_has("*") && op == intern_map.map_get("*")) { return 6; }
    if (intern_map.map_has("/") && op == intern_map.map_get("/")) { return 6; }
    if (intern_map.map_has("%") && op == intern_map.map_get("%")) { return 6; }
    0
}

fn p_is_binary_op() : Bool => {
    if (p_at(TK_SYMBOL, "+")) { return true; }
    if (p_at(TK_SYMBOL, "-")) { return true; }
    if (p_at(TK_SYMBOL, "*")) { return true; }
    if (p_at(TK_SYMBOL, "/")) { return true; }
    if (p_at(TK_SYMBOL, "%")) { return true; }
    if (p_at(TK_SYMBOL, "==")) { return true; }
    if (p_at(TK_SYMBOL, "!=")) { return true; }
    if (p_at(TK_SYMBOL, "<")) { return true; }
    if (p_at(TK_SYMBOL, "<=")) { return true; }
    if (p_at(TK_SYMBOL, ">")) { return true; }
    if (p_at(TK_SYMBOL, ">=")) { return true; }
    if (p_at(TK_SYMBOL, "&&")) { return true; }
    if (p_at(TK_SYMBOL, "||")) { return true; }
    if (p_at(TK_KEYWORD, "is")) { return true; }
    false
}

fn p_parse_expression(minPrec: I32) : I32 => {
    let left = p_parse_unary();
    
    while (p_is_binary_op()) {
        let op = tok_value(p_peek(0));
        let prec = p_get_precedence(op);
        
        // Handle 'is' keyword specially
        if (p_at(TK_KEYWORD, "is")) {
            p_eat();
            let pat = p_parse_pattern();
            let is_node = node_new(NK_IS_EXPR);
            node_set_data1(is_node, left);
            node_set_data2(is_node, pat);
            left = is_node;
            continue;
        }
        
        if (prec < minPrec) {
            break;
        }
        
        p_eat();
        let right = p_parse_expression(prec + 1);
        let bin = node_new(NK_BINARY_EXPR);
        node_set_data1(bin, op);
        node_set_data2(bin, left);
        node_set_data3(bin, right);
        left = bin;
    }
    
    // Unwrap operator
    if (p_at(TK_SYMBOL, "?")) {
        p_eat();
        let unwrap = node_new(NK_UNWRAP_EXPR);
        node_set_data1(unwrap, left);
        left = unwrap;
    }
    
    left
}

fn p_parse_block() : I32 => {
    p_expect(TK_SYMBOL, "{", "Expected '{'");
    let stmts = vec_new();
    while (!p_at(TK_SYMBOL, "}") && !p_at_kind(TK_EOF)) {
        stmts.vec_push(p_parse_statement());
    }
    p_expect(TK_SYMBOL, "}", "Expected '}'");
    let node = node_new(NK_BLOCK);
    node_set_data1(node, stmts);
    node
}

fn p_parse_function(is_class: I32) : I32 => {
    p_expect(TK_KEYWORD, "fn", "Expected 'fn'");
    let name = p_parse_identifier();
    
    // Generics
    let generics = vec_new();
    if (p_at(TK_SYMBOL, "<")) {
        p_eat();
        if (!p_at(TK_SYMBOL, ">")) {
            generics.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                generics.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, ">", "Expected '>'");
    }
    
    // Parameters
    p_expect(TK_SYMBOL, "(", "Expected '('");
    let params = vec_new();
    if (!p_at(TK_SYMBOL, ")")) {
        let pname = p_parse_identifier();
        let ptype = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            ptype = p_parse_type();
        }
        let param = vec_new();
        param.vec_push(pname);
        param.vec_push(ptype);
        params.vec_push(param);
        while (p_at(TK_SYMBOL, ",")) {
            p_eat();
            let pname2 = p_parse_identifier();
            let ptype2 = 0;
            if (p_at(TK_SYMBOL, ":")) {
                p_eat();
                ptype2 = p_parse_type();
            }
            let param2 = vec_new();
            param2.vec_push(pname2);
            param2.vec_push(ptype2);
            params.vec_push(param2);
        }
    }
    p_expect(TK_SYMBOL, ")", "Expected ')'");
    
    // Return type
    let ret_type = 0;
    if (p_at(TK_SYMBOL, ":")) {
        p_eat();
        ret_type = p_parse_type();
    }
    
    // Body
    p_expect(TK_SYMBOL, "=>", "Expected '=>'");
    let body = if (p_at(TK_SYMBOL, "{")) { p_parse_block() } else { p_parse_expression(0) };
    
    // Semicolon for expression body
    if (node_kind(body) != NK_BLOCK) {
        if (!p_at(TK_SYMBOL, "}") && !p_at_kind(TK_EOF)) {
            p_expect(TK_SYMBOL, ";", "Expected ';'");
        }
    }
    
    let kind = if (is_class == 1) { NK_CLASS_FN_DECL } else { NK_FN_DECL };
    let node = node_new(kind);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, params);
    node_set_data4(node, ret_type);
    node_set_data5(node, body);
    node
}

fn p_parse_struct() : I32 => {
    p_expect(TK_KEYWORD, "struct", "Expected 'struct'");
    let name = p_parse_identifier();
    
    let generics = vec_new();
    if (p_at(TK_SYMBOL, "<")) {
        p_eat();
        if (!p_at(TK_SYMBOL, ">")) {
            generics.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                generics.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, ">", "Expected '>'");
    }
    
    p_expect(TK_SYMBOL, "{", "Expected '{'");
    let fields = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        let fname = p_parse_identifier();
        p_expect(TK_SYMBOL, ":", "Expected ':'");
        let ftype = p_parse_type();
        let field = vec_new();
        field.vec_push(fname);
        field.vec_push(ftype);
        fields.vec_push(field);
        if (p_at(TK_SYMBOL, ",") || p_at(TK_SYMBOL, ";")) {
            p_eat();
        }
    }
    p_expect(TK_SYMBOL, "}", "Expected '}'");
    
    let node = node_new(NK_STRUCT_DECL);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, fields);
    node
}

fn p_parse_enum() : I32 => {
    p_expect(TK_KEYWORD, "enum", "Expected 'enum'");
    let name = p_parse_identifier();
    p_expect(TK_SYMBOL, "{", "Expected '{' after enum name");
    let variants = vec_new();
    while (!p_at(TK_SYMBOL, "}")) {
        variants.vec_push(p_parse_identifier());
        if (p_at(TK_SYMBOL, ",") || p_at(TK_SYMBOL, ";")) {
            p_eat();
        }
    }
    p_expect(TK_SYMBOL, "}", "Expected '}' after enum body");
    let node = node_new(NK_ENUM_DECL);
    node_set_data1(node, name);
    node_set_data2(node, variants);
    node
}

fn p_parse_type_alias() : I32 => {
    p_expect(TK_KEYWORD, "type", "Expected 'type'");
    let name = p_parse_identifier();
    
    let generics = vec_new();
    if (p_at(TK_SYMBOL, "<")) {
        p_eat();
        if (!p_at(TK_SYMBOL, ">")) {
            generics.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                generics.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, ">", "Expected '>'");
    }
    
    p_expect(TK_SYMBOL, "=", "Expected '='");
    let aliased = p_parse_type();
    p_expect(TK_SYMBOL, ";", "Expected ';'");
    
    let node = node_new(NK_TYPE_ALIAS);
    node_set_data1(node, name);
    node_set_data2(node, generics);
    node_set_data3(node, aliased);
    node
}

fn p_parse_let() : I32 => {
    p_expect(TK_KEYWORD, "let", "Expected 'let'");
    
    // Destructuring import
    if (p_at(TK_SYMBOL, "{")) {
        p_eat();
        let names = vec_new();
        if (!p_at(TK_SYMBOL, "}")) {
            names.vec_push(p_parse_identifier());
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                names.vec_push(p_parse_identifier());
            }
        }
        p_expect(TK_SYMBOL, "}", "Expected '}'");
        p_expect(TK_SYMBOL, "=", "Expected '='");
        let parts = vec_new();
        parts.vec_push(p_parse_identifier());
        while (p_at(TK_SYMBOL, "::")) {
            p_eat();
            parts.vec_push(p_parse_identifier());
        }
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        let node = node_new(NK_IMPORT_DECL);
        node_set_data1(node, names);
        node_set_data2(node, parts);
        return node;
    }
    
    let name = p_parse_identifier();
    let vtype = 0;
    if (p_at(TK_SYMBOL, ":")) {
        p_eat();
        vtype = p_parse_type();
    }
    p_expect(TK_SYMBOL, "=", "Expected '='");
    let value = p_parse_expression(0);
    p_expect(TK_SYMBOL, ";", "Expected ';'");
    
    let node = node_new(NK_LET_DECL);
    node_set_data1(node, name);
    node_set_data2(node, vtype);
    node_set_data3(node, value);
    node
}

fn p_parse_for() : I32 => {
    p_expect(TK_KEYWORD, "for", "Expected 'for'");
    p_expect(TK_SYMBOL, "(", "Expected '('");
    let iter = p_parse_identifier();
    p_expect(TK_KEYWORD, "in", "Expected 'in'");
    let start = p_parse_expression(0);
    p_expect(TK_SYMBOL, "..", "Expected '..'");
    let end = p_parse_expression(0);
    p_expect(TK_SYMBOL, ")", "Expected ')'");
    let body = p_parse_block();
    
    let node = node_new(NK_FOR_STMT);
    node_set_data1(node, iter);
    node_set_data2(node, start);
    node_set_data3(node, end);
    node_set_data4(node, body);
    node
}

// Parse extern fn/let/type declarations
fn p_parse_extern_decl() : I32 => {
    if (p_at(TK_KEYWORD, "fn")) {
        p_eat();
        let name = p_parse_identifier();
        
        // Generics
        let generics = vec_new();
        if (p_at(TK_SYMBOL, "<")) {
            p_eat();
            if (!p_at(TK_SYMBOL, ">")) {
                generics.vec_push(p_parse_identifier());
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    generics.vec_push(p_parse_identifier());
                }
            }
            p_expect(TK_SYMBOL, ">", "Expected '>'");
        }
        
        // Parameters
        p_expect(TK_SYMBOL, "(", "Expected '('");
        let params = vec_new();
        if (!p_at(TK_SYMBOL, ")")) {
            let pname = p_parse_identifier();
            let ptype = 0;
            if (p_at(TK_SYMBOL, ":")) {
                p_eat();
                ptype = p_parse_type();
            }
            let param = vec_new();
            param.vec_push(pname);
            param.vec_push(ptype);
            params.vec_push(param);
            while (p_at(TK_SYMBOL, ",")) {
                p_eat();
                let pname2 = p_parse_identifier();
                let ptype2 = 0;
                if (p_at(TK_SYMBOL, ":")) {
                    p_eat();
                    ptype2 = p_parse_type();
                }
                let param2 = vec_new();
                param2.vec_push(pname2);
                param2.vec_push(ptype2);
                params.vec_push(param2);
            }
        }
        p_expect(TK_SYMBOL, ")", "Expected ')'");
        
        // Return type
        let ret_type = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            ret_type = p_parse_type();
        }
        
        // No body - just semicolon
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern fn");
        
        // Create a special node for extern fn
        let node = node_new(NK_EXTERN_FN_DECL);
        node_set_data1(node, name);
        node_set_data2(node, generics);
        node_set_data3(node, params);
        node_set_data4(node, ret_type);
        return node;
    }
    if (p_at(TK_KEYWORD, "let")) {
        p_eat();
        let name = p_parse_identifier();
        let typ = 0;
        if (p_at(TK_SYMBOL, ":")) {
            p_eat();
            typ = p_parse_type();
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern let");
        let node = node_new(NK_EXTERN_LET_DECL);
        node_set_data1(node, name);
        node_set_data2(node, typ);
        return node;
    }
    if (p_at(TK_KEYWORD, "type")) {
        p_eat();
        let name = p_parse_identifier();
        let generics = vec_new();
        if (p_at(TK_SYMBOL, "<")) {
            p_eat();
            if (!p_at(TK_SYMBOL, ">")) {
                generics.vec_push(p_parse_identifier());
                while (p_at(TK_SYMBOL, ",")) {
                    p_eat();
                    generics.vec_push(p_parse_identifier());
                }
            }
            p_expect(TK_SYMBOL, ">", "Expected '>' after extern type generics");
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after extern type");
        let node = node_new(NK_EXTERN_TYPE_DECL);
        node_set_data1(node, name);
        node_set_data2(node, generics);
        return node;
    }
    panic("Expected fn, let, or type after extern")
}

fn p_parse_statement() : I32 => {
    if (p_at(TK_KEYWORD, "let")) { return p_parse_let(); }
    if (p_at(TK_KEYWORD, "struct")) { return p_parse_struct(); }
    if (p_at(TK_KEYWORD, "enum")) { return p_parse_enum(); }
    if (p_at(TK_KEYWORD, "type")) { return p_parse_type_alias(); }
    if (p_at(TK_KEYWORD, "fn")) { return p_parse_function(0); }
    if (p_at(TK_KEYWORD, "extern")) {
        p_eat();
        // extern fn/let/type declaration
        return p_parse_extern_decl();
    }
    if (p_at(TK_KEYWORD, "class")) {
        p_eat();
        return p_parse_function(1);
    }
    if (p_at(TK_KEYWORD, "return")) {
        p_eat();
        let value = 0;
        if (!p_at(TK_SYMBOL, ";")) {
            value = p_parse_expression(0);
        }
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        let node = node_new(NK_RETURN_STMT);
        node_set_data1(node, value);
        return node;
    }
    if (p_at(TK_KEYWORD, "if")) {
        let expr = p_parse_primary();
        if (node_get_data2(expr) != 0 && node_kind(node_get_data2(expr)) == NK_BLOCK) {
            let stmt = node_new(NK_IF_STMT);
            node_set_data1(stmt, node_get_data1(expr));
            node_set_data2(stmt, node_get_data2(expr));
            node_set_data3(stmt, node_get_data3(expr));
            return stmt;
        }
        p_expect(TK_SYMBOL, ";", "Expected ';' after if expression");
        let estmt = node_new(NK_EXPR_STMT);
        node_set_data1(estmt, expr);
        return estmt;
    }
    if (p_at(TK_KEYWORD, "while")) {
        p_eat();
        p_expect(TK_SYMBOL, "(", "Expected '('");
        let cond = p_parse_expression(0);
        p_expect(TK_SYMBOL, ")", "Expected ')'");
        let body = p_parse_block();
        let node = node_new(NK_WHILE_STMT);
        node_set_data1(node, cond);
        node_set_data2(node, body);
        return node;
    }
    if (p_at(TK_KEYWORD, "for")) { return p_parse_for(); }
    if (p_at(TK_KEYWORD, "break")) {
        p_eat();
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        return node_new(NK_BREAK_STMT);
    }
    if (p_at(TK_KEYWORD, "continue")) {
        p_eat();
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        return node_new(NK_CONTINUE_STMT);
    }
    if (p_at(TK_SYMBOL, "{")) { return p_parse_block(); }
    
    // Expression statement
    let expr = p_parse_expression(0);
    
    // Assignment
    if (p_at(TK_SYMBOL, "=")) {
        p_eat();
        let value = p_parse_expression(0);
        p_expect(TK_SYMBOL, ";", "Expected ';'");
        let node = node_new(NK_ASSIGN_STMT);
        node_set_data1(node, expr);
        node_set_data2(node, value);
        return node;
    }
    
    if (p_at(TK_SYMBOL, ";")) {
        p_eat();
    } else if (!p_at(TK_SYMBOL, "}")) {
        p_expect(TK_SYMBOL, ";", "Expected ';'");
    }
    
    let node = node_new(NK_EXPR_STMT);
    node_set_data1(node, expr);
    node
}

fn p_parse_program() : I32 => {
    let stmts = vec_new();
    while (!p_at_kind(TK_EOF)) {
        stmts.vec_push(p_parse_statement());
    }
    let node = node_new(NK_PROGRAM);
    node_set_data1(node, stmts);
    node
}

// ============================================================================
// Desugar - skip for now, minimal implementation
// ============================================================================

fn desugar(program: I32) : I32 => program;

// ============================================================================
// Name Resolution - skip for now, minimal implementation
// ============================================================================

fn scope_define(scopes: Vec, depth: I32, name: *Str) : I32 => {
    let scope = scopes.vec_get(depth);
    if (scope.set_has(name)) {
        panic_with_code(
            "E_RESOLVE_SHADOWING",
            "Variable shadowing/redeclaration is not allowed: ".str_concat(name),
            "A name was declared multiple times in the same lexical scope.",
            "Rename one of the bindings or move it to a different scope."
        );
    }
    scope.set_add(name);
    0
}

fn scope_has(scopes: Vec, depth: I32, name: *Str) : Bool => {
    let i = depth;
    while (i >= 0) {
        if (scopes.vec_get(i).set_has(name)) {
            return true;
        }
        i = i - 1;
    }
    false
}

fn resolve_expr(n: I32, globals: Set, scopes: Vec, depth: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_IDENTIFIER) {
        let name = get_interned_str(node_get_data1(n));
        if (!scope_has(scopes, depth, name) && !globals.set_has(name)) {
            panic_with_code(
                "E_RESOLVE_UNKNOWN_IDENTIFIER",
                "Unknown identifier: ".str_concat(name),
                "The identifier is not declared in local scope, global declarations, or imports.",
                "Declare the identifier before use or import it from the correct module."
            );
        }
        return 0;
    }

    if (kind == NK_BINARY_EXPR) {
        resolve_expr(node_get_data2(n), globals, scopes, depth);
        resolve_expr(node_get_data3(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
        resolve_expr(node_get_data2(n), globals, scopes, depth);
        if (kind == NK_UNWRAP_EXPR) {
            resolve_expr(node_get_data1(n), globals, scopes, depth);
        }
        return 0;
    }

    if (kind == NK_CALL_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        let args = node_get_data2(n);
        let i = 0;
        let len = args.vec_length();
        while (i < len) {
            resolve_expr(args.vec_get(i), globals, scopes, depth);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_MEMBER_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_INDEX_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_expr(node_get_data2(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_STRUCT_INIT) {
        let type_name = get_interned_str(node_get_data1(n));
        if (!globals.set_has(type_name)) {
            panic_with_code(
                "E_RESOLVE_UNKNOWN_STRUCT",
                "Unknown struct/type in initializer: ".str_concat(type_name),
                "A struct initializer referenced a type that is not declared in the merged module scope.",
                "Declare the struct/type first or import the module that defines it."
            );
        }
        let fields = node_get_data2(n);
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            resolve_expr(field.vec_get(1), globals, scopes, depth);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IF_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_stmt(node_get_data2(n), globals, scopes, depth);
        if (node_get_data3(n) != 0) {
            resolve_stmt(node_get_data3(n), globals, scopes, depth);
        }
        return 0;
    }

    if (kind == NK_MATCH_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        let cases = node_get_data2(n);
        let i = 0;
        let len = cases.vec_length();
        while (i < len) {
            let case_node = cases.vec_get(i);
            let pat = case_node.vec_get(0);
            let body = case_node.vec_get(1);

            let next_depth = depth + 1;
            scopes.vec_push(set_new());

            if (node_kind(pat) == NK_STRUCT_PAT) {
                let fields = node_get_data2(pat);
                let j = 0;
                let fLen = fields.vec_length();
                while (j < fLen) {
                    scope_define(scopes, next_depth, get_interned_str(fields.vec_get(j)));
                    j = j + 1;
                }
            } else if (node_kind(pat) == NK_NAME_PAT) {
                let pat_name = get_interned_str(node_get_data1(pat));
                if (!globals.set_has(pat_name)) {
                    scope_define(scopes, next_depth, pat_name);
                }
            }

            resolve_stmt(body, globals, scopes, next_depth);
            scopes.vec_pop();
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IS_EXPR) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    0
}

fn resolve_stmt(n: I32, globals: Set, scopes: Vec, depth: I32) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_BLOCK) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        let stmts = node_get_data1(n);
        let i = 0;
        let len = stmts.vec_length();
        while (i < len) {
            resolve_stmt(stmts.vec_get(i), globals, scopes, next_depth);
            i = i + 1;
        }
        scopes.vec_pop();
        return 0;
    }

    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL) {
        let fnScopes = vec_new();
        fnScopes.vec_push(set_new());
        let params = node_get_data3(n);
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let param = params.vec_get(i);
            scope_define(fnScopes, 0, get_interned_str(param.vec_get(0)));
            i = i + 1;
        }
        resolve_stmt(node_get_data5(n), globals, fnScopes, 0);
        return 0;
    }

    if (kind == NK_LET_DECL) {
        resolve_expr(node_get_data3(n), globals, scopes, depth);
        scope_define(scopes, depth, get_interned_str(node_get_data1(n)));
        return 0;
    }

    if (kind == NK_IMPORT_DECL) {
        let names = node_get_data1(n);
        let i = 0;
        let len = names.vec_length();
        while (i < len) {
            scope_define(scopes, depth, get_interned_str(names.vec_get(i)));
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_EXPR_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_ASSIGN_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_expr(node_get_data2(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_RETURN_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        return 0;
    }

    if (kind == NK_IF_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_stmt(node_get_data2(n), globals, scopes, depth);
        if (node_get_data3(n) != 0) {
            resolve_stmt(node_get_data3(n), globals, scopes, depth);
        }
        return 0;
    }

    if (kind == NK_FOR_STMT) {
        let next_depth = depth + 1;
        scopes.vec_push(set_new());
        scope_define(scopes, next_depth, get_interned_str(node_get_data1(n)));
        resolve_expr(node_get_data2(n), globals, scopes, next_depth);
        resolve_expr(node_get_data3(n), globals, scopes, next_depth);
        resolve_stmt(node_get_data4(n), globals, scopes, next_depth);
        scopes.vec_pop();
        return 0;
    }

    if (kind == NK_WHILE_STMT) {
        resolve_expr(node_get_data1(n), globals, scopes, depth);
        resolve_stmt(node_get_data2(n), globals, scopes, depth);
        return 0;
    }

    // Fallback: treat unmatched nodes as expressions.
    resolve_expr(n, globals, scopes, depth);
    0
}

fn resolve_names(program: I32) : I32 => {
    let globals = set_new();
    let body = node_get_data1(program);

    // Predeclare global symbols.
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        let stmt = body.vec_get(i);
        let kind = node_kind(stmt);
        if (
            kind == NK_FN_DECL ||
            kind == NK_CLASS_FN_DECL ||
            kind == NK_STRUCT_DECL ||
            kind == NK_ENUM_DECL ||
            kind == NK_TYPE_ALIAS ||
            kind == NK_LET_DECL ||
            kind == NK_EXTERN_FN_DECL ||
            kind == NK_EXTERN_LET_DECL ||
            kind == NK_EXTERN_TYPE_DECL
        ) {
            let gname = get_interned_str(node_get_data1(stmt));
            if (globals.set_has(gname)) {
                panic_with_code(
                    "E_RESOLVE_SHADOWING",
                    "Variable shadowing/redeclaration is not allowed: ".str_concat(gname),
                    "A global declaration with the same name already exists.",
                    "Rename one of the global declarations or split conflicting declarations into separate modules."
                );
            }
            globals.set_add(gname);
        }
        i = i + 1;
    }

    // Resolve top-level statements.
    let topScopes = vec_new();
    topScopes.vec_push(set_new());
    i = 0;
    while (i < len) {
        resolve_stmt(body.vec_get(i), globals, topScopes, 0);
        i = i + 1;
    }

    program
}

// ============================================================================
// Typecheck - skip for now, minimal implementation
// ============================================================================

fn typecheck_expr(n: I32, fn_arities: Map) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_BINARY_EXPR) {
        typecheck_expr(node_get_data2(n), fn_arities);
        typecheck_expr(node_get_data3(n), fn_arities);
        return 0;
    }

    if (kind == NK_UNARY_EXPR || kind == NK_UNWRAP_EXPR) {
        if (kind == NK_UNARY_EXPR) {
            typecheck_expr(node_get_data2(n), fn_arities);
        } else {
            typecheck_expr(node_get_data1(n), fn_arities);
        }
        return 0;
    }

    if (kind == NK_CALL_EXPR) {
        let callee = node_get_data1(n);
        let args = node_get_data2(n);
        let actual = args.vec_length();

        if (node_kind(callee) == NK_IDENTIFIER) {
            let fname = get_interned_str(node_get_data1(callee));
            if (fn_arities.map_has(fname)) {
                let expected = fn_arities.map_get(fname);
                if (expected != actual) {
                    let msg = "Function ".str_concat(fname).str_concat(" expects ".str_concat(int_to_string(expected))).str_concat(" args, got ".str_concat(int_to_string(actual)));
                    panic_with_code(
                        "E_TYPE_ARG_COUNT",
                        msg,
                        "A function call provided a different number of arguments than the function signature requires.",
                        "Pass exactly the number of parameters declared by the function."
                    );
                }
            }
        }

        typecheck_expr(callee, fn_arities);
        let i = 0;
        while (i < actual) {
            typecheck_expr(args.vec_get(i), fn_arities);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_MEMBER_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities);
        return 0;
    }

    if (kind == NK_INDEX_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities);
        typecheck_expr(node_get_data2(n), fn_arities);
        return 0;
    }

    if (kind == NK_STRUCT_INIT) {
        let fields = node_get_data2(n);
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            typecheck_expr(field.vec_get(1), fn_arities);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IF_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities);
        typecheck_stmt(node_get_data2(n), fn_arities);
        if (node_get_data3(n) != 0) {
            typecheck_stmt(node_get_data3(n), fn_arities);
        }
        return 0;
    }

    if (kind == NK_MATCH_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities);
        let cases = node_get_data2(n);
        let i = 0;
        let len = cases.vec_length();
        while (i < len) {
            let case_node = cases.vec_get(i);
            typecheck_stmt(case_node.vec_get(1), fn_arities);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_IS_EXPR) {
        typecheck_expr(node_get_data1(n), fn_arities);
        return 0;
    }

    0
}

fn typecheck_stmt(n: I32, fn_arities: Map) : I32 => {
    if (n == 0) {
        return 0;
    }

    let kind = node_kind(n);

    if (kind == NK_BLOCK) {
        let stmts = node_get_data1(n);
        let i = 0;
        let len = stmts.vec_length();
        while (i < len) {
            typecheck_stmt(stmts.vec_get(i), fn_arities);
            i = i + 1;
        }
        return 0;
    }

    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL) {
        typecheck_stmt(node_get_data5(n), fn_arities);
        return 0;
    }

    if (kind == NK_LET_DECL) {
        typecheck_expr(node_get_data3(n), fn_arities);
        return 0;
    }

    if (kind == NK_EXPR_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities);
        return 0;
    }

    if (kind == NK_ASSIGN_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities);
        typecheck_expr(node_get_data2(n), fn_arities);
        return 0;
    }

    if (kind == NK_RETURN_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities);
        return 0;
    }

    if (kind == NK_IF_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities);
        typecheck_stmt(node_get_data2(n), fn_arities);
        if (node_get_data3(n) != 0) {
            typecheck_stmt(node_get_data3(n), fn_arities);
        }
        return 0;
    }

    if (kind == NK_FOR_STMT) {
        typecheck_expr(node_get_data2(n), fn_arities);
        typecheck_expr(node_get_data3(n), fn_arities);
        typecheck_stmt(node_get_data4(n), fn_arities);
        return 0;
    }

    if (kind == NK_WHILE_STMT) {
        typecheck_expr(node_get_data1(n), fn_arities);
        typecheck_stmt(node_get_data2(n), fn_arities);
        return 0;
    }

    // Fallback: treat unmatched nodes as expressions.
    typecheck_expr(n, fn_arities);
    0
}

fn typecheck_program(program: I32) : I32 => {
    let fn_arities = map_new();
    let body = node_get_data1(program);

    // Collect function signatures (including extern fns).
    let i = 0;
    let len = body.vec_length();
    while (i < len) {
        let stmt = body.vec_get(i);
        let kind = node_kind(stmt);
        if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL || kind == NK_EXTERN_FN_DECL) {
            let name = get_interned_str(node_get_data1(stmt));
            let params = node_get_data3(stmt);
            fn_arities.map_set(name, params.vec_length());
        }
        i = i + 1;
    }

    // Check calls across whole program.
    i = 0;
    while (i < len) {
        typecheck_stmt(body.vec_get(i), fn_arities);
        i = i + 1;
    }

    program
}

// ============================================================================
// JavaScript Code Generation
// ============================================================================

fn get_interned_str(idx: I32) : *Str => {
    // Look up the interned string by index
    get_intern(idx)
}

fn emit_expr(n: I32) : *Str => {
    let kind = node_kind(n);
    
    if (kind == NK_NUMBER_LIT) {
        let val = node_get_data1(n);
        // Get the number string from intern
        return get_interned_str(val);
    }
    
    if (kind == NK_BOOL_LIT) {
        let val = node_get_data1(n);
        if (val == 1) { return "true"; }
        return "false";
    }
    
    if (kind == NK_STRING_LIT) {
        let val = node_get_data1(n);
        let s = get_interned_str(val);
        return "\"".str_concat(s).str_concat("\"");
    }
    
    if (kind == NK_CHAR_LIT) {
        let val = node_get_data1(n);
        let s = get_interned_str(val);
        return "\"".str_concat(s).str_concat("\"");
    }
    
    if (kind == NK_IDENTIFIER) {
        let name_idx = node_get_data1(n);
        return get_interned_str(name_idx);
    }
    
    if (kind == NK_UNARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        let inner = emit_expr(node_get_data2(n));
        return "(".str_concat(op).str_concat(inner.str_concat(")"));
    }
    
    if (kind == NK_BINARY_EXPR) {
        let op = get_interned_str(node_get_data1(n));
        if (op.str_eq("==")) { op = "==="; }
        if (op.str_eq("!=")) { op = "!=="; }
        let left = emit_expr(node_get_data2(n));
        let right = emit_expr(node_get_data3(n));
        return str_concat("(".str_concat(left).str_concat(" ".str_concat(op)).str_concat(" ".str_concat(right)), ")");
    }
    
    if (kind == NK_CALL_EXPR) {
        let callee = emit_expr(node_get_data1(n));
        let args = node_get_data2(n);
        let arg_strs = vec_new();
        let i = 0;
        let len = args.vec_length();
        while (i < len) {
            arg_strs.vec_push(emit_expr(args.vec_get(i)));
            i = i + 1;
        }
        let args_str = arg_strs.vec_join(", ");
        return callee.str_concat("(").str_concat(args_str.str_concat(")"));
    }
    
    if (kind == NK_MEMBER_EXPR) {
        let obj = emit_expr(node_get_data1(n));
        let prop = get_interned_str(node_get_data2(n));
        return obj.str_concat(".").str_concat(prop);
    }
    
    if (kind == NK_INDEX_EXPR) {
        let target = emit_expr(node_get_data1(n));
        let idx_expr = emit_expr(node_get_data2(n));
        return target.str_concat("[").str_concat(idx_expr).str_concat("]");
    }
    
    if (kind == NK_STRUCT_INIT) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        let fields = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "({ __tag: ");
        sb_append(sb, "\"".str_concat(name).str_concat("\""));
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            let key_idx = field.vec_get(0);
            let val_node = field.vec_get(1);
            sb_append(sb, ", ");
            sb_append(sb, get_interned_str(key_idx));
            sb_append(sb, ": ");
            sb_append(sb, emit_expr(val_node));
            i = i + 1;
        }
        sb_append(sb, " })");
        return sb_build(sb);
    }
    
    if (kind == NK_IF_EXPR) {
        let cond = emit_expr(node_get_data1(n));
        let then_b = node_get_data2(n);
        let else_b = node_get_data3(n);
        let then_str = if (node_kind(then_b) == NK_BLOCK) { emit_block_as_iife(then_b) } else { emit_expr(then_b) };
        let else_str = if (else_b == 0) { "undefined" } else {
            if (node_kind(else_b) == NK_BLOCK) { emit_block_as_iife(else_b) } else { emit_expr(else_b) }
        };
        return str_concat("((".str_concat(cond).str_concat(") ? ").str_concat(then_str.str_concat(" : ")), else_str.str_concat(")"));
    }
    
    if (kind == NK_MATCH_EXPR) {
        let target = emit_expr(node_get_data1(n));
        let cases = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "(() => { const __m = ");
        sb_append(sb, target);
        sb_append(sb, "; ");
        let i = 0;
        let len = cases.vec_length();
        while (i < len) {
            let case_node = cases.vec_get(i);
            let pat = case_node.vec_get(0);
            let body = case_node.vec_get(1);
            let guard = emit_pattern_guard("__m", pat);
            if (i == 0) {
                sb_append(sb, "if (");
            } else {
                sb_append(sb, "else if (");
            }
            sb_append(sb, guard);
            sb_append(sb, ") { ");
            sb_append(sb, emit_pattern_bindings("__m", pat));
            sb_append(sb, "return ");
            sb_append(sb, if (node_kind(body) == NK_BLOCK) { emit_block(body) } else { emit_expr(body) });
            sb_append(sb, "; } ");
            i = i + 1;
        }
        sb_append(sb, "else { throw new Error(\"Non-exhaustive match\"); } })()");
        return sb_build(sb);
    }
    
    if (kind == NK_IS_EXPR) {
        let inner = emit_expr(node_get_data1(n));
        let pat = node_get_data2(n);
        return "(".str_concat(emit_pattern_guard(inner, pat)).str_concat(")");
    }
    
    if (kind == NK_UNWRAP_EXPR) {
        return emit_expr(node_get_data1(n));
    }
    
    "undefined"
}

fn emit_pattern_guard(value_expr: *Str, pat: I32) : *Str => {
    let kind = node_kind(pat);
    if (kind == NK_WILDCARD_PAT) { return "true"; }
    if (kind == NK_LITERAL_PAT) {
        let val = get_interned_str(node_get_data1(pat));
        return value_expr.str_concat(" === ").str_concat(val).str_concat("");
    }
    if (kind == NK_NAME_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        return str_concat(value_expr.str_concat(" && ").str_concat(value_expr).str_concat(".__tag === \""), name.str_concat("\""));
    }
    if (kind == NK_STRUCT_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        return str_concat(value_expr.str_concat(" && ").str_concat(value_expr).str_concat(".__tag === \""), name.str_concat("\""));
    }
    "false"
}

fn emit_pattern_bindings(value_expr: *Str, pat: I32) : *Str => {
    let kind = node_kind(pat);
    if (kind == NK_STRUCT_PAT) {
        let fields = node_get_data2(pat);
        let sb = sb_new();
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let fname_idx = fields.vec_get(i);
            let fname = get_interned_str(fname_idx);
            sb_append(sb, "const ");
            sb_append(sb, fname);
            sb_append(sb, " = ");
            sb_append(sb, value_expr);
            sb_append(sb, ".");
            sb_append(sb, fname);
            sb_append(sb, "; ");
            i = i + 1;
        }
        return sb_build(sb);
    }
    if (kind == NK_NAME_PAT) {
        let name = get_interned_str(node_get_data1(pat));
        return "const ".str_concat(name).str_concat(" = ").str_concat(value_expr.str_concat("; "));
    }
    ""
}

fn emit_stmt(n: I32) : *Str => {
    let kind = node_kind(n);
    
    if (kind == NK_LET_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        let value = emit_expr(node_get_data3(n));
        return "let ".str_concat(name).str_concat(" = ").str_concat(value.str_concat(";"));
    }
    
    if (kind == NK_IMPORT_DECL) {
        return "// import placeholder";
    }
    
    if (kind == NK_EXPR_STMT) {
        return emit_expr(node_get_data1(n)).str_concat(";");
    }
    
    if (kind == NK_ASSIGN_STMT) {
        let target = emit_expr(node_get_data1(n));
        let value = emit_expr(node_get_data2(n));
        return target.str_concat(" = ").str_concat(value).str_concat(";");
    }
    
    if (kind == NK_RETURN_STMT) {
        let value = node_get_data1(n);
        if (value == 0) {
            return "return;";
        }
        return "return ".str_concat(emit_expr(value).str_concat(";"));
    }
    
    if (kind == NK_IF_STMT) {
        let cond = emit_expr(node_get_data1(n));
        let then_b = emit_block(node_get_data2(n));
        let else_b = node_get_data3(n);
        if (else_b == 0) {
            return "if (".str_concat(cond).str_concat(") ".str_concat(then_b));
        }
        return str_concat("if (".str_concat(cond).str_concat(") ").str_concat(then_b), " else ".str_concat(emit_stmt_or_block(else_b)));
    }
    
    // IfExpr used as statement (e.g., in else-if chains)
    if (kind == NK_IF_EXPR) {
        let cond = emit_expr(node_get_data1(n));
        let then_b = node_get_data2(n);
        let else_b = node_get_data3(n);
        let then_str = emit_stmt_or_block(then_b);
        if (else_b == 0) {
            return "if (".str_concat(cond).str_concat(") ".str_concat(then_str));
        }
        return str_concat("if (".str_concat(cond).str_concat(") ").str_concat(then_str), " else ".str_concat(emit_stmt_or_block(else_b)));
    }
    
    if (kind == NK_WHILE_STMT) {
        let cond = emit_expr(node_get_data1(n));
        let body = emit_block(node_get_data2(n));
        return "while (".str_concat(cond).str_concat(") ".str_concat(body));
    }
    
    if (kind == NK_FOR_STMT) {
        let iter_idx = node_get_data1(n);
        let iter = get_interned_str(iter_idx);
        let start = emit_expr(node_get_data2(n));
        let end = emit_expr(node_get_data3(n));
        let body = emit_block(node_get_data4(n));
        return str_concat(str_concat(str_concat(str_concat("for (let ".str_concat(iter).str_concat(" = ").str_concat(start), "; ".str_concat(iter)), " < ".str_concat(end)), "; ".str_concat(iter.str_concat("++) "))), body);
    }
    
    if (kind == NK_BREAK_STMT) {
        return "break;";
    }
    
    if (kind == NK_CONTINUE_STMT) {
        return "continue;";
    }
    
    if (kind == NK_BLOCK) {
        return emit_block(n);
    }
    
    if (kind == NK_FN_DECL || kind == NK_CLASS_FN_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        let params = node_get_data3(n);
        let body = node_get_data5(n);
        
        let param_names = vec_new();
        let i = 0;
        let len = params.vec_length();
        while (i < len) {
            let param = params.vec_get(i);
            param_names.vec_push(get_interned_str(param.vec_get(0)));
            i = i + 1;
        }
        let params_str = param_names.vec_join(", ");
        
        if (node_kind(body) == NK_BLOCK) {
            return "function ".str_concat(name).str_concat("(".str_concat(params_str)).str_concat(") ".str_concat(emit_fn_block(body)));
        }
        return str_concat("function ".str_concat(name).str_concat("(".str_concat(params_str)).str_concat(") { return "), emit_expr(body).str_concat("; }"));
    }
    
    if (kind == NK_STRUCT_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        let fields = node_get_data3(n);
        let sb = sb_new();
        sb_append(sb, "function ");
        sb_append(sb, name);
        sb_append(sb, "(fields = {}) { return { __tag: \"");
        sb_append(sb, name);
        sb_append(sb, "\"");
        let i = 0;
        let len = fields.vec_length();
        while (i < len) {
            let field = fields.vec_get(i);
            let fname = get_interned_str(field.vec_get(0));
            sb_append(sb, ", ");
            sb_append(sb, fname);
            sb_append(sb, ": fields.");
            sb_append(sb, fname);
            i = i + 1;
        }
        sb_append(sb, " }; }");
        return sb_build(sb);
    }
    
    if (kind == NK_TYPE_ALIAS) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// type ".str_concat(name).str_concat(" = ...");
    }

    if (kind == NK_ENUM_DECL) {
        let name = get_interned_str(node_get_data1(n));
        let variants = node_get_data2(n);
        let sb = sb_new();
        sb_append(sb, "const ");
        sb_append(sb, name);
        sb_append(sb, " = { ");
        let i = 0;
        let len = variants.vec_length();
        while (i < len) {
            if (i > 0) {
                sb_append(sb, ", ");
            }
            let v = get_interned_str(variants.vec_get(i));
            sb_append(sb, v);
            sb_append(sb, ": { __tag: \"");
            sb_append(sb, v);
            sb_append(sb, "\" }");
            i = i + 1;
        }
        sb_append(sb, " }; ");
        return sb_build(sb);
    }
    
    if (kind == NK_EXTERN_FN_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// extern fn ".str_concat(name);
    }
    
    if (kind == NK_EXTERN_LET_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// extern let ".str_concat(name);
    }
    
    if (kind == NK_EXTERN_TYPE_DECL) {
        let name_idx = node_get_data1(n);
        let name = get_interned_str(name_idx);
        return "// extern type ".str_concat(name);
    }
    
    ""
}

fn emit_stmt_or_block(n: I32) : *Str => {
    if (node_kind(n) == NK_BLOCK) {
        return emit_block(n);
    }
    "{ ".str_concat(emit_stmt(n).str_concat(" }"))
}

fn emit_block(n: I32) : *Str => {
    let stmts = node_get_data1(n);
    let sb = sb_new();
    sb_append(sb, "{\n");
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        sb_append(sb, "  ");
        sb_append(sb, emit_stmt(stmts.vec_get(i)));
        sb_append(sb, "\n");
        i = i + 1;
    }
    sb_append(sb, "}");
    sb_build(sb)
}

// Emit a block wrapped in an IIFE for use in expressions
fn emit_block_as_iife(n: I32) : *Str => {
    let stmts = node_get_data1(n);
    let len = stmts.vec_length();
    if (len == 0) {
        return "(() => undefined)()";
    }
    let sb = sb_new();
    sb_append(sb, "(() => {\n");
    let i = 0;
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let is_last = i == len - 1;
        let kind = node_kind(stmt);
        if (is_last && kind == NK_EXPR_STMT) {
            sb_append(sb, "  return ");
            sb_append(sb, emit_expr(node_get_data1(stmt)));
            sb_append(sb, ";\n");
        } else if (is_last && (kind == NK_IF_STMT || kind == NK_IF_EXPR)) {
            sb_append(sb, "  return ");
            sb_append(sb, emit_if_as_expr(stmt));
            sb_append(sb, ";\n");
        } else {
            sb_append(sb, "  ");
            sb_append(sb, emit_stmt(stmt));
            sb_append(sb, "\n");
        }
        i = i + 1;
    }
    sb_append(sb, "})()");
    sb_build(sb)
}

fn emit_fn_block(n: I32) : *Str => {
    let stmts = node_get_data1(n);
    let len = stmts.vec_length();
    if (len == 0) {
        return "{\n}";
    }
    let sb = sb_new();
    sb_append(sb, "{\n");
    let i = 0;
    while (i < len) {
        let stmt = stmts.vec_get(i);
        let is_last = i == len - 1;
        let kind = node_kind(stmt);
        if (is_last && kind == NK_EXPR_STMT) {
            sb_append(sb, "  return ");
            sb_append(sb, emit_expr(node_get_data1(stmt)));
            sb_append(sb, ";\n");
        } else if (is_last && (kind == NK_IF_STMT || kind == NK_IF_EXPR)) {
            // Return the result of the if expression
            sb_append(sb, "  return ");
            sb_append(sb, emit_if_as_expr(stmt));
            sb_append(sb, ";\n");
        } else {
            sb_append(sb, "  ");
            sb_append(sb, emit_stmt(stmt));
            sb_append(sb, "\n");
        }
        i = i + 1;
    }
    sb_append(sb, "}");
    sb_build(sb)
}

// Emit an if statement as a ternary expression
fn emit_if_as_expr(n: I32) : *Str => {
    let cond = emit_expr(node_get_data1(n));
    let then_branch = node_get_data2(n);
    let else_branch = node_get_data3(n);
    
    let then_code = emit_branch_as_expr(then_branch);
    let else_code = if (else_branch == 0) { "undefined" } else { emit_branch_as_expr(else_branch) };
    
    str_concat("((".str_concat(cond).str_concat(") ? ").str_concat(then_code.str_concat(" : ")), else_code.str_concat(")"))
}

fn emit_branch_as_expr(n: I32) : *Str => {
    let kind = node_kind(n);
    if (kind == NK_BLOCK) {
        // Wrap block in IIFE
        let stmts = node_get_data1(n);
        let len = stmts.vec_length();
        if (len == 0) {
            return "undefined";
        }
        let sb = sb_new();
        sb_append(sb, "(() => {\n");
        let i = 0;
        while (i < len) {
            let stmt = stmts.vec_get(i);
            let is_last = i == len - 1;
            let stmt_kind = node_kind(stmt);
            if (is_last && stmt_kind == NK_EXPR_STMT) {
                sb_append(sb, "    return ");
                sb_append(sb, emit_expr(node_get_data1(stmt)));
                sb_append(sb, ";\n");
            } else if (is_last && (stmt_kind == NK_IF_STMT || stmt_kind == NK_IF_EXPR)) {
                sb_append(sb, "    return ");
                sb_append(sb, emit_if_as_expr(stmt));
                sb_append(sb, ";\n");
            } else {
                sb_append(sb, "    ");
                sb_append(sb, emit_stmt(stmt));
                sb_append(sb, "\n");
            }
            i = i + 1;
        }
        sb_append(sb, "  })()");
        return sb_build(sb);
    }
    if (kind == NK_IF_STMT || kind == NK_IF_EXPR) {
        return emit_if_as_expr(n);
    }
    emit_expr(n)
}

fn generate_js(program: I32) : *Str => {
    let stmts = node_get_data1(program);
    let sb = sb_new();
    sb_append(sb, "\"use strict\";\n\n");
    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        sb_append(sb, emit_stmt(stmts.vec_get(i)));
        sb_append(sb, "\n\n");
        i = i + 1;
    }
    sb_build(sb)
}

// ============================================================================
// Main compiler pipeline
// ============================================================================

fn compile_source(source: *Str) : *Str => {
    lex_init(source);
    lex_all();
    parse_init();
    let program = p_parse_program();
    let desugared = desugar(program);
    let resolved = resolve_names(desugared);
    let typed = typecheck_program(resolved);
    generate_js(typed)
}

fn module_parts_to_relative_path(parts: Vec) : *Str => {
    let sb = sb_new();
    let i = 0;
    let len = parts.vec_length();
    while (i < len) {
        if (i > 0) {
            sb_append(sb, "/");
        }
        sb_append(sb, get_interned_str(parts.vec_get(i)));
        i = i + 1;
    }
    sb_append(sb, ".tuff");
    sb_build(sb)
}

fn join_sources(sources: Vec<*Str>) : *Str => {
    let sb = sb_new();
    let i = 0;
    let len = sources.vec_length();
    while (i < len) {
        if (i > 0) {
            sb_append(sb, "\n\n");
        }
        sb_append(sb, sources.vec_get(i));
        i = i + 1;
    }
    sb_build(sb)
}

fn gather_module_sources(filePath: *Str, seen: Set, visiting: Set, sources: Vec<*Str>) : I32 => {
    if (seen.set_has(filePath)) {
        return 0;
    }
    if (visiting.set_has(filePath)) {
        panic_with_code(
            "E_MODULE_CYCLE",
            "Module import cycle detected at ".str_concat(filePath),
            "A module was revisited while still being loaded, which means the import graph contains a cycle.",
            "Break the cycle by extracting shared declarations into a third module imported by both sides."
        );
    }
    visiting.set_add(filePath);

    let source = read_file(filePath);
    lex_init(source);
    lex_all();
    parse_init();
    let program = p_parse_program();
    let stmts = node_get_data1(program);

    let i = 0;
    let len = stmts.vec_length();
    while (i < len) {
        let stmt = stmts.vec_get(i);
        if (node_kind(stmt) == NK_IMPORT_DECL) {
            let parts = node_get_data2(stmt);
            let rel = module_parts_to_relative_path(parts);
            let depPath = path_join(path_dirname(filePath), rel);
            gather_module_sources(depPath, seen, visiting, sources);
        }
        i = i + 1;
    }

    visiting.set_delete(filePath);
    seen.set_add(filePath);
    sources.vec_push(source);
    0
}

fn compile_file(inputPath: *Str, outputPath: *Str) : I32 => {
    let seen = set_new();
    let visiting = set_new();
    let sources = vec_new();
    gather_module_sources(inputPath, seen, visiting, sources);
    let merged = join_sources(sources);
    let js = compile_source(merged);
    write_file(outputPath, js)
}

// Entry point for testing
fn main() : I32 => {
    print("Self-hosted Tuff compiler loaded");
    0
}
