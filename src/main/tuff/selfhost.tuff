/**
 * Self-hosted Tuff compiler.
 * Compiles Tuff source to JavaScript.
 */

let { compile_file } = selfhost::module_loader;
let { compile_file_with_options } = selfhost::module_loader;
let { selfhost_runtime_lexer_marker } = selfhost::runtime_lexer;
let { selfhost_parser_core_marker } = selfhost::parser_core;
let { selfhost_parser_expr_marker } = selfhost::parser_expr;
let { selfhost_parser_decls_marker } = selfhost::parser_decls;
let { selfhost_resolver_marker } = selfhost::resolver;
let { selfhost_typecheck_marker } = selfhost::typecheck;
let { selfhost_borrowcheck_marker } = selfhost::borrowcheck;
let { selfhost_codegen_expr_marker } = selfhost::codegen_expr;
let { selfhost_codegen_stmt_marker } = selfhost::codegen_stmt;
let { selfhost_codegen_c_marker } = selfhost::codegen_c;
let { selfhost_linter_marker } = selfhost::linter;
let { lex_init, lex_all, str_includes } = selfhost::runtime_lexer;
let { parse_init } = selfhost::parser_core;
let { p_parse_program, desugar } = selfhost::parser_decls;
let { resolve_names } = selfhost::resolver;
let { typecheck_program, typecheck_program_with_options } = selfhost::typecheck;
let { borrowcheck_program } = selfhost::borrowcheck;
let { generate_js } = selfhost::codegen_stmt;
let { generate_c } = selfhost::codegen_c;
let { lint_reset, lint_take_issues, lint_program } = selfhost::linter;
extern let { __host_get_c_substrate } = globalThis;
extern let { __host_get_c_runtime_prelude_source } = globalThis;
extern fn __host_get_c_substrate() : *Str;
extern fn __host_get_c_runtime_prelude_source() : *Str;
extern fn __host_emit_target_from_source(source: *Str, target: *Str) : *Str;

fn sanitize_max_effective_lines(max_effective_lines: I32) : I32 => {
    if (max_effective_lines <= 0) {
        500
    } else {
        max_effective_lines
    }
}

fn normalize_flag(value: I32) : I32 => {
    if (value == 0) { 0 } else { 1 }
}

fn with_c_runtime_prelude(source: *Str, target: *Str) : *Str => {
    if (!target.str_eq("c")) {
        return source;
    }
    if (source.str_includes("fn tuff_runtime_panic(")) {
        return source;
    }
    let prelude = __host_get_c_runtime_prelude_source();
    if (prelude.str_eq("")) {
        return source;
    }
    source.str_concat("\n\n").str_concat(prelude)
}

fn emit_target_output(typed: I32, source: *Str, target: *Str) : *Str => {
    if (target.str_eq("js")) {
        return generate_js(typed);
    }
    if (target.str_eq("c")) {
        return generate_c(typed, __host_get_c_substrate());
    }
    panic_with_code(
        "E_UNSUPPORTED_TARGET",
        "Unsupported codegen target: ".str_concat(target),
        "The compiler was asked to emit code for a target that is not implemented.",
        "Use target 'js' or target 'c'."
    );
    ""
}

out fn compile_source_with_options(source: *Str, strict_safety: I32, lint_enabled: I32, max_effective_lines: I32, borrow_enabled: I32, target: *Str) : *Str => {
    let effective_source = with_c_runtime_prelude(source, target);
    let max_lines = sanitize_max_effective_lines(max_effective_lines);
    let strict = normalize_flag(strict_safety);
    let lint = normalize_flag(lint_enabled);
    let borrow = normalize_flag(borrow_enabled);
    lint_reset();
    lex_init(effective_source);
    lex_all();
    parse_init();
    let program = p_parse_program();
    let desugared = desugar(program);
    let resolved = resolve_names(desugared);
    let typed = typecheck_program_with_options(resolved, strict);
    if (borrow == 1) {
        borrowcheck_program(typed);
    }
    if (lint == 1) {
        lint_program(typed, "<memory>", max_lines);
    }
    emit_target_output(typed, effective_source, target)
}

out fn take_lint_issues() : *Str => lint_take_issues();

// Main compiler pipeline
fn compile_source(source: *Str) : *Str => compile_source_with_options(source, 1, 0, 500, 1, "js");

// Entry point for testing
fn main() : I32 => {
    print("Self-hosted Tuff compiler loaded");
    0
}
