/**
 * Self-hosted Tuff compiler.
 * Compiles Tuff source to JavaScript.
 */

let { compile_file } = selfhost::module_loader;
let { compile_file_with_options } = selfhost::module_loader;
let { selfhost_runtime_lexer_marker } = selfhost::runtime_lexer;
let { selfhost_parser_core_marker } = selfhost::parser_core;
let { selfhost_parser_expr_marker } = selfhost::parser_expr;
let { selfhost_parser_decls_marker } = selfhost::parser_decls;
let { selfhost_resolver_marker } = selfhost::resolver;
let { selfhost_typecheck_marker } = selfhost::typecheck;
let { selfhost_borrowcheck_marker } = selfhost::borrowcheck;
let { selfhost_codegen_expr_marker } = selfhost::codegen_expr;
let { selfhost_codegen_stmt_marker } = selfhost::codegen_stmt;
let { selfhost_codegen_c_marker } = selfhost::codegen_c;
let { selfhost_linter_marker } = selfhost::linter;
let { lex_init, lex_all, tok_kind, tok_value, tok_line, tok_col, get_interned_str, str_includes } = selfhost::runtime_lexer;
let { parse_init } = selfhost::parser_core;
let { p_parse_program, desugar } = selfhost::parser_decls;
let { resolve_names } = selfhost::resolver;
let { typecheck_program, typecheck_program_with_options } = selfhost::typecheck;
let { borrowcheck_program } = selfhost::borrowcheck;
let { generate_js } = selfhost::codegen_stmt;
let { generate_c } = selfhost::codegen_c;
let { lint_reset, lint_take_issues, lint_program } = selfhost::linter;
extern let { __host_get_c_substrate } = globalThis;
extern let { __host_get_c_runtime_prelude_source } = globalThis;
extern let { __host_emit_target_from_source } = globalThis;
extern fn __host_get_c_substrate() : *Str;
extern fn __host_get_c_runtime_prelude_source() : *Str;
extern fn __host_emit_target_from_source(source: *Str, target: *Str) : *Str;

fn sanitize_max_effective_lines(max_effective_lines: I32) : I32 => {
    if (max_effective_lines <= 0) {
        500
    } else {
        max_effective_lines
    }
}

fn normalize_flag(value: I32) : I32 => {
    if (value == 0) { 0 } else { 1 }
}

fn with_c_runtime_prelude(source: *Str, target: *Str) : *Str => {
    if (!target.str_eq("c")) {
        return source;
    }
    if (source.str_includes("fn tuff_runtime_panic(")) {
        return source;
    }
    let prelude = __host_get_c_runtime_prelude_source();
    if (prelude.str_eq("")) {
        return source;
    }
    source.str_concat("\n\n").str_concat(prelude)
}

fn emit_target_output(typed: I32, source: *Str, target: *Str) : *Str => {
    if (target.str_eq("js")) {
        return generate_js(typed);
    }
    if (target.str_eq("c")) {
        return generate_c(typed, __host_get_c_substrate());
    }
    panic_with_code(
        "E_UNSUPPORTED_TARGET",
        "Unsupported codegen target: ".str_concat(target),
        "The compiler was asked to emit code for a target that is not implemented.",
        "Use target 'js' or target 'c'."
    );
    ""
}

out fn compile_source_with_options(source: *Str, strict_safety: I32, lint_enabled: I32, max_effective_lines: I32, borrow_enabled: I32, target: *Str) : *Str => {
    let t_start = perf_now();
    let effective_source = with_c_runtime_prelude(source, target);
    let max_lines = sanitize_max_effective_lines(max_effective_lines);
    let strict = normalize_flag(strict_safety);
    let lint = normalize_flag(lint_enabled);
    let borrow = normalize_flag(borrow_enabled);
    lint_reset();
    
    let t0 = perf_now();
    lex_init(effective_source);
    lex_all();
    let t1 = perf_now();
    profile_mark("lex", t1 - t0);
    
    let t1_parse = perf_now();
    parse_init();
    let program = p_parse_program();
    let t2_parse = perf_now();
    profile_mark("parse", t2_parse - t1_parse);
    
    let t2_desugar = perf_now();
    let desugared = desugar(program);
    let t3_desugar = perf_now();
    profile_mark("desugar", t3_desugar - t2_desugar);
    
    let t3_resolve = perf_now();
    let resolved = resolve_names(desugared);
    let t4_resolve = perf_now();
    profile_mark("resolve", t4_resolve - t3_resolve);
    
    let t4_typecheck = perf_now();
    let typed = typecheck_program_with_options(resolved, strict);
    let t5_typecheck = perf_now();
    profile_mark("typecheck", t5_typecheck - t4_typecheck);
    
    let t5_borrow = perf_now();
    if (borrow == 1) {
        borrowcheck_program(typed);
    }
    let t6_borrow = perf_now();
    profile_mark("borrowcheck", t6_borrow - t5_borrow);
    
    if (lint == 1) {
        lint_program(typed, "<memory>", max_lines);
    }
    
    let t6_emit = perf_now();
    let output = emit_target_output(typed, effective_source, target);
    let t7_emit = perf_now();
    profile_mark("emit", t7_emit - t6_emit);
    
    let t_end = perf_now();
    profile_mark("total", t_end - t_start);
    
    output
}

out fn take_lint_issues() : *Str => lint_take_issues();

// CPD lexer bridge exports (read-only wrappers)
out fn cpd_lex_init(source: *Str) : I32 => lex_init(source);
out fn cpd_lex_all() : I32 => lex_all();
out fn cpd_tok_kind(idx: I32) : I32 => tok_kind(idx);
out fn cpd_tok_value(idx: I32) : I32 => tok_value(idx);
out fn cpd_tok_line(idx: I32) : I32 => tok_line(idx);
out fn cpd_tok_col(idx: I32) : I32 => tok_col(idx);
out fn cpd_get_interned_str(idx: I32) : *Str => get_interned_str(idx);

// Main compiler pipeline
fn compile_source(source: *Str) : *Str => compile_source_with_options(source, 1, 0, 500, 1, "js");

// Main compiler CLI entry point
fn main() : I32 => {
    let argc = get_argc();
    // argv[0] is the executable name; we need at least argv[1] (input file).
    if (argc < 2) {
        print_error("Usage: tuffc <input.tuff> [-o <output>] [--target <js|c>] [--modules --module-base <dir>]");
        return 1;
    }

    // Fast-path: handle flags-only commands before any file parsing.
    let first_arg = get_argv(1);
    if (first_arg.str_eq("--version")) {
        print("tuffc (stage3 native)");
        return 0;
    }
    if (first_arg.str_eq("-h") || first_arg.str_eq("--help")) {
        print("Usage: tuffc <input.tuff> [-o <output>] [--target <js|c>] [--modules --module-base <dir>] [--version]");
        return 0;
    }

    let input_file = first_arg;
    let output_file = "";
    let target = "js";
    let use_modules = 0;
    let strict_safety = 0;
    let lint_enabled = 0;
    let borrow_enabled = 1;
    let profile_enabled = 0;
    let i = 2;
    let had_error = 0;

    while (i < argc) {
        let arg = get_argv(i);
        if (arg.str_eq("-o") || arg.str_eq("--out")) {
            i = i + 1;
            if (i < argc) {
                output_file = get_argv(i);
            } else {
                print_error("Missing value for -o/--out");
                had_error = 1;
            }
        } else if (arg.str_eq("--target")) {
            i = i + 1;
            if (i < argc) {
                target = get_argv(i);
            } else {
                print_error("Missing value for --target");
                had_error = 1;
            }
        } else if (arg.str_eq("--stage2")) {
            strict_safety = 1;
        } else if (arg.str_eq("--lint")) {
            lint_enabled = 1;
        } else if (arg.str_eq("--profile")) {
            profile_enabled = 1;
        } else if (arg.str_eq("--no-borrowcheck")) {
            borrow_enabled = 0;
        } else if (arg.str_eq("--modules")) {
            use_modules = 1;
        } else if (arg.str_eq("--module-base")) {
            // compile_file_with_options derives the base from path_dirname(inputPath);
            // consume the arg but don't need to do anything with it.
            i = i + 1;
            if (i >= argc) {
                print_error("Missing value for --module-base");
                had_error = 1;
            }
        }
        i = i + 1;
    }

    if (had_error == 1) {
        return 1;
    }

    if (use_modules == 1) {
        if (output_file.str_eq("")) {
            print_error("--modules requires -o <output_file>");
            return 1;
        }
        let result_code = compile_file_with_options(input_file, output_file, strict_safety, lint_enabled, 500, borrow_enabled, target);
        if (profile_enabled == 1) {
            print_error("[profile] ".str_concat(profile_take_json()));
        }
        return result_code;
    }

    let source = read_file(input_file);
    let result = compile_source_with_options(source, strict_safety, lint_enabled, 500, borrow_enabled, target);

    if (output_file.str_eq("")) {
        print(result);
    } else {
        write_file(output_file, result);
        print("Compiled ".str_concat(input_file).str_concat(" -> ").str_concat(output_file));
    }

    if (profile_enabled == 1) {
        print_error("[profile] ".str_concat(profile_take_json()));
    }

    0
}
