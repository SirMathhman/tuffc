/**
* Self - hosted Tuff compiler.
* Compiles Tuff source to JavaScript.
*/
let {
    compileFile
}
 = selfhost::moduleLoader;
let {
    compileFileWithOptions
}
 = selfhost::moduleLoader;
let {
    Ok, Err, Result
}
 = selfhost::Result;
let {
    ResolveError
}
 = selfhost::errors::ResolveError;
let {
    selfhostRuntimeLexerMarker, perfNow, printError, profileTakeJson
}
 = selfhost::runtimeLexer;
let {
    selfhostParserCoreMarker
}
 = selfhost::parserCore;
let {
    selfhostParserExprMarker
}
 = selfhost::parserExpr;
let {
    selfhostParserDeclsMarker
}
 = selfhost::parserDecls;
let {
    selfhostResolverMarker
}
 = selfhost::resolver;
let {
    selfhostTypecheckMarker
}
 = selfhost::typecheck;
let {
    selfhostBorrowcheckMarker
}
 = selfhost::borrowcheck;
let {
    selfhostCodegenExprMarker
}
 = selfhost::codegenExpr;
let {
    selfhostCodegenStmtMarker
}
 = selfhost::codegenStmt;
let {
    selfhostCodegenCMarker
}
 = selfhost::codegenC;
let {
    selfhostLinterMarker
}
 = selfhost::linter;
let {
    formatTuffSource, selfhostFormatterMarker
}
 = selfhost::formatter;
let {
    emitTuffFromTyped, selfhostTuffPrinterMarker
}
 = selfhost::tuffPrinter;
let {
    selfhostModuleSourcemapMarker
}
 = selfhost::moduleSourcemap;
let {
    lexInit, lexAll, tokKind, tokValue, tokLine, tokCol, getInternedStr, strIncludes,
    lexTakeTrivia
}
 = selfhost::runtimeLexer;
let {
    parseInit
}
 = selfhost::parserCore;
let {
    pParseProgram, desugar
}
 = selfhost::parserDecls;
let {
    resolveNames
}
 = selfhost::resolver;
let {
    typecheckProgram, typecheckProgramWithOptions
}
 = selfhost::typecheck;
let {
    borrowcheckProgram
}
 = selfhost::borrowcheck;
let {
    generateJs
}
 = selfhost::codegenStmt;
let {
    generateC
}
 = selfhost::codegenC;
let {
    lintReset, lintTakeIssues, lintProgram
}
 = selfhost::linter;
extern let {
    __host_get_c_substrate
}
 = globalThis;
extern let {
    __host_get_c_runtime_prelude_source
}
 = globalThis;
extern let {
    __host_emit_target_from_source
}
 = globalThis;
extern fn __host_get_c_substrate() : *Str;
extern fn __host_get_c_runtime_prelude_source() : *Str;
extern fn __host_emit_target_from_source(source: *Str, target: *Str) : *Str;
fn sanitizeMaxEffectiveLines(maxEffectiveLines: I32) : I32 => {
    if (maxEffectiveLines <= 0) {
        500
    }
    else {
        maxEffectiveLines
    }
}
fn normalizeFlag(value: I32) : I32 => {
    if (value = = 0) {
        0
    }
    else {
        1
    }
}
fn withCRuntimePrelude(source: *Str, target: *Str) : *Str => {
    if (!target.strEq("c") && !target.strEq("c-split")) {
        return source;
    }
    if (source.strIncludes("fn tuff_runtime_panic(")) {
        return source;
    }
    let prelude = __host_get_c_runtime_prelude_source();
    if (prelude.strEq("")) {
        return source;
    }
    source.strConcat("\n\n").strConcat(prelude)
}
fn emitTargetOutput(typed: I32, source: *Str, target: *Str) : *Str => {
    if (target.strEq("js")) {
        return generateJs(typed);
    }
    if (target.strEq("c")) {
        return generateC(typed, __host_get_c_substrate());
    }
    if (target.strEq("c-split")) {
        return generateC(typed, __host_get_c_substrate());
    }
    if (target.strEq("tuff")) {
        return emitTuffFromTyped(typed, source, lexTakeTrivia());
    }
    panicWithCode(
    "E_UNSUPPORTED_TARGET",
    "Unsupported codegen target: ".strConcat(target),
    "The compiler was asked to emit code for a target that is not implemented.",
    "Use target 'js', target 'c', target 'c-split', or target 'tuff'."
    );
    ""
}
out fn compileSourceWithOptions(source: *Str, lintEnabled: I32, maxEffectiveLines: I32,
borrowEnabled: I32, target: *Str, astDupEnabled: I32) : *Str => {
    let tStart = perfNow();
    let effectiveSource = withCRuntimePrelude(source, target);
    let maxLines = sanitizeMaxEffectiveLines(maxEffectiveLines);
    let lint = normalizeFlag(lintEnabled);
    let borrow = normalizeFlag(borrowEnabled);
    lintReset();
    let t0 = perfNow();
    lexInit(effectiveSource);
    lexAll();
    let t1 = perfNow();
    profileMark("lex", t1 - t0);
    let t1Parse = perfNow();
    parseInit();
    let program = pParseProgram();
    let t2Parse = perfNow();
    profileMark("parse", t2Parse - t1Parse);
    let t2Desugar = perfNow();
    let desugared = desugar(program);
    let t3Desugar = perfNow();
    profileMark("desugar", t3Desugar - t2Desugar);
    let t3Resolve = perfNow();
    let resolvedResultAny = resolveNames(desugared);
    if (resolvedResultAny is struct Err) {
        panic("Resolver error: ".strConcat(resolvedResultAny.error.message));
    }
    let resolved = 0;
    if (resolvedResultAny is struct Ok) {
        resolved = resolvedResultAny.value;
    }
    else {
        panic("Resolver returned unexpected result variant");
    }
    let t4Resolve = perfNow();
    profileMark("resolve", t4Resolve - t3Resolve);
    let t4Typecheck = perfNow();
    let typedResultAny = typecheckProgramWithOptions(resolved);
    if (typedResultAny is struct Err) {
        panic("Typechecker error: ".strConcat(typedResultAny.error.message));
    }
    let typed = 0;
    if (typedResultAny is struct Ok) {
        typed = typedResultAny.value;
    }
    else {
        panic("Typechecker returned unexpected result variant");
    }
    let t5Typecheck = perfNow();
    profileMark("typecheck", t5Typecheck - t4Typecheck);
    let t5Borrow = perfNow();
    if (borrow = = 1) {
        borrowcheckProgram(typed);
    }
    let t6Borrow = perfNow();
    profileMark("borrowcheck", t6Borrow - t5Borrow);
    if (lint = = 1) {
        lintProgram(typed, "<memory>", maxLines, 1, astDupEnabled);
    }
    let t6Emit = perfNow();
    let output = emitTargetOutput(typed, effectiveSource, target);
    let t7Emit = perfNow();
    profileMark("emit", t7Emit - t6Emit);
    let tEnd = perfNow();
    profileMark("total", tEnd - tStart);
    output
}
out fn takeLintIssues() : *Str => lintTakeIssues();
out fn formatSourceTuff(source: *Str) : *Str => formatTuffSource(source);
 // CPD lexer bridge exports (read-only wrappers)
out fn cpdLexInit(source: *Str) : I32 => lexInit(source);
out fn cpdLexAll() : I32 => lexAll();
out fn cpdTokKind(idx: I32) : I32 => tokKind(idx);
out fn cpdTokValue(idx: I32) : I32 => tokValue(idx);
out fn cpdTokLine(idx: I32) : I32 => tokLine(idx);
out fn cpdTokCol(idx: I32) : I32 => tokCol(idx);
out fn cpdGetInternedStr(idx: I32) : *Str => getInternedStr(idx);
 // Main compiler pipeline
fn compileSource(source: *Str) : *Str => compileSourceWithOptions(source, 0, 500, 1, "js", 0);
 // Linter CLI entry point
fn mainLint() : I32 => {
    let argc = getArgc();
     // argv[0] is executable, argv[1] is "lint" subcommand, argv[2] should be input file
    if (argc < 3) {
        printError("Usage: tuffc lint <input.tuff> [--strict] [--ast-dup|--no-ast-dup] [--max-lines <n>] [--target <js|c>]");
        return 1;
    }
    let inputFile = getArgv(2);
    let target = "js";
    let maxLines = 500;
    let astDupEnabled = 1;
    let strict = 0;
    let borrowEnabled = 1;
    let i = 3;
    let hadError = 0;
    while (i < argc) {
        let arg = getArgv(i);
        if (arg.strEq("--strict")) {
            strict = 1;
        }
        else if (arg.strEq("--ast-dup")) {
            astDupEnabled = 1;
        }
        else if (arg.strEq("--no-ast-dup")) {
            astDupEnabled = 0;
        }
        else if (arg.strEq("--max-lines")) {
            i = i + 1;
            if (i < argc) {
                maxLines = parseInt(getArgv(i));
                if (maxLines <= 0) {
                    printError("Invalid value for --max-lines");
                    hadError = 1;
                }
            }
            else {
                printError("Missing value for --max-lines");
                hadError = 1;
            }
        }
        else if (arg.strEq("--target")) {
            i = i + 1;
            if (i < argc) {
                target = getArgv(i);
            }
            else {
                printError("Missing value for --target");
                hadError = 1;
            }
        }
        else {
            printError("Unknown lint option: ".strConcat(arg));
            hadError = 1;
        }
        i = i + 1;
    }
    if (hadError = = 1) {
        return 1;
    }
     // Use a scratch output path (linter doesn't use the compiled output)
    let scratchOutput = "C:\\\\Windows\\\\Temp\\\\tuff-lint-scratch.js";
     // Compile with lint enabled (always strict in lint mode)
    let resultCode = compileFileWithOptions(inputFile, scratchOutput, 1, maxLines,
    borrowEnabled, target, astDupEnabled);
     // Check lint issues
    let issues = takeLintIssues();
    if (issues.strLength() > 0) {
        printError("[lint] ".strConcat(issues));
        if (strict = = 1) {
            resultCode = 1;
        }
    }
    else {
        print("No lint issues found.");
    }
    resultCode
}
 // Main compiler CLI entry point
fn main() : I32 => {
    let argc = getArgc();
     // argv[0] is the executable name; we need at least argv[1] (input file).
    if (argc < 2) {
        printError("Usage: tuffc <input.tuff> -o <output> [--target <js|c|c-split|tuff>] [--module-base <dir> (legacy)]");
        return 1;
    }
     // Check for lint subcommand
    let firstArg = getArgv(1);
    if (firstArg.strEq("lint")) {
        return mainLint();
    }
     // Fast-path: handle flags-only commands before any file parsing.
    if (firstArg.strEq("--version")) {
        print("tuffc (stage3 native)");
        return 0;
    }
    if (firstArg.strEq("-h") || firstArg.strEq("--help")) {
        print("Usage: tuffc <input.tuff> -o <output> [--target <js|c|c-split|tuff>] [--module-base <dir> (legacy)] [--version]");
        return 0;
    }
    let inputFile = firstArg;
    let outputFile = "";
    let target = "js";
    let lintEnabled = 0;
    let lintAstDupEnabled = 1;
    let borrowEnabled = 1;
    let profileEnabled = 0;
    let i = 2;
    let hadError = 0;
    while (i < argc) {
        let arg = getArgv(i);
        if (arg.strEq("-o") || arg.strEq("--out")) {
            i = i + 1;
            if (i < argc) {
                outputFile = getArgv(i);
            }
            else {
                printError("Missing value for -o/--out");
                hadError = 1;
            }
        }
        else if (arg.strEq("--target")) {
            i = i + 1;
            if (i < argc) {
                target = getArgv(i);
            }
            else {
                printError("Missing value for --target");
                hadError = 1;
            }
        }
        else if (arg.strEq("--lint")) {
            lintEnabled = 1;
        }
        else if (arg.strEq("--no-lint-ast-dup")) {
            lintAstDupEnabled = 0;
        }
        else if (arg.strEq("--profile")) {
            profileEnabled = 1;
        }
        else if (arg.strEq("--no-borrowcheck")) {
            borrowEnabled = 0;
        }
        else if (arg.strEq("--modules") || arg.strEq("--no-modules")) {
            printError("Legacy option: ".strConcat(arg).strConcat(". Module graph loading is always enabled for file compilation; remove this option."));
            hadError = 1;
        }
        else if (arg.strEq("--module-base")) {
             // compile_file_with_options derives the base from path_dirname(inputPath);
             // consume the arg but don't need to do anything with it.
            i = i + 1;
            if (i >= argc) {
                printError("Missing value for --module-base");
                hadError = 1;
            }
        }
        i = i + 1;
    }
    if (hadError = = 1) {
        return 1;
    }
    if (outputFile.strEq("")) {
        printError("Missing required -o/--out <output_file>. Native selfhost CLI writes compiled output to a file.");
        return 1;
    }
    let resultCode = compileFileWithOptions(inputFile, outputFile, lintEnabled, 500,
    borrowEnabled, target, lintAstDupEnabled);
    if (resultCode = = 0) {
        print("Compiled ".strConcat(inputFile).strConcat(" -> ").strConcat(outputFile));
    }
    if (lintEnabled = = 1) {
        let issues = takeLintIssues();
        if (issues.strLength() > 0) {
            printError("[lint] ".strConcat(issues));
            resultCode = 1;
        }
    }
    if (profileEnabled = = 1) {
        printError("[profile] ".strConcat(profileTakeJson()));
    }
    resultCode
}
