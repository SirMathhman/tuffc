/**
 * Stage 1 compiler in Tuff-lite.
 *
 * This mirrors the Stage 0 pipeline in Tuff source form:
 * lexer -> parser -> desugar -> resolve -> typecheck -> js codegen
 *
 * The host runtime provides implementation hooks under __host_*.
 */

struct CompileArtifacts {
    tokens : I32,
    cst : I32,
    core : I32,
    js : *Str
}

fn stage1Lex(source : *Str) => __host_lex(source);
fn stage1Parse(tokens : I32) => __host_parse(tokens);
fn stage1Desugar(cst : I32) => __host_desugar(cst);
fn stage1Resolve(core : I32) => __host_resolveNames(core);
fn stage1Typecheck(core : I32) => __host_typecheck(core);
fn stage1GenerateJavaScript(core : I32) => __host_generateJavaScript(core);

fn compileToArtifacts(source : *Str) : CompileArtifacts => {
    let tokens = stage1Lex(source);
    let cst = stage1Parse(tokens);
    let coreA = stage1Desugar(cst);
    let coreB = stage1Resolve(coreA);
    let coreC = stage1Typecheck(coreB);
    let js = stage1GenerateJavaScript(coreC);
    CompileArtifacts {
        tokens : tokens,
        cst : cst,
        core : coreC,
        js : js
    }
}

fn compileToJs(source : *Str) : *Str => {
    let result = compileToArtifacts(source);
    result.js
}

fn compileFileToJs(inputPath : *Str, outputPath : *Str) : I32 => {
    let source = __host_readFile(inputPath);
    let emitted = compileToJs(source);
    __host_writeFile(outputPath, emitted)
}

fn main() : I32 => 0;