import fs from "node:fs";
import path from "node:path";
import { spawnSync } from "node:child_process";
import type { VerificationCertificate } from "./certificate.ts";

// ---------------------------------------------------------------------------
// Typst source generation
// ---------------------------------------------------------------------------

function escapeTypst(s: string): string {
  // Escape backslash first, then square brackets (Typst markup syntax).
  return s.replace(/\\/g, "\\\\").replace(/\[/g, "\\[").replace(/\]/g, "\\]");
}

function renderTypstSource(cert: VerificationCertificate): string {
  const propertyRows = cert.properties
    .map(
      (p) =>
        `  [*${escapeTypst(p.name)}*], [${escapeTypst(p.description)}], [${p.enforcedBy.join(", ")}],`,
    )
    .join("\n");

  const sourceRows = cert.sourceFiles
    .map((f) => `  [${escapeTypst(path.basename(f.path))}], [#raw("${f.sha256}")],`)
    .join("\n");

  const outcomeText = cert.compilationOutcome.success
    ? "#text(green)[*PASSED*]"
    : `#text(red)[*FAILED*] — diagnostics: ${cert.compilationOutcome.diagnosticCodes.join(", ") || "none"}`;

  return `#set document(title: "${escapeTypst(cert.documentTitle)}")
#set page(margin: 2cm)
#set text(font: "New Computer Modern", size: 11pt)

#align(center)[
  #text(size: 18pt, weight: "bold")[${escapeTypst(cert.documentTitle)}]

  #v(0.4em)
  #text(size: 11pt, style: "italic")[Compiler version: ${escapeTypst(cert.compilerVersion)} · Schema: ${cert.schemaVersion}]

  #v(0.2em)
  #text(size: 10pt)[Issued: ${escapeTypst(cert.timestamp)}]
]

#v(1em)
#line(length: 100%)
#v(0.5em)

= Compilation Outcome

Outcome: ${outcomeText}

= Source Files

#table(
  columns: (auto, 1fr),
  [*File*], [*SHA-256*],
${sourceRows}
)

*Combined SHA-256:* #raw("${cert.combinedSha256}")

= Safety Properties

The following eight properties are enforced by the Tuff compiler for every successfully compiled program:

#table(
  columns: (auto, 1fr, auto),
  [*Property*], [*Description*], [*Enforcing Pass*],
${propertyRows}
)

= What This Certificate Asserts

${escapeTypst(cert.certifies)}

= What This Certificate Does Not Assert

${escapeTypst(cert.doesNotCertify)}

#v(1em)
#line(length: 100%)
#align(center)[#text(size: 9pt, style: "italic")[Generated by tuffc ${escapeTypst(cert.compilerVersion)}]]
`;
}

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/**
 * Write a `.typ` file alongside the JSON certificate.
 * Returns the path to the written `.typ` file, or null if writing failed.
 */
export function writeTypstSource(
  cert: VerificationCertificate,
  jsonCertPath: string,
): string | null {
  const typPath = jsonCertPath.replace(/\.json$/i, "") + ".typ";
  try {
    fs.writeFileSync(typPath, renderTypstSource(cert), "utf8");
    return typPath;
  } catch (e) {
    console.error(`tuffc: warning: could not write Typst source to ${typPath}: ${e}`);
    return null;
  }
}

/**
 * Attempt to compile a `.typ` file to PDF using the `typst` CLI.
 * Silently skips if `typst` is not on PATH; logs a hint in that case.
 * Returns true if PDF was produced, false otherwise.
 */
export function compileTypstToPdf(typPath: string): boolean {
  const pdfPath = typPath.replace(/\.typ$/, ".pdf");
  const result = spawnSync("typst", ["compile", typPath, pdfPath], {
    encoding: "utf8",
  });

  if (result.error) {
    // typst binary not found — hint but don't fail
    console.log(
      `tuffc: hint: install the Typst CLI (https://typst.app) to also generate a PDF certificate.`,
    );
    return false;
  }

  if (result.status !== 0) {
    console.error(
      `tuffc: warning: typst returned exit code ${result.status}:\n${result.stderr ?? ""}`,
    );
    return false;
  }

  console.log(`Certificate PDF written to ${pdfPath}`);
  return true;
}
