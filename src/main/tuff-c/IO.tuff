extern let { printf, fopen, fclose, fwrite } = stdio;
extern let { malloc, free } = stdlib;
extern let { strlen, strcpy, strcat } = string;

extern fn printf(fmt : *Str, msg : *Str) : I32;
extern fn fopen(path : *Str, mode : *Str) : I32;
extern fn fclose(file : I32) : I32;
extern fn fwrite(data : *Str, itemSize : USize, itemCount : USize, file : I32) : USize;
extern fn malloc(size : USize) : I32;
extern fn free(ptr : I32) : Void;
extern fn strlen(s : *Str) : USize;
extern fn strcpy(dst : I32, src : *Str) : I32;
extern fn strcat(dst : I32, src : *Str) : I32;


// Temporary fallback until full stdlib-only file read support is completed.
out fn readFile(path : *Str) : *Str => "";

out fn writeFile(path : *Str, contents : *Str) : I32 => {
	let file = fopen(path, "wb");
	if (file == 0) return 0;
	let len = strlen(contents);
	fwrite(contents, 1USize, len, file);
	fclose(file)
};

out fn pathJoin(a : *Str, b : *Str) : *Str => {
	let alen = strlen(a);
	let blen = strlen(b);
	let cap = alen + blen + 2USize;
	let outPtr = malloc(cap);
	if (outPtr == 0) return "";
	strcpy(outPtr, a);
	if (alen > 0USize) {
		strcat(outPtr, "/");
	}
	strcat(outPtr, b);
	outPtr
};

out fn pathDirname(p : *Str) : *Str => p;

out fn print(s : *Str) : I32 => printf("%s\n", s);
out fn printError(s : *Str) : I32 => printf("[error] %s\n", s);
