extern let { strlen } = string;
extern let { malloc, free } = stdlib;

extern fn strlen(s : *Str) : USize;
type Alloc<T> = T then free;
type Vec<T> = Alloc<*[T; _; _]> | 0;
type Map<K, V> = Alloc<*[I32; _; _]> | 0;
type Set<T> = Alloc<*[I32; _; _]> | 0;

extern fn malloc<T, L : USize>(bytesCount : SizeOf<T> * L) : Alloc<*[T; 0; L]> | 0;

lifetime t {
	extern fn realloc<T, I : USize, L : USize, L2 : USize >= I>(
		ptr : Alloc<*t [T; I; L]>,
		bytesCount : SizeOf<T> * L2
	) : Alloc<*t [T; I; L2]> | 0;
}

extern fn free<T>(this : Alloc<*[T; _; _]>) : Void;

let DEFAULT_SIZE = 10USize;
let EMPTY_VEC_I32 : Vec<I32> = 0;
let EMPTY_MAP_I32_I32 : Map<I32, I32> = 0;
let EMPTY_SET_I32 : Set<I32> = 0;

fn vecI32EnsureCapacity(this : Vec<I32>, need : USize) : Vec<I32> => {
	if (this == 0) return this;
	if (this.length >= need) return this;

	let mut nextLen = if (this.length == 0USize) 4USize else this.length;
	while (nextLen < need) {
		nextLen = nextLen * 2USize;
	}

	let grown = realloc<I32, nextLen>(this, sizeOf<I32>() * nextLen);
	if (grown == 0) return this;
	grown
}

fn mapI32EnsureCapacity(this : Map<I32, I32>, need : USize) : Map<I32, I32> => {
	if (this == 0) return this;
	if (this.length >= need) return this;

	let mut nextLen = if (this.length == 0USize) 4USize else this.length;
	while (nextLen < need) {
		nextLen = nextLen * 2USize;
	}

	let grown = realloc<I32, nextLen>(this, sizeOf<I32>() * nextLen);
	if (grown == 0) return this;
	grown
}

fn setI32EnsureCapacity(this : Set<I32>, need : USize) : Set<I32> => {
	if (this == 0) return this;
	if (this.length >= need) return this;

	let mut nextLen = if (this.length == 0USize) 4USize else this.length;
	while (nextLen < need) {
		nextLen = nextLen * 2USize;
	}

	let grown = realloc<I32, nextLen>(this, sizeOf<I32>() * nextLen);
	if (grown == 0) return this;
	grown
}

out fn length(this : *Str) : USize => strlen(this);

out fn vecNewI32() : Vec<I32> => {
	let outPtr = malloc<I32, DEFAULT_SIZE>(sizeOf<I32>() * DEFAULT_SIZE);
	if (outPtr == 0) return EMPTY_VEC_I32;
	outPtr
};

out fn vecPushI32(this : Vec<I32>, item : I32) : Vec<I32> => {
	let mut slice = this;
	if (slice == 0) return this;

	slice = vecI32EnsureCapacity(slice, slice.init + 1USize);
	slice[slice.init] = item;
	slice.init = slice.init + 1USize;
	slice
};

out fn vecGetI32(this : Vec<I32>, index : USize) : I32 => {
	if (this == 0 || index >= this.init) return 0;
	this[index]
};

out fn vecSetI32(this : Vec<I32>, index : USize, item : I32) : Vec<I32> => {
	if (this == 0) return this;
	if (index > this.init) return this;
	let mut slice = vecI32EnsureCapacity(this, index + 1USize);
	slice[index] = item;
	if (index == slice.init) {
		slice.init = slice.init + 1USize;
	}
	slice
};

out fn vecInitI32(this : Vec<I32>) : USize => if (this == 0) 0USize else this.init;
out fn vecCapacityI32(this : Vec<I32>) : USize => if (this == 0) 0USize else this.length;
out fn vecLengthI32(this : Vec<I32>) : USize => vecInitI32(this);

out fn mapNewI32I32() : Map<I32, I32> => {
	let outPtr = malloc<I32, DEFAULT_SIZE>(sizeOf<I32>() * DEFAULT_SIZE);
	if (outPtr == 0) return EMPTY_MAP_I32_I32;
	outPtr
};

out fn mapSetI32I32(this : Map<I32, I32>, k : I32, v : I32) : Map<I32, I32> => {
	let mut m = this;
	if (m == 0) return m;

	let mut i = 0USize;
	while (i + 1USize < m.init) {
		if (m[i] == k) {
			m[i + 1USize] = v;
			return m;
		}
		i = i + 2USize;
	}

	m = mapI32EnsureCapacity(m, m.init + 2USize);
	m[m.init] = k;
	m.init = m.init + 1USize;
	m[m.init] = v;
	m.init = m.init + 1USize;
	m
};

out fn mapGetI32I32(this : Map<I32, I32>, k : I32) : I32 => {
	if (this == 0) return 0;
	let mut i = 0USize;
	while (i + 1USize < this.init) {
		if (this[i] == k) {
			return this[i + 1USize];
		}
		i = i + 2USize;
	}
	0
};

out fn setNewI32() : Set<I32> => {
	let outPtr = malloc<I32, DEFAULT_SIZE>(sizeOf<I32>() * DEFAULT_SIZE);
	if (outPtr == 0) return EMPTY_SET_I32;
	outPtr
};

out fn setAddI32(this : Set<I32>, item : I32) : Set<I32> => {
	if (setHasI32(this, item)) return this;
	let mut s = setI32EnsureCapacity(this, this.init + 1USize);
	s[s.init] = item;
	s.init = s.init + 1USize;
	s
};

out fn setHasI32(this : Set<I32>, item : I32) : Bool => {
	if (this == 0) return false;
	let mut i = 0USize;
	while (i < this.init) {
		if (this[i] == item) return true;
		i = i + 1USize;
	}
	false
};