extern let { __vec_new, vec_push, vec_get, vec_set, vec_init, vec_capacity, vec_includes, vec_length, __map_new, map_set, map_get, __set_new, set_add, set_has } = collections;

extern type Vec<T>;
extern fn __vec_new() : Vec<I32>;
extern fn vec_push(this: Vec<I32>, item: I32) : Vec<I32>;
extern fn vec_get(this: Vec<I32>, index: USize) : I32;
extern fn vec_set(this: Vec<I32>, index: USize, item: I32) : Vec<I32>;
extern fn vec_init(this: Vec<I32>) : USize;
extern fn vec_capacity(this: Vec<I32>) : USize;
extern fn vec_includes(this: Vec<I32>, item: I32) : Bool;
extern fn vec_length(this: Vec<I32>) : USize;
fn vec_new() : Vec<I32> => __vec_new();

extern type Map<K, V>;
extern fn __map_new() : Map<I32, I32>;
extern fn map_set(this: Map<I32, I32>, k: I32, v: I32) : Map<I32, I32>;
extern fn map_get(this: Map<I32, I32>, k: I32) : I32;
fn map_new() : Map<I32, I32> => __map_new();

extern type Set<T>;
extern fn __set_new() : Set<I32>;
extern fn set_add(this: Set<I32>, item: I32) : Set<I32>;
extern fn set_has(this: Set<I32>, item: I32) : Bool;
fn set_new() : Set<I32> => __set_new();

fn main() : I32 => {
    let v = vec_new();
    v.vec_push(7);
    v.vec_push(9);
    v.vec_set(v.vec_length(), 11);

    let m = map_new();
    m.map_set(5, 11);

    let s = set_new();
    s.set_add(42);

    if (
        v.vec_length() == 3 &&
        v.vec_init() == 3 &&
        v.vec_capacity() >= v.vec_init() &&
        v.vec_get(2) == 11 &&
        v.vec_includes(9) &&
        m.map_get(5) == 11 &&
        s.set_has(42)
    ) {
        return 0;
    }
    return 13;
}