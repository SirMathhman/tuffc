// Iterator semantic convention tests
// Iterator shape: () => (Bool, T) where Bool indicates "hasValue"

// Test 1: Range iterator produces values until exhausted
fn testRangeBasic(): I32 => {
    let iter = range(0, 3); // Should produce (true, 0), (true, 1), (true, 2), (false, ?)
    let (has1, v1) = iter();
    let (has2, v2) = iter();
    let (has3, v3) = iter();
    let (has4, v4) = iter();
    
    if (!has1 || v1 != 0) return 1;
    if (!has2 || v2 != 1) return 2;
    if (!has3 || v3 != 2) return 3;
    if (has4) return 4; // Should be exhausted
    
    0
}

// Test 2: first() on non-empty iterator returns Some
fn testFirstNonempty(): I32 => {
    let iter = range(10, 15);
    let result = first(iter);
    
    match (result) {
        case Some { value } = if (value == 10) 0 else 5;
        case None = 6;
    }
}

// Test 3: first() on empty iterator returns None
fn testFirstEmpty(): I32 => {
    let iter = range(5, 5); // Empty range
    let result = first(iter);
    
    match (result) {
        case Some { value } = 7;
        case None = 0;
    }
}

// Test 4: filter preserves hasValue semantics
fn testFilter(): I32 => {
    let iter = range(0, 10);
    let evens = filter(iter, |x| x % 2 == 0);
    
    let (has1, v1) = evens();
    let (has2, v2) = evens();
    let (has3, v3) = evens();
    
    if (!has1 || v1 != 0) return 8;
    if (!has2 || v2 != 2) return 9;
    if (!has3 || v3 != 4) return 10;
    
    0
}

// Helper: simple range iterator
fn range(start: I32, end: I32): () => (Bool, I32) => {
    let mut current = start;
    return () => {
        if (current < end) {
            let value = current;
            current = current + 1;
            (true, value)
        } else {
            (false, 0) // Exhausted; element is garbage
        }
    };
}

// Helper: first implementation
struct Some<T> { value: T }
struct None<T> {}
type Option<T> = Some<T> | None<T>;

fn first<T>(iter: () => (Bool, T)): Option<T> => {
    let (hasValue, element) = iter();
    if (hasValue) Some<T> { value: element } else None<T>
}

// Helper: filter implementation
fn filter<T>(iter: () => (Bool, T), predicate: (T) => Bool): () => (Bool, T) => {
    return () => {
        loop {
            let (hasValue, element) = iter();
            if (!hasValue) return (false, element); // Propagate exhaustion
            if (predicate(element)) return (true, element);
            // Drop element and continue (element goes out of scope)
        }
    };
}

fn main(): I32 => {
    let r1 = testRangeBasic();
    if (r1 != 0) return r1;
    
    let r2 = testFirstNonempty();
    if (r2 != 0) return r2;
    
    let r3 = testFirstEmpty();
    if (r3 != 0) return r3;
    
    let r4 = testFilter();
    if (r4 != 0) return r4;
    
    0
}
