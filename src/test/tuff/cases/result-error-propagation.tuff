// Test: Result error propagation with ? operator
// Validates that Err values propagate correctly through call chains

struct ParseError {
    code: *Str,
    line: I32
}

struct ValidationError {
    field: *Str
}

// Test 1: Successful Ok path
fn parse_number_ok() : Result<I32, ParseError> => {
    Ok<I32> { value: 42 }
}

fn validate_number_ok(n: I32) : Result<I32, ValidationError> => {
    if (n > 0) {
        Ok<I32> { value: n }
    } else {
        Err<ValidationError> { error: ValidationError { field: "number" } }
    }
}

fn process_ok() : Result<I32, ParseError> => {
    let num: I32 = parse_number_ok()?;
    Ok<I32> { value: num * 2 }
}

// Test 2: Error propagation stops execution
fn will_return_error() : Result<I32, ParseError> => {
    Err<ParseError> { error: ParseError { code: "E_PARSE_INVALID", line: 10 } }
}

fn should_propagate_error() : Result<I32, ParseError> => {
    // This should immediately return Err without executing subsequent lines
    let num: I32 = will_return_error()?;
    // This line should NOT execute
    Ok<I32> { value: num + 100 }
}

// Test 3: Deep call chain with error in the middle
fn step1(x: I32) : Result<I32, ParseError> => {
    Ok<I32> { value: x + 1 }
}

fn step2_fails(x: I32) : Result<I32, ParseError> => {
    Err<ParseError> { error: ParseError { code: "E_STEP2_FAIL", line: 20 } }
}

fn step3(x: I32) : Result<I32, ParseError> => {
    Ok<I32> { value: x * 2 }
}

fn chain_with_error() : Result<I32, ParseError> => {
    let a: I32 = step1(5)?;      // OK: a = 6
    let b: I32 = step2_fails(a)?; // Error here - should return immediately
    let c: I32 = step3(b)?;       // This should NOT execute
    Ok<I32> { value: c }
}

// Test 4: Multiple ? operators in sequence
fn op1() : Result<I32, ValidationError> => {
    Ok<I32> { value: 10 }
}

fn op2() : Result<I32, ValidationError> => {
    Ok<I32> { value: 20 }
}

fn op3() : Result<I32, ValidationError> => {
    Ok<I32> { value: 30 }
}

fn multiple_unwraps() : Result<I32, ValidationError> => {
    let x: I32 = op1()?;
    let y: I32 = op2()?;
    let z: I32 = op3()?;
    Ok<I32> { value: x + y + z }
}

// Test 5: ? operator on call result directly
fn inline_unwrap() : Result<I32, ParseError> => {
    Ok<I32> { value: parse_number_ok()? + 10 }
}

// Main tests
fn main() : I32 => {
    // Test successful path
    let r1: Result<I32, ParseError> = process_ok();
    // Can't directly test Err cases without match, but verify Ok path works
    let v1: I32 = r1?;
    
    // Test multiple unwraps
    let r2: Result<I32, ValidationError> = multiple_unwraps();
    let v2: I32 = r2?;
    
    // Test inline unwrap
    let r3: Result<I32, ParseError> = inline_unwrap();
    let v3: I32 = r3?;
    
    if (v1 == 84 && v2 == 60 && v3 == 52) {
        0  // All tests passed
    } else {
        1  // Test failure
    }
}
