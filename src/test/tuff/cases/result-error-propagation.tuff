// Test: Result error propagation with ? operator
// Validates that Err values propagate correctly through call chains

struct ParseError {
    code: *Str,
    line: I32
}

struct ValidationError {
    field: *Str
}

// Test 1: Successful Ok path
fn parseNumberOk() : Result<I32, ParseError> => {
    Ok<I32> { value: 42 }
}

fn validateNumberOk(n: I32) : Result<I32, ValidationError> => {
    if (n > 0) {
        Ok<I32> { value: n }
    } else {
        Err<ValidationError> { error: ValidationError { field: "number" } }
    }
}

fn processOk() : Result<I32, ParseError> => {
    let num: I32 = parseNumberOk()?;
    Ok<I32> { value: num * 2 }
}

// Test 2: Error propagation stops execution
fn willReturnError() : Result<I32, ParseError> => {
    Err<ParseError> { error: ParseError { code: "E_PARSE_INVALID", line: 10 } }
}

fn shouldPropagateError() : Result<I32, ParseError> => {
    // This should immediately return Err without executing subsequent lines
    let num: I32 = willReturnError()?;
    // This line should NOT execute
    Ok<I32> { value: num + 100 }
}

// Test 3: Deep call chain with error in the middle
fn step1(x: I32) : Result<I32, ParseError> => {
    Ok<I32> { value: x + 1 }
}

fn step2Fails(x: I32) : Result<I32, ParseError> => {
    Err<ParseError> { error: ParseError { code: "E_STEP2_FAIL", line: 20 } }
}

fn step3(x: I32) : Result<I32, ParseError> => {
    Ok<I32> { value: x * 2 }
}

fn chainWithError() : Result<I32, ParseError> => {
    let a: I32 = step1(5)?;      // OK: a = 6
    let b: I32 = step2Fails(a)?; // Error here - should return immediately
    let c: I32 = step3(b)?;       // This should NOT execute
    Ok<I32> { value: c }
}

// Test 4: Multiple ? operators in sequence
fn op1() : Result<I32, ValidationError> => {
    Ok<I32> { value: 10 }
}

fn op2() : Result<I32, ValidationError> => {
    Ok<I32> { value: 20 }
}

fn op3() : Result<I32, ValidationError> => {
    Ok<I32> { value: 30 }
}

fn multipleUnwraps() : Result<I32, ValidationError> => {
    let x: I32 = op1()?;
    let y: I32 = op2()?;
    let z: I32 = op3()?;
    Ok<I32> { value: x + y + z }
}

// Test 5: ? operator on call result directly
fn inlineUnwrap() : Result<I32, ParseError> => {
    Ok<I32> { value: parseNumberOk()? + 10 }
}

// Main tests
fn main() : I32 => {
    // Test successful path
    let r1: Result<I32, ParseError> = processOk();
    // Can't directly test Err cases without match, but verify Ok path works
    let v1: I32 = r1?;
    
    // Test multiple unwraps
    let r2: Result<I32, ValidationError> = multipleUnwraps();
    let v2: I32 = r2?;
    
    // Test inline unwrap
    let r3: Result<I32, ParseError> = inlineUnwrap();
    let v3: I32 = r3?;
    
    if (v1 == 84 && v2 == 60 && v3 == 52) {
        0  // All tests passed
    } else {
        1  // Test failure
    }
}
