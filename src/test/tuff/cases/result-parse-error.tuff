// Test: Result with compiler error types
// Demonstrates using the compiler's ParseError type

struct Ok<T> {
    value: T
}

struct Err<E> {
    error: E
}

type Result<T, E> = Ok<T> | Err<E>;

struct ParseError {
    code: *Str,
    message: *Str,
    reason: *Str,
    fix: *Str,
    line: I32,
    col: I32
}

// Function that validates identifier format
fn validateIdentifier(name: *Str) : Result<I32, ParseError> => {
    let len = name.strLength();
    if (len == 0) {
        return Err<ParseError> {
            error: ParseError {
                code: "E_PARSE_EMPTY_IDENTIFIER",
                message: "Identifier cannot be empty",
                reason: "Identifiers must contain at least one character",
                fix: "Provide a non-empty identifier name",
                line: 0,
                col: 0
            }
        };
    }
    
    // Simulate success - return some node ID
    return Ok<I32> {
        value: 42
    };
}

// Test valid identifier
fn testValidIdentifier() : I32 => {
    let result = validateIdentifier("myVar");
    match (result) {
        case Ok { value } = value;
        case Err { error } = -999;
    }
}

// Test empty identifier
fn testEmptyIdentifier() : I32 => {
    let result = validateIdentifier("");
    match (result) {
        case Ok { value } = -998;
        case Err { error } = if (error.code == "E_PARSE_EMPTY_IDENTIFIER") {
            -1
        } else {
            -997
        };
    }
}

out fn main() : I32 => {
    let valid = testValidIdentifier();
    if (valid != 42) {
        panic("Expected test_valid_identifier() to return 42");
    }
    
    let invalid = testEmptyIdentifier();
    if (invalid != -1) {
        panic("Expected test_empty_identifier() to return -1");
    }
    
    0
}
