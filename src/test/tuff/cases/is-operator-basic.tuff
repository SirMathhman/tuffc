// Test: `is` operator for type discrimination
// Validates basic runtime type checks and type narrowing

struct Ok<T> {
    value: T
}

struct Err<E> {
    error: E
}

type Result<T, E> = Ok<T> |> Err<E>;

struct MyError {
    code: I32
}

// Test 1: Basic `is` check with Ok
fn testIsOk() : Bool => {
    let r: Result<I32, MyError> = Ok<I32> { value: 42 };
    r is Ok
}

// Test 2: Basic `is` check with Err
fn testIsErr() : Bool => {
    let r: Result<I32, MyError> = Err<MyError> { error: MyError { code: 1 } };
    r is Err
}

// Test 3: Type narrowing in if statement
fn testTypeNarrowing() : I32 => {
    let r: Result<I32, MyError> = Ok<I32> { value: 100 };
    if (r is Ok) {
        r.value  // Type narrowed to Ok<I32>, can access .value
    } else {
        0
    }
}

// Test 4: Type narrowing in else branch
fn testElseNarrowing() : I32 => {
    let r: Result<I32, MyError> = Err<MyError> { error: MyError { code: 5 } };
    if (r is Ok) {
        0
    } else {
        r.error.code  // Type narrowed to Err<MyError>, can access .error
    }
}

// Test 5: Multiple checks in sequence
fn testMultipleChecks(r: Result<I32, MyError>) : I32 => {
    if (r is Ok) {
        r.value * 2
    } else if (r is Err) {
        r.error.code * 10
    } else {
        -1  // Should never reach here
    }
}

// Test 6: Pattern matching with struct destructuring
fn testStructPattern() : I32 => {
    let r: Result<I32, MyError> = Ok<I32> { value: 25 };
    if (r is Ok) {
        r.value + 10
    } else {
        0
    }
}

fn main() : I32 => {
    let t1: Bool = testIsOk();
    let t2: Bool = testIsErr();
    let t3: I32 = testTypeNarrowing();
    let t4: I32 = testElseNarrowing();
    let t5: I32 = testMultipleChecks(Ok<I32> { value: 7 });
    let t6: I32 = testStructPattern();
    
    // All tests should pass
    if (t1 && t2 && t3 == 100 && t4 == 5 && t5 == 14 && t6 == 35) {
        0  // Success
    } else {
        1  // Failure
    }
}
