// Test: Result<T, E> standard library type
// Validates Ok/Err construction, unwrap operator, and basic Result usage

// Result type definitions
struct Ok<T> {
    value: T
}

struct Err<E> {
    error: E
}

type Result<T, E> = Ok<T> |> Err<E>;

struct SimpleError {
    msg: *Str
}

// Helper to create errors
fn make_error(msg: *Str) : SimpleError => {
    SimpleError { msg: msg }
}

// Import Result helpers (would be from stdlib in real usage)
fn is_ok<T, E>(result: Result<T, E>) : Bool => {
    result is Ok
}

fn is_err<T, E>(result: Result<T, E>) : Bool => {
    result is Err
}

fn unwrap_or<T, E>(result: Result<T, E>, default_value: T) : T => {
    if (result is Ok) {
        result.value
    } else {
        default_value
    }
}

// Test 1: Ok construction and unwrap
fn test_ok_unwrap() : I32 => {
    let result: Ok<I32> = Ok<I32> { value: 42 };
    let value: I32 = result?;
    value
}

// Test 2: Function returning Ok
fn returns_ok() : Ok<I32> => {
    Ok<I32> { value: 100 }
}

fn test_returns_ok() : I32 => {
    let result: Ok<I32> = returns_ok();
    result?
}

// Test 3: Function returning Result (Ok<T> |> Err<E> union)
fn divide(a: I32, b: I32) : Result<I32, SimpleError> => {
    if (b == 0) {
        Err<SimpleError> { error: make_error("division by zero") }
    } else {
        Ok<I32> { value: a / b }
    }
}

fn test_divide_ok() : I32 => {
    let result: Result<I32, SimpleError> = divide(10, 2);
    result?  // Should extract 5
}

// Test 4: Using is_ok() helper
fn test_is_ok_helper() : Bool => {
    let result: Result<I32, SimpleError> = Ok<I32> { value: 42 };
    is_ok(result)
}

// Test 5: Using is_err() helper
fn test_is_err_helper() : Bool => {
    let result: Result<I32, SimpleError> = Err<SimpleError> { error: make_error("test") };
    is_err(result)
}

// Test 6: Using unwrap_or() helper
fn test_unwrap_or_helper() : I32 => {
    let ok_result: Result<I32, SimpleError> = Ok<I32> { value: 50 };
    let err_result: Result<I32, SimpleError> = Err<SimpleError> { error: make_error("fail") };
    let v1: I32 = unwrap_or(ok_result, 999);
    let v2: I32 = unwrap_or(err_result, 777);
    v1 + v2  // Should be 50 + 777 = 827
}

// Test 7: Error propagation with ?
fn safe_divide(a: I32, b: I32) : Result<I32, SimpleError> => {
    // The ? operator propagates Err automatically
    let quotient: I32 = divide(a, b)?;
    Ok<I32> { value: quotient * 2 }
}

fn test_safe_divide_propagates() : I32 => {
    let result: Result<I32, SimpleError> = safe_divide(20, 4);
    result?  // Should extract 10 (20/4 * 2)
}

// Test 8: Nested Result propagation (3 levels deep)
fn level3(x: I32) : Result<I32, SimpleError> => {
    let result: I32 = divide(x, 2)?;
    Ok<I32> { value: result + 1 }
}

fn level2(x: I32) : Result<I32, SimpleError> => {
    let result: I32 = level3(x)?;
    Ok<I32> { value: result * 3 }
}

fn level1(x: I32) : Result<I32, SimpleError> => {
    let result: I32 = level2(x)?;
    Ok<I32> { value: result - 5 }
}

fn test_nested_propagation() : I32 => {
    let result: Result<I32, SimpleError> = level1(20);
    result?  // Should extract ((20/2 + 1) * 3 - 5) = 28
}

// Main entry point - run all tests
fn main() : I32 => {
    let t1: I32 = test_ok_unwrap();
    let t2: I32 = test_returns_ok();
    let t3: I32 = test_divide_ok();
    let t4: Bool = test_is_ok_helper();
    let t5: Bool = test_is_err_helper();
    let t6: I32 = test_unwrap_or_helper();
    let t7: I32 = test_safe_divide_propagates();
    let t8: I32 = test_nested_propagation();
    
    // All tests passed if we got here without Err propagation
    if (t1 == 42 && t2 == 100 && t3 == 5 && t4 && t5 && t6 == 827 && t7 == 10 && t8 == 28) {
        0  // Success
    } else {
        1  // Failure
    }
}
