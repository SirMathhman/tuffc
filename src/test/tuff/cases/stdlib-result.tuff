// Test: Result<T, E> standard library type
// Validates Ok/Err construction, unwrap operator, and basic Result usage

// Result type definitions
struct Ok<T> {
    value: T
}

struct Err<E> {
    error: E
}

type Result<T, E> = Ok<T> |> Err<E>;

struct SimpleError {
    msg: *Str
}

// Helper to create errors
fn makeError(msg: *Str) : SimpleError => {
    SimpleError { msg: msg }
}

// Import Result helpers (would be from stdlib in real usage)
fn isOk<T, E>(result: Result<T, E>) : Bool => {
    result is Ok
}

fn isErr<T, E>(result: Result<T, E>) : Bool => {
    result is Err
}

fn unwrapOr<T, E>(result: Result<T, E>, defaultValue: T) : T => {
    if (result is Ok) {
        result.value
    } else {
        defaultValue
    }
}

// Test 1: Ok construction and unwrap
fn testOkUnwrap() : I32 => {
    let result: Ok<I32> = Ok<I32> { value: 42 };
    let value: I32 = result?;
    value
}

// Test 2: Function returning Ok
fn returnsOk() : Ok<I32> => {
    Ok<I32> { value: 100 }
}

fn testReturnsOk() : I32 => {
    let result: Ok<I32> = returnsOk();
    result?
}

// Test 3: Function returning Result (Ok<T> |> Err<E> union)
fn divide(a: I32, b: I32) : Result<I32, SimpleError> => {
    if (b == 0) {
        Err<SimpleError> { error: makeError("division by zero") }
    } else {
        Ok<I32> { value: a / b }
    }
}

fn testDivideOk() : I32 => {
    let result: Result<I32, SimpleError> = divide(10, 2);
    result?  // Should extract 5
}

// Test 4: Using is_ok() helper
fn testIsOkHelper() : Bool => {
    let result: Result<I32, SimpleError> = Ok<I32> { value: 42 };
    isOk(result)
}

// Test 5: Using is_err() helper
fn testIsErrHelper() : Bool => {
    let result: Result<I32, SimpleError> = Err<SimpleError> { error: makeError("test") };
    isErr(result)
}

// Test 6: Using unwrap_or() helper
fn testUnwrapOrHelper() : I32 => {
    let okResult: Result<I32, SimpleError> = Ok<I32> { value: 50 };
    let errResult: Result<I32, SimpleError> = Err<SimpleError> { error: makeError("fail") };
    let v1: I32 = unwrapOr(okResult, 999);
    let v2: I32 = unwrapOr(errResult, 777);
    v1 + v2  // Should be 50 + 777 = 827
}

// Test 7: Error propagation with ?
fn safeDivide(a: I32, b: I32) : Result<I32, SimpleError> => {
    // The ? operator propagates Err automatically
    let quotient: I32 = divide(a, b)?;
    Ok<I32> { value: quotient * 2 }
}

fn testSafeDividePropagates() : I32 => {
    let result: Result<I32, SimpleError> = safeDivide(20, 4);
    result?  // Should extract 10 (20/4 * 2)
}

// Test 8: Nested Result propagation (3 levels deep)
fn level3(x: I32) : Result<I32, SimpleError> => {
    let result: I32 = divide(x, 2)?;
    Ok<I32> { value: result + 1 }
}

fn level2(x: I32) : Result<I32, SimpleError> => {
    let result: I32 = level3(x)?;
    Ok<I32> { value: result * 3 }
}

fn level1(x: I32) : Result<I32, SimpleError> => {
    let result: I32 = level2(x)?;
    Ok<I32> { value: result - 5 }
}

fn testNestedPropagation() : I32 => {
    let result: Result<I32, SimpleError> = level1(20);
    result?  // Should extract ((20/2 + 1) * 3 - 5) = 28
}

// Main entry point - run all tests
fn main() : I32 => {
    let t1: I32 = testOkUnwrap();
    let t2: I32 = testReturnsOk();
    let t3: I32 = testDivideOk();
    let t4: Bool = testIsOkHelper();
    let t5: Bool = testIsErrHelper();
    let t6: I32 = testUnwrapOrHelper();
    let t7: I32 = testSafeDividePropagates();
    let t8: I32 = testNestedPropagation();
    
    // All tests passed if we got here without Err propagation
    if (t1 == 42 && t2 == 100 && t3 == 5 && t4 && t5 && t6 == 827 && t7 == 10 && t8 == 28) {
        0  // Success
    } else {
        1  // Failure
    }
}
