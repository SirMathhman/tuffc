struct DescriptiveError {
    source : *Str;
    description : *Str;
    reason : *Str;
    fix : *Str;
}

fn Ok<T, X>(value : T) => {
    fn isSuccess() => true;
    fn isFailure() => false;

    this
}

fn Err<T, X>(error : X) => {
    fn isSuccess() => false;
    fn isFailure() => true;

    this
}

type Result<T, X> = Ok<T, X> | Err<T, X>;
type InterpretError = DescriptiveError;

struct FunctionParam {
    name : *Str;
    type : *Str;
}

struct FunctionDefinition {
    body : *Str;
    returnType : *Str;
    params : *[FunctionParam];
}

// OK, now that I can comment, I can explain myself a bit better.
// If a function is marked as `extern` you should just provide a common-sense implementation in JS.
extern fn createSlice<T>() : *mut [T];
extern fn getSlice(this : *[T], index : USize) : T;
extern fn addSlice(this : *mut [T], element : T) : *mut [T];

contract Equatable<T> {
    fn isEqualTo(*this, other : T) : Bool;
}

fn Map<K : Equatable<K>, V>() => {
    // A slice of tuples, tuple (K, V)
    let slice : *mut [(K, V)] = createSlice<(K, V)>();

    fn hasKey(key : V) => {
        for (i in 0..slice.init) {

        }
    }

    fn put(key : K, value : V) => {

    }
}

let counter = 0;
fn empty() => counter += 1;
counter