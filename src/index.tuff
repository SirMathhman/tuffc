struct DescriptiveError {
    source : *Str;
    description : *Str;
    reason : *Str;
    fix : *Str;
}

fn Ok<T, X>(value : T) => {
    fn isSuccess() => true;
    fn isFailure() => false;

    this
}

fn Err<T, X>(error : X) => {
    fn isSuccess() => false;
    fn isFailure() => true;

    this
}

type Result<T, X> = Ok<T, X> | Err<T, X>;
type InterpretError = DescriptiveError;

struct FunctionParam {
    name : *Str;
    type : *Str;
}

struct FunctionDefinition {
    body : *Str;
    returnType : *Str;
    params : *[FunctionParam];
}

// OK, now that I can comment, I can explain myself a bit better.
// If a function is marked as `extern` you should just provide a common-sense implementation in JS.
extern fn createSlice<T>() : *[T];
extern fn getSlice(slice : *[T], index : USize) : T;
extern fn addSlice(slice : *[T], element : T) : *[T];

let slice : *[I32] = createSlice<I32>();

fn addOnce(this : I32) => this + 1;
100.addOnce()